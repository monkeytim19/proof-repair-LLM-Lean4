filepath,thm_name,decl_name,commit,failed_proof,error_msg,statement,proof
Mathlib/Analysis/Calculus/ParametricIntegral.lean,hasFDerivAt_integral_of_dominated_loc_of_lip',hasFDerivAt_integral_of_dominated_loc_of_lip',596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have xâ‚€_in : xâ‚€ âˆˆ ball xâ‚€ Îµ := mem_ball_self Îµ_pos
  have nneg : âˆ€ x, 0 â‰¤ â€–x - xâ‚€â€–â»Â¹ := fun x â†¦ inv_nonneg.mpr (norm_nonneg _)
  set b : Î± â†’ â„ := fun a â†¦ |bound a|
  have b_int : Integrable b Î¼ := bound_integrable.norm
  have b_nonneg : âˆ€ a, 0 â‰¤ b a := fun a â†¦ abs_nonneg _
  replace h_lipsch : âˆ€áµ a âˆ‚Î¼, âˆ€ x âˆˆ ball xâ‚€ Îµ, â€–F x a - F xâ‚€ aâ€– â‰¤ b a * â€–x - xâ‚€â€– :=
    h_lipsch.mono fun a ha x hx â†¦
      (ha x hx).trans <| mul_le_mul_of_nonneg_right (le_abs_self _) (norm_nonneg _)
  have hF_int' : âˆ€ x âˆˆ ball xâ‚€ Îµ, Integrable (F x) Î¼ := fun x x_in â†¦ by
    have : âˆ€áµ a âˆ‚Î¼, â€–F xâ‚€ a - F x aâ€– â‰¤ Îµ * b a := by
      simp only [norm_sub_rev (F xâ‚€ _)]
      refine h_lipsch.mono fun a ha â†¦ (ha x x_in).trans ?_
      rw [mul_comm Îµ]
      rw [mem_ball, dist_eq_norm] at x_in
      exact mul_le_mul_of_nonneg_left x_in.le (b_nonneg _)
    exact integrable_of_norm_sub_le (hF_meas x x_in) hF_int
      (bound_integrable.norm.const_mul Îµ) this
  have hF'_int : Integrable F' Î¼ :=
    have : âˆ€áµ a âˆ‚Î¼, â€–F' aâ€– â‰¤ b a := by
      apply (h_diff.and h_lipsch).mono
      rintro a âŸ¨ha_diff, ha_lipâŸ©
      exact ha_diff.le_of_lip' (b_nonneg a) (mem_of_superset (ball_mem_nhds _ Îµ_pos) <| ha_lip)
    b_int.mono' hF'_meas this
  refine âŸ¨hF'_int, ?_âŸ©
  by_cases hE : CompleteSpace E; swap
  Â· rcases subsingleton_or_nontrivial H with hH|hH
    Â· have : Subsingleton (H â†’L[ğ•œ] E) := inferInstance
      convert hasFDerivAt_of_subsingleton _ xâ‚€
    Â· have : Â¬(CompleteSpace (H â†’L[ğ•œ] E)) := by
        simpa [SeparatingDual.completeSpace_continuousLinearMap_iff] using hE
      simp only [integral, hE, â†“reduceDite, this]
      exact hasFDerivAt_const 0 xâ‚€
  have h_ball : ball xâ‚€ Îµ âˆˆ ğ“ xâ‚€ := ball_mem_nhds xâ‚€ Îµ_pos
  have : âˆ€á¶  x in ğ“ xâ‚€, â€–x - xâ‚€â€–â»Â¹ * â€–((âˆ« a, F x a âˆ‚Î¼) - âˆ« a, F xâ‚€ a âˆ‚Î¼) - (âˆ« a, F' a âˆ‚Î¼) (x - xâ‚€)â€– =
      â€–âˆ« a, â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€)) âˆ‚Î¼â€– := by
    apply mem_of_superset (ball_mem_nhds _ Îµ_pos)
    intro x x_in; simp only
    rw [Set.mem_setOf_eq, â† norm_smul_of_nonneg (nneg _), integral_smul, integral_sub, integral_sub,
      â† ContinuousLinearMap.integral_apply hF'_int]
    exacts [hF_int' x x_in, hF_int, (hF_int' x x_in).sub hF_int,
      hF'_int.apply_continuousLinearMap _]
  rw [hasFDerivAt_iff_tendsto, tendsto_congr' this, â† tendsto_zero_iff_norm_tendsto_zero, â†
    show (âˆ« a : Î±, â€–xâ‚€ - xâ‚€â€–â»Â¹ â€¢ (F xâ‚€ a - F xâ‚€ a - (F' a) (xâ‚€ - xâ‚€)) âˆ‚Î¼) = 0 by simp]
  apply tendsto_integral_filter_of_dominated_convergence
  Â· filter_upwards [h_ball] with _ x_in
    apply AEStronglyMeasurable.const_smul
    exact ((hF_meas _ x_in).sub (hF_meas _ xâ‚€_in)).sub (hF'_meas.apply_continuousLinearMap _)
  Â· refine mem_of_superset h_ball fun x hx â†¦ ?_
    apply (h_diff.and h_lipsch).mono
    on_goal 1 => rintro a âŸ¨-, ha_boundâŸ©
    show â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))â€– â‰¤ b a + â€–F' aâ€–
    replace ha_bound : â€–F x a - F xâ‚€ aâ€– â‰¤ b a * â€–x - xâ‚€â€– := ha_bound x hx
    calc
      â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))â€– =
          â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a) - â€–x - xâ‚€â€–â»Â¹ â€¢ F' a (x - xâ‚€)â€– :=
        by rw [smul_sub]
      _ â‰¤ â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a)â€– + â€–â€–x - xâ‚€â€–â»Â¹ â€¢ F' a (x - xâ‚€)â€– := norm_sub_le _ _
      _ = â€–x - xâ‚€â€–â»Â¹ * â€–F x a - F xâ‚€ aâ€– + â€–x - xâ‚€â€–â»Â¹ * â€–F' a (x - xâ‚€)â€– := by
        rw [norm_smul_of_nonneg, norm_smul_of_nonneg] <;> exact nneg _
      _ â‰¤ â€–x - xâ‚€â€–â»Â¹ * (b a * â€–x - xâ‚€â€–) + â€–x - xâ‚€â€–â»Â¹ * (â€–F' aâ€– * â€–x - xâ‚€â€–) := by
        gcongr; exact (F' a).le_opNorm _
      _ â‰¤ b a + â€–F' aâ€– := ?_
    simp only [â† div_eq_inv_mul]
    apply_rules [add_le_add, div_le_of_nonneg_of_le_mul] <;> first | rfl | positivity
  Â· exact b_int.add hF'_int.norm
  Â· apply h_diff.mono
    intro a ha
    suffices Tendsto (fun x â†¦ â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))) (ğ“ xâ‚€) (ğ“ 0) by simpa
    rw [tendsto_zero_iff_norm_tendsto_zero]
    have : (fun x â†¦ â€–x - xâ‚€â€–â»Â¹ * â€–F x a - F xâ‚€ a - F' a (x - xâ‚€)â€–) = fun x â†¦
        â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))â€– := by
      ext x
      rw [norm_smul_of_nonneg (nneg _)]
    rwa [hasFDerivAt_iff_tendsto, this] at ha",error:  unknown identifier 'reduceDite',"theorem hasFDerivAt_integral_of_dominated_loc_of_lip' {F' : Î± â†’ H â†’L[ğ•œ] E} (Îµ_pos : 0 < Îµ)
    (hF_meas : âˆ€ x âˆˆ ball xâ‚€ Îµ, AEStronglyMeasurable (F x) Î¼) (hF_int : Integrable (F xâ‚€) Î¼)
    (hF'_meas : AEStronglyMeasurable F' Î¼)
    (h_lipsch : âˆ€áµ a âˆ‚Î¼, âˆ€ x âˆˆ ball xâ‚€ Îµ, â€–F x a - F xâ‚€ aâ€– â‰¤ bound a * â€–x - xâ‚€â€–)
    (bound_integrable : Integrable (bound : Î± â†’ â„) Î¼)
    (h_diff : âˆ€áµ a âˆ‚Î¼, HasFDerivAt (F Â· a) (F' a) xâ‚€) :
    Integrable F' Î¼ âˆ§ HasFDerivAt (fun x â†¦ âˆ« a, F x a âˆ‚Î¼) (âˆ« a, F' a âˆ‚Î¼) xâ‚€ ",":= by
  have xâ‚€_in : xâ‚€ âˆˆ ball xâ‚€ Îµ := mem_ball_self Îµ_pos
  have nneg : âˆ€ x, 0 â‰¤ â€–x - xâ‚€â€–â»Â¹ := fun x â†¦ inv_nonneg.mpr (norm_nonneg _)
  set b : Î± â†’ â„ := fun a â†¦ |bound a|
  have b_int : Integrable b Î¼ := bound_integrable.norm
  have b_nonneg : âˆ€ a, 0 â‰¤ b a := fun a â†¦ abs_nonneg _
  replace h_lipsch : âˆ€áµ a âˆ‚Î¼, âˆ€ x âˆˆ ball xâ‚€ Îµ, â€–F x a - F xâ‚€ aâ€– â‰¤ b a * â€–x - xâ‚€â€– :=
    h_lipsch.mono fun a ha x hx â†¦
      (ha x hx).trans <| mul_le_mul_of_nonneg_right (le_abs_self _) (norm_nonneg _)
  have hF_int' : âˆ€ x âˆˆ ball xâ‚€ Îµ, Integrable (F x) Î¼ := fun x x_in â†¦ by
    have : âˆ€áµ a âˆ‚Î¼, â€–F xâ‚€ a - F x aâ€– â‰¤ Îµ * b a := by
      simp only [norm_sub_rev (F xâ‚€ _)]
      refine h_lipsch.mono fun a ha â†¦ (ha x x_in).trans ?_
      rw [mul_comm Îµ]
      rw [mem_ball, dist_eq_norm] at x_in
      exact mul_le_mul_of_nonneg_left x_in.le (b_nonneg _)
    exact integrable_of_norm_sub_le (hF_meas x x_in) hF_int
      (bound_integrable.norm.const_mul Îµ) this
  have hF'_int : Integrable F' Î¼ :=
    have : âˆ€áµ a âˆ‚Î¼, â€–F' aâ€– â‰¤ b a := by
      apply (h_diff.and h_lipsch).mono
      rintro a âŸ¨ha_diff, ha_lipâŸ©
      exact ha_diff.le_of_lip' (b_nonneg a) (mem_of_superset (ball_mem_nhds _ Îµ_pos) <| ha_lip)
    b_int.mono' hF'_meas this
  refine âŸ¨hF'_int, ?_âŸ©
  by_cases hE : CompleteSpace E; swap
  Â· rcases subsingleton_or_nontrivial H with hH|hH
    Â· have : Subsingleton (H â†’L[ğ•œ] E) := inferInstance
      convert hasFDerivAt_of_subsingleton _ xâ‚€
    Â· have : Â¬(CompleteSpace (H â†’L[ğ•œ] E)) := by
        simpa [SeparatingDual.completeSpace_continuousLinearMap_iff] using hE
      simp only [integral, hE, â†“reduceDIte, this]
      exact hasFDerivAt_const 0 xâ‚€
  have h_ball : ball xâ‚€ Îµ âˆˆ ğ“ xâ‚€ := ball_mem_nhds xâ‚€ Îµ_pos
  have : âˆ€á¶  x in ğ“ xâ‚€, â€–x - xâ‚€â€–â»Â¹ * â€–((âˆ« a, F x a âˆ‚Î¼) - âˆ« a, F xâ‚€ a âˆ‚Î¼) - (âˆ« a, F' a âˆ‚Î¼) (x - xâ‚€)â€– =
      â€–âˆ« a, â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€)) âˆ‚Î¼â€– := by
    apply mem_of_superset (ball_mem_nhds _ Îµ_pos)
    intro x x_in; simp only
    rw [Set.mem_setOf_eq, â† norm_smul_of_nonneg (nneg _), integral_smul, integral_sub, integral_sub,
      â† ContinuousLinearMap.integral_apply hF'_int]
    exacts [hF_int' x x_in, hF_int, (hF_int' x x_in).sub hF_int,
      hF'_int.apply_continuousLinearMap _]
  rw [hasFDerivAt_iff_tendsto, tendsto_congr' this, â† tendsto_zero_iff_norm_tendsto_zero, â†
    show (âˆ« a : Î±, â€–xâ‚€ - xâ‚€â€–â»Â¹ â€¢ (F xâ‚€ a - F xâ‚€ a - (F' a) (xâ‚€ - xâ‚€)) âˆ‚Î¼) = 0 by simp]
  apply tendsto_integral_filter_of_dominated_convergence
  Â· filter_upwards [h_ball] with _ x_in
    apply AEStronglyMeasurable.const_smul
    exact ((hF_meas _ x_in).sub (hF_meas _ xâ‚€_in)).sub (hF'_meas.apply_continuousLinearMap _)
  Â· refine mem_of_superset h_ball fun x hx â†¦ ?_
    apply (h_diff.and h_lipsch).mono
    on_goal 1 => rintro a âŸ¨-, ha_boundâŸ©
    show â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))â€– â‰¤ b a + â€–F' aâ€–
    replace ha_bound : â€–F x a - F xâ‚€ aâ€– â‰¤ b a * â€–x - xâ‚€â€– := ha_bound x hx
    calc
      â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))â€– =
          â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a) - â€–x - xâ‚€â€–â»Â¹ â€¢ F' a (x - xâ‚€)â€– := by rw [smul_sub]
      _ â‰¤ â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a)â€– + â€–â€–x - xâ‚€â€–â»Â¹ â€¢ F' a (x - xâ‚€)â€– := norm_sub_le _ _
      _ = â€–x - xâ‚€â€–â»Â¹ * â€–F x a - F xâ‚€ aâ€– + â€–x - xâ‚€â€–â»Â¹ * â€–F' a (x - xâ‚€)â€– := by
        rw [norm_smul_of_nonneg, norm_smul_of_nonneg] <;> exact nneg _
      _ â‰¤ â€–x - xâ‚€â€–â»Â¹ * (b a * â€–x - xâ‚€â€–) + â€–x - xâ‚€â€–â»Â¹ * (â€–F' aâ€– * â€–x - xâ‚€â€–) := by
        gcongr; exact (F' a).le_opNorm _
      _ â‰¤ b a + â€–F' aâ€– := ?_
    simp only [â† div_eq_inv_mul]
    apply_rules [add_le_add, div_le_of_nonneg_of_le_mul] <;> first | rfl | positivity
  Â· exact b_int.add hF'_int.norm
  Â· apply h_diff.mono
    intro a ha
    suffices Tendsto (fun x â†¦ â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))) (ğ“ xâ‚€) (ğ“ 0) by simpa
    rw [tendsto_zero_iff_norm_tendsto_zero]
    have : (fun x â†¦ â€–x - xâ‚€â€–â»Â¹ * â€–F x a - F xâ‚€ a - F' a (x - xâ‚€)â€–) = fun x â†¦
        â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))â€– := by
      ext x
      rw [norm_smul_of_nonneg (nneg _)]
    rwa [hasFDerivAt_iff_tendsto, this] at ha"
Mathlib/Analysis/Complex/Liouville.lean,Differentiable.apply_eq_apply_of_bounded,apply_eq_apply_of_bounded,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  set g : â„‚ â†’ F := f âˆ˜ fun t : â„‚ => t â€¢ (w - z) + z
  suffices g 0 = g 1 by simpa
  apply liouville_theorem_aux
  exacts [hf.comp ((differentiable_id.smul_const (w - z)).add_const z),
    hb.subset (range_comp_subset_range _ _)]","error:  tactic 'assumption' failed
E : Type u
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace â„‚ E
F : Type v
instâœÂ¹ : NormedAddCommGroup F
instâœ : NormedSpace â„‚ F
f : E â†’ F
hf : Differentiable â„‚ f
hb : Bornology.IsBounded (range f)
z w : E
g : â„‚ â†’ F := f âˆ˜ fun t â†¦ t â€¢ (w - z) + z
this : g 0 = g 1
âŠ¢ f z = f w","theorem apply_eq_apply_of_bounded {f : E â†’ F} (hf : Differentiable â„‚ f) (hb : IsBounded (range f))
    (z w : E) : f z = f w ",":= by
  set g : â„‚ â†’ F := f âˆ˜ fun t : â„‚ => t â€¢ (w - z) + z
  suffices g 0 = g 1 by simpa [g]
  apply liouville_theorem_aux
  exacts [hf.comp ((differentiable_id.smul_const (w - z)).add_const z),
    hb.subset (range_comp_subset_range _ _)]"
Mathlib/Topology/SeparatedMap.lean,IsSeparatedMap.eq_of_comp_eq,eq_of_comp_eq,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= funext fun a' â†¦ by
  apply (IsClopen.eq_univ âŸ¨inj.isOpen_eqLocus hâ‚ hâ‚‚ he, sep.isClosed_eqLocus hâ‚ hâ‚‚ heâŸ© âŸ¨a, haâŸ©).symm
    â–¸ Set.mem_univ a'","error:  application type mismatch
  And.intro (IsLocallyInjective.isOpen_eqLocus inj hâ‚ hâ‚‚ he)
argument
  IsLocallyInjective.isOpen_eqLocus inj hâ‚ hâ‚‚ he
has type
  IsOpen {a | gâ‚ a = gâ‚‚ a} : Prop
but is expected to have type
  IsClosed ?m.22091 : Prop
error:  unsolved goals
X : Type u_3
Y : ?m.21392
Aâœ : Type ?u.21401
instâœâ´ : TopologicalSpace X
instâœÂ³ : TopologicalSpace Aâœ
E : Type u_1
A : Type u_2
instâœÂ² : TopologicalSpace E
instâœÂ¹ : TopologicalSpace A
p : E â†’ X
sep : IsSeparatedMap p
inj : IsLocallyInjective p
s : Set A
hs : IsPreconnected s
g gâ‚ gâ‚‚ : A â†’ E
instâœ : PreconnectedSpace A
hâ‚ : Continuous gâ‚
hâ‚‚ : Continuous gâ‚‚
he : p âˆ˜ gâ‚ = p âˆ˜ gâ‚‚
a : A
ha : gâ‚ a = gâ‚‚ a
a' : A
âŠ¢ gâ‚ a' = gâ‚‚ a'
error:  invalid field notation, function 'IsSeparatedMap.eq_of_comp_eq' does not have argument with type (IsSeparatedMap ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'IsSeparatedMap.eq_of_comp_eq' does not have argument with type (IsSeparatedMap ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'IsSeparatedMap.eqOn_of_comp_eqOn' does not have argument with type (IsSeparatedMap ...) that can be used, it must be explicit or implicit with a unique name","theorem eq_of_comp_eq [PreconnectedSpace A] (hâ‚ : Continuous gâ‚) (hâ‚‚ : Continuous gâ‚‚)
    (he : p âˆ˜ gâ‚ = p âˆ˜ gâ‚‚) (a : A) (ha : gâ‚ a = gâ‚‚ a) : gâ‚ = gâ‚‚ ",":= funext fun a' â†¦ by
  apply (IsClopen.eq_univ âŸ¨sep.isClosed_eqLocus hâ‚ hâ‚‚ he, inj.isOpen_eqLocus hâ‚ hâ‚‚ heâŸ© âŸ¨a, haâŸ©).symm
    â–¸ Set.mem_univ a'"
Mathlib/GroupTheory/Perm/Basic.lean,Equiv.Perm.extendDomain_zpow,extendDomain_zpow,27d257fca86730535c755957eeacad78dfe0e921,:=,error:  unexpected token 'end'; expected term,lemma extendDomain_zpow (n : â„¤) : (e ^ n).extendDomain f = e.extendDomain f ^ n ,":=
  map_zpow (extendDomainHom f) _ _"
Mathlib/Algebra/Order/ToIntervalMod.lean,AddCommGroup.tfae_modEq,tfae_modEq,eae9bb40604136c5d5ab4ffb1181933613965f9a,":= by
  rw [modEq_iff_toIcoMod_eq_left hp]
  tfae_have 3 â†’ 2 := by
    rw [â† not_exists, not_imp_not]
    exact fun âŸ¨i, hiâŸ© =>
      ((toIcoMod_eq_iff hp).2 âŸ¨Set.Ioo_subset_Ico_self hi, i, (sub_add_cancel b _).symmâŸ©).trans
        ((toIocMod_eq_iff hp).2 âŸ¨Set.Ioo_subset_Ioc_self hi, i, (sub_add_cancel b _).symmâŸ©).symm
  tfae_have 4 â†’ 3
  | h => by
    rw [â† h, Ne, eq_comm, add_right_eq_self]
    exact hp.ne'
  tfae_have 1 â†’ 4
  | h => by
    rw [h, eq_comm, toIocMod_eq_iff, Set.right_mem_Ioc]
    refine' âŸ¨lt_add_of_pos_right a hp, toIcoDiv hp a b - 1, _âŸ©
    rw [sub_one_zsmul, add_add_add_comm, add_right_neg, add_zero]
    conv_lhs => rw [â† toIcoMod_add_toIcoDiv_zsmul hp a b, h]
  tfae_have 2 â†’ 1 := by
    rw [â† not_exists, not_imp_comm]
    have h' := toIcoMod_mem_Ico hp a b
    exact fun h => âŸ¨_, h'.1.lt_of_ne' h, h'.2âŸ©
  tfae_finish","error:  unsolved goals
case tfae_3_to_2
Î± : Type u_1
instâœ : LinearOrderedAddCommGroup Î±
hÎ± : Archimedean Î±
p : Î±
hp : 0 < p
a b c : Î±
n : â„¤
âŠ¢ toIcoMod hp a b â‰  toIocMod hp a b â†’ âˆ€ (z : â„¤), b - z â€¢ p âˆ‰ Set.Ioo a (a + p)

Î± : Type u_1
instâœ : LinearOrderedAddCommGroup Î±
hÎ± : Archimedean Î±
p : Î±
hp : 0 < p
a b c : Î±
n : â„¤
tfae_3_to_2 : toIcoMod hp a b â‰  toIocMod hp a b â†’ âˆ€ (z : â„¤), b - z â€¢ p âˆ‰ Set.Ioo a (a + p)
âŠ¢ [toIcoMod hp a b = a, âˆ€ (z : â„¤), b - z â€¢ p âˆ‰ Set.Ioo a (a + p), toIcoMod hp a b â‰  toIocMod hp a b,
      toIcoMod hp a b + p = toIocMod hp a b].TFAE
error:  unexpected token ':='; expected command","theorem tfae_modEq :
    TFAE
      [a â‰¡ b [PMOD p], âˆ€ z : â„¤, b - z â€¢ p âˆ‰ Set.Ioo a (a + p), toIcoMod hp a b â‰  toIocMod hp a b,
        toIcoMod hp a b + p = toIocMod hp a b] ",":= by
  rw [modEq_iff_toIcoMod_eq_left hp]
  tfae_have 3 â†’ 2
  Â· rw [â† not_exists, not_imp_not]
    exact fun âŸ¨i, hiâŸ© =>
      ((toIcoMod_eq_iff hp).2 âŸ¨Set.Ioo_subset_Ico_self hi, i, (sub_add_cancel b _).symmâŸ©).trans
        ((toIocMod_eq_iff hp).2 âŸ¨Set.Ioo_subset_Ioc_self hi, i, (sub_add_cancel b _).symmâŸ©).symm
  tfae_have 4 â†’ 3
  Â· intro h
    rw [â† h, Ne, eq_comm, add_right_eq_self]
    exact hp.ne'
  tfae_have 1 â†’ 4
  Â· intro h
    rw [h, eq_comm, toIocMod_eq_iff, Set.right_mem_Ioc]
    refine âŸ¨lt_add_of_pos_right a hp, toIcoDiv hp a b - 1, ?_âŸ©
    rw [sub_one_zsmul, add_add_add_comm, add_right_neg, add_zero]
    conv_lhs => rw [â† toIcoMod_add_toIcoDiv_zsmul hp a b, h]
  tfae_have 2 â†’ 1
  Â· rw [â† not_exists, not_imp_comm]
    have h' := toIcoMod_mem_Ico hp a b
    exact fun h => âŸ¨_, h'.1.lt_of_ne' h, h'.2âŸ©
  tfae_finish"
Mathlib/Geometry/Manifold/IntegralCurve.lean,IsIntegralCurveAt.comp_add,IsIntegralCurveAt.comp_add,7d7a7169c0c35b35c150a198dd8eaa2a47578e1d,":= by
  rw [isIntegralCurveAt_iff] at hÎ³
  obtain âŸ¨Îµ, hÎµ, hâŸ© := hÎ³
  refine âŸ¨Metric.ball (tâ‚€ - dt) Îµ, Metric.isOpen_ball.mem_nhds (Metric.mem_ball_self hÎµ), ?_âŸ©
  convert h.comp_add dt
  ext t
  rw [mem_setOf_eq, Metric.mem_ball, Metric.mem_ball, dist_sub_eq_dist_add_right]","error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  (ğ“ (tâ‚€ - dt)).1
    {x |
      (fun t â†¦
          HasMFDerivAt ğ“˜(â„, â„) I (Î³ âˆ˜ fun x â†¦ x + dt) t (ContinuousLinearMap.smulRight 1 (v ((Î³ âˆ˜ fun x â†¦ x + dt) t))))
        x}
error:  no goals to be solved","lemma IsIntegralCurveAt.comp_add (hÎ³ : IsIntegralCurveAt Î³ v tâ‚€) (dt : â„) :
    IsIntegralCurveAt (Î³ âˆ˜ (Â· + dt)) v (tâ‚€ - dt) ",":= by
  rw [isIntegralCurveAt_iff'] at *
  obtain âŸ¨Îµ, hÎµ, hâŸ© := hÎ³
  refine âŸ¨Îµ, hÎµ, ?_âŸ©
  convert h.comp_add dt
  ext t
  rw [mem_setOf_eq, Metric.mem_ball, Metric.mem_ball, dist_sub_eq_dist_add_right]"
Mathlib/Geometry/Manifold/Diffeomorph.lean,Diffeomorph.coeFn_injective,coeFn_injective,3de553d06bda445e9577ea48a1033f8d736cddeb,":=
  FunLike.coe_injective","warning:  @Diffeomorph does not have a doc string
error:  unknown constant 'FunLike.coe_injective'","theorem coeFn_injective : Injective ((â†‘) : (M â‰ƒâ‚˜^nâŸ®I, I'âŸ¯ M') â†’ (M â†’ M')) ",":=
  DFunLike.coe_injective"
Mathlib/MeasureTheory/Measure/FiniteMeasureProd.lean,MeasureTheory.FiniteMeasure.prod_apply_symm,prod_apply_symm,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  simp [Measure.prod_apply_symm s_mble]","error:  simp made no progress
error:  simp made no progress","lemma prod_apply_symm (s : Set (Î± Ã— Î²)) (s_mble : MeasurableSet s) :
    Î¼.prod Î½ s = ENNReal.toNNReal (âˆ«â» y, Î¼.toMeasure ((fun x â†¦ âŸ¨x, yâŸ©) â»Â¹' s) âˆ‚Î½) ",":= by
  simp [coeFn_def, Measure.prod_apply_symm s_mble]"
Mathlib/Topology/UniformSpace/UniformEmbedding.lean,uniform_extend_subtype,uniform_extend_subtype,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have de : DenseEmbedding e := he.denseEmbedding hd
  have de' : DenseEmbedding (DenseEmbedding.subtypeEmb p e) := de.subtype p
  have ue' : UniformEmbedding (DenseEmbedding.subtypeEmb p e) := uniformEmbedding_subtypeEmb _ he de
  have : b âˆˆ closure (e '' { x | p x }) :=
    (closure_mono <| monotone_image <| hp) (mem_of_mem_nhds hb)
  let âŸ¨c, hcâŸ© := uniformly_extend_exists ue'.toUniformInducing de'.dense hf âŸ¨b, thisâŸ©
  replace hc : Tendsto (f âˆ˜ Subtype.val) (((ğ“ b).comap e).comap Subtype.val) (ğ“ c) := by
    simpa only [nhds_subtype_eq_comap, comap_comap, DenseEmbedding.subtypeEmb_coe] using hc
  refine âŸ¨c, (tendsto_comap'_iff ?_).1 hcâŸ©
  rw [Subtype.range_coe_subtype]
  exact âŸ¨_, hb, by rwa [â† de.toInducing.closure_eq_preimage_closure_image, hs.closure_eq]âŸ©","error:  don't know how to synthesize implicit argument 'Î±'
  @Tendsto (Subtype ?m.85764) Î³ (f âˆ˜ Subtype.val) (comap Subtype.val (comap e (ğ“ b))) (ğ“ c)
context:
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
instâœÂ³ : UniformSpace Î±
instâœÂ² : UniformSpace Î²
instâœÂ¹ : UniformSpace Î³
eâœ : Î² â†’ Î±
h_e : UniformInducing eâœ
h_dense : DenseRange eâœ
fâœ : Î² â†’ Î³
h_f : UniformContinuous fâœ
instâœ : CompleteSpace Î³
p : Î± â†’ Prop
e : Î± â†’ Î²
f : Î± â†’ Î³
b : Î²
s : Set Î±
hf : UniformContinuous fun x â†¦ f â†‘x
he : UniformEmbedding e
hd : âˆ€ (x : Î²), x âˆˆ closure (range e)
hb : closure (e '' s) âˆˆ ğ“ b
hs : IsClosed s
hp : âˆ€ x âˆˆ s, p x
de : DenseEmbedding e
de' : DenseEmbedding (DenseEmbedding.subtypeEmb p e)
ue' : UniformEmbedding (DenseEmbedding.subtypeEmb p e)
this : b âˆˆ closure (e '' {x | p x})
c : Î³
hc : Tendsto (fun x â†¦ f â†‘x) (comap (DenseEmbedding.subtypeEmb p e) (ğ“ âŸ¨b, thisâŸ©)) (ğ“ c)
âŠ¢ Type u_1
error:  don't know how to synthesize implicit argument 'Î±'
  @comap (Subtype ?m.85764) Î± Subtype.val (comap e (ğ“ b))
context:
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
instâœÂ³ : UniformSpace Î±
instâœÂ² : UniformSpace Î²
instâœÂ¹ : UniformSpace Î³
eâœ : Î² â†’ Î±
h_e : UniformInducing eâœ
h_dense : DenseRange eâœ
fâœ : Î² â†’ Î³
h_f : UniformContinuous fâœ
instâœ : CompleteSpace Î³
p : Î± â†’ Prop
e : Î± â†’ Î²
f : Î± â†’ Î³
b : Î²
s : Set Î±
hf : UniformContinuous fun x â†¦ f â†‘x
he : UniformEmbedding e
hd : âˆ€ (x : Î²), x âˆˆ closure (range e)
hb : closure (e '' s) âˆˆ ğ“ b
hs : IsClosed s
hp : âˆ€ x âˆˆ s, p x
de : DenseEmbedding e
de' : DenseEmbedding (DenseEmbedding.subtypeEmb p e)
ue' : UniformEmbedding (DenseEmbedding.subtypeEmb p e)
this : b âˆˆ closure (e '' {x | p x})
c : Î³
hc : Tendsto (fun x â†¦ f â†‘x) (comap (DenseEmbedding.subtypeEmb p e) (ğ“ âŸ¨b, thisâŸ©)) (ğ“ c)
âŠ¢ Type u_1
error:  don't know how to synthesize implicit argument 'p'
  @Subtype.val Î± ?m.85764
context:
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
instâœÂ³ : UniformSpace Î±
instâœÂ² : UniformSpace Î²
instâœÂ¹ : UniformSpace Î³
eâœ : Î² â†’ Î±
h_e : UniformInducing eâœ
h_dense : DenseRange eâœ
fâœ : Î² â†’ Î³
h_f : UniformContinuous fâœ
instâœ : CompleteSpace Î³
p : Î± â†’ Prop
e : Î± â†’ Î²
f : Î± â†’ Î³
b : Î²
s : Set Î±
hf : UniformContinuous fun x â†¦ f â†‘x
he : UniformEmbedding e
hd : âˆ€ (x : Î²), x âˆˆ closure (range e)
hb : closure (e '' s) âˆˆ ğ“ b
hs : IsClosed s
hp : âˆ€ x âˆˆ s, p x
de : DenseEmbedding e
de' : DenseEmbedding (DenseEmbedding.subtypeEmb p e)
ue' : UniformEmbedding (DenseEmbedding.subtypeEmb p e)
this : b âˆˆ closure (e '' {x | p x})
c : Î³
hc : Tendsto (fun x â†¦ f â†‘x) (comap (DenseEmbedding.subtypeEmb p e) (ğ“ âŸ¨b, thisâŸ©)) (ğ“ c)
âŠ¢ Î± â†’ Prop
error:  don't know how to synthesize implicit argument 'Î±'
  @comp (Subtype ?m.85764) Î± Î³ f Subtype.val
context:
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
instâœÂ³ : UniformSpace Î±
instâœÂ² : UniformSpace Î²
instâœÂ¹ : UniformSpace Î³
eâœ : Î² â†’ Î±
h_e : UniformInducing eâœ
h_dense : DenseRange eâœ
fâœ : Î² â†’ Î³
h_f : UniformContinuous fâœ
instâœ : CompleteSpace Î³
p : Î± â†’ Prop
e : Î± â†’ Î²
f : Î± â†’ Î³
b : Î²
s : Set Î±
hf : UniformContinuous fun x â†¦ f â†‘x
he : UniformEmbedding e
hd : âˆ€ (x : Î²), x âˆˆ closure (range e)
hb : closure (e '' s) âˆˆ ğ“ b
hs : IsClosed s
hp : âˆ€ x âˆˆ s, p x
de : DenseEmbedding e
de' : DenseEmbedding (DenseEmbedding.subtypeEmb p e)
ue' : UniformEmbedding (DenseEmbedding.subtypeEmb p e)
this : b âˆˆ closure (e '' {x | p x})
c : Î³
hc : Tendsto (fun x â†¦ f â†‘x) (comap (DenseEmbedding.subtypeEmb p e) (ğ“ âŸ¨b, thisâŸ©)) (ğ“ c)
âŠ¢ Type u_1
error:  don't know how to synthesize implicit argument 'p'
  @Subtype.val Î± ?m.85764
context:
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
instâœÂ³ : UniformSpace Î±
instâœÂ² : UniformSpace Î²
instâœÂ¹ : UniformSpace Î³
eâœ : Î² â†’ Î±
h_e : UniformInducing eâœ
h_dense : DenseRange eâœ
fâœ : Î² â†’ Î³
h_f : UniformContinuous fâœ
instâœ : CompleteSpace Î³
p : Î± â†’ Prop
e : Î± â†’ Î²
f : Î± â†’ Î³
b : Î²
s : Set Î±
hf : UniformContinuous fun x â†¦ f â†‘x
he : UniformEmbedding e
hd : âˆ€ (x : Î²), x âˆˆ closure (range e)
hb : closure (e '' s) âˆˆ ğ“ b
hs : IsClosed s
hp : âˆ€ x âˆˆ s, p x
de : DenseEmbedding e
de' : DenseEmbedding (DenseEmbedding.subtypeEmb p e)
ue' : UniformEmbedding (DenseEmbedding.subtypeEmb p e)
this : b âˆˆ closure (e '' {x | p x})
c : Î³
hc : Tendsto (fun x â†¦ f â†‘x) (comap (DenseEmbedding.subtypeEmb p e) (ğ“ âŸ¨b, thisâŸ©)) (ğ“ c)
âŠ¢ Î± â†’ Prop
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
instâœÂ³ : UniformSpace Î±
instâœÂ² : UniformSpace Î²
instâœÂ¹ : UniformSpace Î³
eâœ : Î² â†’ Î±
h_e : UniformInducing eâœ
h_dense : DenseRange eâœ
fâœ : Î² â†’ Î³
h_f : UniformContinuous fâœ
instâœ : CompleteSpace Î³
p : Î± â†’ Prop
e : Î± â†’ Î²
f : Î± â†’ Î³
b : Î²
s : Set Î±
hf : UniformContinuous fun x â†¦ f â†‘x
he : UniformEmbedding e
hd : âˆ€ (x : Î²), x âˆˆ closure (range e)
hb : closure (e '' s) âˆˆ ğ“ b
hs : IsClosed s
hp : âˆ€ x âˆˆ s, p x
de : DenseEmbedding e
de' : DenseEmbedding (DenseEmbedding.subtypeEmb p e)
ue' : UniformEmbedding (DenseEmbedding.subtypeEmb p e)
this : b âˆˆ closure (e '' {x | p x})
c : Î³
hc : Tendsto (fun x â†¦ f â†‘x) (comap (DenseEmbedding.subtypeEmb p e) (ğ“ âŸ¨b, thisâŸ©)) (ğ“ c)
âŠ¢ âˆƒ c, Tendsto f (comap e (ğ“ b)) (ğ“ c)","theorem uniform_extend_subtype [CompleteSpace Î³] {p : Î± â†’ Prop} {e : Î± â†’ Î²} {f : Î± â†’ Î³} {b : Î²}
    {s : Set Î±} (hf : UniformContinuous fun x : Subtype p => f x.val) (he : UniformEmbedding e)
    (hd : âˆ€ x : Î², x âˆˆ closure (range e)) (hb : closure (e '' s) âˆˆ ğ“ b) (hs : IsClosed s)
    (hp : âˆ€ x âˆˆ s, p x) : âˆƒ c, Tendsto f (comap e (ğ“ b)) (ğ“ c) ",":= by
  have de : DenseEmbedding e := he.denseEmbedding hd
  have de' : DenseEmbedding (DenseEmbedding.subtypeEmb p e) := de.subtype p
  have ue' : UniformEmbedding (DenseEmbedding.subtypeEmb p e) := uniformEmbedding_subtypeEmb _ he de
  have : b âˆˆ closure (e '' { x | p x }) :=
    (closure_mono <| monotone_image <| hp) (mem_of_mem_nhds hb)
  let âŸ¨c, hcâŸ© := uniformly_extend_exists ue'.toUniformInducing de'.dense hf âŸ¨b, thisâŸ©
  replace hc : Tendsto (f âˆ˜ Subtype.val (p := p)) (((ğ“ b).comap e).comap Subtype.val) (ğ“ c) := by
    simpa only [nhds_subtype_eq_comap, comap_comap, DenseEmbedding.subtypeEmb_coe] using hc
  refine âŸ¨c, (tendsto_comap'_iff ?_).1 hcâŸ©
  rw [Subtype.range_coe_subtype]
  exact âŸ¨_, hb, by rwa [â† de.toInducing.closure_eq_preimage_closure_image, hs.closure_eq]âŸ©"
Mathlib/Data/Seq/Computation.lean,Computation.liftRel_think_left,liftRel_think_left,3c930599229893e1b6a931304cf4efff4a01b172,":=
  and_congr (forall_congr' fun _ => imp_congr mem_think_iff Iff.rfl)
    (forall_congr' fun _ =>
      imp_congr Iff.rfl <| exists_congr fun _ => and_congr mem_think_iff Iff.rfl)","error:  unknown identifier 'mem_think_iff'
error:  unknown identifier 'mem_think_iff'","theorem liftRel_think_left (R : Î± â†’ Î² â†’ Prop) (ca : Computation Î±) (cb : Computation Î²) :
    LiftRel R (think ca) cb â†” LiftRel R ca cb ",":=
  and_congr (forall_congr' fun _ => imp_congr âŸ¨of_think_mem, think_memâŸ© Iff.rfl)
    (forall_congr' fun _ =>
      imp_congr Iff.rfl <| exists_congr fun _ => and_congr âŸ¨of_think_mem, think_memâŸ© Iff.rfl)"
Mathlib/Order/Filter/Lift.lean,Filter.lift_lift_same_eq_lift,lift_lift_same_eq_lift,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  lift_lift_same_le_lift.antisymm <|
    le_lift.2 fun s hs => le_lift.2 fun t ht => lift_le (inter_mem hs ht) <|
      calc
        g (s âˆ© t) (s âˆ© t) â‰¤ g s (s âˆ© t) := hgâ‚‚ (s âˆ© t) (inter_subset_left _ _)
        _ â‰¤ g s t := hgâ‚ s (inter_subset_right _ _)","error:  function expected at
  inter_subset_left ?m.21249
term has type
  ?m.21248 âˆˆ ?m.21246
error:  function expected at
  inter_subset_right ?m.21318
term has type
  ?m.21317 âˆˆ ?m.21316","theorem lift_lift_same_eq_lift {g : Set Î± â†’ Set Î± â†’ Filter Î²} (hgâ‚ : âˆ€ s, Monotone fun t => g s t)
    (hgâ‚‚ : âˆ€ t, Monotone fun s => g s t) : (f.lift fun s => f.lift (g s)) = f.lift fun s => g s s ",":=
  lift_lift_same_le_lift.antisymm <|
    le_lift.2 fun s hs => le_lift.2 fun t ht => lift_le (inter_mem hs ht) <|
      calc
        g (s âˆ© t) (s âˆ© t) â‰¤ g s (s âˆ© t) := hgâ‚‚ (s âˆ© t) inter_subset_left
        _ â‰¤ g s t := hgâ‚ s inter_subset_right"
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean,aestronglyMeasurable_of_tendsto_ae,_root_.aestronglyMeasurable_of_tendsto_ae,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  borelize Î²
  refine' aestronglyMeasurable_iff_aemeasurable_separable.2 âŸ¨_, _âŸ©
  Â· exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  Â· rcases u.exists_seq_tendsto with âŸ¨v, hvâŸ©
    have : âˆ€ n : â„•, âˆƒ t : Set Î², IsSeparable t âˆ§ f (v n) â»Â¹' t âˆˆ Î¼.ae := fun n =>
      (aestronglyMeasurable_iff_aemeasurable_separable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine âŸ¨closure (â‹ƒ i, t i), .closure <| .iUnion t_sep, ?_âŸ©
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    filter_upwards with n using mem_iUnion_of_mem n (hx n)","error:  invalid field 'ae', the environment does not contain 'MeasureTheory.Measure.ae'
  Î¼
has type
  Measure Î±","theorem _root_.aestronglyMeasurable_of_tendsto_ae {Î¹ : Type*} [PseudoMetrizableSpace Î²]
    (u : Filter Î¹) [NeBot u] [IsCountablyGenerated u] {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²}
    (hf : âˆ€ i, AEStronglyMeasurable (f i) Î¼) (lim : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => f n x) u (ğ“ (g x))) :
    AEStronglyMeasurable g Î¼ ",":= by
  borelize Î²
  refine aestronglyMeasurable_iff_aemeasurable_separable.2 âŸ¨?_, ?_âŸ©
  Â· exact aemeasurable_of_tendsto_metrizable_ae _ (fun n => (hf n).aemeasurable) lim
  Â· rcases u.exists_seq_tendsto with âŸ¨v, hvâŸ©
    have : âˆ€ n : â„•, âˆƒ t : Set Î², IsSeparable t âˆ§ f (v n) â»Â¹' t âˆˆ ae Î¼ := fun n =>
      (aestronglyMeasurable_iff_aemeasurable_separable.1 (hf (v n))).2
    choose t t_sep ht using this
    refine âŸ¨closure (â‹ƒ i, t i), .closure <| .iUnion t_sep, ?_âŸ©
    filter_upwards [ae_all_iff.2 ht, lim] with x hx h'x
    apply mem_closure_of_tendsto (h'x.comp hv)
    filter_upwards with n using mem_iUnion_of_mem n (hx n)"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.zipWith_single_single,zipWith_single_single,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.zipWith_single_single (fun _ => f) (fun _ => hf) (i := a) m n","warning:  Finsupp does not have a doc string
error:  unknown identifier 'DFinsupp.zipWith_single_single'","theorem zipWith_single_single (f : M â†’ N â†’ P) (hf : f 0 0 = 0) (a : Î±) (m : M) (n : N) :
    zipWith f hf (single a m) (single a n) = single a (f m n) ",":= by
  ext a'
  rw [zipWith_apply]
  obtain rfl | ha' := eq_or_ne a a'
  Â· rw [single_eq_same, single_eq_same, single_eq_same]
  Â· rw [single_eq_of_ne ha', single_eq_of_ne ha', single_eq_of_ne ha', hf]"
Mathlib/Logic/Equiv/Defs.lean,Equiv.coe_fn_injective,coe_fn_injective,6ca2f19564ae0bc82677d73a9000fadb5724d981,":=
  FunLike.coe_injective","warning:  Equiv does not have a doc string
error:  unknown constant 'FunLike.coe_injective'",theorem coe_fn_injective : @Function.Injective (Î± â‰ƒ Î²) (Î± â†’ Î²) (fun e => e) ,":=
  DFunLike.coe_injective'"
Mathlib/FieldTheory/IsPerfectClosure.lean,mem_pNilradical,mem_pNilradical,25527279cf0fc38a336bb3b3d913a403b5f38ac1,":= by
  by_cases hp : 1 < p
  Â· rw [pNilradical_eq_nilradical hp]
    refine âŸ¨fun âŸ¨n, hâŸ© â†¦ âŸ¨n, ?_âŸ©, fun âŸ¨n, hâŸ© â†¦ âŸ¨p ^ n, hâŸ©âŸ©
    rw [â† Nat.sub_add_cancel ((Nat.lt_pow_self hp n).le), pow_add, h, mul_zero]
  rw [pNilradical_eq_bot hp, Ideal.mem_bot]
  refine âŸ¨fun h â†¦ âŸ¨0, by rw [pow_zero, pow_one, h]âŸ©, fun âŸ¨n, hâŸ© â†¦ ?_âŸ©
  rcases Nat.le_one_iff_eq_zero_or_eq_one.1 (not_lt.1 hp) with hp | hp
  Â· by_cases hn : n = 0
    Â· rwa [hn, pow_zero, pow_one] at h
    rw [hp, zero_pow hn, pow_zero] at h
    subsingleton [subsingleton_of_zero_eq_one h.symm]
  rwa [hp, one_pow, pow_one] at h","error:  unknown tactic
error:  unsolved goals
case neg
R : Type u_1
instâœ : CommSemiring R
p : â„•
x : R
hpâœ : Â¬1 < p
xâœ : âˆƒ n, x ^ p ^ n = 0
n : â„•
h : 1 = 0
hp : p = 0
hn : Â¬n = 0
âŠ¢ x = 0
error:  unsolved goals
case neg.inr
R : Type u_1
instâœ : CommSemiring R
p : â„•
x : R
hpâœ : Â¬1 < p
xâœ : âˆƒ n, x ^ p ^ n = 0
n : â„•
h : x ^ p ^ n = 0
hp : p = 1
âŠ¢ x = 0","theorem mem_pNilradical {R : Type*} [CommSemiring R] {p : â„•} {x : R} :
    x âˆˆ pNilradical R p â†” âˆƒ n : â„•, x ^ p ^ n = 0 ",":= by
  by_cases hp : 1 < p
  Â· rw [pNilradical_eq_nilradical hp]
    refine âŸ¨fun âŸ¨n, hâŸ© â†¦ âŸ¨n, ?_âŸ©, fun âŸ¨n, hâŸ© â†¦ âŸ¨p ^ n, hâŸ©âŸ©
    rw [â† Nat.sub_add_cancel ((Nat.lt_pow_self hp n).le), pow_add, h, mul_zero]
  rw [pNilradical_eq_bot hp, Ideal.mem_bot]
  refine âŸ¨fun h â†¦ âŸ¨0, by rw [pow_zero, pow_one, h]âŸ©, fun âŸ¨n, hâŸ© â†¦ ?_âŸ©
  rcases Nat.le_one_iff_eq_zero_or_eq_one.1 (not_lt.1 hp) with hp | hp
  Â· by_cases hn : n = 0
    Â· rwa [hn, pow_zero, pow_one] at h
    rw [hp, zero_pow hn, pow_zero] at h
    haveI := subsingleton_of_zero_eq_one h.symm
    exact Subsingleton.elim _ _
  rwa [hp, one_pow, pow_one] at h"
Mathlib/Combinatorics/SetFamily/Shadow.lean,Finset.mem_upShadow_iff_exists_sdiff,mem_upShadow_iff_exists_sdiff,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  simp_rw [mem_upShadow_iff, â†covby_iff_card_sdiff_eq_one, covby_iff_exists_insert]","warning:  @shadow does not have a doc string
warning:  @upShadow does not have a doc string
error:  unknown identifier 'covby_iff_card_sdiff_eq_one'
error:  simp made no progress","lemma mem_upShadow_iff_exists_sdiff : t âˆˆ âˆ‚âº ğ’œ â†” âˆƒ s âˆˆ ğ’œ, s âŠ† t âˆ§ (t \ s).card = 1 ",":= by
  simp_rw [mem_upShadow_iff, â† covBy_iff_card_sdiff_eq_one, covBy_iff_exists_insert]"
Mathlib/Combinatorics/Enumerative/Composition.lean,List.get_splitWrtCompositionAux,get_splitWrtCompositionAux,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' ns with n ns IH generalizing l i
  Â· cases hi
  cases' i with i
  Â· rw [Nat.add_zero, List.take_zero, sum_nil]
    simpa using get_mk_zero hi
  Â· simp only [splitWrtCompositionAux._eq_2, get_cons_succ, IH, take,
        sum_cons, Nat.add_eq, add_zero, splitAt_eq_take_drop, drop_take, drop_drop]
    rw [Nat.succ_eq_add_one, add_comm (sum _) n, Nat.add_sub_add_left]","warning:  try 'simp' instead of 'simpa'
note: this linter can be disabled with `set_option linter.unnecessarySimpa false`
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  splitWrtCompositionAux
has type
  List ?m.63363 â†’ List â„• â†’ List (List ?m.63363)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case cons.succ
nâœ : â„•
Î± : Type u_1
n : â„•
ns : List â„•
IH :
  âˆ€ (l : List Î±) {i : â„•} (hi : i < (l.splitWrtCompositionAux ns).length),
    (l.splitWrtCompositionAux ns).get âŸ¨i, hiâŸ© = drop (take i ns).sum (take (take (i + 1) ns).sum l)
l : List Î±
i : â„•
hi : i + 1 < (l.splitWrtCompositionAux (n :: ns)).length
âŠ¢ (l.splitWrtCompositionAux (n :: ns)).get âŸ¨i + 1, hiâŸ© =
    take (n + (take (i + 1) ns).sum - (n + (take i ns).sum)) (drop (n + (take i ns).sum) l)","theorem get_splitWrtCompositionAux (l : List Î±) (ns : List â„•) {i : â„•} (hi) :
    (l.splitWrtCompositionAux ns).get âŸ¨i, hiâŸ©  =
      (l.take (ns.take (i + 1)).sum).drop (ns.take i).sum ",":= by
  simp [getElem_splitWrtCompositionAux]"
Mathlib/Topology/Connected/Basic.lean,isPreconnected_iff_subset_of_disjoint,isPreconnected_iff_subset_of_disjoint,64b674911520c89d4467fb9e8410ab9d79e82064,":= by
  constructor <;> intro h
  Â· intro u v hu hv hs huv
    specialize h u v hu hv hs
    contrapose! huv
    rw [â† nonempty_iff_ne_empty]
    simp [not_subset] at huv
    rcases huv with âŸ¨âŸ¨x, hxs, hxuâŸ©, âŸ¨y, hys, hyvâŸ©âŸ©
    have hxv : x âˆˆ v := or_iff_not_imp_left.mp (hs hxs) hxu
    have hyu : y âˆˆ u := or_iff_not_imp_right.mp (hs hys) hyv
    exact h âŸ¨y, hys, hyuâŸ© âŸ¨x, hxs, hxvâŸ©
  Â· intro u v hu hv hs hsu hsv
    rw [nonempty_iff_ne_empty]
    intro H
    specialize h u v hu hv hs H
    contrapose H
    apply Nonempty.ne_empty
    cases' h with h h
    Â· rcases hsv with âŸ¨x, hxs, hxvâŸ©
      exact âŸ¨x, hxs, âŸ¨h hxs, hxvâŸ©âŸ©
    Â· rcases hsu with âŸ¨x, hxs, hxuâŸ©
      exact âŸ¨x, hxs, âŸ¨hxu, h hxsâŸ©âŸ©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.82811 â‰  âˆ…
case mp
Î± : Type u
Î² : Type v
Î¹ : Type u_1
Ï€ : Î¹ â†’ Type u_2
instâœ : TopologicalSpace Î±
sâœ t uâœ vâœ s u v : Set Î±
hu : IsOpen u
hv : IsOpen v
hs : s âŠ† u âˆª v
h : (s âˆ© u).Nonempty â†’ (s âˆ© v).Nonempty â†’ (s âˆ© (u âˆ© v)).Nonempty
huv : Â¬s âŠ† u âˆ§ Â¬s âŠ† v
âŠ¢ (s âˆ© (u âˆ© v)).Nonempty","theorem isPreconnected_iff_subset_of_disjoint {s : Set Î±} :
    IsPreconnected s â†”
      âˆ€ u v, IsOpen u â†’ IsOpen v â†’ s âŠ† u âˆª v â†’ s âˆ© (u âˆ© v) = âˆ… â†’ s âŠ† u âˆ¨ s âŠ† v ",":= by
  constructor <;> intro h
  Â· intro u v hu hv hs huv
    specialize h u v hu hv hs
    contrapose! huv
    simp [not_subset] at huv
    rcases huv with âŸ¨âŸ¨x, hxs, hxuâŸ©, âŸ¨y, hys, hyvâŸ©âŸ©
    have hxv : x âˆˆ v := or_iff_not_imp_left.mp (hs hxs) hxu
    have hyu : y âˆˆ u := or_iff_not_imp_right.mp (hs hys) hyv
    exact h âŸ¨y, hys, hyuâŸ© âŸ¨x, hxs, hxvâŸ©
  Â· intro u v hu hv hs hsu hsv
    by_contra H
    specialize h u v hu hv hs (Set.not_nonempty_iff_eq_empty.mp H)
    apply H
    cases' h with h h
    Â· rcases hsv with âŸ¨x, hxs, hxvâŸ©
      exact âŸ¨x, hxs, âŸ¨h hxs, hxvâŸ©âŸ©
    Â· rcases hsu with âŸ¨x, hxs, hxuâŸ©
      exact âŸ¨x, hxs, âŸ¨hxu, h hxsâŸ©âŸ©"
Mathlib/Analysis/Complex/Basic.lean,Complex.exists_norm_eq_mul_self,exists_norm_eq_mul_self,cc92efbba7c836fd1168a41a3a4ef1d126c990d7,":=
  IsROrC.exists_norm_eq_mul_self _",error:  unknown identifier 'IsROrC.exists_norm_eq_mul_self',"lemma exists_norm_eq_mul_self (z : â„‚) : âˆƒ c, â€–câ€– = 1 âˆ§ â€–zâ€– = c * z ",":=
  RCLike.exists_norm_eq_mul_self _"
Mathlib/Topology/Semicontinuous.lean,UpperSemicontinuousWithinAt.add,UpperSemicontinuousWithinAt.add,105a48d42f84ef02d78acca07b3565aa1b78ec83,":=
  @LowerSemicontinuousWithinAt.add' Î± _ x s Î³áµ’áµˆ _ _ _ _ _ _ hf hg hcont","error:  application type mismatch
  LowerSemicontinuousWithinAt.add' ?m.195172 hf hg
argument
  hg
has type
  UpperSemicontinuousWithinAt g s x : Prop
but is expected to have type
  ContinuousAt (fun p â†¦ p.1 + p.2) (?m.195170 x, f x) : Prop","theorem UpperSemicontinuousWithinAt.add' {f g : Î± â†’ Î³} (hf : UpperSemicontinuousWithinAt f s x)
    (hg : UpperSemicontinuousWithinAt g s x)
    (hcont : ContinuousAt (fun p : Î³ Ã— Î³ => p.1 + p.2) (f x, g x)) :
    UpperSemicontinuousWithinAt (fun z => f z + g z) s x ",":=
  @LowerSemicontinuousWithinAt.add' Î± _ x s Î³áµ’áµˆ _ _ _ _ _ hf hg hcont"
Mathlib/Topology/MetricSpace/Isometry.lean,isometry_iff_nndist_eq,isometry_iff_nndist_eq,161c69c1dbf66cf3c7ec4f648a61551d044a43e4,":= by
  simp only [Isometry, edist_nndist, ENNReal.coe_eq_coe]","error:  unknown constant 'ENNReal.coe_eq_coe'
error:  unsolved goals
Î¹ : Type u_1
Î± : Type u
Î² : Type v
Î³ : Type w
instâœÂ¹ : PseudoMetricSpace Î±
instâœ : PseudoMetricSpace Î²
f : Î± â†’ Î²
âŠ¢ (âˆ€ (x1 x2 : Î±), â†‘(nndist (f x1) (f x2)) = â†‘(nndist x1 x2)) â†” âˆ€ (x y : Î±), nndist (f x) (f y) = nndist x y
warning:  declaration uses 'sorry'
warning:  declaration uses 'sorry'
warning:  IsometryEquiv does not have a doc string","theorem isometry_iff_nndist_eq [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] {f : Î± â†’ Î²} :
    Isometry f â†” âˆ€ x y, nndist (f x) (f y) = nndist x y ",":= by
  simp only [Isometry, edist_nndist, ENNReal.coe_inj]"
Mathlib/MeasureTheory/Constructions/Prod/Integral.lean,MeasureTheory.continuous_integral_integral,continuous_integral_integral,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  rw [continuous_iff_continuousAt]; intro g
  refine'
    tendsto_integral_of_L1 _ (L1.integrable_coeFn g).integral_prod_left
      (eventually_of_forall fun h => (L1.integrable_coeFn h).integral_prod_left) _
  simp_rw [â†
    lintegral_fn_integral_sub (fun x => (â€–xâ€–â‚Š : â„â‰¥0âˆ)) (L1.integrable_coeFn _)
      (L1.integrable_coeFn g)]
  refine' tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds _ (fun i => zero_le _) _
  Â· exact fun i => âˆ«â» x, âˆ«â» y, â€–i (x, y) - g (x, y)â€–â‚Š âˆ‚Î½ âˆ‚Î¼
  swap; Â· exact fun i => lintegral_mono fun x => ennnorm_integral_le_lintegral_ennnorm _
  show
    Tendsto (fun i : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E => âˆ«â» x, âˆ«â» y : Î², â€–i (x, y) - g (x, y)â€–â‚Š âˆ‚Î½ âˆ‚Î¼) (ğ“ g)
      (ğ“ 0)
  have : âˆ€ i : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E, Measurable fun z => (â€–i z - g zâ€–â‚Š : â„â‰¥0âˆ) := fun i =>
    ((Lp.stronglyMeasurable i).sub (Lp.stronglyMeasurable g)).ennnorm
  conv =>
    congr
    ext
    rw [â† lintegral_prod_of_measurable _ (this _), â† L1.ofReal_norm_sub_eq_lintegral]
  rw [â† ofReal_zero]
  refine' (continuous_ofReal.tendsto 0).comp _
  rw [â† tendsto_iff_norm_tendsto_zero]; exact tendsto_id","error:  unknown identifier 'tendsto_iff_norm_tendsto_zero'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.117617
case refine'_2
Î± : Type u_1
Î±' : Type u_2
Î² : Type u_3
Î²' : Type u_4
Î³ : Type u_5
E : Type u_6
instâœÂ¹â° : MeasurableSpace Î±
instâœâ¹ : MeasurableSpace Î±'
instâœâ¸ : MeasurableSpace Î²
instâœâ· : MeasurableSpace Î²'
instâœâ¶ : MeasurableSpace Î³
Î¼ Î¼' : Measure Î±
Î½ Î½' : Measure Î²
Ï„ : Measure Î³
instâœâµ : NormedAddCommGroup E
instâœâ´ : SigmaFinite Î½
instâœÂ³ : NormedSpace â„ E
instâœÂ² : SigmaFinite Î¼
E' : Type u_7
instâœÂ¹ : NormedAddCommGroup E'
instâœ : NormedSpace â„ E'
g : â†¥(Lp E 1 (Î¼.prod Î½))
this : âˆ€ (i : â†¥(Lp E 1 (Î¼.prod Î½))), Measurable fun z â†¦ â†‘â€–â†‘â†‘i z - â†‘â†‘g zâ€–â‚Š
âŠ¢ Tendsto (fun x â†¦ â€–x - gâ€–) (ğ“ g) (ğ“ 0)","theorem continuous_integral_integral :
    Continuous fun f : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E => âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼ ",":= by
  rw [continuous_iff_continuousAt]; intro g
  refine
    tendsto_integral_of_L1 _ (L1.integrable_coeFn g).integral_prod_left
      (eventually_of_forall fun h => (L1.integrable_coeFn h).integral_prod_left) ?_
  simp_rw [â†
    lintegral_fn_integral_sub (fun x => (â€–xâ€–â‚Š : â„â‰¥0âˆ)) (L1.integrable_coeFn _)
      (L1.integrable_coeFn g)]
  apply tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds _ (fun i => zero_le _) _
  Â· exact fun i => âˆ«â» x, âˆ«â» y, â€–i (x, y) - g (x, y)â€–â‚Š âˆ‚Î½ âˆ‚Î¼
  swap; Â· exact fun i => lintegral_mono fun x => ennnorm_integral_le_lintegral_ennnorm _
  show
    Tendsto (fun i : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E => âˆ«â» x, âˆ«â» y : Î², â€–i (x, y) - g (x, y)â€–â‚Š âˆ‚Î½ âˆ‚Î¼) (ğ“ g)
      (ğ“ 0)
  have : âˆ€ i : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E, Measurable fun z => (â€–i z - g zâ€–â‚Š : â„â‰¥0âˆ) := fun i =>
    ((Lp.stronglyMeasurable i).sub (Lp.stronglyMeasurable g)).ennnorm
  conv =>
    congr
    ext
    rw [â† lintegral_prod_of_measurable _ (this _), â† L1.ofReal_norm_sub_eq_lintegral]
  rw [â† ofReal_zero]
  refine (continuous_ofReal.tendsto 0).comp ?_
  rw [â† tendsto_iff_norm_sub_tendsto_zero]; exact tendsto_id"
Mathlib/Analysis/Normed/Group/ControlledClosure.lean,controlled_closure_range_of_complete,controlled_closure_range_of_complete,c84d9003027b182d6e34911289aa4dc7700ea050,":= by
  replace hyp : âˆ€ h âˆˆ j.range, âˆƒ g, f g = h âˆ§ â€–gâ€– â‰¤ C * â€–hâ€–
  Â· intro h h_in
    rcases(j.mem_range _).mp h_in with âŸ¨k, rflâŸ©
    rw [hj]
    exact hyp k
  exact controlled_closure_of_complete hC hÎµ hyp","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
G : Type u_1
instâœÂ³ : NormedAddCommGroup G
instâœÂ² : CompleteSpace G
H : Type u_2
instâœÂ¹ : NormedAddCommGroup H
f : NormedAddGroupHom G H
K : Type u_3
instâœ : SeminormedAddCommGroup K
j : NormedAddGroupHom K H
hj : âˆ€ (x : K), â€–j xâ€– = â€–xâ€–
C Îµ : â„
hC : 0 < C
hÎµ : 0 < Îµ
hyp : âˆ€ h âˆˆ j.range, âˆƒ g, f g = h âˆ§ â€–gâ€– â‰¤ C * â€–hâ€–
âŠ¢ f.SurjectiveOnWith j.range.topologicalClosure (C + Îµ)","theorem controlled_closure_range_of_complete {f : NormedAddGroupHom G H} {K : Type*}
    [SeminormedAddCommGroup K] {j : NormedAddGroupHom K H} (hj : âˆ€ x, â€–j xâ€– = â€–xâ€–) {C Îµ : â„}
    (hC : 0 < C) (hÎµ : 0 < Îµ) (hyp : âˆ€ k, âˆƒ g, f g = j k âˆ§ â€–gâ€– â‰¤ C * â€–kâ€–) :
    f.SurjectiveOnWith j.range.topologicalClosure (C + Îµ) ",":= by
  replace hyp : âˆ€ h âˆˆ j.range, âˆƒ g, f g = h âˆ§ â€–gâ€– â‰¤ C * â€–hâ€– := by
    intro h h_in
    rcases (j.mem_range _).mp h_in with âŸ¨k, rflâŸ©
    rw [hj]
    exact hyp k
  exact controlled_closure_of_complete hC hÎµ hyp"
Mathlib/CategoryTheory/Limits/Constructions/Pullbacks.lean,CategoryTheory.Limits.hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair,hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair,14167e48d13e9c2d72cbdff0431a8edba6021c34,":=
  let Î¹â‚ : Y âŸ¶ Y â¨¿ Z := coprod.inl
  let Î¹â‚‚ : Z âŸ¶ Y â¨¿ Z := coprod.inr
  let c := coequalizer.Ï€ (f â‰« Î¹â‚) (g â‰« Î¹â‚‚)
  HasColimit.mk
    { cocone :=
        PushoutCocone.mk (Î¹â‚ â‰« c) (Î¹â‚‚ â‰« c) <| by
          rw [â† Category.assoc, â† Category.assoc, coequalizer.condition]
      isColimit :=
        PushoutCocone.IsColimit.mk _
          (fun s => coequalizer.desc
              (coprod.desc (s.Î¹.app WalkingSpan.left) (s.Î¹.app WalkingSpan.right)) <| by
            rw [Category.assoc, colimit.Î¹_desc, Category.assoc, colimit.Î¹_desc]
            exact PushoutCocone.condition _)
          (by simp) (by simp) fun s m hâ‚ hâ‚‚ => by
          apply coequalizer.hom_ext
          apply coprod.hom_ext
          Â· simpa using hâ‚
          Â· simpa using hâ‚‚ }","error:  unsolved goals
C : Type u
ğ’ : Category.{v, u} C
X Y Z : C
f : X âŸ¶ Y
g : X âŸ¶ Z
instâœÂ¹ : HasColimit (pair Y Z)
instâœ : HasColimit (parallelPair (f â‰« coprod.inl) (g â‰« coprod.inr))
Î¹â‚ : Y âŸ¶ Y â¨¿ Z := coprod.inl
Î¹â‚‚ : Z âŸ¶ Y â¨¿ Z := coprod.inr
c : Y â¨¿ Z âŸ¶ coequalizer (f â‰« Î¹â‚) (g â‰« Î¹â‚‚) := coequalizer.Ï€ (f â‰« Î¹â‚) (g â‰« Î¹â‚‚)
âŠ¢ âˆ€ (s : PushoutCocone f g), Î¹â‚ â‰« c â‰« coequalizer.desc (coprod.desc s.inl s.inr) â‹¯ = s.inl
error:  unsolved goals
C : Type u
ğ’ : Category.{v, u} C
X Y Z : C
f : X âŸ¶ Y
g : X âŸ¶ Z
instâœÂ¹ : HasColimit (pair Y Z)
instâœ : HasColimit (parallelPair (f â‰« coprod.inl) (g â‰« coprod.inr))
Î¹â‚ : Y âŸ¶ Y â¨¿ Z := coprod.inl
Î¹â‚‚ : Z âŸ¶ Y â¨¿ Z := coprod.inr
c : Y â¨¿ Z âŸ¶ coequalizer (f â‰« Î¹â‚) (g â‰« Î¹â‚‚) := coequalizer.Ï€ (f â‰« Î¹â‚) (g â‰« Î¹â‚‚)
âŠ¢ âˆ€ (s : PushoutCocone f g), Î¹â‚‚ â‰« c â‰« coequalizer.desc (coprod.desc s.inl s.inr) â‹¯ = s.inr","theorem hasColimit_span_of_hasColimit_pair_of_hasColimit_parallelPair {C : Type u}
    [ğ’ : Category.{v} C] {X Y Z : C} (f : X âŸ¶ Y) (g : X âŸ¶ Z) [HasColimit (pair Y Z)]
    [HasColimit (parallelPair (f â‰« coprod.inl) (g â‰« coprod.inr))] : HasColimit (span f g) ",":=
  let Î¹â‚ : Y âŸ¶ Y â¨¿ Z := coprod.inl
  let Î¹â‚‚ : Z âŸ¶ Y â¨¿ Z := coprod.inr
  let c := coequalizer.Ï€ (f â‰« Î¹â‚) (g â‰« Î¹â‚‚)
  HasColimit.mk
    { cocone :=
        PushoutCocone.mk (Î¹â‚ â‰« c) (Î¹â‚‚ â‰« c) <| by
          rw [â† Category.assoc, â† Category.assoc, coequalizer.condition]
      isColimit :=
        PushoutCocone.IsColimit.mk _
          (fun s => coequalizer.desc
              (coprod.desc (s.Î¹.app WalkingSpan.left) (s.Î¹.app WalkingSpan.right)) <| by
            rw [Category.assoc, colimit.Î¹_desc, Category.assoc, colimit.Î¹_desc]
            exact PushoutCocone.condition _)
          (by simp [Î¹â‚, c]) (by simp [Î¹â‚‚, c]) fun s m hâ‚ hâ‚‚ => by
          ext
          Â· simpa using hâ‚
          Â· simpa using hâ‚‚ }"
Mathlib/Analysis/NormedSpace/BanachSteinhaus.lean,banach_steinhaus_iSup_nnnorm,banach_steinhaus_iSup_nnnorm,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  rw [show ((â¨† i, â†‘â€–g iâ€–â‚Š) < âˆ) â†” _ from (NormedSpace.equicontinuous_TFAE g).out 8 2]
  refine (norm_withSeminorms ğ•œâ‚‚ F).banach_steinhaus (fun _ x â†¦ ?_)
  simpa [â† NNReal.bddAbove_coe, â† Set.range_comp] using
    (WithTop.iSup_coe_lt_top (fun i â†¦ â€–g i xâ€–â‚Š)).mp (h x)","error:  function expected at
  WithTop.iSup_coe_lt_top
term has type
  â¨† x, â†‘(?m.26162 x) < âŠ¤ â†” BddAbove (range ?m.26162)","theorem banach_steinhaus_iSup_nnnorm {Î¹ : Type*} [CompleteSpace E] {g : Î¹ â†’ E â†’SL[Ïƒâ‚â‚‚] F}
    (h : âˆ€ x, (â¨† i, â†‘â€–g i xâ€–â‚Š) < âˆ) : (â¨† i, â†‘â€–g iâ€–â‚Š) < âˆ ",":= by
  rw [show ((â¨† i, â†‘â€–g iâ€–â‚Š) < âˆ) â†” _ from (NormedSpace.equicontinuous_TFAE g).out 8 2]
  refine (norm_withSeminorms ğ•œâ‚‚ F).banach_steinhaus (fun _ x â†¦ ?_)
  simpa [â† NNReal.bddAbove_coe, â† Set.range_comp] using ENNReal.iSup_coe_lt_top.1 (h x)"
Mathlib/AlgebraicTopology/DoldKan/PInfty.lean,AlgebraicTopology.DoldKan.karoubi_PInfty_f,karoubi_PInfty_f,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  let Yâ‚ := (karoubiFunctorCategoryEmbedding _ _).obj Y
  let Yâ‚‚ := Y.X
  let Yâ‚ƒ := ((whiskering _ _).obj (toKaroubi C)).obj Y.X
  let Yâ‚„ := (karoubiFunctorCategoryEmbedding _ _).obj ((toKaroubi _).obj Y.X)
  let Pâ‚ : K[Yâ‚] âŸ¶ _ := PInfty
  let Pâ‚‚ : K[Yâ‚‚] âŸ¶ _ := PInfty
  let Pâ‚ƒ : K[Yâ‚ƒ] âŸ¶ _ := PInfty
  let Pâ‚„ : K[Yâ‚„] âŸ¶ _ := PInfty
  change (Pâ‚.f n).f = Y.p.app (op [n]) â‰« Pâ‚‚.f n
  have hâ‚ƒâ‚‚ : (Pâ‚ƒ.f n).f = Pâ‚‚.f n := Karoubi.hom_ext_iff.mp (map_PInfty_f (toKaroubi C) Yâ‚‚ n)
  have hâ‚„â‚ƒ : Pâ‚„.f n = Pâ‚ƒ.f n := by
    have h := Functor.congr_obj (toKaroubi_comp_karoubiFunctorCategoryEmbedding _ _) Yâ‚‚
    simp only [â† natTransPInfty_f_app]
    congr 1
  have hâ‚â‚„ := Idempotents.natTrans_eq
    ((ğŸ™ (karoubiFunctorCategoryEmbedding SimplexCategoryáµ’áµ– C)) â—«
      (natTransPInfty_f (Karoubi C) n)) Y
  dsimp [natTransPInfty_f] at hâ‚â‚„
  erw [id_comp, id_comp, comp_id, comp_id] at hâ‚â‚„
  rw [â† hâ‚ƒâ‚‚, â† hâ‚„â‚ƒ, hâ‚â‚„]
  simp only [KaroubiFunctorCategoryEmbedding.map_app_f, Karoubi.decompId_p_f,
    Karoubi.decompId_i_f, Karoubi.comp_f]
  let Ï€ : Yâ‚„ âŸ¶ Yâ‚„ := (toKaroubi _ â‹™ karoubiFunctorCategoryEmbedding _ _).map Y.p
  have eq := Karoubi.hom_ext_iff.mp (PInfty_f_naturality n Ï€)
  simp only [Karoubi.comp_f] at eq
  dsimp at eq
  rw [â† eq, app_idem_assoc Y (op [n])]","error:  simp made no progress
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (PInfty.f n).f â‰« (Ï€.app { unop := [n] }).f
C : Type u_1
instâœÂ¹ : Category.{u_2, u_1} C
instâœ : Preadditive C
X : SimplicialObject C
Y : Karoubi (SimplicialObject C)
n : â„•
Yâ‚ : SimplexCategoryáµ’áµ– â¥¤ Karoubi C := (karoubiFunctorCategoryEmbedding SimplexCategoryáµ’áµ– C).obj Y
Yâ‚‚ : SimplicialObject C := Y.X
Yâ‚ƒ : SimplicialObject (Karoubi C) := ((whiskering C (Karoubi C)).obj (toKaroubi C)).obj Y.X
Yâ‚„ : SimplexCategoryáµ’áµ– â¥¤ Karoubi C :=
  (karoubiFunctorCategoryEmbedding SimplexCategoryáµ’áµ– C).obj ((toKaroubi (SimplexCategoryáµ’áµ– â¥¤ C)).obj Y.X)
Pâ‚ : K[Yâ‚] âŸ¶ K[Yâ‚] := PInfty
Pâ‚‚ : K[Yâ‚‚] âŸ¶ K[Yâ‚‚] := PInfty
Pâ‚ƒ : K[Yâ‚ƒ] âŸ¶ K[Yâ‚ƒ] := PInfty
Pâ‚„ : K[Yâ‚„] âŸ¶ K[Yâ‚„] := PInfty
hâ‚ƒâ‚‚ : (Pâ‚ƒ.f n).f = Pâ‚‚.f n
hâ‚„â‚ƒ : Pâ‚„.f n = Pâ‚ƒ.f n
hâ‚â‚„ :
  PInfty.f n =
    (KaroubiFunctorCategoryEmbedding.map Y.decompId_i).app { unop := [n] } â‰«
      PInfty.f n â‰« (KaroubiFunctorCategoryEmbedding.map Y.decompId_p).app { unop := [n] }
Ï€ : Yâ‚„ âŸ¶ Yâ‚„ := (toKaroubi (SimplexCategoryáµ’áµ– â¥¤ C) â‹™ karoubiFunctorCategoryEmbedding SimplexCategoryáµ’áµ– C).map Y.p
eq : (Ï€.app { unop := [n] }).f â‰« (PInfty.f n).f = (PInfty.f n).f â‰« (Ï€.app { unop := [n] }).f
âŠ¢ Y.p.app { unop := [n] } â‰« (PInfty.f n).f â‰« Y.p.app { unop := [n] } = Y.p.app { unop := [n] } â‰« (Pâ‚„.f n).f","theorem karoubi_PInfty_f {Y : Karoubi (SimplicialObject C)} (n : â„•) :
    ((PInfty : K[(karoubiFunctorCategoryEmbedding _ _).obj Y] âŸ¶ _).f n).f =
      Y.p.app (op [n]) â‰« (PInfty : K[Y.X] âŸ¶ _).f n ",":= by
  let Yâ‚ := (karoubiFunctorCategoryEmbedding _ _).obj Y
  let Yâ‚‚ := Y.X
  let Yâ‚ƒ := ((whiskering _ _).obj (toKaroubi C)).obj Y.X
  let Yâ‚„ := (karoubiFunctorCategoryEmbedding _ _).obj ((toKaroubi _).obj Y.X)
  let Pâ‚ : K[Yâ‚] âŸ¶ _ := PInfty
  let Pâ‚‚ : K[Yâ‚‚] âŸ¶ _ := PInfty
  let Pâ‚ƒ : K[Yâ‚ƒ] âŸ¶ _ := PInfty
  let Pâ‚„ : K[Yâ‚„] âŸ¶ _ := PInfty
  change (Pâ‚.f n).f = Y.p.app (op [n]) â‰« Pâ‚‚.f n
  have hâ‚ƒâ‚‚ : (Pâ‚ƒ.f n).f = Pâ‚‚.f n := Karoubi.hom_ext_iff.mp (map_PInfty_f (toKaroubi C) Yâ‚‚ n)
  have hâ‚„â‚ƒ : Pâ‚„.f n = Pâ‚ƒ.f n := by
    have h := Functor.congr_obj (toKaroubi_comp_karoubiFunctorCategoryEmbedding _ _) Yâ‚‚
    simp only [Pâ‚ƒ, Pâ‚„, â† natTransPInfty_f_app]
    congr 1
  have hâ‚â‚„ := Idempotents.natTrans_eq
    ((ğŸ™ (karoubiFunctorCategoryEmbedding SimplexCategoryáµ’áµ– C)) â—«
      (natTransPInfty_f (Karoubi C) n)) Y
  dsimp [natTransPInfty_f] at hâ‚â‚„
  erw [id_comp, id_comp, comp_id, comp_id] at hâ‚â‚„
  rw [â† hâ‚ƒâ‚‚, â† hâ‚„â‚ƒ, hâ‚â‚„]
  simp only [KaroubiFunctorCategoryEmbedding.map_app_f, Karoubi.decompId_p_f,
    Karoubi.decompId_i_f, Karoubi.comp_f]
  let Ï€ : Yâ‚„ âŸ¶ Yâ‚„ := (toKaroubi _ â‹™ karoubiFunctorCategoryEmbedding _ _).map Y.p
  have eq := Karoubi.hom_ext_iff.mp (PInfty_f_naturality n Ï€)
  simp only [Karoubi.comp_f] at eq
  dsimp [Ï€] at eq
  rw [â† eq, app_idem_assoc Y (op [n])]"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.addHaar_image_le_lintegral_abs_det_fderiv,addHaar_image_le_lintegral_abs_det_fderiv,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have :
    âˆ€ A : E â†’L[â„] E,
      âˆƒ Î´ : â„â‰¥0,
        0 < Î´ âˆ§
          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§
            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’
              Î¼ (g '' t) â‰¤ (ENNReal.ofReal |A.det| + Îµ) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©
    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt Îµ Îµpos
    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©
    refine âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), ?_, ?_âŸ©
    Â· intro B hB
      rw [â† Real.dist_eq]
      apply (hÎ´' B _).le
      rw [dist_eq_norm]
      calc
        â€–B - Aâ€– â‰¤ (min Î´ Î´'' : â„â‰¥0) := hB
        _ â‰¤ Î´'' := by simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
        _ < Î´' := half_lt_self Î´'pos
    Â· intro t g htg
      exact h t g (htg.mono_num (min_le_left _ _))
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (ENNReal.ofReal |(A n).det| + Îµ) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2.2
      exact ht n
    _ = âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by
      simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
    _ â‰¤ âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono (inter_subset_left _ _)]
      intro x hx
      have I : |(A n).det| â‰¤ |(f' x).det| + Îµ :=
        calc
          |(A n).det| = |(f' x).det - ((f' x).det - (A n).det)| := by congr 1; abel
          _ â‰¤ |(f' x).det| + |(f' x).det - (A n).det| := abs_sub _ _
          _ â‰¤ |(f' x).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(A n).det| + Îµ â‰¤ ENNReal.ofReal (|(f' x).det| + Îµ) + Îµ := by gcongr
        _ = ENNReal.ofReal |(f' x).det| + 2 * Îµ := by
          simp only [ENNReal.ofReal_add, abs_nonneg, two_mul, add_assoc, NNReal.zero_le_coe,
            ENNReal.ofReal_coe_nnreal]
    _ = âˆ«â» x in â‹ƒ n, s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      have M : âˆ€ n : â„•, MeasurableSet (s âˆ© t n) := fun n => hs.inter (t_meas n)
      rw [lintegral_iUnion M]
      exact pairwise_disjoint_mono t_disj fun n => inter_subset_right _ _
    _ = âˆ«â» x in s, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      rw [â† inter_iUnion, inter_eq_self_of_subset_left t_cover]
    _ = (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s := by
      simp only [lintegral_add_right' _ aemeasurable_const, set_lintegral_const]","error:  function expected at
  inter_subset_left ?m.432033
term has type
  ?m.432032 âˆˆ ?m.432030
error:  function expected at
  inter_subset_right ?m.446838
term has type
  ?m.446837 âˆˆ ?m.446836
warning:  `MeasureTheory.set_lintegral_const` has been deprecated, use `MeasureTheory.setLIntegral_const` instead","theorem addHaar_image_le_lintegral_abs_det_fderiv_aux1 (hs : MeasurableSet s)
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) {Îµ : â„â‰¥0} (Îµpos : 0 < Îµ) :
    Î¼ (f '' s) â‰¤ (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s ",":= by
  have :
    âˆ€ A : E â†’L[â„] E,
      âˆƒ Î´ : â„â‰¥0,
        0 < Î´ âˆ§
          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§
            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’
              Î¼ (g '' t) â‰¤ (ENNReal.ofReal |A.det| + Îµ) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©
    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt Îµ Îµpos
    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©
    refine âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), ?_, ?_âŸ©
    Â· intro B hB
      rw [â† Real.dist_eq]
      apply (hÎ´' B _).le
      rw [dist_eq_norm]
      calc
        â€–B - Aâ€– â‰¤ (min Î´ Î´'' : â„â‰¥0) := hB
        _ â‰¤ Î´'' := by simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
        _ < Î´' := half_lt_self Î´'pos
    Â· intro t g htg
      exact h t g (htg.mono_num (min_le_left _ _))
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (ENNReal.ofReal |(A n).det| + Îµ) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2.2
      exact ht n
    _ = âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by
      simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
    _ â‰¤ âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono inter_subset_left]
      intro x hx
      have I : |(A n).det| â‰¤ |(f' x).det| + Îµ :=
        calc
          |(A n).det| = |(f' x).det - ((f' x).det - (A n).det)| := by congr 1; abel
          _ â‰¤ |(f' x).det| + |(f' x).det - (A n).det| := abs_sub _ _
          _ â‰¤ |(f' x).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(A n).det| + Îµ â‰¤ ENNReal.ofReal (|(f' x).det| + Îµ) + Îµ := by gcongr
        _ = ENNReal.ofReal |(f' x).det| + 2 * Îµ := by
          simp only [ENNReal.ofReal_add, abs_nonneg, two_mul, add_assoc, NNReal.zero_le_coe,
            ENNReal.ofReal_coe_nnreal]
    _ = âˆ«â» x in â‹ƒ n, s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      have M : âˆ€ n : â„•, MeasurableSet (s âˆ© t n) := fun n => hs.inter (t_meas n)
      rw [lintegral_iUnion M]
      exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
    _ = âˆ«â» x in s, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      rw [â† inter_iUnion, inter_eq_self_of_subset_left t_cover]
    _ = (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s := by
      simp only [lintegral_add_right' _ aemeasurable_const, setLIntegral_const]"
Mathlib/GroupTheory/Complement.lean,Subgroup.exists_right_transversal_of_le,exists_right_transversal_of_le,d3b10564ae5faf08a7fba089e2773d175b9145d2,":= by
  let H'' : Subgroup H := H'.comap H.subtype
  have : H' = H''.map H.subtype := by simp [h]
  rw [this]
  obtain âŸ¨S, cmem, -âŸ© := H''.exists_right_transversal 1
  refine âŸ¨H.subtype '' S, ?_, ?_âŸ©
  Â· have : H.subtype '' (H'' * S) = H''.map H.subtype * H.subtype '' S := image_mul H.subtype
    rw [â† this, cmem.mul_eq]
    simp [Set.ext_iff]
  Â· have : Nat.card H'' * Nat.card S = Nat.card H := cmem.card_mul_card
    rw [â† this]
    refine congr_argâ‚‚ (Â· * Â·) ?_ ?_ <;>
      exact Nat.card_congr (Equiv.Set.image _ _ $ subtype_injective H).symm",error:  simp made no progress,"lemma exists_right_transversal_of_le {H' H : Subgroup G} (h : H' â‰¤ H) :
    âˆƒ S : Set G, H' * S = H âˆ§ Nat.card H' * Nat.card S = Nat.card H ",":= by
  let H'' : Subgroup H := H'.comap H.subtype
  have : H' = H''.map H.subtype := by simp [H'', h]
  rw [this]
  obtain âŸ¨S, cmem, -âŸ© := H''.exists_right_transversal 1
  refine âŸ¨H.subtype '' S, ?_, ?_âŸ©
  Â· have : H.subtype '' (H'' * S) = H''.map H.subtype * H.subtype '' S := image_mul H.subtype
    rw [â† this, cmem.mul_eq]
    simp [Set.ext_iff]
  Â· have : Nat.card H'' * Nat.card S = Nat.card H := cmem.card_mul_card
    rw [â† this]
    refine congr_argâ‚‚ (Â· * Â·) ?_ ?_ <;>
      exact Nat.card_congr (Equiv.Set.image _ _ <| subtype_injective H).symm"
Mathlib/Dynamics/OmegaLimit.lean,eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset',eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset',08ffc014ce7472c743cc849e2820181b3a1c4cae,":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  let k := closure (image2 Ï• v s)
  have hk : IsCompact (k \ n) :=
    IsCompact.diff (isCompact_of_isClosed_subset hcâ‚ isClosed_closure hvâ‚‚) hnâ‚
  let j u := closure (image2 Ï• (u âˆ© v) s)á¶œ
  have hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u) := fun _ _ â†¦ isOpen_compl_iff.mpr isClosed_closure
  have hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u := by
    have : (â‹ƒ u âˆˆ f, j u) = â‹ƒ u : (â†¥f.sets), j u := bunionáµ¢_eq_unionáµ¢ _ _
    rw [this, diff_subset_comm, diff_unionáµ¢]
    rw [omegaLimit_eq_interáµ¢_inter _ _ _ hvâ‚] at hnâ‚‚
    simp_rw [diff_compl]
    rw [â† inter_interáµ¢]
    exact Subset.trans (inter_subset_right _ _) hnâ‚‚
  rcases hk.elim_finite_subcover_image hjâ‚ hjâ‚‚ with âŸ¨g, hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f, hgâ‚‚, hgâ‚ƒâŸ©
  let w := (â‹‚ u âˆˆ g, u) âˆ© v
  have hwâ‚‚ : w âˆˆ f := by simpa [*]
  have hwâ‚ƒ : k \ n âŠ† closure (image2 Ï• w s)á¶œ := by
    apply Subset.trans hgâ‚ƒ
    simp only [unionáµ¢_subset_iff, compl_subset_compl]
    intros u hu
    mono*
    refine' interáµ¢_subset_of_subset u (interáµ¢_subset_of_subset hu _)
    all_goals exact Subset.rfl
  have hwâ‚„ : ká¶œ âŠ† closure (image2 Ï• w s)á¶œ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset (inter_subset_right _ _) Subset.rfl)
  have hnc : ná¶œ âŠ† k \ n âˆª ká¶œ := by rw [union_comm, â† inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 Ï• w s) âŠ† n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hwâ‚ƒ hwâ‚„))
  exact âŸ¨_, hwâ‚‚, hwâŸ©","warning:  @omegaLimit does not have a doc string
error:  unknown identifier 'isCompact_of_isClosed_subset'
error:  type mismatch
  isOpen_compl_iff.mpr isClosed_closure
has type
  IsOpen (closure ?m.18571)á¶œ : Prop
but is expected to have type
  IsOpen (j xâœÂ¹) : Prop
error:  unknown identifier 'bunionáµ¢_eq_unionáµ¢'
error:  unknown identifier 'diff_unionáµ¢'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.19401
Ï„ : Type u_1
Î± : Type u_2
Î² : Type u_3
Î¹ : Type u_4
instâœ : TopologicalSpace Î²
f : Filter Ï„
Ï• : Ï„ â†’ Î± â†’ Î²
s sâ‚ sâ‚‚ : Set Î±
c : Set Î²
hcâ‚ : IsCompact c
n : Set Î²
hnâ‚ : IsOpen n
hnâ‚‚ : Ï‰ f Ï• s âŠ† n
v : Set Ï„
hvâ‚ : v âˆˆ f
hvâ‚‚ : closure (image2 Ï• v s) âŠ† c
k : Set Î² := closure (image2 Ï• v s)
hk : IsCompact (k \ n)
j : Set Ï„ â†’ Set Î² := fun u â†¦ closure (image2 Ï• (u âˆ© v) s)á¶œ
hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u)
this : â‹ƒ u âˆˆ f, j u = â‹ƒ u, j â†‘u
âŠ¢ k \ â‹ƒ u, j â†‘u âŠ† n
error:  tactic 'assumption' failed
Ï„ : Type u_1
Î± : Type u_2
Î² : Type u_3
Î¹ : Type u_4
instâœ : TopologicalSpace Î²
f : Filter Ï„
Ï• : Ï„ â†’ Î± â†’ Î²
s sâ‚ sâ‚‚ : Set Î±
c : Set Î²
hcâ‚ : IsCompact c
n : Set Î²
hnâ‚ : IsOpen n
hnâ‚‚ : Ï‰ f Ï• s âŠ† n
v : Set Ï„
hvâ‚ : v âˆˆ f
hvâ‚‚ : closure (image2 Ï• v s) âŠ† c
k : Set Î² := closure (image2 Ï• v s)
hk : IsCompact (k \ n)
j : Set Ï„ â†’ Set Î² := fun u â†¦ closure (image2 Ï• (u âˆ© v) s)á¶œ
hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u)
hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u
g : Set (Set Ï„)
hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f
hgâ‚‚ : g.Finite
hgâ‚ƒ : k \ n âŠ† â‹ƒ i âˆˆ g, j i
w : Set Ï„ := (â‹‚ u âˆˆ g, u) âˆ© v
âŠ¢ w âˆˆ f
error:  unknown identifier 'unionáµ¢_subset_iff'
error:  simp made no progress
error:  simp made no progress
error:  application type mismatch
  union_subset hwâ‚ƒ
argument
  hwâ‚ƒ
has type
  k \ n âŠ† closure (image2 Ï• w s)á¶œ : Prop
but is expected to have type
  k \ n âŠ† (closure (image2 Ï• w s))á¶œ : Prop","theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set Î²}
    (hcâ‚ : IsCompact c) (hcâ‚‚ : âˆƒ v âˆˆ f, closure (image2 Ï• v s) âŠ† c) {n : Set Î²} (hnâ‚ : IsOpen n)
    (hnâ‚‚ : Ï‰ f Ï• s âŠ† n) : âˆƒ u âˆˆ f, closure (image2 Ï• u s) âŠ† n ",":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  let k := closure (image2 Ï• v s)
  have hk : IsCompact (k \ n) :=
    (hcâ‚.of_isClosed_subset isClosed_closure hvâ‚‚).diff hnâ‚
  let j u := (closure (image2 Ï• (u âˆ© v) s))á¶œ
  have hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u) := fun _ _ â†¦ isOpen_compl_iff.mpr isClosed_closure
  have hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u := by
    have : â‹ƒ u âˆˆ f, j u = â‹ƒ u : (â†¥f.sets), j u := biUnion_eq_iUnion _ _
    rw [this, diff_subset_comm, diff_iUnion]
    rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚] at hnâ‚‚
    simp_rw [j, diff_compl]
    rw [â† inter_iInter]
    exact Subset.trans inter_subset_right hnâ‚‚
  rcases hk.elim_finite_subcover_image hjâ‚ hjâ‚‚ with âŸ¨g, hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f, hgâ‚‚, hgâ‚ƒâŸ©
  let w := (â‹‚ u âˆˆ g, u) âˆ© v
  have hwâ‚‚ : w âˆˆ f := by simpa [w, *]
  have hwâ‚ƒ : k \ n âŠ† (closure (image2 Ï• w s))á¶œ := by
    apply Subset.trans hgâ‚ƒ
    simp only [j, iUnion_subset_iff, compl_subset_compl]
    intros u hu
    mono
    refine iInter_subset_of_subset u (iInter_subset_of_subset hu ?_)
    all_goals exact Subset.rfl
  have hwâ‚„ : ká¶œ âŠ† (closure (image2 Ï• w s))á¶œ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset inter_subset_right Subset.rfl)
  have hnc : ná¶œ âŠ† k \ n âˆª ká¶œ := by rw [union_comm, â† inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 Ï• w s) âŠ† n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hwâ‚ƒ hwâ‚„))
  exact âŸ¨_, hwâ‚‚, hwâŸ©"
Mathlib/GroupTheory/MonoidLocalization.lean,Submonoid.LocalizationMap.lift_mk',lift_mk',d8706958c4ace0c8be69913719416f240c67c54a,":=
  (mul_inv hg).2 <|
    f.eq_of_eq hg <| by
      simp_rw [f.toMap.map_mul, f.toMap.map_mul, sec_spec', mul_assoc, f.mk'_spec, mul_comm]",error:  simp made no progress,theorem lift_mk' (x y) : f.lift hg (f.mk' x y) = g x * (IsUnit.liftRight (g.restrict S) hg y)â»Â¹ ,":=
  (mul_inv hg).2 <|
    f.eq_of_eq hg <| by
      simp_rw [f.toMap.map_mul, sec_spec', mul_assoc, f.mk'_spec, mul_comm]"
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean,MeasureTheory.AEFinStronglyMeasurable.exists_set_sigmaFinite,exists_set_sigmaFinite,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rcases hf with âŸ¨fs, hT_lt_top, h_approxâŸ©
  let T n := support (fs n)
  have hT_meas : âˆ€ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)
  let t := â‹ƒ n, T n
  refine' âŸ¨t, MeasurableSet.iUnion hT_meas, _, _âŸ©
  Â· have h_fs_zero : âˆ€ n, âˆ€ x âˆˆ tá¶œ, fs n x = 0 := by
      intro n x hxt
      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt
      simpa [T] using hxt n
    refine' fun x hxt => tendsto_nhds_unique (h_approx x) _
    rw [funext fun n => h_fs_zero n x hxt]
    exact tendsto_const_nhds
  Â· refine' âŸ¨âŸ¨âŸ¨fun n => tá¶œ âˆª T n, fun _ => trivial, fun n => _, _âŸ©âŸ©âŸ©
    Â· rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,
        Set.compl_inter_self t, Set.empty_union]
      exact (measure_mono (Set.inter_subset_left _ _)).trans_lt (hT_lt_top n)
    Â· rw [â† Set.union_iUnion tá¶œ T]
      exact Set.compl_union_self _","error:  function expected at
  inter_subset_left ?m.176273
term has type
  ?m.176272 âˆˆ ?m.176270","theorem exists_set_sigmaFinite [Zero Î²] [TopologicalSpace Î²] [T2Space Î²]
    (hf : FinStronglyMeasurable f Î¼) :
    âˆƒ t, MeasurableSet t âˆ§ (âˆ€ x âˆˆ tá¶œ, f x = 0) âˆ§ SigmaFinite (Î¼.restrict t) ",":= by
  rcases hf with âŸ¨fs, hT_lt_top, h_approxâŸ©
  let T n := support (fs n)
  have hT_meas : âˆ€ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)
  let t := â‹ƒ n, T n
  refine âŸ¨t, MeasurableSet.iUnion hT_meas, ?_, ?_âŸ©
  Â· have h_fs_zero : âˆ€ n, âˆ€ x âˆˆ tá¶œ, fs n x = 0 := by
      intro n x hxt
      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt
      simpa [T] using hxt n
    refine fun x hxt => tendsto_nhds_unique (h_approx x) ?_
    rw [funext fun n => h_fs_zero n x hxt]
    exact tendsto_const_nhds
  Â· refine âŸ¨âŸ¨âŸ¨fun n => tá¶œ âˆª T n, fun _ => trivial, fun n => ?_, ?_âŸ©âŸ©âŸ©
    Â· rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,
        Set.compl_inter_self t, Set.empty_union]
      exact (measure_mono Set.inter_subset_left).trans_lt (hT_lt_top n)
    Â· rw [â† Set.union_iUnion tá¶œ T]
      exact Set.compl_union_self _"
Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean,CategoryTheory.Limits.colimitLimitToLimitColimit_surjective,colimitLimitToLimitColimit_surjective,14167e48d13e9c2d72cbdff0431a8edba6021c34,":= by
  classical
    intro x
    have z := fun j => jointly_surjective'.{v, v} (limit.Ï€ (curry.obj F â‹™ Limits.colim) j x)
    let k : J â†’ K := fun j => (z j).choose
    let y : âˆ€ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : âˆ€ j,
        colimit.Î¹ ((curry.obj F).obj j) (k j) (y j) = limit.Ï€ (curry.obj F â‹™ Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) âˆ…
    have g : âˆ€ j, k j âŸ¶ k' := fun j => IsFiltered.toSup (Finset.univ.image k) âˆ… (by simp)
    clear_value k'
    have w :
      âˆ€ {j j' : J} (f : j âŸ¶ j'),
        colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((ğŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =
          colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ğŸ™ (k j)) : (j, k j) âŸ¶ (j', k j)) â‰« (ğŸ™ j', g j) : (j, k j) âŸ¶ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply', t, FunctorToTypes.map_comp_apply, Colimit.w_apply', e, â†
        Limit.w_apply' f, â† e]
      simp
    simp_rw [colimit_eq_iff.{v, v}] at w
    let kf : âˆ€ {j j'} (_ : j âŸ¶ j'), K := fun f => (w f).choose
    let gf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun f => (w f).choose_spec.choose
    let hf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      âˆ€ {j j'} (f : j âŸ¶ j'),
        F.map ((ğŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j') =
          F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ğŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [â† FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.bunionáµ¢ fun j => Finset.univ.bunionáµ¢ fun j' => Finset.univ.image
        (@kf j j')) âˆª {k'}
    have kfO : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âˆˆ O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (by
            rw [Finset.mem_bunionáµ¢]
            refine' âŸ¨j, Finset.mem_univ j, _âŸ©
            rw [Finset.mem_bunionáµ¢]
            refine' âŸ¨j', Finset.mem_univ j', _âŸ©
            rw [Finset.mem_image]
            refine' âŸ¨f, Finset.mem_univ _, _âŸ©
            rfl))
    have k'O : k' âˆˆ O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Î£'(X Y : K)(_ : X âˆˆ O)(_ : Y âˆˆ O), X âŸ¶ Y) :=
      Finset.univ.bunionáµ¢ fun j : J =>
        Finset.univ.bunionáµ¢ fun j' : J =>
          Finset.univ.bunionáµ¢ fun f : j âŸ¶ j' =>
            {âŸ¨k', kf f, k'O, kfO f, gf fâŸ©, âŸ¨k', kf f, k'O, kfO f, hf fâŸ©}
    obtain âŸ¨k'', i', s'âŸ© := IsFiltered.sup_exists O H
    let i : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âŸ¶ k'' := fun {j} {j'} f => i' (kfO f)
    have s : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ jâ‚„} (f : jâ‚ âŸ¶ jâ‚‚) (f' : jâ‚ƒ âŸ¶ jâ‚„), gf f â‰« i f = hf f' â‰« i f' := by
      intros jâ‚ jâ‚‚ jâ‚ƒ jâ‚„ f f'
      rw [s', s']
      exact k'O
      swap
      Â· rw [Finset.mem_bunionáµ¢]
        refine' âŸ¨jâ‚, Finset.mem_univ _, _âŸ©
        rw [Finset.mem_bunionáµ¢]
        refine' âŸ¨jâ‚‚, Finset.mem_univ _, _âŸ©
        rw [Finset.mem_bunionáµ¢]
        refine' âŸ¨f, Finset.mem_univ _, _âŸ©
        simp only [true_or_iff, eq_self_iff_true, and_self_iff, Finset.mem_insert, heq_iff_eq]
      Â· rw [Finset.mem_bunionáµ¢]
        refine' âŸ¨jâ‚ƒ, Finset.mem_univ _, _âŸ©
        rw [Finset.mem_bunionáµ¢]
        refine' âŸ¨jâ‚„, Finset.mem_univ _, _âŸ©
        rw [Finset.mem_bunionáµ¢]
        refine' âŸ¨f', Finset.mem_univ _, _âŸ©
        simp only [eq_self_iff_true, or_true_iff, and_self_iff, Finset.mem_insert,
          Finset.mem_singleton, heq_iff_eq]
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    Â· 
      apply colimit.Î¹ (curry.obj (swap K J â‹™ F) â‹™ Limits.lim) k'' _
      dsimp
      apply Limit.mk.{v, v}
      swap
      Â·
        exact fun j => F.map (âŸ¨ğŸ™ j, g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j)âŸ© : (j, k j) âŸ¶ (j, k'')) (y j)
      Â· 
        dsimp
        intro j j' f
        simp only [â† FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j)) : (j, k j) âŸ¶ (j', k'')) (y j) =
              F.map ((f, g j â‰« hf f â‰« i f) : (j, k j) âŸ¶ (j', k'')) (y j) :=
            by rw [s (ğŸ™ j) f]
          _ =
              F.map ((ğŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))
                (F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j)) :=
            by rw [â† FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ğŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))
                (F.map ((ğŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j')) :=
            by rw [â† wf f]
          _ = F.map ((ğŸ™ j', g j' â‰« gf f â‰« i f) : (j', k j') âŸ¶ (j', k'')) (y j') := by
            rw [â† FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ğŸ™ j', g j' â‰« gf (ğŸ™ j') â‰« i (ğŸ™ j')) : (j', k j') âŸ¶ (j', k'')) (y j') := by
            rw [s f (ğŸ™ j'), â† s (ğŸ™ j') (ğŸ™ j')]
    Â· 
      apply limit_ext'
      intro j
      simp only [id.def, â† e, Limits.Î¹_colimitLimitToLimitColimit_Ï€_apply,
          colimit_eq_iff.{v, v}, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.Ï€_mk]
      refine' âŸ¨k'', ğŸ™ k'', g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j), _âŸ©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","error:  application type mismatch
  jointly_surjective' (limit.Ï€ (curry.obj F â‹™ colim) j x)
argument
  limit.Ï€ (curry.obj F â‹™ colim) j x
has type
  (curry.obj F â‹™ colim).obj j : Type v
but is expected to have type
  colimit ?m.27488 : Type v
error:  unsolved goals
J : Type uâ‚
K : Type uâ‚‚
instâœâ´ : SmallCategory J
instâœÂ³ : Category.{vâ‚‚, uâ‚‚} K
instâœÂ² : Small.{v, uâ‚‚} K
instâœÂ¹ : FinCategory J
F : J Ã— K â¥¤ Type v
instâœ : IsFiltered K
x : limit (curry.obj F â‹™ colim)
âŠ¢ âˆƒ a, colimitLimitToLimitColimit F a = x","theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) ",":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.Ï€ (curry.obj F â‹™ Limits.colim) j x)
    let k : J â†’ K := fun j => (z j).choose
    let y : âˆ€ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : âˆ€ j,
        colimit.Î¹ ((curry.obj F).obj j) (k j) (y j) = limit.Ï€ (curry.obj F â‹™ Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) âˆ…
    have g : âˆ€ j, k j âŸ¶ k' := fun j => IsFiltered.toSup (Finset.univ.image k) âˆ… (by simp)
    clear_value k'
    have w :
      âˆ€ {j j' : J} (f : j âŸ¶ j'),
        colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((ğŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =
          colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ğŸ™ (k j)) : (j, k j) âŸ¶ (j', k j)) â‰« (ğŸ™ j', g j) : (j, k j) âŸ¶ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        â† Limit.w_apply.{uâ‚, v, uâ‚} f, â† e]
      simp only [Functor.comp_map, Types.Colimit.Î¹_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : âˆ€ {j j'} (_ : j âŸ¶ j'), K := fun f => (w f).choose
    let gf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun f => (w f).choose_spec.choose
    let hf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      âˆ€ {j j'} (f : j âŸ¶ j'),
        F.map ((ğŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j') =
          F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ğŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [â† FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) âˆª {k'}
    have kfO : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âˆˆ O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr âŸ¨j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr âŸ¨j', Finset.mem_univ j',
              Finset.mem_image.mpr âŸ¨f, Finset.mem_univ _, rflâŸ©âŸ©âŸ©))
    have k'O : k' âˆˆ O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Î£' (X Y : K) (_ : X âˆˆ O) (_ : Y âˆˆ O), X âŸ¶ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j âŸ¶ j' =>
            {âŸ¨k', kf f, k'O, kfO f, gf fâŸ©, âŸ¨k', kf f, k'O, kfO f, hf fâŸ©}
    obtain âŸ¨k'', i', s'âŸ© := IsFiltered.sup_exists O H
    let i : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âŸ¶ k'' := fun {j} {j'} f => i' (kfO f)
    have s : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ jâ‚„} (f : jâ‚ âŸ¶ jâ‚‚) (f' : jâ‚ƒ âŸ¶ jâ‚„), gf f â‰« i f = hf f' â‰« i f' := by
      intros jâ‚ jâ‚‚ jâ‚ƒ jâ‚„ f f'
      rw [s', s']
      Â· exact k'O
      Â· exact Finset.mem_biUnion.mpr âŸ¨jâ‚ƒ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr âŸ¨jâ‚„, Finset.mem_univ _,
            Finset.mem_biUnion.mpr âŸ¨f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivialâŸ©âŸ©âŸ©
      Â· exact Finset.mem_biUnion.mpr âŸ¨jâ‚, Finset.mem_univ _,
          Finset.mem_biUnion.mpr âŸ¨jâ‚‚, Finset.mem_univ _,
            Finset.mem_biUnion.mpr âŸ¨f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivialâŸ©âŸ©âŸ©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    Â· 
      apply colimit.Î¹ (curry.obj (swap K J â‹™ F) â‹™ Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      Â·
        exact fun j => F.map (âŸ¨ğŸ™ j, g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j)âŸ© : (j, k j) âŸ¶ (j, k'')) (y j)
      Â· 
        dsimp
        intro j j' f
        simp only [â† FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j)) : (j, k j) âŸ¶ (j', k'')) (y j) =
              F.map ((f, g j â‰« hf f â‰« i f) : (j, k j) âŸ¶ (j', k'')) (y j) := by
            rw [s (ğŸ™ j) f]
          _ =
              F.map ((ğŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))
                (F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j)) := by
            rw [â† FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ğŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))
                (F.map ((ğŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j')) := by
            rw [â† wf f]
          _ = F.map ((ğŸ™ j', g j' â‰« gf f â‰« i f) : (j', k j') âŸ¶ (j', k'')) (y j') := by
            rw [â† FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ğŸ™ j', g j' â‰« gf (ğŸ™ j') â‰« i (ğŸ™ j')) : (j', k j') âŸ¶ (j', k'')) (y j') := by
            rw [s f (ğŸ™ j'), â† s (ğŸ™ j') (ğŸ™ j')]
    Â· 
      apply limit_ext
      intro j
      simp only [id, â† e, Limits.Î¹_colimitLimitToLimitColimit_Ï€_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.Ï€_mk]
      refine âŸ¨k'', ğŸ™ k'', g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j), ?_âŸ©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]"
Mathlib/Analysis/NormedSpace/BoundedLinearMaps.lean,IsBoundedBilinearMap.continuous,IsBoundedBilinearMap.continuous,0939faa78a0c4506a8aee4e86b897d6e84c6cb96,":= by
  refine continuous_iff_continuousAt.2 fun x â†¦ tendsto_sub_nhds_zero_iff.1 ?_
  suffices : Tendsto (Î» y : E Ã— F â†¦ f (y.1 - x.1, y.2) + f (x.1, y.2 - x.2)) (ğ“ x) (ğ“ (0 + 0))
  Â· simpa only [h.map_sub_left, h.map_sub_right, sub_add_sub_cancel, zero_add] using this
  apply Tendsto.add
  Â· rw [â† isLittleO_one_iff â„, â† one_mul 1]
    refine h.isBigO_comp.trans_isLittleO ?_
    refine (IsLittleO.norm_left ?_).mul_isBigO (IsBigO.norm_left ?_)
    Â· exact (isLittleO_one_iff _).2 (tendsto_sub_nhds_zero_iff.2 (continuous_fst.tendsto _))
    Â· exact (continuous_snd.tendsto _).isBigO_one â„
  Â· refine Continuous.tendsto' ?_ _ _ (by rw [h.map_sub_right, sub_self])
    exact ((h.toContinuousLinearMap x.1).continuous).comp (continuous_snd.sub continuous_const)",error:  unexpected token ':'; expected term,theorem IsBoundedBilinearMap.continuous (h : IsBoundedBilinearMap ğ•œ f) : Continuous f ,":= by
  refine continuous_iff_continuousAt.2 fun x â†¦ tendsto_sub_nhds_zero_iff.1 ?_
  suffices Tendsto (fun y : E Ã— F â†¦ f (y.1 - x.1, y.2) + f (x.1, y.2 - x.2)) (ğ“ x) (ğ“ (0 + 0)) by
    simpa only [h.map_sub_left, h.map_sub_right, sub_add_sub_cancel, zero_add] using this
  apply Tendsto.add
  Â· rw [â† isLittleO_one_iff â„, â† one_mul 1]
    refine h.isBigO_comp.trans_isLittleO ?_
    refine (IsLittleO.norm_left ?_).mul_isBigO (IsBigO.norm_left ?_)
    Â· exact (isLittleO_one_iff _).2 (tendsto_sub_nhds_zero_iff.2 (continuous_fst.tendsto _))
    Â· exact (continuous_snd.tendsto _).isBigO_one â„
  Â· refine Continuous.tendsto' ?_ _ _ (by rw [h.map_sub_right, sub_self])
    exact ((h.toContinuousLinearMap x.1).continuous).comp (continuous_snd.sub continuous_const)"
Mathlib/RingTheory/Ideal/LocalRing.lean,LocalRing.local_hom_TFAE,local_hom_TFAE,415d6b952a0c6bc1221dd68bc6ae84a0390ea21f,":= by
  tfae
    1 â†’ 2 := by
      rintro _ _ âŸ¨a, ha, rflâŸ©
      exact map_nonunit f a ha
    2 â†’ 4 := Set.image_subset_iff.1
    3 â†” 4 := Ideal.map_le_iff_le_comap
    4 â†’ 1
    | h => by
      constructor
      exact fun x => not_imp_not.1 (@h x)
    1 â†’ 5
    | _ => by
      ext
      exact not_iff_not.2 (isUnit_map_iff f _)
    5 â†’ 4 := fun h => le_of_eq h.symm","error:  unknown tactic
error:  unsolved goals
R : Type u
S : Type v
T : Type w
K : Type u'
instâœÂ³ : CommSemiring R
instâœÂ² : LocalRing R
instâœÂ¹ : CommSemiring S
instâœ : LocalRing S
f : R â†’+* S
âŠ¢ [IsLocalRingHom f, â‡‘f '' â†‘(maximalIdeal R).toAddSubmonoid âŠ† â†‘(maximalIdeal S),
      Ideal.map f (maximalIdeal R) â‰¤ maximalIdeal S, maximalIdeal R â‰¤ Ideal.comap f (maximalIdeal S),
      Ideal.comap f (maximalIdeal S) = maximalIdeal R].TFAE","theorem local_hom_TFAE (f : R â†’+* S) :
    List.TFAE
      [IsLocalRingHom f, f '' (maximalIdeal R).1 âŠ† maximalIdeal S,
        (maximalIdeal R).map f â‰¤ maximalIdeal S, maximalIdeal R â‰¤ (maximalIdeal S).comap f,
        (maximalIdeal S).comap f = maximalIdeal R] ",":= by
  tfae_have 1 â†’ 2
  Â· rintro _ _ âŸ¨a, ha, rflâŸ©
    exact map_nonunit f a ha
  tfae_have 2 â†’ 4
  Â· exact Set.image_subset_iff.1
  tfae_have 3 â†” 4
  Â· exact Ideal.map_le_iff_le_comap
  tfae_have 4 â†’ 1
  Â· intro h
    constructor
    exact fun x => not_imp_not.1 (@h x)
  tfae_have 1 â†’ 5
  Â· intro
    ext
    exact not_iff_not.2 (isUnit_map_iff f _)
  tfae_have 5 â†’ 4
  Â· exact fun h => le_of_eq h.symm
  tfae_finish"
Mathlib/AlgebraicGeometry/Pullbacks.lean,AlgebraicGeometry.Scheme.Pullback.lift_comp_Î¹,lift_comp_Î¹,8d72f500a692fb12cb594b710bb3ac6e29534e0d,":= by
  apply ((gluing ğ’° f g).openCover.pullbackCover pullback.fst).hom_ext
  intro j
  dsimp only [OpenCover.pullbackCover]
  trans pullbackFstÎ¹ToV ğ’° f g i j â‰« fV ğ’° f g j i â‰« (gluing ğ’° f g).Î¹ _
  Â· rw [â† show _ = fV ğ’° f g j i â‰« _ from (gluing ğ’° f g).glue_condition j i]
    simp_rw [â† Category.assoc]
    congr 1
    rw [gluing_f, gluing_t]
    apply pullback.hom_ext <;> simp_rw [Category.assoc]
    Â· rw [t_fst_fst, pullback.lift_fst, pullbackFstÎ¹ToV_snd]; rfl
    Â· rw [t_fst_snd, pullback.lift_snd, pullbackFstÎ¹ToV_fst_assoc, pullback.condition_assoc]
      erw [Multicoequalizer.inj_desc]
      rfl
  Â· rw [pullback.condition, â† Category.assoc]
    congr 1
    apply pullback.hom_ext
    Â· simp only [pullbackFstÎ¹ToV_fst]; rfl
    Â· simp only [pullbackFstÎ¹ToV_fst]; rfl","error:  unknown identifier 'Multicoequalizer.inj_desc'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.356136
case e_a.hâ‚
C : Type u
instâœÂ¹ : Category.{v, u} C
X Y Z : Scheme
ğ’° : X.OpenCover
f : X âŸ¶ Z
g : Y âŸ¶ Z
instâœ : âˆ€ (i : ğ’°.J), HasPullback (ğ’°.map i â‰« f) g
s : PullbackCone f g
i : ğ’°.J
j : ((gluing ğ’° f g).openCover.pullbackCover pullback.fst).J
âŠ¢ pullback.snd â‰« (gluing ğ’° f g).openCover.map j â‰« p2 ğ’° f g = pullback.snd â‰« pullback.snd","theorem lift_comp_Î¹ (i : ğ’°.J) :
    pullback.lift pullback.snd (pullback.fst â‰« p2 ğ’° f g)
          (by rw [â† pullback.condition_assoc, Category.assoc, p_comm]) â‰«
        (gluing ğ’° f g).Î¹ i =
      (pullback.fst : pullback (p1 ğ’° f g) (ğ’°.map i) âŸ¶ _) ",":= by
  apply ((gluing ğ’° f g).openCover.pullbackCover pullback.fst).hom_ext
  intro j
  dsimp only [OpenCover.pullbackCover]
  trans pullbackFstÎ¹ToV ğ’° f g i j â‰« fV ğ’° f g j i â‰« (gluing ğ’° f g).Î¹ _
  Â· rw [â† show _ = fV ğ’° f g j i â‰« _ from (gluing ğ’° f g).glue_condition j i]
    simp_rw [â† Category.assoc]
    congr 1
    rw [gluing_f, gluing_t]
    apply pullback.hom_ext <;> simp_rw [Category.assoc]
    Â· simp_rw [t_fst_fst, pullback.lift_fst, pullbackFstÎ¹ToV_snd, GlueData.openCover_map]
    Â· simp_rw [t_fst_snd, pullback.lift_snd, pullbackFstÎ¹ToV_fst_assoc, pullback.condition_assoc,
        GlueData.openCover_map, p2]
      simp
  Â· rw [pullback.condition, â† Category.assoc]
    simp_rw [pullbackFstÎ¹ToV_fst, GlueData.openCover_map]"
Mathlib/CategoryTheory/EqToHom.lean,CategoryTheory.congrArg_cast_hom_left,congrArg_cast_hom_left,ce551b4c26f32fd85949e1fca91a8c5f2a0aec3f,":= by
  cases p
  simp

 theorem congrArg_mpr_hom_left {X Y Z : C} (p : X = Y) (q : Y âŸ¶ Z) :
    (congrArg (fun W : C => W âŸ¶ Z) p).mpr q = eqToHom p â‰« q := by
  cases p
  simp [eq_mpr_eq_cast]",error:  'CategoryTheory.congrArg_mpr_hom_left' has already been declared,"theorem congrArg_cast_hom_left {X Y Z : C} (p : X = Y) (q : Y âŸ¶ Z) :
    cast (congrArg (fun W : C => W âŸ¶ Z) p.symm) q = eqToHom p â‰« q ",":= by
  cases p
  simp"
Mathlib/MeasureTheory/Measure/Typeclasses.lean,MeasureTheory.insert_ae_eq_self,insert_ae_eq_self,089ac90928952b8a08be66ede7ff142d0f9ba666,":=
  union_ae_eq_right.2 <| measure_mono_null (diff_subset _ _) (measure_singleton _)","error:  function expected at
  diff_subset ?m.100996
term has type
  ?m.100995 âˆˆ ?m.100993",theorem insert_ae_eq_self (a : Î±) (s : Set Î±) : (insert a s : Set Î±) =áµ[Î¼] s ,":=
  union_ae_eq_right.2 <| measure_mono_null diff_subset (measure_singleton _)"
Mathlib/Analysis/NormedSpace/Star/Unitization.lean,Unitization.norm_splitMul_snd_sq,Unitization.norm_splitMul_snd_sq,af8d8e6d37fbe07db1396e407d0253571fd7ea2b,":= by
  refine (Real.le_sqrt (norm_nonneg _) (norm_nonneg _)).mp ?_
  simp only [Unitization.splitMul_apply]
  rw [â† sSup_unit_closedBall_eq_norm]
  refine csSup_le ((Metric.nonempty_closedBall.2 zero_le_one).image _) ?_
  rintro - âŸ¨b, hb, rflâŸ©
  simp only
  rw [â† Real.sqrt_sq (norm_nonneg _), Real.sqrt_le_sqrt_iff (norm_nonneg _), sq,
    â† CstarRing.norm_star_mul_self, ContinuousLinearMap.add_apply, star_add, mul_apply',
    Algebra.algebraMap_eq_smul_one, ContinuousLinearMap.smul_apply,
    ContinuousLinearMap.one_apply, star_mul, star_smul, add_mul, smul_mul_assoc, â† mul_smul_comm,
    mul_assoc, â† mul_add, â† sSup_unit_closedBall_eq_norm]
  refine (norm_mul_le _ _).trans ?_
  calc
    _ â‰¤ â€–star x.fst â€¢ (x.fst â€¢ b + x.snd * b) + star x.snd * (x.fst â€¢ b + x.snd * b)â€– := by
      nth_rewrite 2 [â† one_mul â€–_ + _â€–]
      gcongr
      exact (norm_star b).symm â–¸ mem_closedBall_zero_iff.1 hb
    _ â‰¤ sSup (_ '' Metric.closedBall 0 1) := le_csSup ?_ âŸ¨b, hb, ?_âŸ©
  Â· refine âŸ¨â€–(star x * x).fstâ€– + â€–(star x * x).sndâ€–, ?_âŸ©
    rintro _ âŸ¨y, hy, rflâŸ©
    refine (norm_add_le _ _).trans ?_
    gcongr
    Â· rw [Algebra.algebraMap_eq_smul_one]
      refine (norm_smul _ _).trans_le ?_
      simpa only [mul_one] using
        mul_le_mul_of_nonneg_left (mem_closedBall_zero_iff.1 hy) (norm_nonneg (star x * x).fst)
    Â· exact (unit_le_op_norm _ y <| mem_closedBall_zero_iff.1 hy).trans (op_norm_mul_apply_le _ _ _)
  Â· simp only [ContinuousLinearMap.add_apply, mul_apply', Unitization.snd_star, Unitization.snd_mul,
      Unitization.fst_mul, Unitization.fst_star, Algebra.algebraMap_eq_smul_one, smul_apply,
      one_apply, smul_add, mul_add, add_mul]
    simp only [smul_smul, smul_mul_assoc, â† add_assoc, â† mul_assoc, mul_smul_comm]","error:  unknown identifier 'sSup_unit_closedBall_eq_norm'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.89275
ğ•œ : Type u_1
E : Type u_2
instâœâ¹ : DenselyNormedField ğ•œ
instâœâ¸ : NonUnitalNormedRing E
instâœâ· : StarRing E
instâœâ¶ : CstarRing E
instâœâµ : NormedSpace ğ•œ E
instâœâ´ : IsScalarTower ğ•œ E E
instâœÂ³ : SMulCommClass ğ•œ E E
instâœÂ² : StarRing ğ•œ
instâœÂ¹ : CstarRing ğ•œ
instâœ : StarModule ğ•œ E
x : Unitization ğ•œ E
âŠ¢ â€–(algebraMap ğ•œ (E â†’L[ğ•œ] E)) x.fst + (mul ğ•œ E) x.sndâ€– â‰¤
    âˆšâ€–(algebraMap ğ•œ (E â†’L[ğ•œ] E)) (xâ‹† * x).fst + (mul ğ•œ E) (xâ‹† * x).sndâ€–","theorem Unitization.norm_splitMul_snd_sq (x : Unitization ğ•œ E) :
    â€–(Unitization.splitMul ğ•œ E x).sndâ€– ^ 2 â‰¤ â€–(Unitization.splitMul ğ•œ E (star x * x)).sndâ€– ",":= by
  refine (Real.le_sqrt (norm_nonneg _) (norm_nonneg _)).mp ?_
  simp only [Unitization.splitMul_apply]
  rw [â† sSup_closed_unit_ball_eq_norm]
  refine csSup_le ((Metric.nonempty_closedBall.2 zero_le_one).image _) ?_
  rintro - âŸ¨b, hb, rflâŸ©
  simp only
  rw [â† Real.sqrt_sq (norm_nonneg _), Real.sqrt_le_sqrt_iff (norm_nonneg _), sq,
    â† CstarRing.norm_star_mul_self, ContinuousLinearMap.add_apply, star_add, mul_apply',
    Algebra.algebraMap_eq_smul_one, ContinuousLinearMap.smul_apply,
    ContinuousLinearMap.one_apply, star_mul, star_smul, add_mul, smul_mul_assoc, â† mul_smul_comm,
    mul_assoc, â† mul_add, â† sSup_closed_unit_ball_eq_norm]
  refine (norm_mul_le _ _).trans ?_
  calc
    _ â‰¤ â€–star x.fst â€¢ (x.fst â€¢ b + x.snd * b) + star x.snd * (x.fst â€¢ b + x.snd * b)â€– := by
      nth_rewrite 2 [â† one_mul â€–_ + _â€–]
      gcongr
      exact (norm_star b).symm â–¸ mem_closedBall_zero_iff.1 hb
    _ â‰¤ sSup (_ '' Metric.closedBall 0 1) := le_csSup ?_ âŸ¨b, hb, ?_âŸ©
  Â· refine âŸ¨â€–(star x * x).fstâ€– + â€–(star x * x).sndâ€–, ?_âŸ©
    rintro _ âŸ¨y, hy, rflâŸ©
    refine (norm_add_le _ _).trans ?_
    gcongr
    Â· rw [Algebra.algebraMap_eq_smul_one]
      refine (norm_smul _ _).trans_le ?_
      simpa only [mul_one] using
        mul_le_mul_of_nonneg_left (mem_closedBall_zero_iff.1 hy) (norm_nonneg (star x * x).fst)
    Â· exact (unit_le_opNorm _ y <| mem_closedBall_zero_iff.1 hy).trans (opNorm_mul_apply_le _ _ _)
  Â· simp only [ContinuousLinearMap.add_apply, mul_apply', Unitization.snd_star, Unitization.snd_mul,
      Unitization.fst_mul, Unitization.fst_star, Algebra.algebraMap_eq_smul_one, smul_apply,
      one_apply, smul_add, mul_add, add_mul]
    simp only [smul_smul, smul_mul_assoc, â† add_assoc, â† mul_assoc, mul_smul_comm]"
Mathlib/Logic/Encodable/Basic.lean,Encodable.decode_ge_two,decode_ge_two,c047c646d66e915f27c3e7f159bef508bfc8dd10,":= by
  suffices decodeSum n = none by
    change (decodeSum n).bind _ = none
    rw [this]
    rfl
  have : 1 â‰¤ n / 2 := by
    rw [Nat.le_div_iff_mul_le]
    exacts [h, by decide]
  cases' exists_eq_succ_of_ne_zero (_root_.ne_of_gt this) with m e
  simp only [decodeSum, div2_val]; cases bodd n <;> simp [e]","error:  unsolved goals
case intro.false
Î± : Type u_1
Î² : Type u_2
n : â„•
h : 2 â‰¤ n
this : 1 â‰¤ n / 2
m : â„•
e : n / 2 = m.succ
âŠ¢ (match (n.bodd, n.div2) with
    | (false, m) => Option.map Sum.inl (decode m)
    | (fst, m) => Option.map Sum.inr (decode m)) =
    none

case intro.true
Î± : Type u_1
Î² : Type u_2
n : â„•
h : 2 â‰¤ n
this : 1 â‰¤ n / 2
m : â„•
e : n / 2 = m.succ
âŠ¢ (match (n.bodd, n.div2) with
    | (false, m) => Option.map Sum.inl (decode m)
    | (fst, m) => Option.map Sum.inr (decode m)) =
    none",theorem decode_ge_two (n) (h : 2 â‰¤ n) : (decode n : Option Bool) = none ,":= by
  suffices decodeSum n = none by
    change (decodeSum n).bind _ = none
    rw [this]
    rfl
  have : 1 â‰¤ n / 2 := by
    rw [Nat.le_div_iff_mul_le]
    exacts [h, by decide]
  cases' exists_eq_succ_of_ne_zero (_root_.ne_of_gt this) with m e
  simp only [decodeSum, boddDiv2_eq, div2_val]; cases bodd n <;> simp [e]"
Mathlib/Analysis/InnerProductSpace/Basic.lean,innerSL_apply_norm,innerSL_apply_norm,cfaaf51b1223a931e15d15067bb0c504c1943ffc,":= by
  refine'
    le_antisymm ((innerSL ğ•œ x).op_norm_le_bound (norm_nonneg _) fun y => norm_inner_le_norm _ _ _) _
  rcases eq_or_ne x 0 with (rfl | h)
  Â· simp
  Â· refine' (mul_le_mul_right (norm_pos_iff.2 h)).mp _
    calc
      â€–xâ€– * â€–xâ€– = â€–(âŸªx, xâŸ« : ğ•œ)â€– := by
        rw [â† sq, inner_self_eq_norm_sq_to_K, norm_pow, norm_ofReal, abs_norm]
      _ â‰¤ â€–innerSL ğ•œ xâ€– * â€–xâ€– := (innerSL ğ•œ x).le_op_norm _","warning:  `ContinuousLinearMap.op_norm_le_bound` has been deprecated, use `ContinuousLinearMap.opNorm_le_bound` instead
error:  function expected at
  norm_inner_le_norm ?m.899449 ?m.899450
term has type
  â€–âŸª?m.899449, ?m.899450âŸ«_?m.899444â€– â‰¤ â€–?m.899449â€– * â€–?m.899450â€–
warning:  `ContinuousLinearMap.le_op_norm` has been deprecated, use `ContinuousLinearMap.le_opNorm` instead",theorem innerSL_apply_norm (x : E) : â€–innerSL ğ•œ xâ€– = â€–xâ€– ,":= by
  refine
    le_antisymm ((innerSL ğ•œ x).opNorm_le_bound (norm_nonneg _) fun y => norm_inner_le_norm _ _) ?_
  rcases eq_or_ne x 0 with (rfl | h)
  Â· simp
  Â· refine (mul_le_mul_right (norm_pos_iff.2 h)).mp ?_
    calc
      â€–xâ€– * â€–xâ€– = â€–(âŸªx, xâŸ« : ğ•œ)â€– := by
        rw [â† sq, inner_self_eq_norm_sq_to_K, norm_pow, norm_ofReal, abs_norm]
      _ â‰¤ â€–innerSL ğ•œ xâ€– * â€–xâ€– := (innerSL ğ•œ x).le_opNorm _"
Mathlib/CategoryTheory/Sites/Canonical.lean,CategoryTheory.Sheaf.isSheafFor_trans,isSheafFor_trans,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  have : (bind R fun Y f _ => S.pullback f : Presieve X) â‰¤ S := by
    rintro Z f âŸ¨W, f, g, hg, hf : S _, rflâŸ©
    apply hf
  apply Presieve.isSheafFor_subsieve_aux P this
  apply isSheafFor_bind _ _ _ hR hS
  Â· intro Y f hf Z g
    dsimp
    rw [â† pullback_comp]
    apply (hS (R.downward_closed hf _)).isSeparatedFor
  Â· intro Y f hf
    have : Sieve.pullback f (bind R fun T (k : T âŸ¶ X) (_ : R k) => pullback k S) =
        R.pullback f := by
      ext Z g
      constructor
      Â· rintro âŸ¨W, k, l, hl, _, commâŸ©
        rw [pullback_apply, â† comm]
        simp [hl]
      Â· intro a
        refine' âŸ¨Z, ğŸ™ Z, _, a, _âŸ©
        simp [hf]
    rw [this]
    apply hR' hf",error:  dsimp made no progress,"theorem isSheafFor_trans (P : Cáµ’áµ– â¥¤ Type v) (R S : Sieve X)
    (hR : Presieve.IsSheafFor P (R : Presieve X))
    (hR' : âˆ€ â¦ƒYâ¦„ â¦ƒf : Y âŸ¶ Xâ¦„ (_ : S f), Presieve.IsSeparatedFor P (R.pullback f : Presieve Y))
    (hS : âˆ€ â¦ƒYâ¦„ â¦ƒf : Y âŸ¶ Xâ¦„ (_ : R f), Presieve.IsSheafFor P (S.pullback f : Presieve Y)) :
    Presieve.IsSheafFor P (S : Presieve X) ",":= by
  have : (bind R fun Y f _ => S.pullback f : Presieve X) â‰¤ S := by
    rintro Z f âŸ¨W, f, g, hg, hf : S _, rflâŸ©
    apply hf
  apply Presieve.isSheafFor_subsieve_aux P this
  Â· apply isSheafFor_bind _ _ _ hR hS
    intro Y f hf Z g
    rw [â† pullback_comp]
    apply (hS (R.downward_closed hf _)).isSeparatedFor
  Â· intro Y f hf
    have : Sieve.pullback f (bind R fun T (k : T âŸ¶ X) (_ : R k) => pullback k S) =
        R.pullback f := by
      ext Z g
      constructor
      Â· rintro âŸ¨W, k, l, hl, _, commâŸ©
        rw [pullback_apply, â† comm]
        simp [hl]
      Â· intro a
        refine âŸ¨Z, ğŸ™ Z, _, a, ?_âŸ©
        simp [hf]
    rw [this]
    apply hR' hf"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,7dc162787d2a79bf721a83a87f641ace70251b17,":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine' âŸ¨[], rfl.le, show Ï† = 1 from _âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      omega
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine' âŸ¨x::l, Nat.succ_le_succ hl, _âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâµ : _root_.RCLike ğ•œ
instâœâ´ : NormedAddCommGroup E
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : InnerProductSpace ğ•œ E
instâœÂ¹ : InnerProductSpace â„ F
K : Submodule ğ•œ E
instâœ : FiniteDimensional â„ F
Ï† : F â‰ƒâ‚—áµ¢[â„] F
hn :
  finrank â„
      â†¥(LinearMap.ker
            (ContinuousLinearMap.id â„ F -
              â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }))á—® â‰¤
    0
âŠ¢ LinearMap.ker
      (ContinuousLinearMap.id â„ F -
        â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }) =
    âŠ¤","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional â„ F] {n : â„•}
    (Ï† : F â‰ƒâ‚—áµ¢[â„] F) (hn : finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—® â‰¤ n) :
    âˆƒ l : List F, l.length â‰¤ n âˆ§ Ï† = (l.map fun v => reflection (â„ âˆ™ v)á—®).prod ",":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine âŸ¨[], rfl.le, show Ï† = 1 from ?_âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      omega
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine âŸ¨x::l, Nat.succ_le_succ hl, ?_âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this"
Mathlib/MeasureTheory/Measure/Dirac.lean,MeasureTheory.Measure.map_const,map_const,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  ext s hs
  simp only [aemeasurable_const, measurable_const, smul_toOuterMeasure, OuterMeasure.coe_smul,
    Pi.smul_apply, dirac_apply' _ hs, smul_eq_mul]
  classical
  rw [Measure.map_apply measurable_const hs, Set.preimage_const]
  by_cases hsc : c âˆˆ s
  Â· rw [(Set.indicator_eq_one_iff_mem _).mpr hsc, mul_one, if_pos hsc]
  Â· rw [if_neg hsc, (Set.indicator_eq_zero_iff_not_mem _).mpr hsc, measure_empty, mul_zero]",error:  simp made no progress,lemma map_const (Î¼ : Measure Î±) (c : Î²) : Î¼.map (fun _ â†¦ c) = (Î¼ Set.univ) â€¢ dirac c ,":= by
  ext s hs
  simp only [aemeasurable_const, measurable_const, Measure.coe_smul, Pi.smul_apply,
    dirac_apply' _ hs, smul_eq_mul]
  classical
  rw [Measure.map_apply measurable_const hs, Set.preimage_const]
  by_cases hsc : c âˆˆ s
  Â· rw [(Set.indicator_eq_one_iff_mem _).mpr hsc, mul_one, if_pos hsc]
  Â· rw [if_neg hsc, (Set.indicator_eq_zero_iff_not_mem _).mpr hsc, measure_empty, mul_zero]"
Mathlib/Analysis/Complex/CauchyIntegral.lean,Complex.circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable,50dac17e96f8a0ddcbd8740f9929f7cf0a85740d,":= by
  set A := closedBall c R \ ball c r
  obtain âŸ¨a, rflâŸ© : âˆƒ a, Real.exp a = r; exact âŸ¨Real.log r, Real.exp_log h0âŸ©
  obtain âŸ¨b, rflâŸ© : âˆƒ b, Real.exp b = R; exact âŸ¨Real.log R, Real.exp_log (h0.trans_le hle)âŸ©
  rw [Real.exp_le_exp] at hle
  suffices
    (âˆ« Î¸ in (0)..2 * Ï€, I â€¢ f (circleMap c (Real.exp b) Î¸)) =
      âˆ« Î¸ in (0)..2 * Ï€, I â€¢ f (circleMap c (Real.exp a) Î¸) by
    simpa only [circleIntegral, add_sub_cancel', ofReal_exp, â† exp_add, smul_smul, â†
      div_eq_mul_inv, mul_div_cancel_left _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] Ã—â„‚ [[0, 2 * Ï€]]
  set g : â„‚ â†’ â„‚ := (c + exp Â·)
  have hdg : Differentiable â„‚ g := differentiable_exp.const_add _
  replace hs : (g â»Â¹' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z âŸ¨h, -âŸ©; simpa [dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f âˆ˜ g) R; exact hc.comp hdg.continuous.continuousOn h_maps
  replace hd :
    âˆ€ z âˆˆ Ioo (min a b) (max a b) Ã—â„‚ Ioo (min 0 (2 * Ï€)) (max 0 (2 * Ï€)) \ g â»Â¹' s,
      DifferentiableAt â„‚ (f âˆ˜ g) z
  Â· refine' fun z hz => (hd (g z) âŸ¨_, hz.2âŸ©).comp z (hdg _)
    simpa [dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [circleMap, exp_periodic _, sub_eq_zero, â† exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ âŸ¨a, 0âŸ© âŸ¨b, 2 * Ï€âŸ© _ hs hc hd","error:  unexpected token ';'; expected '|'
error:  unsolved goals
case intro.intro
E : Type u
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„‚ E
instâœ : CompleteSpace E
c : â„‚
f : â„‚ â†’ E
s : Set â„‚
a : â„
h0 : 0 < rexp a
b : â„
hle : a â‰¤ b
hd : âˆ€ z âˆˆ (ball c (rexp b) \ closedBall c (rexp a)) \ s, DifferentiableAt â„‚ f z
A : Set â„‚ := closedBall c (rexp b) \ ball c (rexp a)
R : Set â„‚ := [[a, b]] Ã—â„‚ [[0, 2 * Ï€]]
g : â„‚ â†’ â„‚ := fun x â†¦ c + cexp x
hdg : Differentiable â„‚ g
hs : (g â»Â¹' s).Countable
h_maps : MapsTo g R A
hc : ContinuousOn (f âˆ˜ g) R
âŠ¢ âˆ« (Î¸ : â„) in 0 ..2 * Ï€, I â€¢ f (circleMap c (rexp b) Î¸) = âˆ« (Î¸ : â„) in 0 ..2 * Ï€, I â€¢ f (circleMap c (rexp a) Î¸)","theorem circleIntegral_sub_center_inv_smul_eq_of_differentiable_on_annulus_off_countable {c : â„‚}
    {r R : â„} (h0 : 0 < r) (hle : r â‰¤ R) {f : â„‚ â†’ E} {s : Set â„‚} (hs : s.Countable)
    (hc : ContinuousOn f (closedBall c R \ ball c r))
    (hd : âˆ€ z âˆˆ (ball c R \ closedBall c r) \ s, DifferentiableAt â„‚ f z) :
    (âˆ® z in C(c, R), (z - c)â»Â¹ â€¢ f z) = âˆ® z in C(c, r), (z - c)â»Â¹ â€¢ f z ",":= by
  set A := closedBall c R \ ball c r
  obtain âŸ¨a, rflâŸ© : âˆƒ a, Real.exp a = r := âŸ¨Real.log r, Real.exp_log h0âŸ©
  obtain âŸ¨b, rflâŸ© : âˆƒ b, Real.exp b = R := âŸ¨Real.log R, Real.exp_log (h0.trans_le hle)âŸ©
  rw [Real.exp_le_exp] at hle
  suffices
    (âˆ« Î¸ in (0)..2 * Ï€, I â€¢ f (circleMap c (Real.exp b) Î¸)) =
      âˆ« Î¸ in (0)..2 * Ï€, I â€¢ f (circleMap c (Real.exp a) Î¸) by
    simpa only [circleIntegral, add_sub_cancel_left, ofReal_exp, â† exp_add, smul_smul, â†
      div_eq_mul_inv, mul_div_cancel_leftâ‚€ _ (circleMap_ne_center (Real.exp_pos _).ne'),
      circleMap_sub_center, deriv_circleMap]
  set R := [[a, b]] Ã—â„‚ [[0, 2 * Ï€]]
  set g : â„‚ â†’ â„‚ := (c + exp Â·)
  have hdg : Differentiable â„‚ g := differentiable_exp.const_add _
  replace hs : (g â»Â¹' s).Countable := (hs.preimage (add_right_injective c)).preimage_cexp
  have h_maps : MapsTo g R A := by rintro z âŸ¨h, -âŸ©; simpa [g, A, dist_eq, abs_exp, hle] using h.symm
  replace hc : ContinuousOn (f âˆ˜ g) R := hc.comp hdg.continuous.continuousOn h_maps
  replace hd : âˆ€ z âˆˆ Ioo (min a b) (max a b) Ã—â„‚ Ioo (min 0 (2 * Ï€)) (max 0 (2 * Ï€)) \ g â»Â¹' s,
      DifferentiableAt â„‚ (f âˆ˜ g) z := by
    refine fun z hz => (hd (g z) âŸ¨?_, hz.2âŸ©).comp z (hdg _)
    simpa [g, dist_eq, abs_exp, hle, and_comm] using hz.1.1
  simpa [g, circleMap, exp_periodic _, sub_eq_zero, â† exp_add] using
    integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ âŸ¨a, 0âŸ© âŸ¨b, 2 * Ï€âŸ© _ hs hc hd"
Mathlib/Data/List/Indexes.lean,List.mapIdxGo_length,mapIdxGo_length,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  intro f l
  induction' l with head tail ih
  Â· intro; simp only [mapIdx.go, Array.toList_eq, length_nil, zero_add]
  Â· intro; simp only [mapIdx.go]; rw [ih]; simp only [Array.size_push, length_cons];
    simp only [Nat.add_succ, add_zero, Nat.add_comm]","error:  unsolved goals
case nil
Î± : Type u
Î² : Type v
f : â„• â†’ Î± â†’ Î²
arrâœ : Array Î²
âŠ¢ arrâœ.data.length = 0 + arrâœ.size
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem mapIdxGo_length : âˆ€ (f : â„• â†’ Î± â†’ Î²) (l : List Î±) (arr : Array Î²),
    length (mapIdx.go f l arr) = length l + arr.size ",":= by
  intro f l
  induction' l with head tail ih
  Â· intro; simp only [mapIdx.go, Array.toList_eq, length_nil, Nat.zero_add]
  Â· intro; simp only [mapIdx.go]; rw [ih]; simp only [Array.size_push, length_cons];
    simp only [Nat.add_succ, add_zero, Nat.add_comm]"
Mathlib/RingTheory/Ideal/IsPrincipal.lean,Ideal.associatesEquivIsPrincipal_map_one,associatesEquivIsPrincipal_map_one,94f8f604abb9aebc9ff83f8d1c77d38a2ab15f5d,":= by
  rw [one_eq_mk_one, associatesEquivIsPrincipal_apply, span_singleton_one, one_eq_top]","error:  unknown identifier 'one_eq_mk_one'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.16956
R : Type u_1
instâœÂ¹ : CommRing R
instâœ : IsDomain R
âŠ¢ â†‘((associatesEquivIsPrincipal R) 1) = 1","theorem associatesEquivIsPrincipal_map_one :
    (associatesEquivIsPrincipal R 1 : Ideal R) = 1 ",":= by
  rw [Associates.one_eq_mk_one, â† Associates.quotient_mk_eq_mk, associatesEquivIsPrincipal_apply,
    span_singleton_one, one_eq_top]"
Mathlib/MeasureTheory/Decomposition/Lebesgue.lean,MeasureTheory.Measure.exists_positive_of_not_mutuallySingular,exists_positive_of_not_mutuallySingular,9e34a191034458a56331f976ff7400a26407c888,":= by
  have :
    âˆ€ n : â„•, âˆƒ i : Set Î±,
      MeasurableSet i âˆ§
        0 â‰¤[i] Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure âˆ§
          Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure â‰¤[iá¶œ] 0 := by
    intro; exact exists_compl_positive_negative _
  choose f hfâ‚ hfâ‚‚ hfâ‚ƒ using this
  set A := â‹‚ n, (f n)á¶œ with hAâ‚
  have hAmeas : MeasurableSet A := MeasurableSet.iInter fun n => (hfâ‚ n).compl
  have hAâ‚‚ : âˆ€ n : â„•, Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure â‰¤[A] 0 := by
    intro n; exact restrict_le_restrict_subset _ _ (hfâ‚ n).compl (hfâ‚ƒ n) (iInter_subset _ _)
  have hAâ‚ƒ : âˆ€ n : â„•, Î¼ A â‰¤ (1 / (n + 1) : â„â‰¥0) * Î½ A := by
    intro n
    have := nonpos_of_restrict_le_zero _ (hAâ‚‚ n)
    rwa [toSignedMeasure_sub_apply hAmeas, sub_nonpos, ENNReal.toReal_le_toReal] at this
    exacts [ne_of_lt (measure_lt_top _ _), ne_of_lt (measure_lt_top _ _)]
  have hÎ¼ : Î¼ A = 0 := by
    lift Î¼ A to â„â‰¥0 using ne_of_lt (measure_lt_top _ _) with Î¼A
    lift Î½ A to â„â‰¥0 using ne_of_lt (measure_lt_top _ _) with Î½A
    rw [ENNReal.coe_eq_zero]
    by_cases hb : 0 < Î½A
    Â· suffices âˆ€ b, 0 < b â†’ Î¼A â‰¤ b by
        by_contra h
        have h' := this (Î¼A / 2) (half_pos (zero_lt_iff.2 h))
        rw [â† @Classical.not_not (Î¼A â‰¤ Î¼A / 2)] at h'
        exact h' (not_le.2 (NNReal.half_lt_self h))
      intro c hc
      have : âˆƒ n : â„•, 1 / (n + 1 : â„) < c * (Î½A : â„)â»Â¹; refine' exists_nat_one_div_lt _
      Â· refine' mul_pos hc _
        rw [_root_.inv_pos]; exact hb
      rcases this with âŸ¨n, hnâŸ©
      have hbâ‚ : (0 : â„) < (Î½A : â„)â»Â¹ := by rw [_root_.inv_pos]; exact hb
      have h' : 1 / (â†‘n + 1) * Î½A < c := by
        rw [â† NNReal.coe_lt_coe, â† mul_lt_mul_right hbâ‚, NNReal.coe_mul, mul_assoc, â†
          NNReal.coe_inv, â† NNReal.coe_mul, _root_.mul_inv_cancel, â† NNReal.coe_mul, mul_one,
          NNReal.coe_inv]
        Â· exact hn
        Â· exact Ne.symm (ne_of_lt hb)
      refine' le_trans _ (le_of_lt h')
      rw [â† ENNReal.coe_le_coe, ENNReal.coe_mul]
      exact hAâ‚ƒ n
    Â· rw [not_lt, le_zero_iff] at hb
      specialize hAâ‚ƒ 0
      simp [hb, le_zero_iff] at hAâ‚ƒ
      assumption
  rw [MutuallySingular] at h; push_neg at h
  have := h _ hAmeas hÎ¼
  simp_rw [hAâ‚, compl_iInter, compl_compl] at this
  obtain âŸ¨n, hnâŸ© := exists_measure_pos_of_not_measure_iUnion_null this
  exact âŸ¨1 / (n + 1), by simp, f n, hfâ‚ n, hn, hfâ‚‚ nâŸ©","error:  unexpected token ';'; expected '|'
error:  unsolved goals
case pos
Î± : Type u_1
Î² : Type u_2
m : MeasurableSpace Î±
Î¼âœ Î½âœ Î¼ Î½ : Measure Î±
instâœÂ¹ : IsFiniteMeasure Î¼
instâœ : IsFiniteMeasure Î½
h : Â¬Î¼ âŸ‚â‚˜ Î½
f : â„• â†’ Set Î±
hfâ‚ : âˆ€ (n : â„•), MeasurableSet (f n)
hfâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict 0 (f n) â‰¤
      VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)
hfâ‚ƒ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)á¶œ â‰¤
      VectorMeasure.restrict 0 (f n)á¶œ
A : Set Î± := â‹‚ n, (f n)á¶œ
hAmeas : MeasurableSet A
hAâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) A â‰¤ VectorMeasure.restrict 0 A
Î¼A : â„â‰¥0
hAâ‚âœ hAâ‚ : True
hAâ‚ƒâœÂ¹ : âˆ€ (n : â„•), â†‘Î¼A â‰¤ â†‘(1 / (â†‘n + 1)) * Î½ A
Î½A : â„â‰¥0
hAâ‚ƒâœ hAâ‚ƒ : âˆ€ (n : â„•), â†‘Î¼A â‰¤ â†‘(1 / (â†‘n + 1)) * â†‘Î½A
hb : 0 < Î½A
c : â„â‰¥0
hc : 0 < c
this : âˆƒ n, 1 / (â†‘n + 1) < â†‘c * (â†‘Î½A)â»Â¹
âŠ¢ Î¼A â‰¤ c
error:  unsolved goals
case neg
Î± : Type u_1
Î² : Type u_2
m : MeasurableSpace Î±
Î¼âœ Î½âœ Î¼ Î½ : Measure Î±
instâœÂ¹ : IsFiniteMeasure Î¼
instâœ : IsFiniteMeasure Î½
h : Â¬Î¼ âŸ‚â‚˜ Î½
f : â„• â†’ Set Î±
hfâ‚ : âˆ€ (n : â„•), MeasurableSet (f n)
hfâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict 0 (f n) â‰¤
      VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)
hfâ‚ƒ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)á¶œ â‰¤
      VectorMeasure.restrict 0 (f n)á¶œ
A : Set Î± := â‹‚ n, (f n)á¶œ
hAmeas : MeasurableSet A
hAâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) A â‰¤ VectorMeasure.restrict 0 A
Î¼A : â„â‰¥0
hAâ‚âœ hAâ‚ : True
hAâ‚ƒâœÂ¹ : âˆ€ (n : â„•), â†‘Î¼A â‰¤ â†‘(1 / (â†‘n + 1)) * Î½ A
Î½A : â„â‰¥0
hAâ‚ƒâœ hAâ‚ƒ : âˆ€ (n : â„•), â†‘Î¼A â‰¤ â†‘(1 / (â†‘n + 1)) * â†‘Î½A
hb : Â¬0 < Î½A
âŠ¢ Î¼A = 0
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
m : MeasurableSpace Î±
Î¼âœ Î½âœ Î¼ Î½ : Measure Î±
instâœÂ¹ : IsFiniteMeasure Î¼
instâœ : IsFiniteMeasure Î½
h : Â¬Î¼ âŸ‚â‚˜ Î½
f : â„• â†’ Set Î±
hfâ‚ : âˆ€ (n : â„•), MeasurableSet (f n)
hfâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict 0 (f n) â‰¤
      VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)
hfâ‚ƒ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)á¶œ â‰¤
      VectorMeasure.restrict 0 (f n)á¶œ
A : Set Î± := â‹‚ n, (f n)á¶œ
hAâ‚ : A = â‹‚ n, (f n)á¶œ
hAmeas : MeasurableSet A
hAâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) A â‰¤ VectorMeasure.restrict 0 A
hAâ‚ƒ : âˆ€ (n : â„•), Î¼ A â‰¤ â†‘(1 / (â†‘n + 1)) * Î½ A
hÎ¼ : Î¼ A = 0
âŠ¢ âˆƒ Îµ,
    0 < Îµ âˆ§
      âˆƒ E,
        MeasurableSet E âˆ§
          0 < Î½ E âˆ§ VectorMeasure.restrict 0 E â‰¤ VectorMeasure.restrict (Î¼.toSignedMeasure - (Îµ â€¢ Î½).toSignedMeasure) E","theorem exists_positive_of_not_mutuallySingular (Î¼ Î½ : Measure Î±) [IsFiniteMeasure Î¼]
    [IsFiniteMeasure Î½] (h : Â¬Î¼ âŸ‚â‚˜ Î½) :
    âˆƒ Îµ : â„â‰¥0, 0 < Îµ âˆ§
      âˆƒ E : Set Î±,
        MeasurableSet E âˆ§ 0 < Î½ E âˆ§ 0 â‰¤[E] Î¼.toSignedMeasure - (Îµ â€¢ Î½).toSignedMeasure ",":= by
  have :
    âˆ€ n : â„•, âˆƒ i : Set Î±,
      MeasurableSet i âˆ§
        0 â‰¤[i] Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure âˆ§
          Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure â‰¤[iá¶œ] 0 := by
    intro; exact exists_compl_positive_negative _
  choose f hfâ‚ hfâ‚‚ hfâ‚ƒ using this
  let A := â‹‚ n, (f n)á¶œ
  have hAmeas : MeasurableSet A := MeasurableSet.iInter fun n â†¦ (hfâ‚ n).compl
  have hAâ‚‚ : âˆ€ n : â„•, Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure â‰¤[A] 0 := by
    intro n; exact restrict_le_restrict_subset _ _ (hfâ‚ n).compl (hfâ‚ƒ n) (iInter_subset _ _)
  have hAâ‚ƒ : âˆ€ n : â„•, Î¼ A â‰¤ (1 / (n + 1) : â„â‰¥0) * Î½ A := by
    intro n
    have := nonpos_of_restrict_le_zero _ (hAâ‚‚ n)
    rwa [toSignedMeasure_sub_apply hAmeas, sub_nonpos, ENNReal.toReal_le_toReal] at this
    exacts [measure_ne_top _ _, measure_ne_top _ _]
  have hÎ¼ : Î¼ A = 0 := by
    lift Î¼ A to â„â‰¥0 using measure_ne_top _ _ with Î¼A
    lift Î½ A to â„â‰¥0 using measure_ne_top _ _ with Î½A
    rw [ENNReal.coe_eq_zero]
    by_cases hb : 0 < Î½A
    Â· suffices âˆ€ b, 0 < b â†’ Î¼A â‰¤ b by
        by_contra h
        have h' := this (Î¼A / 2) (half_pos (zero_lt_iff.2 h))
        rw [â† @Classical.not_not (Î¼A â‰¤ Î¼A / 2)] at h'
        exact h' (not_le.2 (NNReal.half_lt_self h))
      intro c hc
      have : âˆƒ n : â„•, 1 / (n + 1 : â„) < c * (Î½A : â„)â»Â¹ := by
        refine exists_nat_one_div_lt ?_
        positivity
      rcases this with âŸ¨n, hnâŸ©
      have hbâ‚ : (0 : â„) < (Î½A : â„)â»Â¹ := by rw [_root_.inv_pos]; exact hb
      have h' : 1 / (â†‘n + 1) * Î½A < c := by
        rw [â† NNReal.coe_lt_coe, â† mul_lt_mul_right hbâ‚, NNReal.coe_mul, mul_assoc, â†
          NNReal.coe_inv, â† NNReal.coe_mul, _root_.mul_inv_cancel, â† NNReal.coe_mul, mul_one,
          NNReal.coe_inv]
        Â· exact hn
        Â· exact hb.ne'
      refine le_trans ?_ h'.le
      rw [â† ENNReal.coe_le_coe, ENNReal.coe_mul]
      exact hAâ‚ƒ n
    Â· rw [not_lt, le_zero_iff] at hb
      specialize hAâ‚ƒ 0
      simp? [hb] at hAâ‚ƒ says
        simp only [CharP.cast_eq_zero, zero_add, ne_eq, one_ne_zero, not_false_eq_true, div_self,
          ENNReal.coe_one, hb, ENNReal.coe_zero, mul_zero, nonpos_iff_eq_zero,
          ENNReal.coe_eq_zero] at hAâ‚ƒ
      assumption
  rw [MutuallySingular] at h; push_neg at h
  have := h _ hAmeas hÎ¼
  simp_rw [A, compl_iInter, compl_compl] at this
  obtain âŸ¨n, hnâŸ© := exists_measure_pos_of_not_measure_iUnion_null this
  exact âŸ¨1 / (n + 1), by simp, f n, hfâ‚ n, hn, hfâ‚‚ nâŸ©"
Mathlib/Dynamics/OmegaLimit.lean,eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset',eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset',e31b04e652f40495b00249252a86ab4a012d6bd2,":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  let k := closure (image2 Ï• v s)
  have hk : IsCompact (k \ n) :=
    IsCompact.diff (isCompact_of_isClosed_subset hcâ‚ isClosed_closure hvâ‚‚) hnâ‚
  let j u := (closure (image2 Ï• (u âˆ© v) s))á¶œ
  have hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u) := fun _ _ â†¦ isOpen_compl_iff.mpr isClosed_closure
  have hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u := by
    have : (â‹ƒ u âˆˆ f, j u) = â‹ƒ u : (â†¥f.sets), j u := biUnion_eq_iUnion _ _
    rw [this, diff_subset_comm, diff_iUnion]
    rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚] at hnâ‚‚
    simp_rw [diff_compl]
    rw [â† inter_iInter]
    exact Subset.trans (inter_subset_right _ _) hnâ‚‚
  rcases hk.elim_finite_subcover_image hjâ‚ hjâ‚‚ with âŸ¨g, hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f, hgâ‚‚, hgâ‚ƒâŸ©
  let w := (â‹‚ u âˆˆ g, u) âˆ© v
  have hwâ‚‚ : w âˆˆ f := by simpa [*]
  have hwâ‚ƒ : k \ n âŠ† (closure (image2 Ï• w s))á¶œ := by
    apply Subset.trans hgâ‚ƒ
    simp only [iUnion_subset_iff, compl_subset_compl]
    intros u hu
    mono
    refine' iInter_subset_of_subset u (iInter_subset_of_subset hu _)
    all_goals exact Subset.rfl
  have hwâ‚„ : ká¶œ âŠ† (closure (image2 Ï• w s))á¶œ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset (inter_subset_right _ _) Subset.rfl)
  have hnc : ná¶œ âŠ† k \ n âˆª ká¶œ := by rw [union_comm, â† inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 Ï• w s) âŠ† n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hwâ‚ƒ hwâ‚„))
  exact âŸ¨_, hwâ‚‚, hwâŸ©","warning:  @omegaLimit does not have a doc string
error:  unknown identifier 'isCompact_of_isClosed_subset'
error:  simp made no progress
error:  tactic 'assumption' failed
Ï„ : Type u_1
Î± : Type u_2
Î² : Type u_3
Î¹ : Type u_4
instâœ : TopologicalSpace Î²
f : Filter Ï„
Ï• : Ï„ â†’ Î± â†’ Î²
s sâ‚ sâ‚‚ : Set Î±
c : Set Î²
hcâ‚ : IsCompact c
n : Set Î²
hnâ‚ : IsOpen n
hnâ‚‚ : Ï‰ f Ï• s âŠ† n
v : Set Ï„
hvâ‚ : v âˆˆ f
hvâ‚‚ : closure (image2 Ï• v s) âŠ† c
k : Set Î² := closure (image2 Ï• v s)
hk : IsCompact (k \ n)
j : Set Ï„ â†’ Set Î² := fun u â†¦ (closure (image2 Ï• (u âˆ© v) s))á¶œ
hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u)
hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u
g : Set (Set Ï„)
hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f
hgâ‚‚ : g.Finite
hgâ‚ƒ : k \ n âŠ† â‹ƒ i âˆˆ g, j i
w : Set Ï„ := (â‹‚ u âˆˆ g, u) âˆ© v
âŠ¢ w âˆˆ f
error:  repeat1' made no progress
error:  function expected at
  inter_subset_right ?m.28370
term has type
  ?m.28369 âˆˆ ?m.28368","theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set Î²}
    (hcâ‚ : IsCompact c) (hcâ‚‚ : âˆƒ v âˆˆ f, closure (image2 Ï• v s) âŠ† c) {n : Set Î²} (hnâ‚ : IsOpen n)
    (hnâ‚‚ : Ï‰ f Ï• s âŠ† n) : âˆƒ u âˆˆ f, closure (image2 Ï• u s) âŠ† n ",":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  let k := closure (image2 Ï• v s)
  have hk : IsCompact (k \ n) :=
    (hcâ‚.of_isClosed_subset isClosed_closure hvâ‚‚).diff hnâ‚
  let j u := (closure (image2 Ï• (u âˆ© v) s))á¶œ
  have hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u) := fun _ _ â†¦ isOpen_compl_iff.mpr isClosed_closure
  have hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u := by
    have : â‹ƒ u âˆˆ f, j u = â‹ƒ u : (â†¥f.sets), j u := biUnion_eq_iUnion _ _
    rw [this, diff_subset_comm, diff_iUnion]
    rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚] at hnâ‚‚
    simp_rw [j, diff_compl]
    rw [â† inter_iInter]
    exact Subset.trans inter_subset_right hnâ‚‚
  rcases hk.elim_finite_subcover_image hjâ‚ hjâ‚‚ with âŸ¨g, hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f, hgâ‚‚, hgâ‚ƒâŸ©
  let w := (â‹‚ u âˆˆ g, u) âˆ© v
  have hwâ‚‚ : w âˆˆ f := by simpa [w, *]
  have hwâ‚ƒ : k \ n âŠ† (closure (image2 Ï• w s))á¶œ := by
    apply Subset.trans hgâ‚ƒ
    simp only [j, iUnion_subset_iff, compl_subset_compl]
    intros u hu
    mono
    refine iInter_subset_of_subset u (iInter_subset_of_subset hu ?_)
    all_goals exact Subset.rfl
  have hwâ‚„ : ká¶œ âŠ† (closure (image2 Ï• w s))á¶œ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset inter_subset_right Subset.rfl)
  have hnc : ná¶œ âŠ† k \ n âˆª ká¶œ := by rw [union_comm, â† inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 Ï• w s) âŠ† n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hwâ‚ƒ hwâ‚„))
  exact âŸ¨_, hwâ‚‚, hwâŸ©"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.not_mem_support_iff,not_mem_support_iff,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.not_mem_support_iff","warning:  Finsupp does not have a doc string
error:  unknown identifier 'DFinsupp.not_mem_support_iff'",theorem not_mem_support_iff {f : Î± â†’â‚€ M} {a} : a âˆ‰ f.support â†” f a = 0 ,":=
  not_iff_comm.1 mem_support_iff.symm"
Mathlib/RingTheory/HahnSeries/Multiplication.lean,HahnSeries.single_mul_coeff_add,single_mul_coeff_add,3fe2b42b4b56e4d7b982931cb0812dbd57571ca1,":= by
  rw [â† smul_eq_mul, add_comm, â† smul_eq_mul]
  exact HahnModule.single_smul_coeff_add",error:  unknown constant 'HahnModule.single_smul_coeff_add',"theorem single_mul_coeff_add [NonUnitalNonAssocSemiring R] {r : R} {x : HahnSeries Î“ R} {a : Î“}
    {b : Î“} : (single b r * x).coeff (a + b) = r * x.coeff a ",":= by
  by_cases hr : r = 0
  Â· simp [hr, mul_coeff]
  simp only [hr, smul_coeff, mul_coeff, support_single_of_ne, Ne, not_false_iff, smul_eq_mul]
  by_cases hx : x.coeff a = 0
  Â· simp only [hx, mul_zero]
    rw [sum_congr _ fun _ _ => rfl, sum_empty]
    ext âŸ¨a1, a2âŸ©
    simp only [not_mem_empty, not_and, Set.mem_singleton_iff, Classical.not_not,
      mem_addAntidiagonal, Set.mem_setOf_eq, iff_false_iff]
    rintro rfl h2 h1
    rw [add_comm] at h1
    rw [â† add_right_cancel h1] at hx
    exact h2 hx
  trans âˆ‘ ij âˆˆ {(b, a)}, (single b r).coeff ij.fst * x.coeff ij.snd
  Â· apply sum_congr _ fun _ _ => rfl
    ext âŸ¨a1, a2âŸ©
    simp only [Set.mem_singleton_iff, Prod.mk.inj_iff, mem_addAntidiagonal, mem_singleton,
      Set.mem_setOf_eq]
    constructor
    Â· rintro âŸ¨rfl, _, h1âŸ©
      rw [add_comm] at h1
      exact âŸ¨rfl, add_right_cancel h1âŸ©
    Â· rintro âŸ¨rfl, rflâŸ©
      exact âŸ¨rfl, by simp [hx], add_comm _ _âŸ©
  Â· simp"
Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean,Balanced.subset_balancedCore_of_subset,Balanced.subset_balancedCore_of_subset,14167e48d13e9c2d72cbdff0431a8edba6021c34,":=
  subset_unionâ‚›_of_mem âŸ¨hs, hâŸ©",error:  unknown identifier 'subset_unionâ‚›_of_mem',"theorem Balanced.subset_balancedCore_of_subset (hs : Balanced ğ•œ s) (h : s âŠ† t) :
    s âŠ† balancedCore ğ•œ t ",":=
  subset_sUnion_of_mem âŸ¨hs, hâŸ©"
Mathlib/RingTheory/Polynomial/Cyclotomic/Eval.lean,Polynomial.sub_one_lt_natAbs_cyclotomic_eval,sub_one_lt_natAbs_cyclotomic_eval,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  calc
    q - 1 â‰¤ (q - 1) ^ totient n := Nat.le_self_pow (Nat.totient_pos <| pos_of_gt hn').ne' _
    _ < ((cyclotomic n â„¤).eval â†‘q).natAbs := sub_one_pow_totient_lt_natAbs_cyclotomic_eval hn' hq","error:  function expected at
  totient_pos
term has type
  0 < Ï† ?m.151610 â†” 0 < ?m.151610","theorem sub_one_lt_natAbs_cyclotomic_eval {n : â„•} {q : â„•} (hn' : 1 < n) (hq : q â‰  1) :
    q - 1 < ((cyclotomic n â„¤).eval â†‘q).natAbs ",":=
  calc
    q - 1 â‰¤ (q - 1) ^ totient n := Nat.le_self_pow (Nat.totient_pos.2 <| pos_of_gt hn').ne' _
    _ < ((cyclotomic n â„¤).eval â†‘q).natAbs := sub_one_pow_totient_lt_natAbs_cyclotomic_eval hn' hq"
Mathlib/MeasureTheory/Measure/MeasureSpace.lean,MeasureTheory.Measure.measure_inter_eq_of_measure_eq,measure_inter_eq_of_measure_eq,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [h] at ht_ne_top
  refine le_antisymm (by gcongr) ?_
  have A : Î¼ (u âˆ© s) + Î¼ (u \ s) â‰¤ Î¼ (t âˆ© s) + Î¼ (u \ s) :=
    calc
      Î¼ (u âˆ© s) + Î¼ (u \ s) = Î¼ u := measure_inter_add_diff _ hs
      _ = Î¼ t := h.symm
      _ = Î¼ (t âˆ© s) + Î¼ (t \ s) := (measure_inter_add_diff _ hs).symm
      _ â‰¤ Î¼ (t âˆ© s) + Î¼ (u \ s) := by gcongr
  have B : Î¼ (u \ s) â‰  âˆ := (lt_of_le_of_lt (measure_mono (diff_subset _ _)) ht_ne_top.lt_top).ne
  exact ENNReal.le_of_add_le_add_right B A","error:  function expected at
  diff_subset ?m.175969
term has type
  ?m.175968 âˆˆ ?m.175966
warning:  @Measure.AbsolutelyContinuous does not have a doc string","theorem measure_inter_eq_of_measure_eq {s t u : Set Î±} (hs : MeasurableSet s) (h : Î¼ t = Î¼ u)
    (htu : t âŠ† u) (ht_ne_top : Î¼ t â‰  âˆ) : Î¼ (t âˆ© s) = Î¼ (u âˆ© s) ",":= by
  rw [h] at ht_ne_top
  refine le_antisymm (by gcongr) ?_
  have A : Î¼ (u âˆ© s) + Î¼ (u \ s) â‰¤ Î¼ (t âˆ© s) + Î¼ (u \ s) :=
    calc
      Î¼ (u âˆ© s) + Î¼ (u \ s) = Î¼ u := measure_inter_add_diff _ hs
      _ = Î¼ t := h.symm
      _ = Î¼ (t âˆ© s) + Î¼ (t \ s) := (measure_inter_add_diff _ hs).symm
      _ â‰¤ Î¼ (t âˆ© s) + Î¼ (u \ s) := by gcongr
  have B : Î¼ (u \ s) â‰  âˆ := (lt_of_le_of_lt (measure_mono diff_subset) ht_ne_top.lt_top).ne
  exact ENNReal.le_of_add_le_add_right B A"
Mathlib/LinearAlgebra/Basis.lean,Basis.ext_elem_iff,ext_elem_iff,b09462282225ca03a37b7e6afde435d1ab7552ef,":= by
  simp only [â† FunLike.ext_iff, EmbeddingLike.apply_eq_iff_eq]","error:  unknown constant 'FunLike.ext_iff'
error:  simp made no progress
warning:  declaration uses 'sorry'","theorem ext_elem_iff {x y : M} : x = y â†” âˆ€ i, b.repr x i = b.repr y i ",":= by
  simp only [â† DFunLike.ext_iff, EmbeddingLike.apply_eq_iff_eq]"
Mathlib/MeasureTheory/Covering/BesicovitchVectorSpace.lean,Besicovitch.card_le_of_separated,card_le_of_separated,b43327b8d438b89cabcf8001bd80229c7ae3faf5,":= by
  borelize E
  let Î¼ : Measure E := Measure.addHaar
  let Î´ : â„ := (1 : â„) / 2
  let Ï : â„ := (5 : â„) / 2
  have Ïpos : 0 < Ï := by norm_num
  set A := â‹ƒ c âˆˆ s, ball (c : E) Î´ with hA
  have D : Set.Pairwise (s : Set E) (Disjoint on fun c => ball (c : E) Î´) := by
    rintro c hc d hd hcd
    apply ball_disjoint_ball
    rw [dist_eq_norm]
    convert h c hc d hd hcd
    norm_num
  have A_subset : A âŠ† ball (0 : E) Ï := by
    refine' iUnionâ‚‚_subset fun x hx => _
    apply ball_subset_ball'
    calc
      Î´ + dist x 0 â‰¤ Î´ + 2 := by rw [dist_zero_right]; exact add_le_add le_rfl (hs x hx)
      _ = 5 / 2 := by norm_num
  have I :
    (s.card : â„â‰¥0âˆ) * ENNReal.ofReal (Î´ ^ finrank â„ E) * Î¼ (ball 0 1) â‰¤
      ENNReal.ofReal (Ï ^ finrank â„ E) * Î¼ (ball 0 1) :=
    calc
      (s.card : â„â‰¥0âˆ) * ENNReal.ofReal (Î´ ^ finrank â„ E) * Î¼ (ball 0 1) = Î¼ A := by
        rw [hA, measure_biUnion_finset D fun c _ => measurableSet_ball]
        have I : 0 < Î´ := by norm_num
        simp only [div_pow, Î¼.addHaar_ball_of_pos _ I]
        simp only [one_div, one_pow, Finset.sum_const, nsmul_eq_mul, mul_assoc]
      _ â‰¤ Î¼ (ball (0 : E) Ï) := (measure_mono A_subset)
      _ = ENNReal.ofReal (Ï ^ finrank â„ E) * Î¼ (ball 0 1) := by
        simp only [Î¼.addHaar_ball_of_pos _ Ïpos]
  have J : (s.card : â„â‰¥0âˆ) * ENNReal.ofReal (Î´ ^ finrank â„ E) â‰¤ ENNReal.ofReal (Ï ^ finrank â„ E) :=
    (ENNReal.mul_le_mul_right (measure_ball_pos _ _ zero_lt_one).ne' measure_ball_lt_top.ne).1 I
  have K : (s.card : â„) â‰¤ (5 : â„) ^ finrank â„ E := by
    have := ENNReal.toReal_le_of_le_ofReal (pow_nonneg Ïpos.le _) J
    simpa [div_eq_mul_inv, mul_pow] using this
  exact mod_cast K","error:  type mismatch
  hâœ
has type
  â†‘s.card * (ENNReal.ofReal (Î´ ^ finrank â„ E)).toReal â‰¤ Ï ^ finrank â„ E : Prop
but is expected to have type
  â†‘s.card â‰¤ 5 ^ finrank â„ E : Prop","theorem card_le_of_separated (s : Finset E) (hs : âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2)
    (h : âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 â‰¤ â€–c - dâ€–) : s.card â‰¤ 5 ^ finrank â„ E ",":= by
  borelize E
  let Î¼ : Measure E := Measure.addHaar
  let Î´ : â„ := (1 : â„) / 2
  let Ï : â„ := (5 : â„) / 2
  have Ïpos : 0 < Ï := by norm_num
  set A := â‹ƒ c âˆˆ s, ball (c : E) Î´ with hA
  have D : Set.Pairwise (s : Set E) (Disjoint on fun c => ball (c : E) Î´) := by
    rintro c hc d hd hcd
    apply ball_disjoint_ball
    rw [dist_eq_norm]
    convert h c hc d hd hcd
    norm_num
  have A_subset : A âŠ† ball (0 : E) Ï := by
    refine iUnionâ‚‚_subset fun x hx => ?_
    apply ball_subset_ball'
    calc
      Î´ + dist x 0 â‰¤ Î´ + 2 := by rw [dist_zero_right]; exact add_le_add le_rfl (hs x hx)
      _ = 5 / 2 := by norm_num
  have I :
    (s.card : â„â‰¥0âˆ) * ENNReal.ofReal (Î´ ^ finrank â„ E) * Î¼ (ball 0 1) â‰¤
      ENNReal.ofReal (Ï ^ finrank â„ E) * Î¼ (ball 0 1) :=
    calc
      (s.card : â„â‰¥0âˆ) * ENNReal.ofReal (Î´ ^ finrank â„ E) * Î¼ (ball 0 1) = Î¼ A := by
        rw [hA, measure_biUnion_finset D fun c _ => measurableSet_ball]
        have I : 0 < Î´ := by norm_num
        simp only [div_pow, Î¼.addHaar_ball_of_pos _ I]
        simp only [one_div, one_pow, Finset.sum_const, nsmul_eq_mul, mul_assoc]
      _ â‰¤ Î¼ (ball (0 : E) Ï) := measure_mono A_subset
      _ = ENNReal.ofReal (Ï ^ finrank â„ E) * Î¼ (ball 0 1) := by
        simp only [Î¼.addHaar_ball_of_pos _ Ïpos]
  have J : (s.card : â„â‰¥0âˆ) * ENNReal.ofReal (Î´ ^ finrank â„ E) â‰¤ ENNReal.ofReal (Ï ^ finrank â„ E) :=
    (ENNReal.mul_le_mul_right (measure_ball_pos _ _ zero_lt_one).ne' measure_ball_lt_top.ne).1 I
  have K : (s.card : â„) â‰¤ (5 : â„) ^ finrank â„ E := by
    have := ENNReal.toReal_le_of_le_ofReal (pow_nonneg Ïpos.le _) J
    simpa [Ï, Î´, div_eq_mul_inv, mul_pow] using this
  exact mod_cast K"
Mathlib/RingTheory/AdicCompletion/Functoriality.lean,AdicCompletion.sum_comp_sumInv,sum_comp_sumInv,daf3a20f754d8cdc3f208745f3a796f4423274a9,":= by
  ext f n
  simp only [LinearMap.coe_comp, Function.comp_apply, LinearMap.id_coe, id_eq, mk_apply_coe,
    Submodule.mkQ_apply]
  classical
  rw [â† DirectSum.sum_univ_of _ (((sumInv I M) ((AdicCompletion.mk I (â¨ (j : Î¹), M j)) f)))]
  simp only [sumInv_apply, LinearMap.adicCompletion_mk, map_sum, sum_of, LinearMap.val_sum,
    mk_apply_coe, LinearMap.adicCauchy_apply_coe, Submodule.mkQ_apply]
  simp only [â† Submodule.mkQ_apply, â† map_sum]
  erw [DirectSum.sum_univ_of]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.363172 â†’+* ?m.363173) â†’
    (M : Type ?u.363169) â†’
      (Mâ‚‚ : Type ?u.363168) â†’
        [inst : AddCommMonoid M] â†’
          [inst_1 : AddCommMonoid Mâ‚‚] â†’
            [inst : Module ?m.363172 M] â†’ [inst : Module ?m.363173 Mâ‚‚] â†’ Type (max ?u.363169 ?u.363168)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.363396 â†’+* ?m.363397) â†’
    (M : Type ?u.363393) â†’
      (Mâ‚‚ : Type ?u.363392) â†’
        [inst : AddCommMonoid M] â†’
          [inst_1 : AddCommMonoid Mâ‚‚] â†’
            [inst : Module ?m.363396 M] â†’ [inst : Module ?m.363397 Mâ‚‚] â†’ Type (max ?u.363393 ?u.363392)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.363562 â†’+* ?m.363563) â†’
    (M : Type ?u.363559) â†’
      (Mâ‚‚ : Type ?u.363558) â†’
        [inst : AddCommMonoid M] â†’
          [inst_1 : AddCommMonoid Mâ‚‚] â†’
            [inst : Module ?m.363562 M] â†’ [inst : Module ?m.363563 Mâ‚‚] â†’ Type (max ?u.363559 ?u.363558)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  âˆ‘ i : ?m.367514, (DirectSum.of ?Î² i) (?x i)
case h.h
R : Type u_1
instâœÂ¹Â² : CommRing R
I : Ideal R
Mâœ : Type u_2
instâœÂ¹Â¹ : AddCommGroup Mâœ
instâœÂ¹â° : Module R Mâœ
N : Type u_3
instâœâ¹ : AddCommGroup N
instâœâ¸ : Module R N
P : Type u_4
instâœâ· : AddCommGroup P
instâœâ¶ : Module R P
T : Type u_5
instâœâµ : AddCommGroup T
instâœâ´ : Module (AdicCompletion I R) T
Î¹ : Type u_6
instâœÂ³ : DecidableEq Î¹
M : Î¹ â†’ Type u_7
instâœÂ² : (i : Î¹) â†’ AddCommGroup (M i)
instâœÂ¹ : (i : Î¹) â†’ Module R (M i)
instâœ : Fintype Î¹
f : AdicCauchySequence I (â¨ (j : Î¹), M j)
n : â„•
âŠ¢ â†‘(âˆ‘ x : Î¹, (map I (lof R Î¹ M x)) ((map I (component R Î¹ M x)) ((mk I (â¨ (j : Î¹), M j)) f))) n = (I ^ n â€¢ âŠ¤).mkQ (â†‘f n)",theorem sum_comp_sumInv : sum I M âˆ˜â‚— sumInv I M = LinearMap.id ,":= by
  ext f n
  simp only [LinearMap.coe_comp, Function.comp_apply, LinearMap.id_coe, id_eq, mk_apply_coe,
    Submodule.mkQ_apply]
  rw [â† DirectSum.sum_univ_of _ (((sumInv I M) ((AdicCompletion.mk I (â¨ (j : Î¹), M j)) f)))]
  simp only [sumInv_apply, map_mk, map_sum, sum_of, val_sum, mk_apply_coe,
    AdicCauchySequence.map_apply_coe, Submodule.mkQ_apply]
  simp only [â† Submodule.mkQ_apply, â† map_sum]
  erw [DirectSum.sum_univ_of]"
Mathlib/Geometry/RingedSpace/OpenImmersion.lean,AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion.lift_range,lift_range,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have := pullback_snd_isIso_of_range_subset f g H'
  dsimp only [lift]
  have : _ = (pullback.fst : pullback f g âŸ¶ _).val.base :=
    PreservesPullback.iso_hom_fst
      (LocallyRingedSpace.forgetToSheafedSpace â‹™ SheafedSpace.forget _) f g
  rw [LocallyRingedSpace.comp_val, SheafedSpace.comp_base, â† this, â† Category.assoc, coe_comp]
  rw [Set.range_comp, Set.range_iff_surjective.mpr, Set.image_univ]
  Â· erw [TopCat.pullback_fst_range]
    ext
    constructor
    Â· rintro âŸ¨y, eqâŸ©; exact âŸ¨y, eq.symmâŸ©
    Â· rintro âŸ¨y, eqâŸ©; exact âŸ¨y, eq.symmâŸ©
  Â· rw [â† TopCat.epi_iff_surjective]
    rw [show (inv (pullback.snd : pullback f g âŸ¶ _)).val.base = _ from
        (LocallyRingedSpace.forgetToSheafedSpace â‹™ SheafedSpace.forget _).map_inv _]
    infer_instance","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â‡‘(?f â‰« ?g)
C : Type u
instâœ : Category.{v, u} C
X Y Z : LocallyRingedSpace
f : X âŸ¶ Z
g : Y âŸ¶ Z
H : IsOpenImmersion f
H' : Set.range â‡‘g.val.base âŠ† Set.range â‡‘f.val.base
thisâœ : IsIso pullback.snd
this :
  (PreservesPullback.iso (forgetToSheafedSpace â‹™ SheafedSpace.forget CommRingCat) f g).hom â‰« pullback.fst =
    pullback.fst.val.base
âŠ¢ Set.range
      â‡‘(((inv pullback.snd).val.base â‰«
            (PreservesPullback.iso (forgetToSheafedSpace â‹™ SheafedSpace.forget CommRingCat) f g).hom) â‰«
          pullback.fst) =
    â‡‘f.val.base â»Â¹' Set.range â‡‘g.val.base","theorem lift_range (H' : Set.range g.1.base âŠ† Set.range f.1.base) :
    Set.range (lift f g H').1.base = f.1.base â»Â¹' Set.range g.1.base ",":= by
  have := pullback_snd_isIso_of_range_subset f g H'
  dsimp only [lift]
  have : _ = (pullback.fst : pullback f g âŸ¶ _).val.base :=
    PreservesPullback.iso_hom_fst
      (LocallyRingedSpace.forgetToSheafedSpace â‹™ SheafedSpace.forget _) f g
  erw [LocallyRingedSpace.comp_val, SheafedSpace.comp_base, â† this, â† Category.assoc, coe_comp]
  rw [Set.range_comp, Set.range_iff_surjective.mpr, Set.image_univ]
  Â· erw [TopCat.pullback_fst_range]
    ext
    constructor
    Â· rintro âŸ¨y, eqâŸ©; exact âŸ¨y, eq.symmâŸ©
    Â· rintro âŸ¨y, eqâŸ©; exact âŸ¨y, eq.symmâŸ©
  Â· erw [â† TopCat.epi_iff_surjective] 
    rw [show (inv (pullback.snd : pullback f g âŸ¶ _)).val.base = _ from
        (LocallyRingedSpace.forgetToSheafedSpace â‹™ SheafedSpace.forget _).map_inv _]
    infer_instance"
Mathlib/MeasureTheory/Integral/CircleIntegral.lean,hasSum_two_pi_I_cauchyPowerSeries_integral,hasSum_two_pi_I_cauchyPowerSeries_integral,50dac17e96f8a0ddcbd8740f9929f7cf0a85740d,":= by
  have hR : 0 < R := (Complex.abs.nonneg w).trans_lt hw
  have hwR : abs w / R âˆˆ Ico (0 : â„) 1 :=
    âŸ¨div_nonneg (Complex.abs.nonneg w) hR.le, (div_lt_one hR).2 hwâŸ©
  refine' intervalIntegral.hasSum_integral_of_dominated_convergence
      (fun n Î¸ => â€–f (circleMap c R Î¸)â€– * (abs w / R) ^ n) (fun n => _) (fun n => _) _ _ _
  Â· simp only [deriv_circleMap]
    apply_rules [AEStronglyMeasurable.smul, hf.def.1] <;> apply Measurable.aestronglyMeasurable
    Â· exact (measurable_circleMap 0 R).mul_const I
    Â· exact (((measurable_circleMap c R).sub measurable_const).const_div w).pow measurable_const
    Â· exact ((measurable_circleMap c R).sub measurable_const).inv
  Â· simp [norm_smul, abs_of_pos hR, mul_left_comm R, inv_mul_cancel_leftâ‚€ hR.ne', mul_comm â€–_â€–]
  Â· exact eventually_of_forall fun _ _ => (summable_geometric_of_lt_1 hwR.1 hwR.2).mul_left _
  Â· simpa only [tsum_mul_left, tsum_geometric_of_lt_1 hwR.1 hwR.2] using
      hf.norm.mul_continuousOn continuousOn_const
  Â· refine' eventually_of_forall fun Î¸ _ => HasSum.const_smul _ _
    simp only [smul_smul]
    refine' HasSum.smul_const _ _
    have : â€–w / (circleMap c R Î¸ - c)â€– < 1 := by simpa [abs_of_pos hR] using hwR.2
    convert (hasSum_geometric_of_norm_lt_1 this).mul_right _ using 1
    simp [â† sub_sub, â† mul_inv, sub_mul, div_mul_cancel _ (circleMap_ne_center hR.ne')]","error:  invalid field 'def', the environment does not contain 'CircleIntegrable.def'
  hf
has type
  CircleIntegrable f c R
error:  invalid field 'def', the environment does not contain 'IntervalIntegrable.def'
  hf
has type
  IntervalIntegrable (fun Î¸ â†¦ f (circleMap c R Î¸)) volume 0 (2 * Ï€)
error:  invalid field 'def', the environment does not contain 'And.def'
  hf
has type
  IntegrableOn (fun Î¸ â†¦ f (circleMap c R Î¸)) (Ioc 0 (2 * Ï€)) volume âˆ§
    IntegrableOn (fun Î¸ â†¦ f (circleMap c R Î¸)) (Ioc (2 * Ï€) 0) volume
error:  invalid field 'def', the environment does not contain 'CircleIntegrable.def'
  hf
has type
  CircleIntegrable f c R
error:  invalid field 'def', the environment does not contain 'IntervalIntegrable.def'
  hf
has type
  IntervalIntegrable (fun Î¸ â†¦ f (circleMap c R Î¸)) volume 0 (2 * Ï€)
error:  invalid field 'def', the environment does not contain 'And.def'
  hf
has type
  IntegrableOn (fun Î¸ â†¦ f (circleMap c R Î¸)) (Ioc 0 (2 * Ï€)) volume âˆ§
    IntegrableOn (fun Î¸ â†¦ f (circleMap c R Î¸)) (Ioc (2 * Ï€) 0) volume
error:  invalid field 'def', the environment does not contain 'CircleIntegrable.def'
  hf
has type
  CircleIntegrable f c R
error:  invalid field 'def', the environment does not contain 'IntervalIntegrable.def'
  hf
has type
  IntervalIntegrable (fun Î¸ â†¦ f (circleMap c R Î¸)) volume 0 (2 * Ï€)
error:  invalid field 'def', the environment does not contain 'And.def'
  hf
has type
  IntegrableOn (fun Î¸ â†¦ f (circleMap c R Î¸)) (Ioc 0 (2 * Ï€)) volume âˆ§
    IntegrableOn (fun Î¸ â†¦ f (circleMap c R Î¸)) (Ioc (2 * Ï€) 0) volume
error:  invalid field 'def', the environment does not contain 'CircleIntegrable.def'
  hf
has type
  CircleIntegrable f c R
error:  invalid field 'def', the environment does not contain 'IntervalIntegrable.def'
  hf
has type
  IntervalIntegrable (fun Î¸ â†¦ f (circleMap c R Î¸)) volume 0 (2 * Ï€)
error:  invalid field 'def', the environment does not contain 'And.def'
  hf
has type
  IntegrableOn (fun Î¸ â†¦ f (circleMap c R Î¸)) (Ioc 0 (2 * Ï€)) volume âˆ§
    IntegrableOn (fun Î¸ â†¦ f (circleMap c R Î¸)) (Ioc (2 * Ï€) 0) volume
error:  invalid field 'def', the environment does not contain 'CircleIntegrable.def'
  hf
has type
  CircleIntegrable f c R
error:  invalid field 'def', the environment does not contain 'IntervalIntegrable.def'
  hf
has type
  IntervalIntegrable (fun Î¸ â†¦ f (circleMap c R Î¸)) volume 0 (2 * Ï€)
error:  invalid field 'def', the environment does not contain 'And.def'
  hf
has type
  IntegrableOn (fun Î¸ â†¦ f (circleMap c R Î¸)) (Ioc 0 (2 * Ï€)) volume âˆ§
    IntegrableOn (fun Î¸ â†¦ f (circleMap c R Î¸)) (Ioc (2 * Ï€) 0) volume
error:  invalid field 'def', the environment does not contain 'CircleIntegrable.def'
  hf
has type
  CircleIntegrable f c R
error:  invalid field 'def', the environment does not contain 'IntervalIntegrable.def'
  hf
has type
  IntervalIntegrable (fun Î¸ â†¦ f (circleMap c R Î¸)) volume 0 (2 * Ï€)
error:  invalid field 'def', the environment does not contain 'And.def'
  hf
has type
  IntegrableOn (fun Î¸ â†¦ f (circleMap c R Î¸)) (Ioc 0 (2 * Ï€)) volume âˆ§
    IntegrableOn (fun Î¸ â†¦ f (circleMap c R Î¸)) (Ioc (2 * Ï€) 0) volume
error:  invalid field 'def', the environment does not contain 'CircleIntegrable.def'
  hf
has type
  CircleIntegrable f c R
error:  invalid field 'def', the environment does not contain 'IntervalIntegrable.def'
  hf
has type
  IntervalIntegrable (fun Î¸ â†¦ f (circleMap c R Î¸)) volume 0 (2 * Ï€)
error:  invalid field 'def', the environment does not contain 'And.def'
  hf
has type
  IntegrableOn (fun Î¸ â†¦ f (circleMap c R Î¸)) (Ioc 0 (2 * Ï€)) volume âˆ§
    IntegrableOn (fun Î¸ â†¦ f (circleMap c R Î¸)) (Ioc (2 * Ï€) 0) volume
error:  no goals to be solved
warning:  `summable_geometric_of_lt_1` has been deprecated, use `summable_geometric_of_lt_one` instead
warning:  `tsum_geometric_of_lt_1` has been deprecated, use `tsum_geometric_of_lt_one` instead
warning:  `hasSum_geometric_of_norm_lt_1` has been deprecated, use `hasSum_geometric_of_norm_lt_one` instead
error:  application type mismatch
  div_mul_cancel ?m.357883 (circleMap_ne_center (LT.lt.ne' hR))
argument
  circleMap_ne_center (LT.lt.ne' hR)
has type
  circleMap ?m.357884 R ?m.357915 â‰  ?m.357884 : Prop
but is expected to have type
  ?m.357881 : Type ?u.357880
error:  unsolved goals
case h.e'_6
E : Type u_1
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„‚ E
instâœ : CompleteSpace E
f : â„‚ â†’ E
c : â„‚
R : â„
w : â„‚
hf : CircleIntegrable f c R
hw : Complex.abs w < R
hR : 0 < R
hwR : Complex.abs w / R âˆˆ Ico 0 1
Î¸ : â„
xâœ : Î¸ âˆˆ Î™ 0 (2 * Ï€)
this : â€–w / (circleMap c R Î¸ - c)â€– < 1
âŠ¢ w = w / circleMap 0 R Î¸ * circleMap 0 R Î¸","theorem hasSum_two_pi_I_cauchyPowerSeries_integral {f : â„‚ â†’ E} {c : â„‚} {R : â„} {w : â„‚}
    (hf : CircleIntegrable f c R) (hw : abs w < R) :
    HasSum (fun n : â„• => âˆ® z in C(c, R), (w / (z - c)) ^ n â€¢ (z - c)â»Â¹ â€¢ f z)
      (âˆ® z in C(c, R), (z - (c + w))â»Â¹ â€¢ f z) ",":= by
  have hR : 0 < R := (Complex.abs.nonneg w).trans_lt hw
  have hwR : abs w / R âˆˆ Ico (0 : â„) 1 :=
    âŸ¨div_nonneg (Complex.abs.nonneg w) hR.le, (div_lt_one hR).2 hwâŸ©
  refine intervalIntegral.hasSum_integral_of_dominated_convergence
      (fun n Î¸ => â€–f (circleMap c R Î¸)â€– * (abs w / R) ^ n) (fun n => ?_) (fun n => ?_) ?_ ?_ ?_
  Â· simp only [deriv_circleMap]
    apply_rules [AEStronglyMeasurable.smul, hf.def'.1] <;> apply Measurable.aestronglyMeasurable
    Â· exact (measurable_circleMap 0 R).mul_const I
    Â· exact (((measurable_circleMap c R).sub measurable_const).const_div w).pow measurable_const
    Â· exact ((measurable_circleMap c R).sub measurable_const).inv
  Â· simp [norm_smul, abs_of_pos hR, mul_left_comm R, inv_mul_cancel_leftâ‚€ hR.ne', mul_comm â€–_â€–]
  Â· exact eventually_of_forall fun _ _ => (summable_geometric_of_lt_one hwR.1 hwR.2).mul_left _
  Â· simpa only [tsum_mul_left, tsum_geometric_of_lt_one hwR.1 hwR.2] using
      hf.norm.mul_continuousOn continuousOn_const
  Â· refine eventually_of_forall fun Î¸ _ => HasSum.const_smul _ ?_
    simp only [smul_smul]
    refine HasSum.smul_const ?_ _
    have : â€–w / (circleMap c R Î¸ - c)â€– < 1 := by simpa [abs_of_pos hR] using hwR.2
    convert (hasSum_geometric_of_norm_lt_one this).mul_right _ using 1
    simp [â† sub_sub, â† mul_inv, sub_mul, div_mul_cancelâ‚€ _ (circleMap_ne_center hR.ne')]"
Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean,HomogeneousIdeal.toIdeal_iInfâ‚‚,toIdeal_iInfâ‚‚,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":=
  HomogeneousSubmodule.toSubmodule_iInfâ‚‚ s",error:  unknown identifier 'HomogeneousSubmodule.toSubmodule_iInfâ‚‚',"theorem toIdeal_iInfâ‚‚ {Îº : Sort*} {Îº' : Îº â†’ Sort*} (s : âˆ€ i, Îº' i â†’ HomogeneousIdeal ğ’œ) :
    (â¨… (i) (j), s i j).toIdeal = â¨… (i) (j), (s i j).toIdeal ",":= by
  simp_rw [toIdeal_iInf]"
Mathlib/LinearAlgebra/Matrix/Spectrum.lean,Matrix.IsHermitian.rank_eq_rank_diagonal,rank_eq_rank_diagonal,f19a0371b87a29a9a331a0262ff2d25a28357e62,":= by
  conv_lhs => rw [hA.spectral_theorem2]
  have hG : (hA.eigenvectorUnitary.1) * (star (hA.eigenvectorUnitary.1)) = 1 := by
          simp only [hA.eigenvectorUnitary.2, unitary.mul_star_self_of_mem]
  have hE := isUnit_det_of_right_inverse hG
  have hE1 := isUnit_det_of_left_inverse hG
  simp only [rank_mul_eq_right_of_isUnit_det (A := hA.eigenvectorUnitary.1)
      (B := star (hA.eigenvectorUnitary.1)) hE, rank_mul_eq_left_of_isUnit_det
      (B := hA.eigenvectorUnitary.1) (A := star (hA.eigenvectorUnitary.1)) hE1,
    rank_diagonal, Function.comp_apply, ne_eq, algebraMap.lift_map_eq_zero_iff]","error:  invalid field 'spectral_theorem2', the environment does not contain 'Matrix.IsHermitian.spectral_theorem2'
  hA
has type
  A.IsHermitian
error:  invalid field 'spectral_theorem2', the environment does not contain 'Eq.spectral_theorem2'
  hA
has type
  Aá´´ = A
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.98289
ğ•œ : Type u_1
instâœÂ² : RCLike ğ•œ
n : Type u_2
instâœÂ¹ : Fintype n
A : Matrix n n ğ•œ
instâœ : DecidableEq n
hA : A.IsHermitian
| A.rank",lemma rank_eq_rank_diagonal : A.rank = (Matrix.diagonal hA.eigenvalues).rank ,":= by
  conv_lhs => rw [hA.spectral_theorem, â† unitary.coe_star]
  simp [-isUnit_iff_ne_zero, -unitary.coe_star, rank_diagonal]"
Mathlib/Topology/Order/LowerUpperTopology.lean,Topology.IsUpper.continuous_of_Iic,continuous_of_Iic,5553d1d4d9cb54aba8a3131a473b458da599a149,":=
  LowerTopology.continuous_of_Ici (Î± := Î±áµ’áµˆ) h",error:  unknown identifier 'LowerTopology.continuous_of_Ici',"lemma continuous_of_Iic [TopologicalSpace Î²] {f : Î² â†’ Î±} (h : âˆ€ a, IsClosed (f â»Â¹' (Iic a))) :
    Continuous f ",":=
  continuous_iff_Iic.2 h"
Mathlib/LinearAlgebra/Matrix/Transvection.lean,Matrix.Pivot.exists_isTwoBlockDiagonal_list_transvec_mul_mul_list_transvec,exists_isTwoBlockDiagonal_list_transvec_mul_mul_list_transvec,9f4034ab38e4815706a7d12c61d5e009e2c84ba9,":= by
  by_cases H : IsTwoBlockDiagonal M
  Â· refine' âŸ¨List.nil, List.nil, by simpa using HâŸ©
  by_cases hM : M (inr unit) (inr unit) â‰  0
  Â· exact exists_isTwoBlockDiagonal_of_ne_zero M hM
  push_neg at hM
  simp only [not_and_or, IsTwoBlockDiagonal, toBlocksâ‚â‚‚, toBlocksâ‚‚â‚, â† Matrix.ext_iff] at H
  have : âˆƒ i : Fin r, M (inl i) (inr unit) â‰  0 âˆ¨ M (inr unit) (inl i) â‰  0 := by
    cases' H with H H
    Â· contrapose! H
      rintro i âŸ¨âŸ©
      exact (H i).1
    Â· contrapose! H
      rintro âŸ¨âŸ© j
      exact (H j).2
  rcases this with âŸ¨i, h | hâŸ©
  Â· let M' := transvection (inr Unit.unit) (inl i) 1 * M
    have hM' : M' (inr unit) (inr unit) â‰  0 := by simpa [hM]
    rcases exists_isTwoBlockDiagonal_of_ne_zero M' hM' with âŸ¨L, L', hLL'âŸ©
    rw [Matrix.mul_assoc] at hLL'
    refine' âŸ¨L ++ [âŸ¨inr unit, inl i, by simp, 1âŸ©], L', _âŸ©
    simp only [List.map_append, List.prod_append, Matrix.mul_one, toMatrix_mk, List.prod_cons,
      List.prod_nil, List.map, Matrix.mul_assoc (L.map toMatrix).prod]
    exact hLL'
  Â· let M' := M * transvection (inl i) (inr unit) 1
    have hM' : M' (inr unit) (inr unit) â‰  0 := by simpa [hM]
    rcases exists_isTwoBlockDiagonal_of_ne_zero M' hM' with âŸ¨L, L', hLL'âŸ©
    refine' âŸ¨L, âŸ¨inl i, inr unit, by simp, 1âŸ©::L', _âŸ©
    simp only [â† Matrix.mul_assoc, toMatrix_mk, List.prod_cons, List.map]
    rw [Matrix.mul_assoc (L.map toMatrix).prod]
    exact hLL'","error:  tactic 'assumption' failed
n : Type u_1
p : Type u_2
R : Type uâ‚‚
ğ•œ : Type u_3
instâœÂ³ : Field ğ•œ
instâœÂ² : DecidableEq n
instâœÂ¹ : DecidableEq p
instâœ : CommRing R
r : â„•
Mâœ M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ğ•œ
hM : M (inr ()) (inr ()) = 0
H :
  (Â¬âˆ€ (i : Fin r) (j : Unit), of (fun i j â†¦ M (inl i) (inr j)) i j = 0 i j) âˆ¨
    Â¬âˆ€ (i : Unit) (j : Fin r), of (fun i j â†¦ M (inr i) (inl j)) i j = 0 i j
i : Fin r
h : M (inl i) (inr ()) â‰  0
M' : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ğ•œ := transvection (inr ()) (inl i) 1 * M
âŠ¢ Â¬M' (inr ()) (inr ()) = 0
error:  tactic 'assumption' failed
n : Type u_1
p : Type u_2
R : Type uâ‚‚
ğ•œ : Type u_3
instâœÂ³ : Field ğ•œ
instâœÂ² : DecidableEq n
instâœÂ¹ : DecidableEq p
instâœ : CommRing R
r : â„•
Mâœ M : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ğ•œ
hM : M (inr ()) (inr ()) = 0
H :
  (Â¬âˆ€ (i : Fin r) (j : Unit), of (fun i j â†¦ M (inl i) (inr j)) i j = 0 i j) âˆ¨
    Â¬âˆ€ (i : Unit) (j : Fin r), of (fun i j â†¦ M (inr i) (inl j)) i j = 0 i j
i : Fin r
h : M (inr ()) (inl i) â‰  0
M' : Matrix (Fin r âŠ• Unit) (Fin r âŠ• Unit) ğ•œ := M * transvection (inl i) (inr ()) 1
âŠ¢ Â¬M' (inr ()) (inr ()) = 0","theorem exists_isTwoBlockDiagonal_list_transvec_mul_mul_list_transvec
    (M : Matrix (Sum (Fin r) Unit) (Sum (Fin r) Unit) ğ•œ) :
    âˆƒ L L' : List (TransvectionStruct (Sum (Fin r) Unit) ğ•œ),
      IsTwoBlockDiagonal ((L.map toMatrix).prod * M * (L'.map toMatrix).prod) ",":= by
  by_cases H : IsTwoBlockDiagonal M
  Â· refine âŸ¨List.nil, List.nil, by simpa using HâŸ©
  by_cases hM : M (inr unit) (inr unit) â‰  0
  Â· exact exists_isTwoBlockDiagonal_of_ne_zero M hM
  push_neg at hM
  simp only [not_and_or, IsTwoBlockDiagonal, toBlocksâ‚â‚‚, toBlocksâ‚‚â‚, â† Matrix.ext_iff] at H
  have : âˆƒ i : Fin r, M (inl i) (inr unit) â‰  0 âˆ¨ M (inr unit) (inl i) â‰  0 := by
    cases' H with H H
    Â· contrapose! H
      rintro i âŸ¨âŸ©
      exact (H i).1
    Â· contrapose! H
      rintro âŸ¨âŸ© j
      exact (H j).2
  rcases this with âŸ¨i, h | hâŸ©
  Â· let M' := transvection (inr Unit.unit) (inl i) 1 * M
    have hM' : M' (inr unit) (inr unit) â‰  0 := by simpa [M', hM]
    rcases exists_isTwoBlockDiagonal_of_ne_zero M' hM' with âŸ¨L, L', hLL'âŸ©
    rw [Matrix.mul_assoc] at hLL'
    refine âŸ¨L ++ [âŸ¨inr unit, inl i, by simp, 1âŸ©], L', ?_âŸ©
    simp only [List.map_append, List.prod_append, Matrix.mul_one, toMatrix_mk, List.prod_cons,
      List.prod_nil, List.map, Matrix.mul_assoc (L.map toMatrix).prod]
    exact hLL'
  Â· let M' := M * transvection (inl i) (inr unit) 1
    have hM' : M' (inr unit) (inr unit) â‰  0 := by simpa [M', hM]
    rcases exists_isTwoBlockDiagonal_of_ne_zero M' hM' with âŸ¨L, L', hLL'âŸ©
    refine âŸ¨L, âŸ¨inl i, inr unit, by simp, 1âŸ©::L', ?_âŸ©
    simp only [â† Matrix.mul_assoc, toMatrix_mk, List.prod_cons, List.map]
    rw [Matrix.mul_assoc (L.map toMatrix).prod]
    exact hLL'"
Mathlib/Probability/ConditionalProbability.lean,ProbabilityTheory.cond_cond_eq_cond_inter',cond_cond_eq_cond_inter',05c4c02a126a220762b13df794c36c771e2fbb7d,":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Î¼ (s âˆ© t)) 0
  Â· have : Î¼ (s âˆ© t âˆ© u) = 0 := measure_mono_null (Set.inter_subset_left _ _) hst
    simp [this, â† Set.inter_assoc]
  Â· have hcs' : Î¼ s â‰  0 :=
      (Î¼.toOuterMeasure.pos_of_subset_ne_zero (Set.inter_subset_left _ _) hst).ne'
    simp [*, â† mul_assoc, â† Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (Î¼ s)â»Â¹]","warning:  @cond does not have a doc string
warning:  @cond does not have a doc string
error:  function expected at
  inter_subset_left ?m.28019
term has type
  ?m.28018 âˆˆ ?m.28016
warning:  `MeasureTheory.OuterMeasure.pos_of_subset_ne_zero` has been deprecated, use `MeasureTheory.measure_pos_of_superset` instead
error:  function expected at
  inter_subset_left ?m.30432
term has type
  ?m.30431 âˆˆ ?m.30429","lemma cond_cond_eq_cond_inter' (hms : MeasurableSet s) (hmt : MeasurableSet t) (hcs : Î¼ s â‰  âˆ) :
    Î¼[|s][|t] = Î¼[|s âˆ© t] ",":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Î¼ (s âˆ© t)) 0
  Â· have : Î¼ (s âˆ© t âˆ© u) = 0 := measure_mono_null Set.inter_subset_left hst
    simp [this, â† Set.inter_assoc]
  Â· have hcs' : Î¼ s â‰  0 :=
      (measure_pos_of_superset Set.inter_subset_left hst).ne'
    simp [*, â† mul_assoc, â† Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (Î¼ s)â»Â¹]"
Mathlib/Probability/Cdf.lean,ProbabilityTheory.tendsto_cdf_atTop,tendsto_cdf_atTop,c4988d10a696972769fd676cb9977e896bf0a01b,:= tendsto_condCdf_atTop _ _,error:  unknown identifier 'tendsto_condCdf_atTop',lemma tendsto_cdf_atTop : Tendsto (cdf Î¼) atTop (ğ“ 1) ,:= tendsto_condCDF_atTop _ _
Mathlib/RingTheory/HahnSeries/Multiplication.lean,HahnSeries.single_pow,single_pow,698d5d95363c1494f75c001bb07d1d0daec7ef7f,":= by
  induction' n with n IH
  Â· simp; rfl
  Â· rw [pow_succ, pow_succ, IH, single_mul_single, succ_nsmul]",error:  no goals to be solved,theorem single_pow (a : Î“) (n : â„•) (r : R) : single a r ^ n = single (n â€¢ a) (r ^ n) ,":= by
  induction' n with n IH
  Â· ext; simp only [pow_zero, one_coeff, zero_smul, single_coeff]
  Â· rw [pow_succ, pow_succ, IH, single_mul_single, succ_nsmul]"
Mathlib/NumberTheory/NumberField/Embeddings.lean,NumberField.Embeddings.coeff_bdd_of_norm_le,coeff_bdd_of_norm_le,297417982fafae931b48034c0aab7fe3396185a9,":= by
  have hx := Algebra.IsSeparable.isIntegral â„š x
  rw [â† norm_algebraMap' A, â† coeff_map (algebraMap â„š A)]
  refine coeff_bdd_of_roots_le _ (minpoly.monic hx)
      (IsAlgClosed.splits_codomain _) (minpoly.natDegree_le x) (fun z hz => ?_) i
  classical
  rw [â† Multiset.mem_toFinset] at hz
  obtain âŸ¨Ï†, rflâŸ© := (range_eval_eq_rootSet_minpoly K A x).symm.subset hz
  exact h Ï†","error:  unknown constant 'Algebra.IsSeparable.isIntegral'
error:  unsolved goals
K : Type u_1
instâœâ´ : Field K
instâœÂ³ : NumberField K
A : Type u_2
instâœÂ² : NormedField A
instâœÂ¹ : IsAlgClosed A
instâœ : NormedAlgebra â„š A
B : â„
x : K
h : âˆ€ (Ï† : K â†’+* A), â€–Ï† xâ€– â‰¤ B
i : â„•
âŠ¢ â€–(minpoly â„š x).coeff iâ€– â‰¤ max B 1 ^ finrank â„š K * â†‘((finrank â„š K).choose (finrank â„š K / 2))","theorem coeff_bdd_of_norm_le {B : â„} {x : K} (h : âˆ€ Ï† : K â†’+* A, â€–Ï† xâ€– â‰¤ B) (i : â„•) :
    â€–(minpoly â„š x).coeff iâ€– â‰¤ max B 1 ^ finrank â„š K * (finrank â„š K).choose (finrank â„š K / 2) ",":= by
  have hx := IsSeparable.isIntegral â„š x
  rw [â† norm_algebraMap' A, â† coeff_map (algebraMap â„š A)]
  refine coeff_bdd_of_roots_le _ (minpoly.monic hx)
      (IsAlgClosed.splits_codomain _) (minpoly.natDegree_le x) (fun z hz => ?_) i
  classical
  rw [â† Multiset.mem_toFinset] at hz
  obtain âŸ¨Ï†, rflâŸ© := (range_eval_eq_rootSet_minpoly K A x).symm.subset hz
  exact h Ï†"
Mathlib/ModelTheory/Definability.lean,Set.Definable.image_comp_sum_inl_fin,Definable.image_comp_sum_inl_fin,49e208cd730f8d087fd80ae7a5bd1d90451bc8c5,":= by
  obtain âŸ¨Ï†, rflâŸ© := h
  refine' âŸ¨(Semiformula.relabel id Ï†).exs, _âŸ©
  ext x
  simp only [Set.mem_image, mem_setOf_eq, Semiformula.realize_exs,
    Semiformula.realize_relabel, Function.comp_id, Fin.castAdd_zero, Fin.cast_refl]
  constructor
  Â· rintro âŸ¨y, hy, rflâŸ©
    exact
      âŸ¨y âˆ˜ Sum.inr, (congr (congr rfl (Sum.elim_comp_inl_inr y).symm) (funext finZeroElim)).mp hyâŸ©
  Â· rintro âŸ¨y, hyâŸ©
    exact âŸ¨Sum.elim x y, (congr rfl (funext finZeroElim)).mp hy, Sum.elim_comp_inl _ _âŸ©","error:  unknown identifier 'Semiformula.relabel'
error:  unknown identifier 'Semiformula.realize_exs'
error:  unknown identifier 'Semiformula.realize_relabel'","theorem Definable.image_comp_sum_inl_fin (m : â„•) {s : Set (Sum Î± (Fin m) â†’ M)}
    (h : A.Definable L s) : A.Definable L ((fun g : Sum Î± (Fin m) â†’ M => g âˆ˜ Sum.inl) '' s) ",":= by
  obtain âŸ¨Ï†, rflâŸ© := h
  refine âŸ¨(BoundedFormula.relabel id Ï†).exs, ?_âŸ©
  ext x
  simp only [Set.mem_image, mem_setOf_eq, BoundedFormula.realize_exs,
    BoundedFormula.realize_relabel, Function.comp_id, Fin.castAdd_zero, Fin.cast_refl]
  constructor
  Â· rintro âŸ¨y, hy, rflâŸ©
    exact
      âŸ¨y âˆ˜ Sum.inr, (congr (congr rfl (Sum.elim_comp_inl_inr y).symm) (funext finZeroElim)).mp hyâŸ©
  Â· rintro âŸ¨y, hyâŸ©
    exact âŸ¨Sum.elim x y, (congr rfl (funext finZeroElim)).mp hy, Sum.elim_comp_inl _ _âŸ©"
Mathlib/MeasureTheory/Measure/Haar/Basic.lean,MeasureTheory.Measure.haar.chaar_sup_eq,chaar_sup_eq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rcases SeparatedNhds.of_isCompact_isCompact_isClosed Kâ‚.2 Kâ‚‚.2 hâ‚‚ h
    with âŸ¨Uâ‚, Uâ‚‚, h1Uâ‚, h1Uâ‚‚, h2Uâ‚, h2Uâ‚‚, hUâŸ©
  rcases compact_open_separated_mul_right Kâ‚.2 h1Uâ‚ h2Uâ‚ with âŸ¨Lâ‚, h1Lâ‚, h2Lâ‚âŸ©
  rcases mem_nhds_iff.mp h1Lâ‚ with âŸ¨Vâ‚, h1Vâ‚, h2Vâ‚, h3Vâ‚âŸ©
  replace h2Lâ‚ := Subset.trans (mul_subset_mul_left h1Vâ‚) h2Lâ‚
  rcases compact_open_separated_mul_right Kâ‚‚.2 h1Uâ‚‚ h2Uâ‚‚ with âŸ¨Lâ‚‚, h1Lâ‚‚, h2Lâ‚‚âŸ©
  rcases mem_nhds_iff.mp h1Lâ‚‚ with âŸ¨Vâ‚‚, h1Vâ‚‚, h2Vâ‚‚, h3Vâ‚‚âŸ©
  replace h2Lâ‚‚ := Subset.trans (mul_subset_mul_left h1Vâ‚‚) h2Lâ‚‚
  let eval : (Compacts G â†’ â„) â†’ â„ := fun f => f Kâ‚ + f Kâ‚‚ - f (Kâ‚ âŠ” Kâ‚‚)
  have : Continuous eval :=
    ((continuous_apply Kâ‚).add (continuous_apply Kâ‚‚)).sub (continuous_apply (Kâ‚ âŠ” Kâ‚‚))
  rw [eq_comm, â† sub_eq_zero]; show chaar Kâ‚€ âˆˆ eval â»Â¹' {(0 : â„)}
  let V := Vâ‚ âˆ© Vâ‚‚
  apply
    mem_of_subset_of_mem _
      (chaar_mem_clPrehaar Kâ‚€
        âŸ¨âŸ¨Vâ»Â¹, (h2Vâ‚.inter h2Vâ‚‚).preimage continuous_invâŸ©, by
          simp only [V, mem_inv, inv_one, h3Vâ‚, h3Vâ‚‚, mem_inter_iff, true_and_iff]âŸ©)
  unfold clPrehaar; rw [IsClosed.closure_subset_iff]
  Â· rintro _ âŸ¨U, âŸ¨h1U, h2U, h3UâŸ©, rflâŸ©
    simp only [eval, mem_preimage, sub_eq_zero, mem_singleton_iff]; rw [eq_comm]
    apply prehaar_sup_eq
    Â· rw [h2U.interior_eq]; exact âŸ¨1, h3UâŸ©
    Â· refine' disjoint_of_subset _ _ hU
      Â· refine' Subset.trans (mul_subset_mul Subset.rfl _) h2Lâ‚
        exact Subset.trans (inv_subset.mpr h1U) (inter_subset_left _ _)
      Â· refine' Subset.trans (mul_subset_mul Subset.rfl _) h2Lâ‚‚
        exact Subset.trans (inv_subset.mpr h1U) (inter_subset_right _ _)
  Â· apply continuous_iff_isClosed.mp this; exact isClosed_singleton","error:  function expected at
  inter_subset_left ?m.76370
term has type
  ?m.76369 âˆˆ ?m.76367
error:  application type mismatch
  inv_subset.mpr h1U
argument
  h1U
has type
  U âŠ† â†‘{ carrier := Vâ»Â¹, is_open' := â‹¯, mem' := â‹¯ }.toOpens : Prop
but is expected to have type
  U âŠ† ?m.76202â»Â¹ : Prop
error:  function expected at
  inter_subset_right ?m.76764
term has type
  ?m.76763 âˆˆ ?m.76762
error:  application type mismatch
  inv_subset.mpr h1U
argument
  h1U
has type
  U âŠ† â†‘{ carrier := Vâ»Â¹, is_open' := â‹¯, mem' := â‹¯ }.toOpens : Prop
but is expected to have type
  U âŠ† ?m.76726â»Â¹ : Prop","theorem chaar_sup_eq {Kâ‚€ : PositiveCompacts G}
    {Kâ‚ Kâ‚‚ : Compacts G} (h : Disjoint Kâ‚.1 Kâ‚‚.1) (hâ‚‚ : IsClosed Kâ‚‚.1) :
    chaar Kâ‚€ (Kâ‚ âŠ” Kâ‚‚) = chaar Kâ‚€ Kâ‚ + chaar Kâ‚€ Kâ‚‚ ",":= by
  rcases SeparatedNhds.of_isCompact_isCompact_isClosed Kâ‚.2 Kâ‚‚.2 hâ‚‚ h
    with âŸ¨Uâ‚, Uâ‚‚, h1Uâ‚, h1Uâ‚‚, h2Uâ‚, h2Uâ‚‚, hUâŸ©
  rcases compact_open_separated_mul_right Kâ‚.2 h1Uâ‚ h2Uâ‚ with âŸ¨Lâ‚, h1Lâ‚, h2Lâ‚âŸ©
  rcases mem_nhds_iff.mp h1Lâ‚ with âŸ¨Vâ‚, h1Vâ‚, h2Vâ‚, h3Vâ‚âŸ©
  replace h2Lâ‚ := Subset.trans (mul_subset_mul_left h1Vâ‚) h2Lâ‚
  rcases compact_open_separated_mul_right Kâ‚‚.2 h1Uâ‚‚ h2Uâ‚‚ with âŸ¨Lâ‚‚, h1Lâ‚‚, h2Lâ‚‚âŸ©
  rcases mem_nhds_iff.mp h1Lâ‚‚ with âŸ¨Vâ‚‚, h1Vâ‚‚, h2Vâ‚‚, h3Vâ‚‚âŸ©
  replace h2Lâ‚‚ := Subset.trans (mul_subset_mul_left h1Vâ‚‚) h2Lâ‚‚
  let eval : (Compacts G â†’ â„) â†’ â„ := fun f => f Kâ‚ + f Kâ‚‚ - f (Kâ‚ âŠ” Kâ‚‚)
  have : Continuous eval :=
    ((continuous_apply Kâ‚).add (continuous_apply Kâ‚‚)).sub (continuous_apply (Kâ‚ âŠ” Kâ‚‚))
  rw [eq_comm, â† sub_eq_zero]; show chaar Kâ‚€ âˆˆ eval â»Â¹' {(0 : â„)}
  let V := Vâ‚ âˆ© Vâ‚‚
  apply
    mem_of_subset_of_mem _
      (chaar_mem_clPrehaar Kâ‚€
        âŸ¨âŸ¨Vâ»Â¹, (h2Vâ‚.inter h2Vâ‚‚).preimage continuous_invâŸ©, by
          simp only [V, mem_inv, inv_one, h3Vâ‚, h3Vâ‚‚, mem_inter_iff, true_and_iff]âŸ©)
  unfold clPrehaar; rw [IsClosed.closure_subset_iff]
  Â· rintro _ âŸ¨U, âŸ¨h1U, h2U, h3UâŸ©, rflâŸ©
    simp only [eval, mem_preimage, sub_eq_zero, mem_singleton_iff]; rw [eq_comm]
    apply prehaar_sup_eq
    Â· rw [h2U.interior_eq]; exact âŸ¨1, h3UâŸ©
    Â· refine disjoint_of_subset ?_ ?_ hU
      Â· refine Subset.trans (mul_subset_mul Subset.rfl ?_) h2Lâ‚
        exact Subset.trans (inv_subset.mpr h1U) inter_subset_left
      Â· refine Subset.trans (mul_subset_mul Subset.rfl ?_) h2Lâ‚‚
        exact Subset.trans (inv_subset.mpr h1U) inter_subset_right
  Â· apply continuous_iff_isClosed.mp this; exact isClosed_singleton"
Mathlib/MeasureTheory/Integral/DivergenceTheorem.lean,MeasureTheory.integral_divergence_of_hasFDerivWithinAt_off_countable_auxâ‚,integral_divergence_of_hasFDerivWithinAt_off_countable_auxâ‚,daf56f7104803477ea626b45f8979189439896db,":= by
  simp only [â† set_integral_congr_set_ae (Box.coe_ae_eq_Icc _)]
  have A := (Hi.mono_set Box.coe_subset_Icc).hasBoxIntegral âŠ¥ rfl
  have B :=
    hasIntegral_GP_divergence_of_forall_hasDerivWithinAt I f f' (s âˆ© Box.Icc I)
      (hs.mono (inter_subset_left _ _)) (fun x hx => Hc _ hx.2) fun x hx =>
      Hd _ âŸ¨hx.1, fun h => hx.2 âŸ¨h, hx.1âŸ©âŸ©
  rw [continuousOn_pi] at Hc
  refine' (A.unique B).trans (sum_congr rfl fun i _ => _)
  refine' congr_argâ‚‚ Sub.sub _ _
  Â· have := Box.continuousOn_face_Icc (Hc i) (Set.right_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Î¼ := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral âŠ¥ rfl).integral_eq
  Â· have := Box.continuousOn_face_Icc (Hc i) (Set.left_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Î¼ := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral âŠ¥ rfl).integral_eq","warning:  `MeasureTheory.set_integral_congr_set_ae` has been deprecated, use `MeasureTheory.setIntegral_congr_set_ae` instead
error:  overloaded, errors 
  function expected at
    Finset.inter_subset_left ?m.17305
  term has type
    ?m.17304 âˆˆ ?m.17302
  
  function expected at
    Set.inter_subset_left ?m.17442
  term has type
    ?m.17441 âˆˆ ?m.17439","theorem integral_divergence_of_hasFDerivWithinAt_off_countable_auxâ‚ (I : Box (Fin (n + 1)))
    (f : â„â¿âºÂ¹ â†’ Eâ¿âºÂ¹)
    (f' : â„â¿âºÂ¹ â†’ â„â¿âºÂ¹ â†’L[â„] Eâ¿âºÂ¹) (s : Set â„â¿âºÂ¹)
    (hs : s.Countable) (Hc : ContinuousOn f (Box.Icc I))
    (Hd : âˆ€ x âˆˆ (Box.Icc I) \ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x)
    (Hi : IntegrableOn (fun x => âˆ‘ i, f' x (e i) i) (Box.Icc I)) :
    (âˆ« x in Box.Icc I, âˆ‘ i, f' x (e i) i) =
      âˆ‘ i : Fin (n + 1),
        ((âˆ« x in Box.Icc (I.face i), f (i.insertNth (I.upper i) x) i) -
          âˆ« x in Box.Icc (I.face i), f (i.insertNth (I.lower i) x) i) ",":= by
  simp only [â† setIntegral_congr_set_ae (Box.coe_ae_eq_Icc _)]
  have A := (Hi.mono_set Box.coe_subset_Icc).hasBoxIntegral âŠ¥ rfl
  have B :=
    hasIntegral_GP_divergence_of_forall_hasDerivWithinAt I f f' (s âˆ© Box.Icc I)
      (hs.mono inter_subset_left) (fun x hx => Hc _ hx.2) fun x hx =>
      Hd _ âŸ¨hx.1, fun h => hx.2 âŸ¨h, hx.1âŸ©âŸ©
  rw [continuousOn_pi] at Hc
  refine (A.unique B).trans (sum_congr rfl fun i _ => ?_)
  refine congr_argâ‚‚ Sub.sub ?_ ?_
  Â· have := Box.continuousOn_face_Icc (Hc i) (Set.right_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Î¼ := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral âŠ¥ rfl).integral_eq
  Â· have := Box.continuousOn_face_Icc (Hc i) (Set.left_mem_Icc.2 (I.lower_le_upper i))
    have := (this.integrableOn_compact (Î¼ := volume) (Box.isCompact_Icc _)).mono_set
      Box.coe_subset_Icc
    exact (this.hasBoxIntegral âŠ¥ rfl).integral_eq"
Mathlib/FieldTheory/NormalClosure.lean,IntermediateField.le_normalClosure,le_normalClosure,2ac7d87c221020b247729b180bbe2575cceb0700,:=,error:  unexpected token 'lemma'; expected term,lemma le_normalClosure : K â‰¤ normalClosure F K L ,":=
  K.fieldRange_val.symm.trans_le K.val.fieldRange_le_normalClosure"
Mathlib/Algebra/Order/Floor.lean,Int.fract_pos,fract_pos,ac36b28ef3759cb65a7f386f3b7e15ee0ac1b4c9,:=,"warning:  @floor does not have a doc string
warning:  @ceil does not have a doc string
warning:  @floor does not have a doc string
warning:  @ceil does not have a doc string
error:  unexpected token 'theorem'; expected term",lemma fract_pos : 0 < fract a â†” a â‰  âŒŠaâŒ‹ ,":=
  (fract_nonneg a).lt_iff_ne.trans <| ne_comm.trans sub_ne_zero"
Mathlib/Topology/MetricSpace/Bounded.lean,Metric.finite_isBounded_inter_isClosed,Metric.finite_isBounded_inter_isClosed,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine Set.Finite.subset (IsCompact.finite ?_ ?_) (Set.inter_subset_inter_left s subset_closure)
  Â· exact hK.isCompact_closure.inter_right hs
  Â· exact DiscreteTopology.of_subset inferInstance (Set.inter_subset_right _ s)","error:  function expected at
  inter_subset_right ?m.48534
term has type
  ?m.48533 âˆˆ ?m.48532","theorem Metric.finite_isBounded_inter_isClosed [ProperSpace Î±] {K s : Set Î±} [DiscreteTopology s]
    (hK : IsBounded K) (hs : IsClosed s) : Set.Finite (K âˆ© s) ",":= by
  refine Set.Finite.subset (IsCompact.finite ?_ ?_) (Set.inter_subset_inter_left s subset_closure)
  Â· exact hK.isCompact_closure.inter_right hs
  Â· exact DiscreteTopology.of_subset inferInstance Set.inter_subset_right"
Mathlib/NumberTheory/Modular.lean,ModularGroup.abs_c_le_one,abs_c_le_one,f3db3040b24eea7e8cf5c566bd4354149c7dbdc9,":= by
  let c' : â„¤ := (â†‘â‚˜g) 1 0
  let c : â„ := (c' : â„)
  suffices 3 * c ^ 2 < 4 by
    rw [â† Int.cast_pow, â† Int.cast_three, â† Int.cast_four, â† Int.cast_mul, Int.cast_lt] at this
    replace this : c' ^ 2 â‰¤ 1 ^ 2; Â· linarith
    rwa [sq_le_sq, abs_one] at this
  suffices c â‰  0 â†’ 9 * c ^ 4 < 16 by
    rcases eq_or_ne c 0 with (hc | hc)
    Â· rw [hc]; norm_num
    Â· refine' (abs_lt_of_sq_lt_sq' _ (by norm_num)).2
      specialize this hc
      linarith
  intro hc
  replace hc : 0 < c ^ 4;
  Â· change 0 < c ^ (2 * 2); rw [pow_mul]; apply sq_pos_of_pos (sq_pos_of_ne_zero _ hc)
  have hâ‚ :=
    mul_lt_mul_of_pos_right
      (mul_lt_mul'' (three_lt_four_mul_im_sq_of_mem_fdo hg) (three_lt_four_mul_im_sq_of_mem_fdo hz)
        (by linarith) (by linarith))
      hc
  have hâ‚‚ : (c * z.im) ^ 4 / normSq (denom (â†‘g) z) ^ 2 â‰¤ 1 :=
    div_le_one_of_le
      (pow_four_le_pow_two_of_pow_two_le (UpperHalfPlane.c_mul_im_sq_le_normSq_denom z g))
      (sq_nonneg _)
  let nsq := normSq (denom g z)
  calc
    9 * c ^ 4 < c ^ 4 * z.im ^ 2 * (g â€¢ z).im ^ 2 * 16 := by linarith
    _ = c ^ 4 * z.im ^ 4 / nsq ^ 2 * 16 := by
      rw [ModularGroup.im_smul_eq_div_normSq, div_pow]
      ring
    _ â‰¤ 16 := by rw [â† mul_pow]; linarith","warning:  fd does not have a doc string
warning:  fdo does not have a doc string
error:  unexpected token ';'; expected '|'
error:  unsolved goals
g : SL(2, â„¤)
z : â„
hz : z âˆˆ ğ’Ÿáµ’
hg : g â€¢ z âˆˆ ğ’Ÿáµ’
c' : â„¤ := â†‘g 1 0
c : â„ := â†‘c'
this : c' ^ 2 â‰¤ 1 ^ 2
âŠ¢ |â†‘g 1 0| â‰¤ 1
error:  unsolved goals
g : SL(2, â„¤)
z : â„
hz : z âˆˆ ğ’Ÿáµ’
hg : g â€¢ z âˆˆ ğ’Ÿáµ’
c' : â„¤ := â†‘g 1 0
c : â„ := â†‘c'
âŠ¢ 3 * c ^ 2 < 4",theorem abs_c_le_one (hz : z âˆˆ ğ’Ÿáµ’) (hg : g â€¢ z âˆˆ ğ’Ÿáµ’) : |(â†‘â‚˜g) 1 0| â‰¤ 1 ,":= by
  let c' : â„¤ := (â†‘â‚˜g) 1 0
  let c : â„ := (c' : â„)
  suffices 3 * c ^ 2 < 4 by
    rw [â† Int.cast_pow, â† Int.cast_three, â† Int.cast_four, â† Int.cast_mul, Int.cast_lt] at this
    replace this : c' ^ 2 â‰¤ 1 ^ 2 := by linarith
    rwa [sq_le_sq, abs_one] at this
  suffices c â‰  0 â†’ 9 * c ^ 4 < 16 by
    rcases eq_or_ne c 0 with (hc | hc)
    Â· rw [hc]; norm_num
    Â· refine (abs_lt_of_sq_lt_sq' ?_ (by norm_num)).2
      specialize this hc
      linarith
  intro hc
  replace hc : 0 < c ^ 4 := by
    change 0 < c ^ (2 * 2); rw [pow_mul]; apply sq_pos_of_pos (sq_pos_of_ne_zero hc)
  have hâ‚ :=
    mul_lt_mul_of_pos_right
      (mul_lt_mul'' (three_lt_four_mul_im_sq_of_mem_fdo hg) (three_lt_four_mul_im_sq_of_mem_fdo hz)
        (by linarith) (by linarith))
      hc
  have hâ‚‚ : (c * z.im) ^ 4 / normSq (denom (â†‘g) z) ^ 2 â‰¤ 1 :=
    div_le_one_of_le
      (pow_four_le_pow_two_of_pow_two_le (UpperHalfPlane.c_mul_im_sq_le_normSq_denom z g))
      (sq_nonneg _)
  let nsq := normSq (denom g z)
  calc
    9 * c ^ 4 < c ^ 4 * z.im ^ 2 * (g â€¢ z).im ^ 2 * 16 := by linarith
    _ = c ^ 4 * z.im ^ 4 / nsq ^ 2 * 16 := by
      rw [ModularGroup.im_smul_eq_div_normSq, div_pow]
      ring
    _ â‰¤ 16 := by rw [â† mul_pow]; linarith"
Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/Basic.lean,quadraticChar_sq_one',quadraticChar_sq_one',8e31b5ac6bed8ba535a30f3442252684d2f151c1,":= by
  simp only [quadraticCharFun, ha, pow_eq_zero_iff, Nat.succ_pos', IsSquare_sq, if_true, if_false,
    quadraticChar_apply]","error:  unsolved goals
F : Type u_1
instâœÂ² : Field F
instâœÂ¹ : Fintype F
instâœ : DecidableEq F
a : F
ha : a â‰  0
âŠ¢ (if a ^ 2 = 0 then 0 else 1) = 1
warning:  `MulChar.IsNontrivial` has been deprecated
warning:  `MulChar.isNontrivial_iff` has been deprecated",theorem quadraticChar_sq_one' {a : F} (ha : a â‰  0) : quadraticChar F (a ^ 2) = 1 ,":= by
  simp only [quadraticChar_apply, quadraticCharFun, sq_eq_zero_iff, ha, IsSquare_sq, if_true,
    if_false]"
Mathlib/Topology/FiberBundle/Basic.lean,FiberBundle.exists_trivialization_Icc_subset,FiberBundle.exists_trivialization_Icc_subset,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain âŸ¨ea, heaâŸ© : âˆƒ ea : Trivialization F (Ï€ F E), a âˆˆ ea.baseSet :=
    âŸ¨trivializationAt F E a, mem_baseSet_trivializationAt F E aâŸ©
  cases' lt_or_le b a with hab hab
  Â· exact âŸ¨ea, by simp [*]âŸ©
  set s : Set B := { x âˆˆ Icc a b | âˆƒ e : Trivialization F (Ï€ F E), Icc a x âŠ† e.baseSet }
  have ha : a âˆˆ s := âŸ¨left_mem_Icc.2 hab, ea, by simp [hea]âŸ©
  have sne : s.Nonempty := âŸ¨a, haâŸ©
  have hsb : b âˆˆ upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := âŸ¨b, hsbâŸ©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c âˆˆ Icc a b := âŸ¨hsc.1 ha, hsc.2 hsbâŸ©
  obtain âŸ¨-, ec : Trivialization F (Ï€ F E), hec : Icc a c âŠ† ec.baseSetâŸ© : c âˆˆ s := by
    rcases hc.1.eq_or_lt with heq | hlt
    Â· rwa [â† heq]
    refine âŸ¨hc, ?_âŸ©
    obtain âŸ¨ec, hcâŸ© : âˆƒ ec : Trivialization F (Ï€ F E), c âˆˆ ec.baseSet :=
      âŸ¨trivializationAt F E c, mem_baseSet_trivializationAt F E câŸ©
    obtain âŸ¨c', hc', hc'eâŸ© : âˆƒ c' âˆˆ Ico a c, Ioc c' c âŠ† ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain âŸ¨d, âŸ¨hdab, ead, hadâŸ©, hdâŸ© : âˆƒ d âˆˆ s, d âˆˆ Ioc c' c := hsc.exists_between hc'.2
    refine' âŸ¨ead.piecewiseLe ec d (had âŸ¨hdab.1, le_rflâŸ©) (hc'e hd), subset_ite.2 _âŸ©
    exact âŸ¨fun x hx => had âŸ¨hx.1.1, hx.2âŸ©, fun x hx => hc'e âŸ¨hd.1.trans (not_le.1 hx.2), hx.1.2âŸ©âŸ©
  rcases hc.2.eq_or_lt with heq | hlt
  Â· exact âŸ¨ec, heq â–¸ hecâŸ©
  rsuffices âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, âˆƒ e : Trivialization F (Ï€ F E), Icc a d âŠ† e.baseSet
  Â· exact ((hsc.1 âŸ¨âŸ¨hc.1.trans hdcb.1.le, hdcb.2âŸ©, hdâŸ©).not_lt hdcb.1).elim
  obtain âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, Ico c d âŠ† ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec âŸ¨hc.1, le_rflâŸ©))
  have had : Ico a d âŠ† ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  Â· obtain âŸ¨ed, hedâŸ© : âˆƒ ed : Trivialization F (Ï€ F E), d âˆˆ ed.baseSet :=
      âŸ¨trivializationAt F E d, mem_baseSet_trivializationAt F E dâŸ©
    refine' âŸ¨d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono (inter_subset_right _ _) (inter_subset_right _ _)), fun x hx => _âŸ©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr âŸ¨hed, hdcb.1âŸ©, Or.inl âŸ¨had âŸ¨hx.1, hxdâŸ©, hxdâŸ©]
  Â· rw [disjoint_left] at he
    push_neg at he
    rcases he with âŸ¨d', hdd' : d' < d, hd'câŸ©
    exact âŸ¨d', âŸ¨hd'c, hdd'.le.trans hdcb.2âŸ©, ec, (Icc_subset_Ico_right hdd').trans hadâŸ©","error:  function expected at
  inter_subset_right ?m.16125
term has type
  ?m.16124 âˆˆ ?m.16123
error:  function expected at
  inter_subset_right ?m.16167
term has type
  ?m.16166 âˆˆ ?m.16165","theorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]
    [OrderTopology B] [FiberBundle F E] (a b : B) :
    âˆƒ e : Trivialization F (Ï€ F E), Icc a b âŠ† e.baseSet ",":= by
  obtain âŸ¨ea, heaâŸ© : âˆƒ ea : Trivialization F (Ï€ F E), a âˆˆ ea.baseSet :=
    âŸ¨trivializationAt F E a, mem_baseSet_trivializationAt F E aâŸ©
  cases' lt_or_le b a with hab hab
  Â· exact âŸ¨ea, by simp [*]âŸ©
  set s : Set B := { x âˆˆ Icc a b | âˆƒ e : Trivialization F (Ï€ F E), Icc a x âŠ† e.baseSet }
  have ha : a âˆˆ s := âŸ¨left_mem_Icc.2 hab, ea, by simp [hea]âŸ©
  have sne : s.Nonempty := âŸ¨a, haâŸ©
  have hsb : b âˆˆ upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := âŸ¨b, hsbâŸ©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c âˆˆ Icc a b := âŸ¨hsc.1 ha, hsc.2 hsbâŸ©
  obtain âŸ¨-, ec : Trivialization F (Ï€ F E), hec : Icc a c âŠ† ec.baseSetâŸ© : c âˆˆ s := by
    rcases hc.1.eq_or_lt with heq | hlt
    Â· rwa [â† heq]
    refine âŸ¨hc, ?_âŸ©
    obtain âŸ¨ec, hcâŸ© : âˆƒ ec : Trivialization F (Ï€ F E), c âˆˆ ec.baseSet :=
      âŸ¨trivializationAt F E c, mem_baseSet_trivializationAt F E câŸ©
    obtain âŸ¨c', hc', hc'eâŸ© : âˆƒ c' âˆˆ Ico a c, Ioc c' c âŠ† ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain âŸ¨d, âŸ¨hdab, ead, hadâŸ©, hdâŸ© : âˆƒ d âˆˆ s, d âˆˆ Ioc c' c := hsc.exists_between hc'.2
    refine âŸ¨ead.piecewiseLe ec d (had âŸ¨hdab.1, le_rflâŸ©) (hc'e hd), subset_ite.2 ?_âŸ©
    exact âŸ¨fun x hx => had âŸ¨hx.1.1, hx.2âŸ©, fun x hx => hc'e âŸ¨hd.1.trans (not_le.1 hx.2), hx.1.2âŸ©âŸ©
  rcases hc.2.eq_or_lt with heq | hlt
  Â· exact âŸ¨ec, heq â–¸ hecâŸ©
  rsuffices âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, âˆƒ e : Trivialization F (Ï€ F E), Icc a d âŠ† e.baseSet
  Â· exact ((hsc.1 âŸ¨âŸ¨hc.1.trans hdcb.1.le, hdcb.2âŸ©, hdâŸ©).not_lt hdcb.1).elim
  obtain âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, Ico c d âŠ† ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec âŸ¨hc.1, le_rflâŸ©))
  have had : Ico a d âŠ† ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  Â· obtain âŸ¨ed, hedâŸ© : âˆƒ ed : Trivialization F (Ï€ F E), d âˆˆ ed.baseSet :=
      âŸ¨trivializationAt F E d, mem_baseSet_trivializationAt F E dâŸ©
    refine âŸ¨d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono inter_subset_right inter_subset_right), fun x hx => ?_âŸ©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr âŸ¨hed, hdcb.1âŸ©, Or.inl âŸ¨had âŸ¨hx.1, hxdâŸ©, hxdâŸ©]
  Â· rw [disjoint_left] at he
    push_neg at he
    rcases he with âŸ¨d', hdd' : d' < d, hd'câŸ©
    exact âŸ¨d', âŸ¨hd'c, hdd'.le.trans hdcb.2âŸ©, ec, (Icc_subset_Ico_right hdd').trans hadâŸ©"
Mathlib/LinearAlgebra/Reflection.lean,Module.Dual.eq_of_preReflection_mapsTo,Dual.eq_of_preReflection_mapsTo,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  let u := reflection hgâ‚ * reflection hfâ‚
  have hu : u = LinearMap.id (R := R) (M := M) + (f - g).smulRight x := by
    ext y
    simp only [u, reflection_apply, hgâ‚, two_smul, LinearEquiv.coe_toLinearMap_mul,
      LinearMap.id_coe, LinearEquiv.coe_coe, LinearMap.mul_apply, LinearMap.add_apply, id_eq,
      LinearMap.coe_smulRight, LinearMap.sub_apply, map_sub, map_smul, sub_add_cancel_left,
      smul_neg, sub_neg_eq_add, sub_smul]
    abel
  replace hu : âˆ€ (n : â„•),
      â†‘(u ^ n) = LinearMap.id (R := R) (M := M) + (n : R) â€¢ (f - g).smulRight x := by
    intros n
    induction' n with n ih; simp
    have : ((f - g).smulRight x).comp ((n : R) â€¢ (f - g).smulRight x) = 0 := by ext; simp [hfâ‚, hgâ‚]
    rw [pow_succ, LinearEquiv.coe_toLinearMap_mul, ih, hu, add_mul, mul_add, mul_add]
    simp_rw [LinearMap.mul_eq_comp, LinearMap.comp_id, LinearMap.id_comp, this, add_zero, add_assoc,
      Nat.cast_succ, add_smul, one_smul]
  suffices IsOfFinOrder u by
    obtain âŸ¨n, hnâ‚€, hnâ‚âŸ© := isOfFinOrder_iff_pow_eq_one.mp this
    replace hnâ‚ : (â†‘(u ^ n) : M â†’â‚—[R] M) = LinearMap.id := LinearEquiv.toLinearMap_inj.mpr hnâ‚
    simpa [hnâ‚, hnâ‚€.ne', hx, sub_eq_zero] using hu n
  exact u.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo hÎ¦â‚ hÎ¦â‚‚ (hgâ‚‚.comp hfâ‚‚)",error:  simp made no progress,"lemma Dual.eq_of_preReflection_mapsTo [CharZero R] [NoZeroSMulDivisors R M]
    {x : M} (hx : x â‰  0) {Î¦ : Set M} (hÎ¦â‚ : Î¦.Finite) (hÎ¦â‚‚ : span R Î¦ = âŠ¤) {f g : Dual R M}
    (hfâ‚ : f x = 2) (hfâ‚‚ : MapsTo (preReflection x f) Î¦ Î¦)
    (hgâ‚ : g x = 2) (hgâ‚‚ : MapsTo (preReflection x g) Î¦ Î¦) :
    f = g ",":= by
  let u := reflection hgâ‚ * reflection hfâ‚
  have hu : u = LinearMap.id (R := R) (M := M) + (f - g).smulRight x := by
    ext y
    simp only [u, reflection_apply, hgâ‚, two_smul, LinearEquiv.coe_toLinearMap_mul,
      LinearMap.id_coe, LinearEquiv.coe_coe, LinearMap.mul_apply, LinearMap.add_apply, id_eq,
      LinearMap.coe_smulRight, LinearMap.sub_apply, map_sub, map_smul, sub_add_cancel_left,
      smul_neg, sub_neg_eq_add, sub_smul]
    abel
  replace hu : âˆ€ (n : â„•),
      â†‘(u ^ n) = LinearMap.id (R := R) (M := M) + (n : R) â€¢ (f - g).smulRight x := by
    intros n
    induction n with
    | zero => simp
    | succ n ih =>
      have : ((f - g).smulRight x).comp ((n : R) â€¢ (f - g).smulRight x) = 0 := by
        ext; simp [hfâ‚, hgâ‚]
      rw [pow_succ', LinearEquiv.coe_toLinearMap_mul, ih, hu, add_mul, mul_add, mul_add]
      simp_rw [LinearMap.mul_eq_comp, LinearMap.comp_id, LinearMap.id_comp, this, add_zero,
        add_assoc, Nat.cast_succ, add_smul, one_smul]
  suffices IsOfFinOrder u by
    obtain âŸ¨n, hnâ‚€, hnâ‚âŸ© := isOfFinOrder_iff_pow_eq_one.mp this
    replace hnâ‚ : (â†‘(u ^ n) : M â†’â‚—[R] M) = LinearMap.id := LinearEquiv.toLinearMap_inj.mpr hnâ‚
    simpa [hnâ‚, hnâ‚€.ne', hx, sub_eq_zero] using hu n
  exact u.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo hÎ¦â‚ hÎ¦â‚‚ (hgâ‚‚.comp hfâ‚‚)"
Mathlib/Combinatorics/Additive/PluenneckeRuzsa.lean,Finset.mul_pluennecke_petridis,mul_pluennecke_petridis,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' C with x C _ ih
  Â· simp
  set A' := A âˆ© (A * C / {x}) with hA'
  set C' := insert x C with hC'
  have hâ‚€ : A' * {x} = A * {x} âˆ© (A * C) := by
    rw [hA', inter_mul_singleton, (isUnit_singleton x).div_mul_cancel]
  have hâ‚ : A * B * C' = A * B * C âˆª (A * B * {x}) \ (A' * B * {x}) := by
    rw [hC', insert_eq, union_comm, mul_union]
    refine (sup_sdiff_eq_sup ?_).symm
    rw [mul_right_comm, mul_right_comm A, hâ‚€]
    exact mul_subset_mul_right inter_subset_right
  have hâ‚‚ : A' * B * {x} âŠ† A * B * {x} :=
    mul_subset_mul_right (mul_subset_mul_right inter_subset_left)
  have hâ‚ƒ : (A * B * C').card â‰¤ (A * B * C).card + (A * B).card - (A' * B).card := by
    rw [hâ‚]
    refine (card_union_le _ _).trans_eq ?_
    rw [card_sdiff hâ‚‚, â† add_tsub_assoc_of_le (card_le_card hâ‚‚), card_mul_singleton,
      card_mul_singleton]
  refine (mul_le_mul_right' hâ‚ƒ _).trans ?_
  rw [tsub_mul, add_mul]
  refine (tsub_le_tsub (add_le_add_right ih _) <| hA _ inter_subset_left).trans_eq ?_
  rw [â† mul_add, â† mul_tsub, â† hA', hC', insert_eq, mul_union, â† card_mul_singleton A x, â†
    card_mul_singleton A' x, add_comm (card _), hâ‚€,
    eq_tsub_of_add_eq (card_union_add_card_inter _ _)]","error:  simp made no progress
error:  no goals to be solved","theorem mul_pluennecke_petridis (C : Finset Î±)
    (hA : âˆ€ A' âŠ† A, (A * B).card * A'.card â‰¤ (A' * B).card * A.card) :
    (A * B * C).card * A.card â‰¤ (A * B).card * (A * C).card ",":= by
  induction' C using Finset.induction_on with x C _ ih
  Â· simp
  set A' := A âˆ© (A * C / {x}) with hA'
  set C' := insert x C with hC'
  have hâ‚€ : A' * {x} = A * {x} âˆ© (A * C) := by
    rw [hA', inter_mul_singleton, (isUnit_singleton x).div_mul_cancel]
  have hâ‚ : A * B * C' = A * B * C âˆª (A * B * {x}) \ (A' * B * {x}) := by
    rw [hC', insert_eq, union_comm, mul_union]
    refine (sup_sdiff_eq_sup ?_).symm
    rw [mul_right_comm, mul_right_comm A, hâ‚€]
    exact mul_subset_mul_right inter_subset_right
  have hâ‚‚ : A' * B * {x} âŠ† A * B * {x} :=
    mul_subset_mul_right (mul_subset_mul_right inter_subset_left)
  have hâ‚ƒ : (A * B * C').card â‰¤ (A * B * C).card + (A * B).card - (A' * B).card := by
    rw [hâ‚]
    refine (card_union_le _ _).trans_eq ?_
    rw [card_sdiff hâ‚‚, â† add_tsub_assoc_of_le (card_le_card hâ‚‚), card_mul_singleton,
      card_mul_singleton]
  refine (mul_le_mul_right' hâ‚ƒ _).trans ?_
  rw [tsub_mul, add_mul]
  refine (tsub_le_tsub (add_le_add_right ih _) <| hA _ inter_subset_left).trans_eq ?_
  rw [â† mul_add, â† mul_tsub, â† hA', hC', insert_eq, mul_union, â† card_mul_singleton A x, â†
    card_mul_singleton A' x, add_comm (card _), hâ‚€,
    eq_tsub_of_add_eq (card_union_add_card_inter _ _)]"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,6861d9247d1a06a093e444c3a0319e5ec45263c2,":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine' âŸ¨[], rfl.le, show Ï† = 1 from _âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      apply reflection_mem_subspace_eq_self
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      omega
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine' âŸ¨x::l, Nat.succ_le_succ hl, _âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâµ : _root_.RCLike ğ•œ
instâœâ´ : NormedAddCommGroup E
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : InnerProductSpace ğ•œ E
instâœÂ¹ : InnerProductSpace â„ F
K : Submodule ğ•œ E
instâœ : FiniteDimensional â„ F
Ï† : F â‰ƒâ‚—áµ¢[â„] F
hn :
  finrank â„
      â†¥(LinearMap.ker
            (ContinuousLinearMap.id â„ F -
              â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }))á—® â‰¤
    0
âŠ¢ LinearMap.ker
      (ContinuousLinearMap.id â„ F -
        â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }) =
    âŠ¤","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional â„ F] {n : â„•}
    (Ï† : F â‰ƒâ‚—áµ¢[â„] F) (hn : finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—® â‰¤ n) :
    âˆƒ l : List F, l.length â‰¤ n âˆ§ Ï† = (l.map fun v => reflection (â„ âˆ™ v)á—®).prod ",":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine âŸ¨[], rfl.le, show Ï† = 1 from ?_âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      omega
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine âŸ¨x::l, Nat.succ_le_succ hl, ?_âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this"
Mathlib/Probability/Kernel/Disintegration/CondCdf.lean,ProbabilityTheory.isRatCondKernelCDFAux_preCDF,isRatCondKernelCDFAux_preCDF,9ad07e7ddb192ef9ee24f6a4ed6bbb71d10b50b9,"  measurable := measurable_preCDF'.comp measurable_snd
  mono' a r r' hrr' := by
    filter_upwards [monotone_preCDF Ï, preCDF_le_one Ï] with a h1 h2
    have h_ne_top : âˆ€ r, preCDF Ï r a â‰  âˆ := fun r â†¦ ((h2 r).trans_lt ENNReal.one_lt_top).ne
    rw [ENNReal.toReal_le_toReal (h_ne_top _) (h_ne_top _)]
    exact h1 hrr'
  nonneg' _ q := by simp
  le_one' a q := by
    simp only [kernel.const_apply, forall_const]
    filter_upwards [preCDF_le_one Ï] with a ha
    refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_
    simp [ha]
  tendsto_integral_of_antitone a s _ hs_tendsto := by
    simp_rw [kernel.const_apply, integral_preCDF_fst Ï]
    have h := Ï.tendsto_IicSnd_atBot MeasurableSet.univ
    rw [â† ENNReal.zero_toReal]
    have h0 : Tendsto ENNReal.toReal (ğ“ 0) (ğ“ 0) :=
      ENNReal.continuousAt_toReal ENNReal.zero_ne_top
    exact h0.comp (h.comp hs_tendsto)
  tendsto_integral_of_monotone a s _ hs_tendsto := by
    simp_rw [kernel.const_apply, integral_preCDF_fst Ï]
    have h := Ï.tendsto_IicSnd_atTop MeasurableSet.univ
    have h0 : Tendsto ENNReal.toReal (ğ“ (Ï.fst univ)) (ğ“ (Ï.fst univ).toReal) :=
      ENNReal.continuousAt_toReal (measure_ne_top _ _)
    exact h0.comp (h.comp hs_tendsto)
  integrable _ q := integrable_preCDF Ï q
  set_integral a s hs q := by rw [kernel.const_apply, kernel.const_apply,
    set_integral_preCDF_fst _ _ hs, Measure.IicSnd_apply _ _ hs]",error:  'set_integral' is not a field of structure 'ProbabilityTheory.IsRatCondKernelCDFAux',"lemma isRatCondKernelCDFAux_preCDF (Ï : Measure (Î± Ã— â„)) [IsFiniteMeasure Ï] :
    IsRatCondKernelCDFAux (fun p r â†¦ (preCDF Ï r p.2).toReal)
      (kernel.const Unit Ï) (kernel.const Unit Ï.fst) where
","  measurable := measurable_preCDF'.comp measurable_snd
  mono' a r r' hrr' := by
    filter_upwards [monotone_preCDF Ï, preCDF_le_one Ï] with a h1 h2
    have h_ne_top : âˆ€ r, preCDF Ï r a â‰  âˆ := fun r â†¦ ((h2 r).trans_lt ENNReal.one_lt_top).ne
    rw [ENNReal.toReal_le_toReal (h_ne_top _) (h_ne_top _)]
    exact h1 hrr'
  nonneg' _ q := by simp
  le_one' a q := by
    simp only [kernel.const_apply, forall_const]
    filter_upwards [preCDF_le_one Ï] with a ha
    refine ENNReal.toReal_le_of_le_ofReal zero_le_one ?_
    simp [ha]
  tendsto_integral_of_antitone a s _ hs_tendsto := by
    simp_rw [kernel.const_apply, integral_preCDF_fst Ï]
    have h := Ï.tendsto_IicSnd_atBot MeasurableSet.univ
    rw [â† ENNReal.zero_toReal]
    have h0 : Tendsto ENNReal.toReal (ğ“ 0) (ğ“ 0) :=
      ENNReal.continuousAt_toReal ENNReal.zero_ne_top
    exact h0.comp (h.comp hs_tendsto)
  tendsto_integral_of_monotone a s _ hs_tendsto := by
    simp_rw [kernel.const_apply, integral_preCDF_fst Ï]
    have h := Ï.tendsto_IicSnd_atTop MeasurableSet.univ
    have h0 : Tendsto ENNReal.toReal (ğ“ (Ï.fst univ)) (ğ“ (Ï.fst univ).toReal) :=
      ENNReal.continuousAt_toReal (measure_ne_top _ _)
    exact h0.comp (h.comp hs_tendsto)
  integrable _ q := integrable_preCDF Ï q
  setIntegral a s hs q := by rw [kernel.const_apply, kernel.const_apply,
    setIntegral_preCDF_fst _ _ hs, Measure.IicSnd_apply _ _ hs]"
Mathlib/MeasureTheory/Measure/Count.lean,MeasureTheory.Measure.count_injective_image,count_injective_image,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  by_cases hs : s.Finite
  Â· lift s to Finset Î² using hs
    rw [â† Finset.coe_image, count_apply_finset' _, count_apply_finset' s_mble,
      s.card_image_of_injective hf]
    simpa only [Finset.coe_image] using fs_mble
  Â· rw [count_apply_infinite hs]
    rw [â† finite_image_iff <| hf.injOn _] at hs
    rw [count_apply_infinite hs]","error:  application type mismatch
  finite_image_iff (Function.Injective.injOn hf ?m.26655)
argument
  Function.Injective.injOn hf ?m.26655
has type
  âˆ€ â¦ƒxâ‚‚ : Î²â¦„, xâ‚‚ âˆˆ ?m.26653 â†’ f ?m.26654 = f xâ‚‚ â†’ ?m.26654 = xâ‚‚ : Prop
but is expected to have type
  InjOn ?m.26636 ?m.26635 : Prop","theorem count_injective_image' {f : Î² â†’ Î±} (hf : Function.Injective f) {s : Set Î²}
    (s_mble : MeasurableSet s) (fs_mble : MeasurableSet (f '' s)) : count (f '' s) = count s ",":= by
  by_cases hs : s.Finite
  Â· lift s to Finset Î² using hs
    rw [â† Finset.coe_image, count_apply_finset' _, count_apply_finset' s_mble,
      s.card_image_of_injective hf]
    simpa only [Finset.coe_image] using fs_mble
  Â· rw [count_apply_infinite hs]
    rw [â† finite_image_iff hf.injOn] at hs
    rw [count_apply_infinite hs]"
Mathlib/NumberTheory/ClassNumber/Finite.lean,ClassGroup.exists_mem_finsetApprox,exists_mem_finsetApprox,22e97510854d6906cc856e022d297bf9cf8c9b3a,":= by
  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty
  set Îµ : â„ := normBound abv bS ^ (-1 / Fintype.card Î¹ : â„) with Îµ_eq
  have hÎµ : 0 < Îµ := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _
  have Îµ_le : (normBound abv bS : â„) * (abv b â€¢ Îµ) ^ Fintype.card Î¹ â‰¤ abv b ^ Fintype.card Î¹ := by
    have := normBound_pos abv bS
    have := abv.nonneg b
    rw [Îµ_eq, Algebra.smul_def, eq_intCast, mul_rpow, â† rpow_mul, div_mul_cancel, rpow_neg_one,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_nat_cast] <;>
      try norm_cast; linarith
    Â· exact Iff.mpr Int.cast_nonneg this
    Â· linarith
  set Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm with hÎ¼
  let s : Î¹ â†’â‚€ R := bS.repr a
  have s_eq : âˆ€ i, s i = bS.repr a i := fun i => rfl
  let qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i / b
  let rs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i % b
  have r_eq : âˆ€ j i, rs j i = Î¼ j * s i % b := fun i j => rfl
  have Î¼_eq : âˆ€ i j, Î¼ j * s i = b * qs j i + rs j i := by
    intro i j
    rw [r_eq, EuclideanDomain.div_add_mod]
  have Î¼_mul_a_eq : âˆ€ j, Î¼ j â€¢ a = b â€¢ âˆ‘ i, qs j i â€¢ bS i + âˆ‘ i, rs j i â€¢ bS i := by
    intro j
    rw [â† bS.sum_repr a]
    simp only [Finset.smul_sum, â† Finset.sum_add_distrib]
    refine'
      Finset.sum_congr rfl fun i _ => _
    rw [â† hÎ¼, â† r_eq, â† s_eq, â† mul_smul, Î¼_eq, add_smul, mul_smul, â† Î¼_eq]
  obtain âŸ¨j, k, j_ne_k, hjkâŸ© := adm.exists_approx hÎµ hb fun j i => Î¼ j * s i
  have hjk' : âˆ€ i, (abv (rs k i - rs j i) : â„) < abv b â€¢ Îµ := by simpa only [r_eq] using hjk
  let q := âˆ‘ i, (qs k i - qs j i) â€¢ bS i
  set r := Î¼ k - Î¼ j with r_eq
  refine' âŸ¨q, r, (mem_finsetApprox bS adm).mpr _, _âŸ©
  Â· exact âŸ¨k, j, j_ne_k.symm, rflâŸ©
  have : r â€¢ a - b â€¢ q = âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) := by
    simp only [r_eq, sub_smul, Î¼_mul_a_eq, Finset.smul_sum, â† Finset.sum_add_distrib,
      â† Finset.sum_sub_distrib, smul_sub]
    refine' Finset.sum_congr rfl fun x _ => _
    ring
  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]
  refine' Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt _ (hjk' i)).trans_le _)
  Â· apply le_of_eq
    congr
    simp_rw [map_sum, LinearEquiv.map_sub, LinearEquiv.map_smul, Finset.sum_apply',
      Finsupp.sub_apply, Finsupp.smul_apply, Finset.sum_sub_distrib, Basis.repr_self_apply,
      smul_eq_mul, mul_boole, Finset.sum_ite_eq', Finset.mem_univ, if_true]
  Â· exact mod_cast Îµ_le","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?m.172686 * ?m.172687) ^ ?m.172688
R : Type u_1
S : Type u_2
K : Type u_3
L : Type u_4
instâœÂ¹â¶ : EuclideanDomain R
instâœÂ¹âµ : CommRing S
instâœÂ¹â´ : IsDomain S
instâœÂ¹Â³ : Field K
instâœÂ¹Â² : Field L
instâœÂ¹Â¹ : Algebra R K
instâœÂ¹â° : IsFractionRing R K
instâœâ¹ : Algebra K L
instâœâ¸ : FiniteDimensional K L
instâœâ· : IsSeparable K L
algRL : Algebra R L
instâœâ¶ : IsScalarTower R K L
instâœâµ : Algebra R S
instâœâ´ : Algebra S L
ist : IsScalarTower R S L
iic : IsIntegralClosure S R L
abv : AbsoluteValue R â„¤
Î¹ : Type u_5
instâœÂ³ : DecidableEq Î¹
instâœÂ² : Fintype Î¹
bS : Basis Î¹ R S
adm : abv.IsAdmissible
instâœÂ¹ : Infinite R
instâœ : DecidableEq R
a : S
b : R
hb : b â‰  0
dim_pos : 0 < Fintype.card Î¹
Îµ : â„ := â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))
Îµ_eq : Îµ = â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))
hÎµ : 0 < Îµ
thisâœ : 0 < normBound abv bS
this : 0 â‰¤ abv b
âŠ¢ â†‘(normBound abv bS) * (â†‘(abv b) * â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))) ^ Fintype.card Î¹ â‰¤
    â†‘(abv b) ^ Fintype.card Î¹
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  distinctElems bS adm
R : Type u_1
S : Type u_2
K : Type u_3
L : Type u_4
instâœÂ¹â¶ : EuclideanDomain R
instâœÂ¹âµ : CommRing S
instâœÂ¹â´ : IsDomain S
instâœÂ¹Â³ : Field K
instâœÂ¹Â² : Field L
instâœÂ¹Â¹ : Algebra R K
instâœÂ¹â° : IsFractionRing R K
instâœâ¹ : Algebra K L
instâœâ¸ : FiniteDimensional K L
instâœâ· : IsSeparable K L
algRL : Algebra R L
instâœâ¶ : IsScalarTower R K L
instâœâµ : Algebra R S
instâœâ´ : Algebra S L
ist : IsScalarTower R S L
iic : IsIntegralClosure S R L
abv : AbsoluteValue R â„¤
Î¹ : Type u_5
instâœÂ³ : DecidableEq Î¹
instâœÂ² : Fintype Î¹
bS : Basis Î¹ R S
adm : abv.IsAdmissible
instâœÂ¹ : Infinite R
instâœ : DecidableEq R
a : S
b : R
hb : b â‰  0
dim_pos : 0 < Fintype.card Î¹
Îµ : â„ := â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))
Îµ_eq : Îµ = â†‘(normBound abv bS) ^ (-1 / â†‘(Fintype.card Î¹))
hÎµ : 0 < Îµ
Îµ_le : â†‘(normBound abv bS) * (abv b â€¢ Îµ) ^ Fintype.card Î¹ â‰¤ â†‘(abv b) ^ Fintype.card Î¹
Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm
hÎ¼ : Î¼ = distinctElems bS adm
s : Î¹ â†’â‚€ R := bS.repr a
s_eq : âˆ€ (i : Î¹), s i = (bS.repr a) i
qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i â†¦ Î¼ j * s i / b
rs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i â†¦ Î¼ j * s i % b
r_eq : âˆ€ (j : Fin (cardM bS adm).succ) (i : Î¹), rs j i = Î¼ j * s i % b
Î¼_eq : âˆ€ (i : Î¹) (j : Fin (cardM bS adm).succ), Î¼ j * s i = b * qs j i + rs j i
j : Fin (cardM bS adm).succ
i : Î¹
xâœ : i âˆˆ Finset.univ
âŠ¢ Î¼ j â€¢ (bS.repr a) i â€¢ bS i = b â€¢ qs j i â€¢ bS i + rs j i â€¢ bS i
error:  type mismatch
  Finset.sum_congr rfl fun x x_1 â†¦ ?m.187579 x x_1
has type
  ?m.187475.sum ?m.187376 = ?m.187475.sum ?m.187377 : Prop
but is expected to have type
  âˆ‘ x : Î¹, (b â€¢ qs k x â€¢ bS x + rs k x â€¢ bS x - (b â€¢ qs j x â€¢ bS x + rs j x â€¢ bS x)) - b â€¢ q =
    âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearEquiv
has type
  (Ïƒ : ?m.194819 â†’+* ?m.194820) â†’
    {Ïƒ' : ?m.194820 â†’+* ?m.194819} â†’
      [inst : RingHomInvPair Ïƒ Ïƒ'] â†’
        [inst : RingHomInvPair Ïƒ' Ïƒ] â†’
          (M : Type ?u.194816) â†’
            (Mâ‚‚ : Type ?u.194815) â†’
              [inst : AddCommMonoid M] â†’
                [inst_1 : AddCommMonoid Mâ‚‚] â†’
                  [inst : Module ?m.194819 M] â†’ [inst : Module ?m.194820 Mâ‚‚] â†’ Type (max ?u.194816 ?u.194815)
error:  simp made no progress","theorem exists_mem_finsetApprox (a : S) {b} (hb : b â‰  (0 : R)) :
    âˆƒ q : S,
      âˆƒ r âˆˆ finsetApprox bS adm, abv (Algebra.norm R (r â€¢ a - b â€¢ q)) <
      abv (Algebra.norm R (algebraMap R S b)) ",":= by
  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty
  set Îµ : â„ := normBound abv bS ^ (-1 / Fintype.card Î¹ : â„) with Îµ_eq
  have hÎµ : 0 < Îµ := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _
  have Îµ_le : (normBound abv bS : â„) * (abv b â€¢ Îµ) ^ (Fintype.card Î¹ : â„)
                â‰¤ abv b ^ (Fintype.card Î¹ : â„) := by
    have := normBound_pos abv bS
    have := abv.nonneg b
    rw [Îµ_eq, Algebra.smul_def, eq_intCast, mul_rpow, â† rpow_mul, div_mul_cancelâ‚€, rpow_neg_one,
      mul_left_comm, mul_inv_cancel, mul_one, rpow_natCast] <;>
      try norm_cast; omega
    Â· exact Iff.mpr Int.cast_nonneg this
    Â· linarith
  set Î¼ : Fin (cardM bS adm).succ â†ª R := distinctElems bS adm with hÎ¼
  let s : Î¹ â†’â‚€ R := bS.repr a
  have s_eq : âˆ€ i, s i = bS.repr a i := fun i => rfl
  let qs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i / b
  let rs : Fin (cardM bS adm).succ â†’ Î¹ â†’ R := fun j i => Î¼ j * s i % b
  have r_eq : âˆ€ j i, rs j i = Î¼ j * s i % b := fun i j => rfl
  have Î¼_eq : âˆ€ i j, Î¼ j * s i = b * qs j i + rs j i := by
    intro i j
    rw [r_eq, EuclideanDomain.div_add_mod]
  have Î¼_mul_a_eq : âˆ€ j, Î¼ j â€¢ a = b â€¢ âˆ‘ i, qs j i â€¢ bS i + âˆ‘ i, rs j i â€¢ bS i := by
    intro j
    rw [â† bS.sum_repr a]
    simp only [Î¼, qs, rs, Finset.smul_sum, â† Finset.sum_add_distrib]
    refine Finset.sum_congr rfl fun i _ => ?_
    rw [â† hÎ¼, â† r_eq, â† s_eq, â† mul_smul, Î¼_eq, add_smul, mul_smul, â† Î¼_eq]
  obtain âŸ¨j, k, j_ne_k, hjkâŸ© := adm.exists_approx hÎµ hb fun j i => Î¼ j * s i
  have hjk' : âˆ€ i, (abv (rs k i - rs j i) : â„) < abv b â€¢ Îµ := by simpa only [r_eq] using hjk
  let q := âˆ‘ i, (qs k i - qs j i) â€¢ bS i
  set r := Î¼ k - Î¼ j with r_eq
  refine âŸ¨q, r, (mem_finsetApprox bS adm).mpr ?_, ?_âŸ©
  Â· exact âŸ¨k, j, j_ne_k.symm, rflâŸ©
  have : r â€¢ a - b â€¢ q = âˆ‘ x : Î¹, (rs k x â€¢ bS x - rs j x â€¢ bS x) := by
    simp only [q, r_eq, sub_smul, Î¼_mul_a_eq, Finset.smul_sum, â† Finset.sum_add_distrib,
      â† Finset.sum_sub_distrib, smul_sub]
    refine Finset.sum_congr rfl fun x _ => ?_
    ring
  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]
  refine Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt ?_ (hjk' i)).trans_le ?_)
  Â· apply le_of_eq
    congr
    simp_rw [map_sum, map_sub, map_smul, Finset.sum_apply',
      Finsupp.sub_apply, Finsupp.smul_apply, Finset.sum_sub_distrib, Basis.repr_self_apply,
      smul_eq_mul, mul_boole, Finset.sum_ite_eq', Finset.mem_univ, if_true]
  Â· exact mod_cast Îµ_le"
Mathlib/GroupTheory/QuotientGroup.lean,QuotientGroup.monoidHom_ext,monoidHom_ext,c025360553cb8b1abdde9fd2609b68dd7ba70b64,":=
  MonoidHom.ext fun x => QuotientGroup.induction_on x <| (FunLike.congr_fun h : _)",error:  unknown constant 'FunLike.congr_fun',theorem monoidHom_ext â¦ƒf g : G â§¸ N â†’* Mâ¦„ (h : f.comp (mk' N) = g.comp (mk' N)) : f = g ,":=
  MonoidHom.ext fun x => QuotientGroup.induction_on x <| (DFunLike.congr_fun h : _)"
Mathlib/Algebra/MonoidAlgebra/Basic.lean,AddMonoidAlgebra.nonUnitalAlgHom_ext',nonUnitalAlgHom_ext',848a6055965ceeab03ba2c4d2d0e4e0e9b07c6e6,":=
  nonUnitalAlgHom_ext k <| FunLike.congr_fun h","error:  unknown constant 'FunLike.congr_fun'
warning:  AddMonoidAlgebra does not have a doc string","theorem nonUnitalAlgHom_ext' [DistribMulAction k A] {Ï†â‚ Ï†â‚‚ : MonoidAlgebra k G â†’â‚™â‚[k] A}
    (h : Ï†â‚.toMulHom.comp (ofMagma k G) = Ï†â‚‚.toMulHom.comp (ofMagma k G)) : Ï†â‚ = Ï†â‚‚ ",":=
  nonUnitalAlgHom_ext k <| DFunLike.congr_fun h"
Mathlib/CategoryTheory/Triangulated/Opposite.lean,CategoryTheory.Pretriangulated.Opposite.distinguished_cocone_triangle,distinguished_cocone_triangle,735efeff72ff3980be3345d0b62100871c7a4b3c,":= by
  obtain âŸ¨Z, g, h, HâŸ© := Pretriangulated.distinguished_cocone_triangleâ‚ f.unop
  simp only [mem_distinguishedOp_iff]
  refine' âŸ¨_, g.op, (opShiftFunctorEquivalence C 1).counitIso.inv.app (Opposite.op Z) â‰«
    (shiftFunctor Cáµ’áµ– (1 : â„¤)).map h.op, _âŸ©
  dsimp
  convert H using 2
  dsimp
  rw [Functor.map_comp]
  apply Quiver.Hom.op_inj
  rw [op_comp, op_comp, shift_unop_opShiftFunctorEquivalence_counitIso_inv_app (Opposite.op Z) 1]
  erw [â† (opShiftFunctorEquivalence C 1).unitIso.hom.naturality h.op,
    assoc, Iso.hom_inv_id_app, comp_id]
  rfl","error:  unknown identifier 'mem_distinguishedOp_iff'
error:  simp made no progress","lemma distinguished_cocone_triangle {X Y : Cáµ’áµ–} (f : X âŸ¶ Y) :
    âˆƒ (Z : Cáµ’áµ–) (g : Y âŸ¶ Z) (h : Z âŸ¶ XâŸ¦(1 : â„¤)âŸ§),
      Triangle.mk f g h âˆˆ distinguishedTriangles C ",":= by
  obtain âŸ¨Z, g, h, HâŸ© := Pretriangulated.distinguished_cocone_triangleâ‚ f.unop
  refine âŸ¨_, g.op, (opShiftFunctorEquivalence C 1).counitIso.inv.app (Opposite.op Z) â‰«
    (shiftFunctor Cáµ’áµ– (1 : â„¤)).map h.op, ?_âŸ©
  simp only [mem_distinguishedTriangles_iff]
  refine Pretriangulated.isomorphic_distinguished _ H _ ?_
  exact Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) (by aesop_cat) (by aesop_cat)
    (Quiver.Hom.op_inj (by simp [shift_unop_opShiftFunctorEquivalence_counitIso_inv_app]))"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformly,hasFDerivAt_of_tendstoUniformly,56d6c36569bfa5f38809662c438716c5f84ec909,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  â€–(f' n.1 x - g' x) (n.2 - x)â€– â‰¤ â€–f' n.1 x - g' xâ€– * â€–n.2 - xâ€– : Prop
but is expected to have type
  â€–(f' n.1 x - g' x) (n.2 - x)â€– â‰¤ â€–(Prod.map (fun n â†¦ g' x - f' n x) id n).1â€– * â€–x - n.2â€– : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ğ“ x))
    (hf : âˆ€á¶  n : Î¹ Ã— E in l Ã—Ë¢ ğ“ x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : âˆ€á¶  y in ğ“ x, Tendsto (fun n => f n y) l (ğ“ (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)"
Mathlib/Algebra/Lie/InvariantForm.lean,LieAlgebra.InvariantForm.restrict_nondegenerate,restrict_nondegenerate,aedc373a02a254ef11dfff4b141a5d952eb52cf0,":= by
  rw [LinearMap.BilinForm.restrict_nondegenerate_iff_isCompl_orthogonal hÎ¦_refl]
  exact orthogonal_isCompl_submodule Î¦ hÎ¦_nondeg hÎ¦_inv hÎ¦_refl hL I hI",error:  unknown identifier 'orthogonal_isCompl_submodule',"lemma restrict_nondegenerate (I : LieIdeal K L) (hI : IsAtom I) :
    (Î¦.restrict I).Nondegenerate ",":= by
  rw [LinearMap.BilinForm.restrict_nondegenerate_iff_isCompl_orthogonal hÎ¦_refl]
  exact orthogonal_isCompl_coe_submodule Î¦ hÎ¦_nondeg hÎ¦_inv hÎ¦_refl hL I hI"
Mathlib/Analysis/Calculus/Taylor.lean,taylor_mean_remainder_lagrange,taylor_mean_remainder_lagrange,7d2c51fa2103976446680baf42aa428cea0e7626,":= by
  have gcont : ContinuousOn (fun t : â„ => (x - t) ^ (n + 1)) (Icc xâ‚€ x) := by
    refine' Continuous.continuousOn _
    exact (continuous_const.sub continuous_id').pow _ 
  have xy_ne : âˆ€ y : â„, y âˆˆ Ioo xâ‚€ x â†’ (x - y) ^ n â‰  0 := by
    intro y hy
    refine' pow_ne_zero _ _
    rw [mem_Ioo] at hy
    rw [sub_ne_zero]
    exact hy.2.ne'
  have hg' : âˆ€ y : â„, y âˆˆ Ioo xâ‚€ x â†’ -(â†‘n + 1) * (x - y) ^ n â‰  0 := fun y hy =>
    mul_ne_zero (neg_ne_zero.mpr (Nat.cast_add_one_ne_zero n)) (xy_ne y hy)
  rcases taylor_mean_remainder hx hf hf' gcont (fun y _ => monomial_has_deriv_aux y x _) hg' with
    âŸ¨y, hy, hâŸ©
  use y, hy
  simp only [sub_self, zero_pow, Ne.def, Nat.succ_ne_zero, not_false_iff, zero_sub, mul_neg] at h
  rw [h, neg_div, â† div_neg, neg_mul, neg_neg]
  sorry","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.136822 â†’ ?m.136822 â†’ Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  -?b / ?a
case right
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace â„ E
f : â„ â†’ â„
x xâ‚€ : â„
n : â„•
hx : xâ‚€ < x
hf : ContDiffOn â„ (â†‘n) f (Icc xâ‚€ x)
hf' : DifferentiableOn â„ (iteratedDerivWithin n f (Icc xâ‚€ x)) (Ioo xâ‚€ x)
gcont : ContinuousOn (fun t â†¦ (x - t) ^ (n + 1)) (Icc xâ‚€ x)
xy_ne : âˆ€ y âˆˆ Ioo xâ‚€ x, (x - y) ^ n â‰  0
hg' : âˆ€ y âˆˆ Ioo xâ‚€ x, -(â†‘n + 1) * (x - y) ^ n â‰  0
y : â„
hy : y âˆˆ Ioo xâ‚€ x
h :
  f x - taylorWithinEval f n (Icc xâ‚€ x) xâ‚€ x =
    ((x - y) ^ n / â†‘n ! * (0 ^ (n + 1) - (x - xâ‚€) ^ (n + 1)) / (-(â†‘n + 1) * (x - y) ^ n)) â€¢
      iteratedDerivWithin (n + 1) f (Icc xâ‚€ x) y
âŠ¢ ((x - y) ^ n / â†‘n ! * (0 ^ (n + 1) - (x - xâ‚€) ^ (n + 1)) / (-(â†‘n + 1) * (x - y) ^ n)) â€¢
      iteratedDerivWithin (n + 1) f (Icc xâ‚€ x) y =
    iteratedDerivWithin (n + 1) f (Icc xâ‚€ x) y * (x - xâ‚€) ^ (n + 1) / â†‘(n + 1)!","theorem taylor_mean_remainder_lagrange {f : â„ â†’ â„} {x xâ‚€ : â„} {n : â„•} (hx : xâ‚€ < x)
    (hf : ContDiffOn â„ n f (Icc xâ‚€ x))
    (hf' : DifferentiableOn â„ (iteratedDerivWithin n f (Icc xâ‚€ x)) (Ioo xâ‚€ x)) :
    âˆƒ x' âˆˆ Ioo xâ‚€ x, f x - taylorWithinEval f n (Icc xâ‚€ x) xâ‚€ x =
      iteratedDerivWithin (n + 1) f (Icc xâ‚€ x) x' * (x - xâ‚€) ^ (n + 1) / (n + 1)! ",":= by
  have gcont : ContinuousOn (fun t : â„ => (x - t) ^ (n + 1)) (Icc xâ‚€ x) := by fun_prop
  have xy_ne : âˆ€ y : â„, y âˆˆ Ioo xâ‚€ x â†’ (x - y) ^ n â‰  0 := by
    intro y hy
    refine pow_ne_zero _ ?_
    rw [mem_Ioo] at hy
    rw [sub_ne_zero]
    exact hy.2.ne'
  have hg' : âˆ€ y : â„, y âˆˆ Ioo xâ‚€ x â†’ -(â†‘n + 1) * (x - y) ^ n â‰  0 := fun y hy =>
    mul_ne_zero (neg_ne_zero.mpr (Nat.cast_add_one_ne_zero n)) (xy_ne y hy)
  rcases taylor_mean_remainder hx hf hf' gcont (fun y _ => monomial_has_deriv_aux y x _) hg' with
    âŸ¨y, hy, hâŸ©
  use y, hy
  simp only [sub_self, zero_pow, Ne, Nat.succ_ne_zero, not_false_iff, zero_sub, mul_neg] at h
  rw [h, neg_div, â† div_neg, neg_mul, neg_neg]
  field_simp [xy_ne y hy, Nat.factorial]; ring"
Mathlib/AlgebraicGeometry/EllipticCurve/Projective.lean,WeierstrassCurve.Projective.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,a83fc959459475e93bffd2243ee0a7c1d9f53d34,":= by
  use (isUnit_Y_of_Z_eq_zero hP hPz).unit / (isUnit_Y_of_Z_eq_zero hQ hQz).unit
  simp only [Units.smul_def, smul_fin3, X_eq_zero_of_Z_eq_zero hQ.left hQz, hQz, mul_zero,
    Units.val_div_eq_div_val, IsUnit.unit_spec, (isUnit_Y_of_Z_eq_zero hQ hQz).div_mul_cancel]
  conv_rhs => rw [â† fin3_def P, X_eq_zero_of_Z_eq_zero hP.left hPz, hPz]","error:  unknown identifier 'isUnit_Y_of_Z_eq_zero'
error:  unknown identifier 'isUnit_Y_of_Z_eq_zero'
error:  unknown identifier 'X_eq_zero_of_Z_eq_zero'
error:  unknown identifier 'isUnit_Y_of_Z_eq_zero'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ![P 0, P 1, P 2]
R : Type u
instâœÂ¹ : CommRing R
Wâœ : Projective R
F : Type u
instâœ : Field F
W : Projective F
P Q : Fin 3 â†’ F
hP : W.Nonsingular P
hQ : W.Nonsingular Q
hPz : P 2 = 0
hQz : Q 2 = 0
| P","lemma equiv_of_Z_eq_zero {P Q : Fin 3 â†’ F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P â‰ˆ Q ",":= by
  rw [fin3_def P, hPz] at hP âŠ¢
  rw [fin3_def Q, hQz] at hQ âŠ¢
  simp? [nonsingular_iff, equation_iff] at hP hQ says
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, nonsingular_iff,
      equation_iff, Matrix.cons_val_one, Matrix.head_cons, Matrix.cons_val_two, Matrix.tail_cons,
      mul_zero, Matrix.cons_val_zero, add_zero, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true,
      zero_pow, zero_eq_mul, pow_eq_zero_iff, not_or, sub_self, not_true_eq_false, false_or]
    at hP hQ
  simp? [pow_eq_zero hP.left.symm, pow_eq_zero hQ.left.symm] at * says
    simp only [Fin.isValue, pow_eq_zero hP.left.symm, ne_eq, OfNat.ofNat_ne_zero,
      not_false_eq_true, zero_pow, not_true_eq_false, and_false, mul_zero, zero_mul, add_zero,
      pow_eq_zero_iff, false_or, true_and, pow_eq_zero hQ.left.symm, Nat.succ_eq_add_one,
      Nat.reduceAdd] at *
  exact âŸ¨Units.mk0 (P y / Q y) <| div_ne_zero hP hQ, by simp [div_mul_cancelâ‚€ _ hQ]âŸ©"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime_pow,isIntegralClosure_adjoin_singleton_of_prime_pow,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine âŸ¨Subtype.val_injective, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©,? _âŸ©âŸ©
  swap
  Â· rintro âŸ¨y, rflâŸ©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hÎ¶.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hÎ¶.subOnePowerBasis â„š
  have hint : IsIntegral â„¤ B.gen := (hÎ¶.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} â„š K
  have H := discr_mul_isIntegral_mem_adjoin â„š hint h
  obtain âŸ¨u, n, hunâŸ© := discr_prime_pow_eq_unit_mul_pow' hÎ¶
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [â† smul_assoc, â† smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, â† Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  Â· haveI : IsCyclotomicExtension {1} â„š K := by simpa using hcycl
    have : x âˆˆ (âŠ¥ : Subalgebra â„š K) := by
      rw [singleton_one â„š K]
      exact mem_top
    obtain âŸ¨y, rflâŸ© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap â„š K).injective).1 h
    obtain âŸ¨z, hzâŸ© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [â† hz, â† IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  Â· have hmin : (minpoly â„¤ B.gen).IsEisensteinAt (Submodule.span â„¤ {((p : â„•) : â„¤)}) := by
      have hâ‚ := minpoly.isIntegrallyClosed_eq_field_fractions' â„š hint
      have hâ‚‚ := hÎ¶.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at hâ‚
      rw [hâ‚, â† map_cyclotomic_int, show Int.castRingHom â„š = algebraMap â„¤ â„š by rfl,
        show X + 1 = map (algebraMap â„¤ â„š) (X + 1) by simp, â† map_comp] at hâ‚‚
      haveI : CharZero â„š := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap â„¤ â„š) (algebraMap â„¤ â„š).injective_int hâ‚‚]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton â„¤ _) (Subalgebra.one_mem _)",error:  unknown constant 'StrictOrderedSemiring.to_charZero',"theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} â„š K]
    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)) : IsIntegralClosure (adjoin â„¤ ({Î¶} : Set K)) â„¤ K ",":= by
  refine âŸ¨Subtype.val_injective, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©, ?_âŸ©âŸ©
  swap
  Â· rintro âŸ¨y, rflâŸ©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hÎ¶.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hÎ¶.subOnePowerBasis â„š
  have hint : IsIntegral â„¤ B.gen := (hÎ¶.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} â„š K
  have H := discr_mul_isIntegral_mem_adjoin â„š hint h
  obtain âŸ¨u, n, hunâŸ© := discr_prime_pow_eq_unit_mul_pow' hÎ¶
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [â† smul_assoc, â† smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, â† Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  Â· haveI : IsCyclotomicExtension {1} â„š K := by simpa using hcycl
    have : x âˆˆ (âŠ¥ : Subalgebra â„š K) := by
      rw [singleton_one â„š K]
      exact mem_top
    obtain âŸ¨y, rflâŸ© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap â„š K).injective).1 h
    obtain âŸ¨z, hzâŸ© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [â† hz, â† IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  Â· have hmin : (minpoly â„¤ B.gen).IsEisensteinAt (Submodule.span â„¤ {((p : â„•) : â„¤)}) := by
      have hâ‚ := minpoly.isIntegrallyClosed_eq_field_fractions' â„š hint
      have hâ‚‚ := hÎ¶.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at hâ‚
      rw [hâ‚, â† map_cyclotomic_int, show Int.castRingHom â„š = algebraMap â„¤ â„š by rfl,
        show X + 1 = map (algebraMap â„¤ â„š) (X + 1) by simp, â† map_comp] at hâ‚‚
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap â„¤ â„š) (algebraMap â„¤ â„š).injective_int hâ‚‚]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton â„¤ _) (Subalgebra.one_mem _)"
Mathlib/Data/Set/Pointwise/Interval.lean,Set.Iic_mul_Iio_subset',Iic_mul_Iio_subset',0d653eb0b05ba674b43555022f52c4b5f1e97748,":= by
  haveI := mulLeftMono_of_mulLeftStrictMono Î±
  haveI := mulRightMono_of_mulRightStrictMono Î±
  rintro x âŸ¨y, hya, z, hzb, rflâŸ©
  exact mul_lt_mul_of_le_of_lt hya hzb","error:  unknown identifier 'mulLeftMono_of_mulLeftStrictMono'
error:  unsolved goals
Î± : Type u_1
instâœÂ³ : Mul Î±
instâœÂ² : PartialOrder Î±
instâœÂ¹ : CovariantClass Î± Î± (fun x x_1 â†¦ x * x_1) fun x x_1 â†¦ x < x_1
instâœ : CovariantClass Î± Î± (Function.swap HMul.hMul) LT.lt
a b : Î±
âŠ¢ Iic a * Iio b âŠ† Iio (a * b)",theorem Iic_mul_Iio_subset' (a b : Î±) : Iic a * Iio b âŠ† Iio (a * b) ,":= by
  haveI := covariantClass_le_of_lt
  rintro x âŸ¨y, hya, z, hzb, rflâŸ©
  exact mul_lt_mul_of_le_of_lt hya hzb"
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.prod_leftInvSeq,prod_leftInvSeq,7683e8d2b190e296fb9afff15b2c8e2d3f9d6b38,":= by
  simp [leftInvSeq_eq_reverse_rightInvSeq_reverse, prod_reverse_noncomm]
  have : List.map (fun x â†¦ xâ»Â¹) (ris Ï‰.reverse) = ris Ï‰.reverse := calc
    List.map (fun x â†¦ xâ»Â¹) (ris Ï‰.reverse)
    _ = List.map id (ris Ï‰.reverse)             := by
        apply List.map_congr
        intro t ht
        exact cs.inv_eq_self_of_isReflection (cs.isReflection_of_mem_rightInvSeq _ ht)
    _ = ris Ï‰.reverse                           := map_id _
  rw [this]
  nth_rw 2 [â† reverse_reverse Ï‰]
  rw [wordProd_reverse]
  exact cs.prod_rightInvSeq _","warning:  `List.map_congr` has been deprecated, use `List.map_congr_left` instead
error:  invalid field 'inv_eq_self_of_isReflection', the environment does not contain 'CoxeterSystem.inv_eq_self_of_isReflection'
  cs
has type
  CoxeterSystem M W",theorem prod_leftInvSeq (Ï‰ : List B) : prod (lis Ï‰) = (Ï€ Ï‰)â»Â¹ ,":= by
  simp [leftInvSeq_eq_reverse_rightInvSeq_reverse, prod_reverse_noncomm]
  have : List.map (fun x â†¦ xâ»Â¹) (ris Ï‰.reverse) = ris Ï‰.reverse := calc
    List.map (fun x â†¦ xâ»Â¹) (ris Ï‰.reverse)
    _ = List.map id (ris Ï‰.reverse)             := by
        apply List.map_congr_left
        intro t ht
        exact (cs.isReflection_of_mem_rightInvSeq _ ht).inv
    _ = ris Ï‰.reverse                           := map_id _
  rw [this]
  nth_rw 2 [â† reverse_reverse Ï‰]
  rw [wordProd_reverse]
  exact cs.prod_rightInvSeq _"
Mathlib/Order/ConditionallyCompleteLattice/Basic.lean,WithTop.isGLB_sInf,isGLB_sInf,c151d0706a00b9e9399de0ded77d06d1106bd505,":= by
  constructor
  Â· show ite _ _ _ âˆˆ _
    split_ifs with h
    Â· intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    Â· rintro (âŸ¨âŸ© | a) ha
      Â· exact le_top
      refine' some_le_some.2 (csInf_le _ ha)
      rcases hs with âŸ¨âŸ¨âŸ© | b, hbâŸ©
      Â· exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, â† top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact some_le_some.1 (hb hc)
  Â· show ite _ _ _ âˆˆ _
    split_ifs with h
    Â· intro _ _
      exact le_top
    Â· rintro (âŸ¨âŸ© | a) ha
      Â· exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      Â· refine' some_le_some.2 (le_csInf _ _)
        Â· classical
            contrapose! h
            rintro (âŸ¨âŸ© | a) ha
            Â· exact mem_singleton âŠ¤
            Â· exact (h âŸ¨a, haâŸ©).elim
        Â· intro b hb
          rw [â† some_le_some]
          exact ha hb","error:  function expected at
  h
term has type
  s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.intro.none
Î± : Type u_1
Î²âœ : Type u_2
Î³ : Type u_3
Î¹ : Sort u_4
instâœÂ¹ : ConditionallyCompleteLinearOrderBot Î±
Î² : Type u_5
instâœ : ConditionallyCompleteLattice Î²
s : Set (WithTop Î²)
h : Â¬(s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s)
a : Î²
ha : Option.some a âˆˆ s
hb : none âˆˆ lowerBounds s
âŠ¢ s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.none
Î± : Type u_1
Î²âœ : Type u_2
Î³ : Type u_3
Î¹ : Sort u_4
instâœÂ¹ : ConditionallyCompleteLinearOrderBot Î±
Î² : Type u_5
instâœ : ConditionallyCompleteLattice Î²
s : Set (WithTop Î²)
hs : BddBelow s
h : Â¬(s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s)
ha : none âˆˆ lowerBounds s
âŠ¢ s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.refine'_1
Î± : Type u_1
Î²âœ : Type u_2
Î³ : Type u_3
Î¹ : Sort u_4
instâœÂ¹ : ConditionallyCompleteLinearOrderBot Î±
Î² : Type u_5
instâœ : ConditionallyCompleteLattice Î²
s : Set (WithTop Î²)
hs : BddBelow s
a : Î²
ha : Option.some a âˆˆ lowerBounds s
h : (fun a â†¦ â†‘a) â»Â¹' s = âˆ…
âŠ¢ s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s
warning:  Don't mix Option and WithTop","theorem isGLB_sInf' {Î² : Type*} [ConditionallyCompleteLattice Î²] {s : Set (WithTop Î²)}
    (hs : BddBelow s) : IsGLB s (sInf s) ",":= by
  constructor
  Â· show ite _ _ _ âˆˆ _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    Â· intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    Â· rintro (âŸ¨âŸ© | a) ha
      Â· exact le_top
      refine coe_le_coe.2 (csInf_le ?_ ha)
      rcases hs with âŸ¨âŸ¨âŸ© | b, hbâŸ©
      Â· exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, â† top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact coe_le_coe.1 (hb hc)
  Â· show ite _ _ _ âˆˆ _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    Â· intro _ _
      exact le_top
    Â· rintro (âŸ¨âŸ© | a) ha
      Â· exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      Â· refine coe_le_coe.2 (le_csInf ?_ ?_)
        Â· classical
            contrapose! h
            rintro (âŸ¨âŸ© | a) ha
            Â· exact mem_singleton âŠ¤
            Â· exact (not_nonempty_iff_eq_empty.2 h âŸ¨a, haâŸ©).elim
        Â· intro b hb
          rw [â† coe_le_coe]
          exact ha hb"
Mathlib/ModelTheory/Satisfiability.lean,FirstOrder.Language.Theory.exists_large_model_of_infinite_model,exists_large_model_of_infinite_model,047f73c34cd3e6bae28166f72847965b1a989c70,":= by
  obtain âŸ¨NâŸ© :=
    isSatisfiable_union_distinctConstantsTheory_of_infinite T (Set.univ : Set Îº.out) M
  refine' âŸ¨(N.is_model.mono (Set.subset_union_left _ _)).bundled.reduct _, _âŸ©
  haveI : N âŠ¨ distinctConstantsTheory _ _ := N.is_model.mono (Set.subset_union_right _ _)
  rw [ModelType.reduct_Carrier, coe_of]
  refine' trans (lift_le.2 (le_of_eq (Cardinal.mk_out Îº).symm)) _
  rw [â† mk_univ]
  refine'
    (card_le_of_model_distinctConstantsTheory L Set.univ N).trans (lift_le.{max u v w}.1 _)
  rw [lift_lift]","error:  function expected at
  Set.subset_union_left ?m.16906
term has type
  ?m.16905 âˆˆ ?m.16903 âˆª ?m.16904
error:  function expected at
  Set.subset_union_right ?m.17980
term has type
  ?m.17979 âˆˆ ?m.17977 âˆª ?m.17978
error:  unsolved goals
case intro.refine'_1
L : Language
Tâœ : L.Theory
Î± : Type w
n : â„•
T' T : L.Theory
Îº : Cardinal.{w}
M : Type w'
instâœÂ² : L.Structure M
instâœÂ¹ : M âŠ¨ T
instâœ : Infinite M
N : ((L.lhomWithConstants (Quotient.out Îº)).onTheory T âˆª L.distinctConstantsTheory Set.univ).ModelType
âŠ¢ L â†’á´¸ L[[Quotient.out Îº]]
warning:  @ModelsBoundedFormula does not have a doc string","theorem exists_large_model_of_infinite_model (T : L.Theory) (Îº : Cardinal.{w}) (M : Type w')
    [L.Structure M] [M âŠ¨ T] [Infinite M] :
    âˆƒ N : ModelType.{_, _, max u v w} T, Cardinal.lift.{max u v w} Îº â‰¤ #N ",":= by
  obtain âŸ¨NâŸ© :=
    isSatisfiable_union_distinctConstantsTheory_of_infinite T (Set.univ : Set Îº.out) M
  refine âŸ¨(N.is_model.mono Set.subset_union_left).bundled.reduct _, ?_âŸ©
  haveI : N âŠ¨ distinctConstantsTheory _ _ := N.is_model.mono Set.subset_union_right
  rw [ModelType.reduct_Carrier, coe_of]
  refine _root_.trans (lift_le.2 (le_of_eq (Cardinal.mk_out Îº).symm)) ?_
  rw [â† mk_univ]
  refine
    (card_le_of_model_distinctConstantsTheory L Set.univ N).trans (lift_le.{max u v w}.1 ?_)
  rw [lift_lift]"
Mathlib/Order/Partition/Finpartition.lean,Finpartition.parts_eq_empty_iff,parts_eq_empty_iff,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  simp_rw [â† P.sup_parts]
  refine âŸ¨fun h â†¦ ?_, fun h â†¦ eq_empty_iff_forall_not_mem.2 fun b hb â†¦ P.not_bot_mem? _âŸ©
  Â· rw [h]
    exact Finset.sup_empty
  Â· rwa [â† le_bot_iff.1 ((le_sup hb).trans h.le)]","error:  invalid field 'not_bot_mem?', the environment does not contain 'Finpartition.not_bot_mem?'
  P
has type
  Finpartition a
error:  no goals to be solved",theorem parts_eq_empty_iff : P.parts = âˆ… â†” a = âŠ¥ ,":= by
  simp_rw [â† P.sup_parts]
  refine âŸ¨fun h â†¦ ?_, fun h â†¦ eq_empty_iff_forall_not_mem.2 fun b hb â†¦ P.not_bot_mem ?_âŸ©
  Â· rw [h]
    exact Finset.sup_empty
  Â· rwa [â† le_bot_iff.1 ((le_sup hb).trans h.le)]"
Mathlib/Topology/Algebra/ConstMulAction.lean,isOpenMap_quotient_mk'_mul,isOpenMap_quotient_mk'_mul,1cd8b316f3e3e2f1e307b4e38e2b304ae5e596bd,":= fun U hU => by
  rw [isOpen_coinduced, MulAction.quotient_preimage_image_eq_union_mul U]
  exact isOpen_unionáµ¢ fun Î³ => isOpenMap_smul Î³ U hU",error:  unknown identifier 'isOpen_unionáµ¢',"theorem isOpenMap_quotient_mk'_mul [ContinuousConstSMul Î“ T] :
    letI := MulAction.orbitRel Î“ T
    IsOpenMap (Quotient.mk' : T â†’ Quotient (MulAction.orbitRel Î“ T)) ",":= fun U hU => by
  rw [isOpen_coinduced, MulAction.quotient_preimage_image_eq_union_mul U]
  exact isOpen_iUnion fun Î³ => isOpenMap_smul Î³ U hU"
Mathlib/GroupTheory/PGroup.lean,IsPGroup.card_orbit,card_orbit,034139f67d1e53664a78cb1986579908d1f2fa67,":= by
  let Ï• := orbitEquivQuotientStabilizer G a
  haveI := Fintype.ofEquiv (orbit G a) Ï•
  haveI := (stabilizer G a).finiteIndex_of_finite_quotient
  rw [card_congr Ï•, â† Nat.card_eq_fintype_card, â† Subgroup.index_eq_card]
  exact hG.index (stabilizer G a)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  card (?m.23935 â§¸ ?H)
p : â„•
G : Type u_1
instâœÂ² : Group G
hG : IsPGroup p G
hp : Fact (Nat.Prime p)
Î± : Type u_2
instâœÂ¹ : MulAction G Î±
a : Î±
instâœ : Fintype â†‘(orbit G a)
Ï• : â†‘(orbit G a) â‰ƒ G â§¸ stabilizer G a := orbitEquivQuotientStabilizer G a
thisâœ : Fintype (G â§¸ stabilizer G a)
this : (stabilizer G a).FiniteIndex
âŠ¢ âˆƒ n, Nat.card (G â§¸ stabilizer G a) = p ^ n
error:  invalid field notation, function 'IsPGroup.card_orbit' does not have argument with type (IsPGroup ...) that can be used, it must be explicit or implicit with a unique name
error:  rcases tactic failed: xâœ : ?m.53021 is not an inductive datatype
error:  invalid field notation, function 'IsPGroup.card_modEq_card_fixedPoints' does not have argument with type (IsPGroup ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'IsPGroup.card_modEq_card_fixedPoints' does not have argument with type (IsPGroup ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'IsPGroup.exists_fixed_point_of_prime_dvd_card_of_fixed_point' does not have argument with type (IsPGroup ...) that can be used, it must be explicit or implicit with a unique name
error:  unsolved goals
case intro
p : â„•
G : Type u_1
instâœâ´ : Group G
hG : IsPGroup p G
hp : Fact (Nat.Prime p)
Î± : Type u_2
instâœÂ³ : MulAction G Î±
instâœÂ² : Fintype Î±
instâœÂ¹ : Nontrivial G
instâœ : Finite G
valâœ : Fintype G
âŠ¢ Nontrivial â†¥(Subgroup.center G)
error:  function expected at
  center_nontrivial
term has type
  Nontrivial â†¥(Subgroup.center ?m.59666)
error:  unsolved goals
p : â„•
G : Type u_1
instâœâ´ : Group G
hG : IsPGroup p G
hp : Fact (Nat.Prime p)
Î± : Type u_2
instâœÂ³ : MulAction G Î±
instâœÂ² : Fintype Î±
instâœÂ¹ : Nontrivial G
instâœ : Finite G
âŠ¢ âŠ¥ < Subgroup.center G
error:  function expected at
  center_nontrivial
term has type
  Nontrivial â†¥(center ?m.83460)","theorem card_orbit (a : Î±) [Fintype (orbit G a)] : âˆƒ n : â„•, card (orbit G a) = p ^ n ",":= by
  let Ï• := orbitEquivQuotientStabilizer G a
  haveI := Fintype.ofEquiv (orbit G a) Ï•
  haveI := (stabilizer G a).finiteIndex_of_finite_quotient
  rw [card_congr Ï•, â† Subgroup.index_eq_card]
  exact hG.index (stabilizer G a)"
Mathlib/Data/Finset/Basic.lean,Finset.nonempty_mk,nonempty_mk,1fe135a920a7dbc55ebabf4084c04000d825f934,":= by
  induction m <;> simp","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
s t : Finset Î±
a b : Î±
m : Multiset Î±
hm : m.Nodup
âŠ¢ { val := m, nodup := hm }.Nonempty â†” m â‰  0","theorem nonempty_mk {m : Multiset Î±} {hm} : (âŸ¨m, hmâŸ© : Finset Î±).Nonempty â†” m â‰  0 ",":= by
  induction m using Multiset.induction_on <;> simp"
Mathlib/Topology/UniformSpace/Compact.lean,CompactSpace.uniformContinuous_of_continuous,CompactSpace.uniformContinuous_of_continuous,ff33484322fbce1ead24eb4ca948306955c68664,":=
  have : Tendsto (Prod.map f f) (ğ“Ë¢ (diagonal Î±)) (ğ“Ë¢ (diagonal Î²)) :=
    (h.prod_map h).tendsto_nhdsSet mapsTo_prod_map_diagonal
  (this.mono_left nhdsSet_diagonal_eq_uniformity.ge).mono_right nhdsSet_diagonal_le_uniformity",error:  unexpected token 'calc'; expected command,"theorem CompactSpace.uniformContinuous_of_continuous [CompactSpace Î±] {f : Î± â†’ Î²}
    (h : Continuous f) : UniformContinuous f ",:=
Mathlib/MeasureTheory/Decomposition/SignedLebesgue.lean,MeasureTheory.ComplexMeasure.integrable_rnDeriv,integrable_rnDeriv,1d139ad79ce099e15226e6bbd1cf8e7d24be07d3,":= by
  refine Integrable.sub ?_ ?_ <;>
    Â· constructor
      Â· apply Measurable.aestronglyMeasurable
        fun_prop
      exact hasFiniteIntegral_toReal_of_lintegral_ne_top (lintegral_rnDeriv_lt_top _ Î¼).ne","error:  `fun_prop` was unable to prove `Measurable fun x â†¦ (s.toJordanDecomposition.posPart.rnDeriv Î¼ x).toReal`

Try running with discharger `fun_prop (disch:=aesop)` or with a different discharger tactic like `assumption`, `linarith`, `omega`.
Sometimes it is useful to run `fun_prop (disch:=trace_state; sorry)` which will print all the necessary subgoals for `fun_prop` to succeed.

Potential issues to fix:
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a â†¦ s.toJordanDecomposition.posPart.rnDeriv Î¼ a
  Failed to synthesize instance TopologicalSpace Î± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Î± when applying theorem Continuous.measurable.
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a â†¦ s.toJordanDecomposition.posPart.rnDeriv Î¼ a
  Failed to synthesize instance TopologicalSpace Î± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Î± when applying theorem Continuous.measurable.

For more detailed information use `set_option trace.Meta.Tactic.fun_prop true`
error:  `fun_prop` was unable to prove `Measurable fun x â†¦ (s.toJordanDecomposition.negPart.rnDeriv Î¼ x).toReal`

Try running with discharger `fun_prop (disch:=aesop)` or with a different discharger tactic like `assumption`, `linarith`, `omega`.
Sometimes it is useful to run `fun_prop (disch:=trace_state; sorry)` which will print all the necessary subgoals for `fun_prop` to succeed.

Potential issues to fix:
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a â†¦ s.toJordanDecomposition.negPart.rnDeriv Î¼ a
  Failed to synthesize instance TopologicalSpace Î± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Î± when applying theorem Continuous.measurable.
  No theorems found for `MeasureTheory.Measure.rnDeriv` in order to prove Measurable fun a â†¦ s.toJordanDecomposition.negPart.rnDeriv Î¼ a
  Failed to synthesize instance TopologicalSpace Î± when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace Î± when applying theorem Continuous.measurable.

For more detailed information use `set_option trace.Meta.Tactic.fun_prop true`",theorem integrable_rnDeriv (s : SignedMeasure Î±) (Î¼ : Measure Î±) : Integrable (rnDeriv s Î¼) Î¼ ,":= by
  refine Integrable.sub ?_ ?_ <;>
    Â· constructor
      Â· 
        exact (((Measure.measurable_rnDeriv _ Î¼
          ).ennreal_toNNReal).coe_nnreal_real).aestronglyMeasurable
      exact hasFiniteIntegral_toReal_of_lintegral_ne_top (lintegral_rnDeriv_lt_top _ Î¼).ne"
Mathlib/Data/Fin/Tuple/Basic.lean,Fin.find_spec,find_spec,b57ede590c8e21e71ba026c0b434dec2631ccd28,"  | 0, p, I, i, hi => Option.noConfusion hi
  | n + 1, p, I, i, hi => by
    rw [find] at hi
    cases' h : find fun i : Fin n â†¦ p (i.castLt (Nat.lt_succ_of_lt i.2)) with j
    Â· rw [h] at hi
      dsimp at hi
      split_ifs at hi with hl
      Â· simp only [Option.mem_def, Option.some.injEq] at hi
        exact hi â–¸ hl
      Â· exact (Option.not_mem_none _ hi).elim
    Â· rw [h] at hi
      dsimp at hi
      rw [â† Option.some_inj.1 hi]
      refine @find_spec n (fun i â†¦ p (i.castLt (Nat.lt_succ_of_lt i.2))) _ _ h","error:  invalid field 'castLt', the environment does not contain 'Fin.castLt'
  i
has type
  Fin n","theorem find_spec :
    âˆ€ {n : â„•} (p : Fin n â†’ Prop) [DecidablePred p] {i : Fin n} (_ : i âˆˆ Fin.find p), p i
","  | 0, p, I, i, hi => Option.noConfusion hi
  | n + 1, p, I, i, hi => by
    rw [find] at hi
    cases' h : find fun i : Fin n â†¦ p (i.castLT (Nat.lt_succ_of_lt i.2)) with j
    Â· rw [h] at hi
      dsimp at hi
      split_ifs at hi with hl
      Â· simp only [Option.mem_def, Option.some.injEq] at hi
        exact hi â–¸ hl
      Â· exact (Option.not_mem_none _ hi).elim
    Â· rw [h] at hi
      dsimp at hi
      rw [â† Option.some_inj.1 hi]
      exact @find_spec n (fun i â†¦ p (i.castLT (Nat.lt_succ_of_lt i.2))) _ _ h"
Mathlib/RingTheory/Valuation/ValuationSubring.lean,ValuationSubring.principalUnitGroup_le_principalUnitGroup,principalUnitGroup_le_principalUnitGroup,0dc91462216e42ad31f44da1480fa20e0fc9bec4,":= by
  constructor
  Â· intro h x hx
    by_cases h_1 : x = 0; Â· simp only [h_1, zero_mem]
    by_cases h_2 : xâ»Â¹ + 1 = 0
    Â· rw [add_eq_zero_iff_eq_neg, inv_eq_iff_eq_inv, inv_neg, inv_one] at h_2
      simpa only [h_2] using B.neg_mem _ B.one_mem
    Â· rw [â† valuation_le_one_iff, â† not_lt, Valuation.one_lt_val_iff _ h_1, â† add_sub_cancel xâ»Â¹, â†
        Units.val_mk0 h_2, â† mem_principalUnitGroup_iff] at hx âŠ¢
      simpa only [hx] using @h (Units.mk0 (xâ»Â¹ + 1) h_2)
  Â· intro h x hx
    by_contra h_1; exact not_lt.2 (monotone_mapOfLE _ _ h (not_lt.1 h_1)) hx","error:  tactic 'rewrite' failed, pattern is a metavariable
  ?b
from equation
  ?b = xâ»Â¹ + (?b - xâ»Â¹)
case neg
K : Type u
instâœ : Field K
Aâœ A B : ValuationSubring K
h : B.principalUnitGroup â‰¤ A.principalUnitGroup
x : K
hx : Â¬A.valuation xâ»Â¹ < 1
h_1 : Â¬x = 0
h_2 : Â¬xâ»Â¹ + 1 = 0
âŠ¢ Â¬B.valuation xâ»Â¹ < 1","theorem principalUnitGroup_le_principalUnitGroup {A B : ValuationSubring K} :
    B.principalUnitGroup â‰¤ A.principalUnitGroup â†” A â‰¤ B ",":= by
  constructor
  Â· intro h x hx
    by_cases h_1 : x = 0; Â· simp only [h_1, zero_mem]
    by_cases h_2 : xâ»Â¹ + 1 = 0
    Â· rw [add_eq_zero_iff_eq_neg, inv_eq_iff_eq_inv, inv_neg, inv_one] at h_2
      simpa only [h_2] using B.neg_mem _ B.one_mem
    Â· rw [â† valuation_le_one_iff, â† not_lt, Valuation.one_lt_val_iff _ h_1,
        â† add_sub_cancel_right xâ»Â¹, â† Units.val_mk0 h_2, â† mem_principalUnitGroup_iff] at hx âŠ¢
      simpa only [hx] using @h (Units.mk0 (xâ»Â¹ + 1) h_2)
  Â· intro h x hx
    by_contra h_1; exact not_lt.2 (monotone_mapOfLE _ _ h (not_lt.1 h_1)) hx"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.length_eq_map,length_eq_map,938069ac7c83a4980c46ca108d9947ab788c12ee,":= by
  refine
    Computation.eq_of_bisim
      (fun c1 c2 =>
        âˆƒ (l : List Î±) (s : WSeq Î±),
          c1 = Computation.corec (fun âŸ¨n, sâŸ© =>
            match Seq'.destruct s with
            | none => Sum.inl n
            | some (none, s') => Sum.inr (n, s')
            | some (some _, s') => Sum.inr (n + 1, s')) (l.length, s) âˆ§
            c2 = Computation.map List.length (Computation.corec (fun âŸ¨l, sâŸ© =>
              match Seq'.destruct s with
              | none => Sum.inl l.reverse
              | some (none, s') => Sum.inr (l, s')
              | some (some a, s') => Sum.inr (a::l, s')) (l, s)))
      ?_ âŸ¨[], s, rfl, rflâŸ©
  intro s1 s2 h; rcases h with âŸ¨l, s, hâŸ©; rw [h.left, h.right]
  induction' s using WSeq.recOn with a s s <;> simp [toList, nil, cons, think, length]
  Â· refine âŸ¨a::l, s, ?_, ?_âŸ© <;> simp
  Â· refine âŸ¨l, s, ?_, ?_âŸ© <;> simp","error:  unknown identifier 'Seq'.destruct'
error:  unknown identifier 'Seq'.destruct'
error:  application type mismatch
  And.intro rfl
argument
  rfl
has type
  s.length = s.length : Prop
but is expected to have type
  s.length =
    Computation.corec (fun x â†¦ ?m.84257 s.length (Computation.map List.length s.toList) [] s x) ([].length, s) : Prop",theorem length_eq_map (s : WSeq Î±) : length s = Computation.map List.length (toList s) ,":= by
  refine
    Computation.eq_of_bisim
      (fun c1 c2 =>
        âˆƒ (l : List Î±) (s : WSeq Î±),
          c1 = Computation.corec (fun âŸ¨n, sâŸ© =>
            match Seq.destruct s with
            | none => Sum.inl n
            | some (none, s') => Sum.inr (n, s')
            | some (some _, s') => Sum.inr (n + 1, s')) (l.length, s) âˆ§
            c2 = Computation.map List.length (Computation.corec (fun âŸ¨l, sâŸ© =>
              match Seq.destruct s with
              | none => Sum.inl l.reverse
              | some (none, s') => Sum.inr (l, s')
              | some (some a, s') => Sum.inr (a::l, s')) (l, s)))
      ?_ âŸ¨[], s, rfl, rflâŸ©
  intro s1 s2 h; rcases h with âŸ¨l, s, hâŸ©; rw [h.left, h.right]
  induction' s using WSeq.recOn with a s s <;> simp [toList, nil, cons, think, length]
  Â· refine âŸ¨a::l, s, ?_, ?_âŸ© <;> simp
  Â· refine âŸ¨l, s, ?_, ?_âŸ© <;> simp"
Mathlib/Data/List/Infix.lean,List.map_reverse_tails,map_reverse_tails,10294a2e3306ccd731ec7cbd6a95830a83a9ff94,":= by
  rw [tails_eq_inits l]
  simp [reverse_involutive.comp_self, reverse_map]","warning:  `List.reverse_map` has been deprecated, use `List.map_reverse` instead
error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead",theorem map_reverse_tails (l : List Î±) : map reverse l.tails = (reverse <| inits <| reverse l) ,":= by
  rw [tails_eq_inits l]
  simp [reverse_involutive.comp_self, â† map_reverse]"
Mathlib/Logic/Relator.lean,Relator.rel_imp,rel_imp,b72bb8581e966b6491cee1c5638e18fae2fc11b2,:=,error:  unexpected token 'lemma'; expected term,lemma rel_imp : (Iff â‡’ (Iff â‡’ Iff)) (Â· â†’ Â·) (Â· â†’ Â·) ,":=
  fun _ _ h _ _ l => imp_congr h l"
Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Degree.lean,WeierstrassCurve.natDegree_Î¦_le,natDegree_Î¦_le,409be1ff4c306030afd38a2641547686c28f2646,":= by
  induction n using Int.negInduction with
  | nat n => exact (W.natDegree_coeff_Î¦_ofNat n).left
  | neg ih => simp only [Î¦_neg, Int.natAbs_neg, ih]","error:  invalid argument, variable is not a proposition or let-declaration
error:  unsolved goals
case neg
R : Type u
instâœ : CommRing R
W : WeierstrassCurve R
ih : â„•
aâœ : (W.Î¦ â†‘ih).natDegree â‰¤ (â†‘ih).natAbs ^ 2
âŠ¢ (W.Î¦ â†‘ih).natDegree â‰¤ (â†‘ih).natAbs ^ 2",lemma natDegree_Î¦_le (n : â„¤) : (W.Î¦ n).natDegree â‰¤ n.natAbs ^ 2 ,":= by
  induction n using Int.negInduction with
  | nat n => exact (W.natDegree_coeff_Î¦_ofNat n).left
  | neg => rwa [Î¦_neg, Int.natAbs_neg]"
Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/GaussSum.lean,FiniteField.isSquare_odd_prime_iff,FiniteField.isSquare_odd_prime_iff,9e34a191034458a56331f976ff7400a26407c888,":= by
  classical
  by_cases hFp : ringChar F = p
  Â· rw [show (p : F) = 0 by rw [â† hFp]; exact ringChar.Nat.cast_ringChar]
    simp only [isSquare_zero, Ne.def, true_iff_iff, map_mul]
    obtain âŸ¨n, _, hcâŸ© := FiniteField.card F (ringChar F)
    have hchar : ringChar F = ringChar (ZMod p) := by rw [hFp]; exact (ringChar_zmod_n p).symm
    conv => enter [1, 1, 2]; rw [hc, Nat.cast_pow, map_pow, hchar, map_ringChar]
    simp only [zero_pow n.pos, MulZeroClass.mul_zero, zero_eq_neg, one_ne_zero, not_false_iff]
  Â· rw [â† Iff.not_left (@quadraticChar_neg_one_iff_not_isSquare F _ _ _ _),
      quadraticChar_odd_prime hF hp]
    exact hFp","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.37884 â†’ ?m.37884 â†’ Prop
error:  cannot select argument","theorem FiniteField.isSquare_odd_prime_iff (hF : ringChar F â‰  2) {p : â„•} [Fact p.Prime]
    (hp : p â‰  2) :
    IsSquare (p : F) â†” quadraticChar (ZMod p) (Ï‡â‚„ (Fintype.card F) * Fintype.card F) â‰  -1 ",":= by
  classical
  by_cases hFp : ringChar F = p
  Â· rw [show (p : F) = 0 by rw [â† hFp]; exact ringChar.Nat.cast_ringChar]
    simp only [isSquare_zero, Ne, true_iff_iff, map_mul]
    obtain âŸ¨n, _, hcâŸ© := FiniteField.card F (ringChar F)
    have hchar : ringChar F = ringChar (ZMod p) := by rw [hFp]; exact (ringChar_zmod_n p).symm
    conv => enter [1, 1, 2]; rw [hc, Nat.cast_pow, map_pow, hchar, map_ringChar]
    simp only [zero_pow n.ne_zero, mul_zero, zero_eq_neg, one_ne_zero, not_false_iff]
  Â· rw [â† Iff.not_left (@quadraticChar_neg_one_iff_not_isSquare F _ _ _ _),
      quadraticChar_odd_prime hF hp]
    exact hFp"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Real.integral_rpow_mul_exp_neg_mul_Ioi,integral_rpow_mul_exp_neg_mul_Ioi,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  rw [â† ofReal_inj, ofReal_mul, â† Gamma_ofReal, ofReal_cpow (by positivity), ofReal_div]
  convert integral_cpow_mul_exp_neg_mul_Ioi (by rwa [ofReal_re] : 0 < (a : â„‚).re) hr
  refine _root_.integral_ofReal.symm.trans <| set_integral_congr measurableSet_Ioi (fun t ht â†¦ ?_)
  norm_cast
  rw [â† ofReal_cpow (le_of_lt ht), IsROrC.ofReal_mul]
  rfl","warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
error:  unknown identifier 'IsROrC.ofReal_mul'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.143835
case h.e'_2
a r : â„
ha : 0 < a
hr : 0 < r
t : â„
ht : t âˆˆ Ioi 0
âŠ¢ â†‘(t ^ (a - 1) * rexp (-(r * t))) = â†‘(t ^ (a - 1)) * â†‘(rexp (-(r * t)))","lemma integral_rpow_mul_exp_neg_mul_Ioi {a r : â„} (ha : 0 < a) (hr : 0 < r) :
    âˆ« t : â„ in Ioi 0, t ^ (a - 1) * exp (-(r * t)) = (1 / r) ^ a * Gamma a ",":= by
  rw [â† ofReal_inj, ofReal_mul, â† Gamma_ofReal, ofReal_cpow (by positivity), ofReal_div]
  convert integral_cpow_mul_exp_neg_mul_Ioi (by rwa [ofReal_re] : 0 < (a : â„‚).re) hr
  refine _root_.integral_ofReal.symm.trans <| setIntegral_congr measurableSet_Ioi (fun t ht â†¦ ?_)
  norm_cast
  rw [â† ofReal_cpow (le_of_lt ht), RCLike.ofReal_mul]
  rfl"
Mathlib/Data/Set/Lattice.lean,Set.image2_eq_iUnion,image2_eq_iUnion,d14658b4fab8f69219eacfab3f0e2ad2951d7e1c,":= by
  simp_rw [â† image_eq_iUnion, iUnion_image_left]","error:  unknown identifier 'iUnion_image_left'
error:  simp made no progress","theorem image2_eq_iUnion (s : Set Î±) (t : Set Î²) : image2 f s t = â‹ƒ (i âˆˆ s) (j âˆˆ t), {f i j} ",":= by
  ext; simp [eq_comm]"
Mathlib/MeasureTheory/Decomposition/Jordan.lean,MeasureTheory.JordanDecomposition.toSignedMeasure_injective,toSignedMeasure_injective,1f3ce1e80e88775f0b46357acc324a8cab3186aa,":= by
  intro jâ‚ jâ‚‚ hj
  obtain âŸ¨S, hSâ‚, hSâ‚‚, hSâ‚ƒ, hSâ‚„, hSâ‚…âŸ© := jâ‚.exists_compl_positive_negative
  obtain âŸ¨T, hTâ‚, hTâ‚‚, hTâ‚ƒ, hTâ‚„, hTâ‚…âŸ© := jâ‚‚.exists_compl_positive_negative
  rw [â† hj] at hTâ‚‚ hTâ‚ƒ
  obtain âŸ¨hSTâ‚, -âŸ© :=
    of_symmDiff_compl_positive_negative hSâ‚.compl hTâ‚.compl âŸ¨hSâ‚ƒ, (compl_compl S).symm â–¸ hSâ‚‚âŸ©
      âŸ¨hTâ‚ƒ, (compl_compl T).symm â–¸ hTâ‚‚âŸ©
  refine' eq_of_posPart_eq_posPart _ hj
  ext1 i hi
  have hÎ¼â‚ : (jâ‚.posPart i).toReal = jâ‚.toSignedMeasure (i âˆ© Sá¶œ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hSâ‚.compl),
      show jâ‚.negPart (i âˆ© Sá¶œ) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚… â–¸ measure_mono (Set.inter_subset_right _ _)),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i S]
    rw [measure_union,
      show jâ‚.posPart (i âˆ© S) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚„ â–¸ measure_mono (Set.inter_subset_right _ _)),
      zero_add]
    Â· exact
        Set.disjoint_of_subset_left (Set.inter_subset_right _ _)
          (Set.disjoint_of_subset_right (Set.inter_subset_right _ _) disjoint_compl_right)
    Â· exact hi.inter hSâ‚.compl
  have hÎ¼â‚‚ : (jâ‚‚.posPart i).toReal = jâ‚‚.toSignedMeasure (i âˆ© Tá¶œ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hTâ‚.compl),
      show jâ‚‚.negPart (i âˆ© Tá¶œ) = 0 from
        nonpos_iff_eq_zero.1 (hTâ‚… â–¸ measure_mono (Set.inter_subset_right _ _)),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i T]
    rw [measure_union,
      show jâ‚‚.posPart (i âˆ© T) = 0 from
        nonpos_iff_eq_zero.1 (hTâ‚„ â–¸ measure_mono (Set.inter_subset_right _ _)),
      zero_add]
    Â· exact
        Set.disjoint_of_subset_left (Set.inter_subset_right _ _)
          (Set.disjoint_of_subset_right (Set.inter_subset_right _ _) disjoint_compl_right)
    Â· exact hi.inter hTâ‚.compl
  rw [â† ENNReal.toReal_eq_toReal (measure_ne_top _ _) (measure_ne_top _ _), hÎ¼â‚, hÎ¼â‚‚, â† hj]
  exact of_inter_eq_of_symmDiff_eq_zero_positive hSâ‚.compl hTâ‚.compl hi hSâ‚ƒ hTâ‚ƒ hSTâ‚","error:  function expected at
  Set.inter_subset_right ?m.66442
term has type
  ?m.66441 âˆˆ ?m.66440
error:  function expected at
  Set.inter_subset_right ?m.67049
term has type
  ?m.67048 âˆˆ ?m.67047
error:  function expected at
  Set.inter_subset_right ?m.67565
term has type
  ?m.67564 âˆˆ ?m.67563
error:  function expected at
  Set.inter_subset_right ?m.67623
term has type
  ?m.67622 âˆˆ ?m.67621
error:  function expected at
  Set.inter_subset_right ?m.68398
term has type
  ?m.68397 âˆˆ ?m.68396
error:  function expected at
  Set.inter_subset_right ?m.68871
term has type
  ?m.68870 âˆˆ ?m.68869
error:  function expected at
  Set.inter_subset_right ?m.69042
term has type
  ?m.69041 âˆˆ ?m.69040
error:  function expected at
  Set.inter_subset_right ?m.69100
term has type
  ?m.69099 âˆˆ ?m.69098",theorem toSignedMeasure_injective : Injective <| @JordanDecomposition.toSignedMeasure Î± _ ,":= by
  intro jâ‚ jâ‚‚ hj
  obtain âŸ¨S, hSâ‚, hSâ‚‚, hSâ‚ƒ, hSâ‚„, hSâ‚…âŸ© := jâ‚.exists_compl_positive_negative
  obtain âŸ¨T, hTâ‚, hTâ‚‚, hTâ‚ƒ, hTâ‚„, hTâ‚…âŸ© := jâ‚‚.exists_compl_positive_negative
  rw [â† hj] at hTâ‚‚ hTâ‚ƒ
  obtain âŸ¨hSTâ‚, -âŸ© :=
    of_symmDiff_compl_positive_negative hSâ‚.compl hTâ‚.compl âŸ¨hSâ‚ƒ, (compl_compl S).symm â–¸ hSâ‚‚âŸ©
      âŸ¨hTâ‚ƒ, (compl_compl T).symm â–¸ hTâ‚‚âŸ©
  refine eq_of_posPart_eq_posPart ?_ hj
  ext1 i hi
  have hÎ¼â‚ : (jâ‚.posPart i).toReal = jâ‚.toSignedMeasure (i âˆ© Sá¶œ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hSâ‚.compl),
      show jâ‚.negPart (i âˆ© Sá¶œ) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚… â–¸ measure_mono Set.inter_subset_right),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i S]
    rw [measure_union,
      show jâ‚.posPart (i âˆ© S) = 0 from
        nonpos_iff_eq_zero.1 (hSâ‚„ â–¸ measure_mono Set.inter_subset_right),
      zero_add]
    Â· refine
        Set.disjoint_of_subset_left Set.inter_subset_right
          (Set.disjoint_of_subset_right Set.inter_subset_right disjoint_compl_right)
    Â· exact hi.inter hSâ‚.compl
  have hÎ¼â‚‚ : (jâ‚‚.posPart i).toReal = jâ‚‚.toSignedMeasure (i âˆ© Tá¶œ) := by
    rw [toSignedMeasure, toSignedMeasure_sub_apply (hi.inter hTâ‚.compl),
      show jâ‚‚.negPart (i âˆ© Tá¶œ) = 0 from
        nonpos_iff_eq_zero.1 (hTâ‚… â–¸ measure_mono Set.inter_subset_right),
      ENNReal.zero_toReal, sub_zero]
    conv_lhs => rw [â† Set.inter_union_compl i T]
    rw [measure_union,
      show jâ‚‚.posPart (i âˆ© T) = 0 from
        nonpos_iff_eq_zero.1 (hTâ‚„ â–¸ measure_mono Set.inter_subset_right),
      zero_add]
    Â· exact
        Set.disjoint_of_subset_left Set.inter_subset_right
          (Set.disjoint_of_subset_right Set.inter_subset_right disjoint_compl_right)
    Â· exact hi.inter hTâ‚.compl
  rw [â† ENNReal.toReal_eq_toReal (measure_ne_top _ _) (measure_ne_top _ _), hÎ¼â‚, hÎ¼â‚‚, â† hj]
  exact of_inter_eq_of_symmDiff_eq_zero_positive hSâ‚.compl hTâ‚.compl hi hSâ‚ƒ hTâ‚ƒ hSTâ‚"
Mathlib/RingTheory/Polynomial/Cyclotomic/Expand.lean,Polynomial.cyclotomic_irreducible_pow_of_irreducible_pow,cyclotomic_irreducible_pow_of_irreducible_pow,c7bd9bd10c613e1788107ba753e252f069560f87,":= by
  rcases m.eq_zero_or_pos with (rfl | hm)
  Â· simpa using irreducible_X_sub_C (1 : R)
  obtain âŸ¨k, rflâŸ© := Nat.exists_eq_add_of_le hmn
  induction' k with k hk
  Â· simpa using h
  have : m + k â‰  0 := (add_pos_of_pos_of_nonneg hm k.zero_le).ne'
  rw [Nat.add_succ, pow_succ', â† cyclotomic_expand_eq_cyclotomic hp <| dvd_pow_self p this] at h
  exact hk (by omega) (of_irreducible_expand hp.ne_zero h)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  cyclotomic (p ^ (m + k) * p) ?R
case inr.intro.succ
p : â„•
hp : Nat.Prime p
R : Type u_1
instâœÂ¹ : CommRing R
instâœ : IsDomain R
m : â„•
hm : m > 0
k : â„•
hk : m â‰¤ m + k â†’ Irreducible (cyclotomic (p ^ (m + k)) R) â†’ Irreducible (cyclotomic (p ^ m) R)
hmn : m â‰¤ m + (k + 1)
h : Irreducible (cyclotomic (p * p ^ (m + k)) R)
this : m + k â‰  0
âŠ¢ Irreducible (cyclotomic (p ^ m) R)","theorem cyclotomic_irreducible_pow_of_irreducible_pow {p : â„•} (hp : Nat.Prime p) {R} [CommRing R]
    [IsDomain R] {n m : â„•} (hmn : m â‰¤ n) (h : Irreducible (cyclotomic (p ^ n) R)) :
    Irreducible (cyclotomic (p ^ m) R) ",":= by
  rcases m.eq_zero_or_pos with (rfl | hm)
  Â· simpa using irreducible_X_sub_C (1 : R)
  obtain âŸ¨k, rflâŸ© := Nat.exists_eq_add_of_le hmn
  induction' k with k hk
  Â· simpa using h
  have : m + k â‰  0 := (add_pos_of_pos_of_nonneg hm k.zero_le).ne'
  rw [Nat.add_succ, pow_succ, â† cyclotomic_expand_eq_cyclotomic hp <| dvd_pow_self p this] at h
  exact hk (by omega) (of_irreducible_expand hp.ne_zero h)"
Mathlib/Data/Finset/NAry.lean,Finset.card_dvd_card_imageâ‚‚_right,card_dvd_card_imageâ‚‚_right,1faa648b0b1359dec61956304fa51ac01bdbb219,":= by
  classical
  induction' s using Finset.induction with a s _ ih
  Â· simp
  specialize ih (forall_of_forall_insert hf)
    (hs.subset <| Set.image_subset _ <| coe_subset.2 <| subset_insert _ _)
  rw [imageâ‚‚_insert_left]
  by_cases h : Disjoint (image (f a) t) (imageâ‚‚ f s t)
  Â· rw [card_union_of_disjoint h]
    exact (card_image_of_injective _ <| hf _ <| mem_insert_self _ _).symm.dvd.add ih
  simp_rw [â† biUnion_image_left, disjoint_biUnion_right, not_forall] at h
  obtain âŸ¨b, hb, hâŸ© := h
  rwa [union_eq_right.2]
  exact (hs.eq (Set.mem_image_of_mem _ <| mem_insert_self _ _)
      (Set.mem_image_of_mem _ <| mem_insert_of_mem hb) h).trans_subset
    (image_subset_imageâ‚‚_right hb)","error:  invalid field 'add', the environment does not contain 'Dvd.dvd.add'
  Eq.dvd (Eq.symm (card_image_of_injective ?m.76954 (hf a (mem_insert_self a s))))
has type
  ?m.76954.card âˆ£ (image (f a) ?m.76954).card
error:  invalid field 'add', the environment does not contain 'Exists.add'
  Eq.dvd (Eq.symm (card_image_of_injective ?m.76954 (hf a (mem_insert_self a s))))
has type
  âˆƒ c, (image (f a) ?m.76954).card = ?m.76954.card * c","theorem card_dvd_card_imageâ‚‚_right (hf : âˆ€ a âˆˆ s, Injective (f a))
    (hs : ((fun a => t.image <| f a) '' s).PairwiseDisjoint id) : t.card âˆ£ (imageâ‚‚ f s t).card ",":= by
  classical
  induction' s using Finset.induction with a s _ ih
  Â· simp
  specialize ih (forall_of_forall_insert hf)
    (hs.subset <| Set.image_subset _ <| coe_subset.2 <| subset_insert _ _)
  rw [imageâ‚‚_insert_left]
  by_cases h : Disjoint (image (f a) t) (imageâ‚‚ f s t)
  Â· rw [card_union_of_disjoint h]
    exact Nat.dvd_add (card_image_of_injective _ <| hf _ <| mem_insert_self _ _).symm.dvd ih
  simp_rw [â† biUnion_image_left, disjoint_biUnion_right, not_forall] at h
  obtain âŸ¨b, hb, hâŸ© := h
  rwa [union_eq_right.2]
  exact (hs.eq (Set.mem_image_of_mem _ <| mem_insert_self _ _)
      (Set.mem_image_of_mem _ <| mem_insert_of_mem hb) h).trans_subset
    (image_subset_imageâ‚‚_right hb)"
Mathlib/Computability/Halting.lean,Partrec.cond,cond,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  let âŸ¨cf, efâŸ© := exists_code.1 hf
  let âŸ¨cg, egâŸ© := exists_code.1 hg
  ((eval_part.compâ‚‚ (Computable.cond hc (const cf) (const cg)) Computable.encode).bind
    ((@Computable.decode Ïƒ _).comp snd).ofOption.toâ‚‚).of_eq
    fun a => by cases c a <;> simp [ef, eg, encodek]","error:  application type mismatch
  Computable.cond hc
argument
  hc
has type
  Computable c : Prop
but is expected to have type
  Computable fun a â†¦ ?m.40632 : Prop
error:  application type mismatch
  c a
argument
  a
has type
  Code Ã— Code : Type
but is expected to have type
  Î± : Type u_1
error:  unsolved goals
case false
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Ïƒ : Type u_4
instâœÂ³ : Primcodable Î±
instâœÂ² : Primcodable Î²
instâœÂ¹ : Primcodable Î³
instâœ : Primcodable Ïƒ
c : Î± â†’ Bool
f g : Î± â†’. Ïƒ
hc : Computable c
hf : Partrec f
hg : Partrec g
cf : Code
ef : cf.eval = fun n â†¦ (â†‘(decode n)).bind fun a â†¦ Part.map encode (f a)
cg : Code
eg : cg.eval = fun n â†¦ (â†‘(decode n)).bind fun a â†¦ Part.map encode (g a)
a : Code Ã— Code
âŠ¢ (((bif ?m.40632 then a.1 else a.2).eval (?m.40573 a.1 a.2)).bind fun b â†¦ â†‘(decode b)) = ?m.228797 a

case true
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Ïƒ : Type u_4
instâœÂ³ : Primcodable Î±
instâœÂ² : Primcodable Î²
instâœÂ¹ : Primcodable Î³
instâœ : Primcodable Ïƒ
c : Î± â†’ Bool
f g : Î± â†’. Ïƒ
hc : Computable c
hf : Partrec f
hg : Partrec g
cf : Code
ef : cf.eval = fun n â†¦ (â†‘(decode n)).bind fun a â†¦ Part.map encode (f a)
cg : Code
eg : cg.eval = fun n â†¦ (â†‘(decode n)).bind fun a â†¦ Part.map encode (g a)
a : Code Ã— Code
âŠ¢ (((bif ?m.40632 then a.1 else a.2).eval (?m.40573 a.1 a.2)).bind fun b â†¦ â†‘(decode b)) = ?m.228797 a","theorem cond {c : Î± â†’ Bool} {f : Î± â†’. Ïƒ} {g : Î± â†’. Ïƒ} (hc : Computable c) (hf : Partrec f)
    (hg : Partrec g) : Partrec fun a => cond (c a) (f a) (g a) ",":=
  let âŸ¨cf, efâŸ© := exists_code.1 hf
  let âŸ¨cg, egâŸ© := exists_code.1 hg
  ((eval_part.comp (Computable.cond hc (const cf) (const cg)) Computable.encode).bind
    ((@Computable.decode Ïƒ _).comp snd).ofOption.toâ‚‚).of_eq
    fun a => by cases c a <;> simp [ef, eg, encodek]"
Mathlib/Topology/Order/ScottTopology.lean,Topology.IsScott.isOpen_iff_isUpperSet_and_dirSupInacc,isOpen_iff_isUpperSet_and_dirSupInacc,9f6d33884de569540c527b667d1573e1b97e1347,":= by
  rw [isOpen_iff_isUpperSet_and_scottHausdorff_open]
  refine and_congr_right fun h â†¦
    âŸ¨@IsScottHausdorff.dirSupInacc_of_isOpen _ _ scottHausdorff _ _, fun h' d dâ‚ dâ‚‚ _ dâ‚ƒ ha â†¦ ?_âŸ©
  obtain âŸ¨b, hbd, hbuâŸ© := h' dâ‚ dâ‚‚ dâ‚ƒ ha
  exact âŸ¨b, hbd, Subset.trans (inter_subset_left (Ici b) d) (h.Ici_subset hbu)âŸ©","error:  application type mismatch
  @IsScottHausdorff.dirSupInacc_of_isOpen ?m.27091 ?m.27092 scottHausdorff
argument
  scottHausdorff
has type
  (Î± : Type ?u.27093) â†’ [inst : Preorder Î±] â†’ TopologicalSpace Î± : Type (?u.27093 + 1)
but is expected to have type
  TopologicalSpace ?m.27091 : Type ?u.27090
error:  application type mismatch
  inter_subset_left (Ici b)
argument
  Ici b
has type
  Set Î± : Type u_1
but is expected to have type
  ?m.27950 âˆˆ ?m.27948 âˆ© ?m.27949 : Prop",lemma isOpen_iff_isUpperSet_and_dirSupInacc : IsOpen s â†” IsUpperSet s âˆ§ DirSupInacc s ,":= by
  rw [isOpen_iff_isUpperSet_and_scottHausdorff_open]
  refine and_congr_right fun h â†¦
    âŸ¨@IsScottHausdorff.dirSupInacc_of_isOpen _ _ (scottHausdorff Î±) _ _,
      fun h' d dâ‚ dâ‚‚ _ dâ‚ƒ ha â†¦ ?_âŸ©
  obtain âŸ¨b, hbd, hbuâŸ© := h' dâ‚ dâ‚‚ dâ‚ƒ ha
  exact âŸ¨b, hbd, Subset.trans inter_subset_left (h.Ici_subset hbu)âŸ©"
Mathlib/Data/List/Cycle.lean,List.next_getLast_cons,next_getLast_cons,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [next, get, â† dropLast_append_getLast (cons_ne_nil y l), hx, nextOr_concat]
  subst hx
  intro H
  obtain âŸ¨âŸ¨_ | k, hkâŸ©, hk'âŸ© := get_of_mem H
  Â· rw [â† Option.some_inj] at hk'
    rw [â† get?_eq_get, dropLast_eq_take, get?_take, get?_zero, head?_cons,
      Option.some_inj] at hk'
    Â· exact hy (Eq.symm hk')
    rw [length_cons, Nat.pred_succ]
    exact length_pos_of_mem (by assumption)
  suffices k + 1 = l.length by simp [this] at hk
  cases' l with hd tl
  Â· simp at hk
  Â· rw [nodup_iff_injective_get] at hl
    rw [length, Nat.succ_inj']
    refine Fin.val_eq_of_eq <| @hl âŸ¨k, Nat.lt_of_succ_lt <| by simpa using hkâŸ©
      âŸ¨tl.length, by simpâŸ© ?_
    rw [â† Option.some_inj] at hk'
    rw [â† get?_eq_get, dropLast_eq_take, get?_take, get?, get?_eq_get, Option.some_inj] at hk'
    Â· rw [hk']
      simp only [getLast_eq_get, length_cons, ge_iff_le, Nat.succ_sub_succ_eq_sub,
        nonpos_iff_eq_zero, add_eq_zero_iff, and_false, tsub_zero, get_cons_succ]
    simpa using hk","warning:  `List.get?_take` has been deprecated, use `List.getElem?_take` instead
warning:  `List.get?_take` has been deprecated, use `List.getElem?_take` instead
error:  unsolved goals
case h.intro.mk.succ.cons
Î± : Type u_1
instâœ : DecidableEq Î±
y : Î±
k : â„•
hd : Î±
tl : List Î±
hl : Function.Injective (hd :: tl).get
hâœ : (y :: hd :: tl).getLast â‹¯ âˆˆ hd :: tl
h : (y :: hd :: tl).getLast â‹¯ âˆˆ y :: hd :: tl
hy : (y :: hd :: tl).getLast â‹¯ â‰  y
H : (y :: hd :: tl).getLast â‹¯ âˆˆ (y :: hd :: tl).dropLast
hk : k + 1 < (y :: hd :: tl).dropLast.length
hk'âœ : (hd :: tl).get? k = some ((y :: hd :: tl).getLast â‹¯)
hk' : (hd :: tl).get âŸ¨k, â‹¯âŸ© = (y :: hd :: tl).getLast â‹¯
âŠ¢ (y :: hd :: tl).get âŸ¨tl.length + 1 - 0, â‹¯âŸ© = (hd :: tl).get âŸ¨tl.length, â‹¯âŸ©
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead","theorem next_getLast_cons (h : x âˆˆ l) (y : Î±) (h : x âˆˆ y :: l) (hy : x â‰  y)
    (hx : x = getLast (y :: l) (cons_ne_nil _ _)) (hl : Nodup l) : next (y :: l) x h = y ",":= by
  rw [next, get, â† dropLast_append_getLast (cons_ne_nil y l), hx, nextOr_concat]
  subst hx
  intro H
  obtain âŸ¨âŸ¨_ | k, hkâŸ©, hk'âŸ© := get_of_mem H
  Â· rw [â† Option.some_inj] at hk'
    rw [â† get?_eq_get, dropLast_eq_take, get?_eq_getElem?, getElem?_take, getElem?_cons_zero,
      Option.some_inj] at hk'
    Â· exact hy (Eq.symm hk')
    rw [length_cons, Nat.pred_succ]
    exact length_pos_of_mem (by assumption)
  suffices k + 1 = l.length by simp [this] at hk
  cases' l with hd tl
  Â· simp at hk
  Â· rw [nodup_iff_injective_get] at hl
    rw [length, Nat.succ_inj']
    refine Fin.val_eq_of_eq <| @hl âŸ¨k, Nat.lt_of_succ_lt <| by simpa using hkâŸ©
      âŸ¨tl.length, by simpâŸ© ?_
    rw [â† Option.some_inj] at hk'
    rw [â† get?_eq_get, dropLast_eq_take, get?_eq_getElem?, getElem?_take, getElem?_cons_succ,
      getElem?_eq_getElem, Option.some_inj] at hk'
    Â· rw [get_eq_getElem, hk']
      simp only [getLast_eq_get, length_cons, Nat.succ_eq_add_one, Nat.succ_sub_succ_eq_sub,
        Nat.sub_zero, get_eq_getElem, getElem_cons_succ]
    simpa using hk"
Mathlib/LinearAlgebra/QuadraticForm/Basic.lean,QuadraticForm.polar_neg_right,polar_neg_right,18f1e3ee387a3d040ba88fad8882f979755c163f,":= by
  rw [â† neg_one_smul R y, polar_smul_right, neg_one_smul]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  -1 â€¢ ?x
S : Type u_1
T : Type u_2
R : Type u_3
M : Type u_4
N : Type u_5
instâœÂ² : CommRing R
instâœÂ¹ : AddCommGroup M
instâœ : Module R M
Q : QuadraticForm R M
x y : M
âŠ¢ -1 * polar (â‡‘Q) x y = -polar (â‡‘Q) x y",theorem polar_neg_right (x y : M) : polar Q x (-y) = -polar Q x y ,":= by
  rw [â† neg_one_smul R y, polar_smul_right, neg_one_mul]"
Mathlib/Analysis/BoxIntegral/Box/SubboxInduction.lean,BoxIntegral.Box.subbox_induction_on',subbox_induction_on',20100f1475ea197bf6dea643b6ee137219455a51,":= by
  by_contra hpI
  replace H_ind := fun J hJ â†¦ not_imp_not.2 (H_ind J hJ)
  simp only [exists_imp, not_forall] at H_ind
  choose! s hs using H_ind
  set J : â„• â†’ Box Î¹ := fun m â†¦ (fun J â†¦ splitCenterBox J (s J))^[m] I
  have J_succ : âˆ€ m, J (m + 1) = splitCenterBox (J m) (s <| J m) :=
    fun m â†¦ iterate_succ_apply' _ _ _
  have hJmono : Antitone J :=
    antitone_nat_of_succ_le fun n â†¦ by simpa [J_succ] using splitCenterBox_le _ _
  have hJle : âˆ€ m, J m â‰¤ I := fun m â†¦ hJmono (zero_le m)
  have hJp : âˆ€ m, Â¬p (J m) :=
    fun m â†¦ Nat.recOn m hpI fun m â†¦ by simpa only [J_succ] using hs (J m) (hJle m)
  have hJsub : âˆ€ m i, (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m := by
    intro m i
    induction' m with m ihm
    Â· simp [Nat.zero_eq]
    simp only [pow_succ', J_succ, upper_sub_lower_splitCenterBox, ihm, div_div]
  have h0 : J 0 = I := rfl
  clear_value J
  clear hpI hs J_succ s
  set z : Î¹ â†’ â„ := â¨† m, (J m).lower
  have hzJ : âˆ€ m, z âˆˆ Box.Icc (J m) :=
    mem_iInter.1 (ciSup_mem_Inter_Icc_of_antitone_Icc
      ((@Box.Icc Î¹).monotone.comp_antitone hJmono) fun m â†¦ (J m).lower_le_upper)
  have hJl_mem : âˆ€ m, (J m).lower âˆˆ Box.Icc I := fun m â†¦ le_iff_Icc.1 (hJle m) (J m).lower_mem_Icc
  have hJu_mem : âˆ€ m, (J m).upper âˆˆ Box.Icc I := fun m â†¦ le_iff_Icc.1 (hJle m) (J m).upper_mem_Icc
  have hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“ z) :=
    tendsto_atTop_ciSup (antitone_lower.comp hJmono) âŸ¨I.upper, fun x âŸ¨m, hmâŸ© â†¦ hm â–¸ (hJl_mem m).2âŸ©
  have hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“ z) := by
    suffices Tendsto (fun m â†¦ (J m).upper - (J m).lower) atTop (ğ“ 0) by simpa using hJlz.add this
    refine' tendsto_pi_nhds.2 fun i â†¦ _
    simpa [hJsub] using
      tendsto_const_nhds.div_atTop (tendsto_pow_atTop_atTop_of_one_lt _root_.one_lt_two)
  replace hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“[Icc I.lower I.upper] z)
  Â· exact
      tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJlz (eventually_of_forall hJl_mem)
  replace hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“[Icc I.lower I.upper] z)
  Â· exact
      tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJuz (eventually_of_forall hJu_mem)
  rcases H_nhds z (h0 â–¸ hzJ 0) with âŸ¨U, hUz, hUâŸ©
  rcases(tendsto_lift'.1 (hJlz.Icc hJuz) U hUz).exists with âŸ¨m, hUmâŸ©
  exact hJp m (hU (J m) (hJle m) m (hzJ m) hUm (hJsub m))","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case zero
Î¹ : Type u_1
Iâœ Jâœ : Box Î¹
p : Box Î¹ â†’ Prop
I : Box Î¹
H_nhds :
  âˆ€ z âˆˆ Box.Icc I,
    âˆƒ U âˆˆ ğ“[Box.Icc I] z,
      âˆ€ J â‰¤ I,
        âˆ€ (m : â„•),
          z âˆˆ Box.Icc J â†’ Box.Icc J âŠ† U â†’ (âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J
hpI : Â¬p I
s : Box Î¹ â†’ Set Î¹
hs : âˆ€ J â‰¤ I, Â¬p J â†’ Â¬p (J.splitCenterBox (s J))
J : â„• â†’ Box Î¹ := fun m â†¦ (fun J â†¦ J.splitCenterBox (s J))^[m] I
J_succ : âˆ€ (m : â„•), J (m + 1) = (J m).splitCenterBox (s (J m))
hJmono : Antitone J
hJle : âˆ€ (m : â„•), J m â‰¤ I
hJp : âˆ€ (m : â„•), Â¬p (J m)
i : Î¹
âŠ¢ (J 0).upper i - (J 0).lower i = I.upper i - I.lower i
error:  unsolved goals
case succ
Î¹ : Type u_1
Iâœ Jâœ : Box Î¹
p : Box Î¹ â†’ Prop
I : Box Î¹
H_nhds :
  âˆ€ z âˆˆ Box.Icc I,
    âˆƒ U âˆˆ ğ“[Box.Icc I] z,
      âˆ€ J â‰¤ I,
        âˆ€ (m : â„•),
          z âˆˆ Box.Icc J â†’ Box.Icc J âŠ† U â†’ (âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J
hpI : Â¬p I
s : Box Î¹ â†’ Set Î¹
hs : âˆ€ J â‰¤ I, Â¬p J â†’ Â¬p (J.splitCenterBox (s J))
J : â„• â†’ Box Î¹ := fun m â†¦ (fun J â†¦ J.splitCenterBox (s J))^[m] I
J_succ : âˆ€ (m : â„•), J (m + 1) = (J m).splitCenterBox (s (J m))
hJmono : Antitone J
hJle : âˆ€ (m : â„•), J m â‰¤ I
hJp : âˆ€ (m : â„•), Â¬p (J m)
i : Î¹
m : â„•
ihm : (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m
âŠ¢ (I.upper i - I.lower i) / (2 ^ m * 2) = (I.upper i - I.lower i) / (2 * 2 ^ m)
error:  unsolved goals
Î¹ : Type u_1
Iâœ Jâœ : Box Î¹
p : Box Î¹ â†’ Prop
I : Box Î¹
H_nhds :
  âˆ€ z âˆˆ Box.Icc I,
    âˆƒ U âˆˆ ğ“[Box.Icc I] z,
      âˆ€ J â‰¤ I,
        âˆ€ (m : â„•),
          z âˆˆ Box.Icc J â†’ Box.Icc J âŠ† U â†’ (âˆ€ (i : Î¹), J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J
J : â„• â†’ Box Î¹
hJmono : Antitone J
hJle : âˆ€ (m : â„•), J m â‰¤ I
hJp : âˆ€ (m : â„•), Â¬p (J m)
hJsub : âˆ€ (m : â„•) (i : Î¹), (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m
h0 : J 0 = I
z : Î¹ â†’ â„ := â¨† m, (J m).lower
hzJ : âˆ€ (m : â„•), z âˆˆ Box.Icc (J m)
hJl_mem : âˆ€ (m : â„•), (J m).lower âˆˆ Box.Icc I
hJu_mem : âˆ€ (m : â„•), (J m).upper âˆˆ Box.Icc I
hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“ z)
hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“[Set.Icc I.lower I.upper] z)
âŠ¢ False","theorem subbox_induction_on' {p : Box Î¹ â†’ Prop} (I : Box Î¹)
    (H_ind : âˆ€ J â‰¤ I, (âˆ€ s, p (splitCenterBox J s)) â†’ p J)
    (H_nhds : âˆ€ z âˆˆ Box.Icc I, âˆƒ U âˆˆ ğ“[Box.Icc I] z, âˆ€ J â‰¤ I, âˆ€ (m : â„•), z âˆˆ Box.Icc J â†’
      Box.Icc J âŠ† U â†’ (âˆ€ i, J.upper i - J.lower i = (I.upper i - I.lower i) / 2 ^ m) â†’ p J) :
    p I ",":= by
  by_contra hpI
  replace H_ind := fun J hJ â†¦ not_imp_not.2 (H_ind J hJ)
  simp only [exists_imp, not_forall] at H_ind
  choose! s hs using H_ind
  set J : â„• â†’ Box Î¹ := fun m â†¦ (fun J â†¦ splitCenterBox J (s J))^[m] I
  have J_succ : âˆ€ m, J (m + 1) = splitCenterBox (J m) (s <| J m) :=
    fun m â†¦ iterate_succ_apply' _ _ _
  have hJmono : Antitone J :=
    antitone_nat_of_succ_le fun n â†¦ by simpa [J_succ] using splitCenterBox_le _ _
  have hJle : âˆ€ m, J m â‰¤ I := fun m â†¦ hJmono (zero_le m)
  have hJp : âˆ€ m, Â¬p (J m) :=
    fun m â†¦ Nat.recOn m hpI fun m â†¦ by simpa only [J_succ] using hs (J m) (hJle m)
  have hJsub : âˆ€ m i, (J m).upper i - (J m).lower i = (I.upper i - I.lower i) / 2 ^ m := by
    intro m i
    induction' m with m ihm
    Â· simp [J, Nat.zero_eq]
    simp only [pow_succ, J_succ, upper_sub_lower_splitCenterBox, ihm, div_div]
  have h0 : J 0 = I := rfl
  clear_value J
  clear hpI hs J_succ s
  set z : Î¹ â†’ â„ := â¨† m, (J m).lower
  have hzJ : âˆ€ m, z âˆˆ Box.Icc (J m) :=
    mem_iInter.1 (ciSup_mem_iInter_Icc_of_antitone_Icc
      ((@Box.Icc Î¹).monotone.comp_antitone hJmono) fun m â†¦ (J m).lower_le_upper)
  have hJl_mem : âˆ€ m, (J m).lower âˆˆ Box.Icc I := fun m â†¦ le_iff_Icc.1 (hJle m) (J m).lower_mem_Icc
  have hJu_mem : âˆ€ m, (J m).upper âˆˆ Box.Icc I := fun m â†¦ le_iff_Icc.1 (hJle m) (J m).upper_mem_Icc
  have hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“ z) :=
    tendsto_atTop_ciSup (antitone_lower.comp hJmono) âŸ¨I.upper, fun x âŸ¨m, hmâŸ© â†¦ hm â–¸ (hJl_mem m).2âŸ©
  have hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“ z) := by
    suffices Tendsto (fun m â†¦ (J m).upper - (J m).lower) atTop (ğ“ 0) by simpa using hJlz.add this
    refine tendsto_pi_nhds.2 fun i â†¦ ?_
    simpa [hJsub] using
      tendsto_const_nhds.div_atTop (tendsto_pow_atTop_atTop_of_one_lt _root_.one_lt_two)
  replace hJlz : Tendsto (fun m â†¦ (J m).lower) atTop (ğ“[Icc I.lower I.upper] z) :=
    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJlz (eventually_of_forall hJl_mem)
  replace hJuz : Tendsto (fun m â†¦ (J m).upper) atTop (ğ“[Icc I.lower I.upper] z) :=
    tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ hJuz (eventually_of_forall hJu_mem)
  rcases H_nhds z (h0 â–¸ hzJ 0) with âŸ¨U, hUz, hUâŸ©
  rcases (tendsto_lift'.1 (hJlz.Icc hJuz) U hUz).exists with âŸ¨m, hUmâŸ©
  exact hJp m (hU (J m) (hJle m) m (hzJ m) hUm (hJsub m))"
Mathlib/Analysis/Convex/Measure.lean,Convex.addHaar_frontier,addHaar_frontier,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  cases' ne_or_eq (affineSpan â„ s) âŠ¤ with hspan hspan
  Â· refine' measure_mono_null _ (addHaar_affineSubspace _ _ hspan)
    exact frontier_subset_closure.trans
      (closure_minimal (subset_affineSpan _ _) (affineSpan â„ s).closed_of_finiteDimensional)
  rw [â† hs.interior_nonempty_iff_affineSpan_eq_top] at hspan
  rcases hspan with âŸ¨x, hxâŸ©
  suffices H : âˆ€ t : Set E, Convex â„ t â†’ x âˆˆ interior t â†’ IsBounded t â†’ Î¼ (frontier t) = 0
  Â· let B : â„• â†’ Set E := fun n => ball x (n + 1)
    have : Î¼ (â‹ƒ n : â„•, frontier (s âˆ© B n)) = 0 := by
      refine' measure_iUnion_null fun n =>
        H _ (hs.inter (convex_ball _ _)) _ (isBounded_ball.subset (inter_subset_right _ _))
      rw [interior_inter, isOpen_ball.interior_eq]
      exact âŸ¨hx, mem_ball_self (add_pos_of_nonneg_of_pos n.cast_nonneg zero_lt_one)âŸ©
    refine' measure_mono_null (fun y hy => _) this; clear this
    set N : â„• := âŒŠdist y xâŒ‹â‚Š
    refine' mem_iUnion.2 âŸ¨N, _âŸ©
    have hN : y âˆˆ B N := by simp [Nat.lt_floor_add_one]
    suffices : y âˆˆ frontier (s âˆ© B N) âˆ© B N; exact this.1
    rw [frontier_inter_open_inter isOpen_ball]
    exact âŸ¨hy, hNâŸ©
  intro s hs hx hb
  replace hb : Î¼ (interior s) â‰  âˆ := (hb.subset interior_subset).measure_lt_top.ne
  suffices Î¼ (closure s) â‰¤ Î¼ (interior s) by
    rwa [frontier, measure_diff interior_subset_closure isOpen_interior.measurableSet hb,
      tsub_eq_zero_iff_le]
  set d : â„• := FiniteDimensional.finrank â„ E
  have : âˆ€ r : â„â‰¥0, 1 < r â†’ Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) := fun r hr â†¦ by
    refine' (measure_mono <|
      hs.closure_subset_image_homothety_interior_of_one_lt hx r hr).trans_eq _
    rw [addHaar_image_homothety, â† NNReal.coe_pow, NNReal.abs_eq, ENNReal.ofReal_coe_nnreal]
  have : âˆ€á¶  (r : â„â‰¥0) in ğ“[>] 1, Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) :=
    mem_of_superset self_mem_nhdsWithin this
  refine' ge_of_tendsto _ this
  refine' (((ENNReal.continuous_mul_const hb).comp
    (ENNReal.continuous_coe.comp (continuous_pow d))).tendsto' _ _ _).mono_left nhdsWithin_le_nhds
  simp",error:  unexpected token 'Â·'; expected 'by' or 'from',theorem addHaar_frontier (hs : Convex â„ s) : Î¼ (frontier s) = 0 ,":= by
  cases' ne_or_eq (affineSpan â„ s) âŠ¤ with hspan hspan
  Â· refine measure_mono_null ?_ (addHaar_affineSubspace _ _ hspan)
    exact frontier_subset_closure.trans
      (closure_minimal (subset_affineSpan _ _) (affineSpan â„ s).closed_of_finiteDimensional)
  rw [â† hs.interior_nonempty_iff_affineSpan_eq_top] at hspan
  rcases hspan with âŸ¨x, hxâŸ©
  suffices H : âˆ€ t : Set E, Convex â„ t â†’ x âˆˆ interior t â†’ IsBounded t â†’ Î¼ (frontier t) = 0 by
    let B : â„• â†’ Set E := fun n => ball x (n + 1)
    have : Î¼ (â‹ƒ n : â„•, frontier (s âˆ© B n)) = 0 := by
      refine measure_iUnion_null fun n =>
        H _ (hs.inter (convex_ball _ _)) ?_ (isBounded_ball.subset inter_subset_right)
      rw [interior_inter, isOpen_ball.interior_eq]
      exact âŸ¨hx, mem_ball_self (add_pos_of_nonneg_of_pos n.cast_nonneg zero_lt_one)âŸ©
    refine measure_mono_null (fun y hy => ?_) this; clear this
    set N : â„• := âŒŠdist y xâŒ‹â‚Š
    refine mem_iUnion.2 âŸ¨N, ?_âŸ©
    have hN : y âˆˆ B N := by simp [B, N, Nat.lt_floor_add_one]
    suffices y âˆˆ frontier (s âˆ© B N) âˆ© B N from this.1
    rw [frontier_inter_open_inter isOpen_ball]
    exact âŸ¨hy, hNâŸ©
  intro s hs hx hb
  replace hb : Î¼ (interior s) â‰  âˆ := (hb.subset interior_subset).measure_lt_top.ne
  suffices Î¼ (closure s) â‰¤ Î¼ (interior s) by
    rwa [frontier, measure_diff interior_subset_closure isOpen_interior.measurableSet hb,
      tsub_eq_zero_iff_le]
  set d : â„• := FiniteDimensional.finrank â„ E
  have : âˆ€ r : â„â‰¥0, 1 < r â†’ Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) := fun r hr â†¦ by
    refine (measure_mono <|
      hs.closure_subset_image_homothety_interior_of_one_lt hx r hr).trans_eq ?_
    rw [addHaar_image_homothety, â† NNReal.coe_pow, NNReal.abs_eq, ENNReal.ofReal_coe_nnreal]
  have : âˆ€á¶  (r : â„â‰¥0) in ğ“[>] 1, Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) :=
    mem_of_superset self_mem_nhdsWithin this
  refine ge_of_tendsto ?_ this
  refine (((ENNReal.continuous_mul_const hb).comp
    (ENNReal.continuous_coe.comp (continuous_pow d))).tendsto' _ _ ?_).mono_left nhdsWithin_le_nhds
  simp"
Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean,Real.BohrMollerup.tendsto_logGammaSeq,tendsto_logGammaSeq,602092f78ff87fff86ac12b6b530300e1fc064a3,":= by
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le' ?_ tendsto_const_nhds ?_ ?_
  pick_goal 4
  Â· show âˆ€á¶  n : â„• in atTop, logGammaSeq x n â‰¤ f x - f 1
    filter_upwards [eventually_ne_atTop 0] with n hn using
      le_sub_iff_add_le'.mpr (ge_logGammaSeq hf_conv hf_feq hx hn)
  pick_goal 3
  Â· show âˆ€á¶  n : â„• in atTop, f x - f 1 - x * (log (n + 1) - log n) â‰¤ logGammaSeq x n
    filter_upwards with n
    rw [sub_le_iff_le_add', sub_le_iff_le_add']
    convert le_logGammaSeq hf_conv (@hf_feq) hx hx' n using 1
    ring
  Â· have : f x - f 1 = f x - f 1 - x * 0 := by ring
    nth_rw 2 [this]
    exact Tendsto.sub tendsto_const_nhds (tendsto_log_nat_add_one_sub_log.const_mul _)","error:  don't know how to synthesize implicit argument 'g'
  @tendsto_of_tendsto_of_tendsto_of_le_of_le' â„ â„• UniformSpace.toTopologicalSpace instPreorder instOrderTopologyReal
    (logGammaSeq x) ?m.95195 (fun x_1 â†¦ f x - f 1) atTop (f x - f 1) ?m.95199 tendsto_const_nhds ?m.95422 ?m.95423
context:
f : â„ â†’ â„
x : â„
n : â„•
hf_conv : ConvexOn â„ (Ioi 0) f
hf_feq : âˆ€ {y : â„}, 0 < y â†’ f (y + 1) = f y + log y
hx : 0 < x
hx' : x â‰¤ 1
âŠ¢ â„• â†’ â„
error:  unsolved goals
f : â„ â†’ â„
x : â„
n : â„•
hf_conv : ConvexOn â„ (Ioi 0) f
hf_feq : âˆ€ {y : â„}, 0 < y â†’ f (y + 1) = f y + log y
hx : 0 < x
hx' : x â‰¤ 1
âŠ¢ Tendsto (logGammaSeq x) atTop (ğ“ (f x - f 1))","theorem tendsto_logGammaSeq_of_le_one (hf_conv : ConvexOn â„ (Ioi 0) f)
    (hf_feq : âˆ€ {y : â„}, 0 < y â†’ f (y + 1) = f y + log y) (hx : 0 < x) (hx' : x â‰¤ 1) :
    Tendsto (logGammaSeq x) atTop (ğ“ <| f x - f 1) ",":= by
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le' (f := logGammaSeq x)
    (g := fun n â†¦ f x - f 1 - x * (log (n + 1) - log n)) ?_ tendsto_const_nhds ?_ ?_
  Â· have : f x - f 1 = f x - f 1 - x * 0 := by ring
    nth_rw 2 [this]
    exact Tendsto.sub tendsto_const_nhds (tendsto_log_nat_add_one_sub_log.const_mul _)
  Â· filter_upwards with n
    rw [sub_le_iff_le_add', sub_le_iff_le_add']
    convert le_logGammaSeq hf_conv (@hf_feq) hx hx' n using 1
    ring
  Â· show âˆ€á¶  n : â„• in atTop, logGammaSeq x n â‰¤ f x - f 1
    filter_upwards [eventually_ne_atTop 0] with n hn using
      le_sub_iff_add_le'.mpr (ge_logGammaSeq hf_conv hf_feq hx hn)"
Mathlib/CategoryTheory/Limits/Shapes/CommSq.lean,CategoryTheory.IsPullback.of_isBilimit,of_isBilimit,25527279cf0fc38a336bb3b3d913a403b5f38ac1,":= by
  convert IsPullback.of_is_product' h.isLimit HasZeroObject.zeroIsTerminal
    <;> subsingleton","error:  unknown tactic
error:  unsolved goals
case h.e'_9
C : Type uâ‚
instâœÂ² : Category.{vâ‚, uâ‚} C
P X Y Z : C
fst : P âŸ¶ X
snd : P âŸ¶ Y
f : X âŸ¶ Z
g : Y âŸ¶ Z
instâœÂ¹ : HasZeroObject C
instâœ : HasZeroMorphisms C
b : BinaryBicone X Y
h : b.IsBilimit
âŠ¢ 0 = HasZeroObject.zeroIsTerminal.from X

case h.e'_10
C : Type uâ‚
instâœÂ² : Category.{vâ‚, uâ‚} C
P X Y Z : C
fst : P âŸ¶ X
snd : P âŸ¶ Y
f : X âŸ¶ Z
g : Y âŸ¶ Z
instâœÂ¹ : HasZeroObject C
instâœ : HasZeroMorphisms C
b : BinaryBicone X Y
h : b.IsBilimit
âŠ¢ 0 = HasZeroObject.zeroIsTerminal.from Y","theorem of_isBilimit {b : BinaryBicone X Y} (h : b.IsBilimit) :
    IsPullback b.fst b.snd (0 : X âŸ¶ 0) (0 : Y âŸ¶ 0) ",":= by
  convert IsPullback.of_is_product' h.isLimit HasZeroObject.zeroIsTerminal
    <;> apply Subsingleton.elim"
Mathlib/CategoryTheory/Preadditive/Yoneda/Injective.lean,CategoryTheory.Injective.injective_iff_preservesEpimorphisms_preadditiveYoneda_obj,injective_iff_preservesEpimorphisms_preadditiveYoneda_obj,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [injective_iff_preservesEpimorphisms_yoneda_obj]
  refine'
    âŸ¨fun h : (preadditiveYoneda.obj J â‹™ (forget AddCommGroupCat)).PreservesEpimorphisms => _, _âŸ©
  Â· exact
      Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveYoneda.obj J) (forget _)
  Â· intro
    exact (inferInstance : (preadditiveYoneda.obj J â‹™ forget _).PreservesEpimorphisms)","error:  unknown identifier 'AddCommGroupCat'
error:  failed to synthesize
  (preadditiveYoneda.obj J â‹™ forget AddCommGrp).PreservesEpimorphisms
use `set_option diagnostics true` to get diagnostic information
error:  no goals to be solved","theorem injective_iff_preservesEpimorphisms_preadditiveYoneda_obj (J : C) :
    Injective J â†” (preadditiveYoneda.obj J).PreservesEpimorphisms ",":= by
  rw [injective_iff_preservesEpimorphisms_yoneda_obj]
  refine
    âŸ¨fun h : (preadditiveYoneda.obj J â‹™ (forget AddCommGrp)).PreservesEpimorphisms => ?_, ?_âŸ©
  Â· exact
      Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveYoneda.obj J) (forget _)
  Â· intro
    exact (inferInstance : (preadditiveYoneda.obj J â‹™ forget _).PreservesEpimorphisms)"
Mathlib/MeasureTheory/Measure/Haar/Unique.lean,MeasureTheory.Measure.haarScalarFactor_self,haarScalarFactor_self,63aaa8cc21050b7a5cb193c6764569918728723b,":= by
  by_cases hG : LocallyCompactSpace G; swap
  Â· simp [haarScalarFactor, hG]
  obtain âŸ¨âŸ¨g, g_contâŸ©, g_comp, g_nonneg, g_oneâŸ© :
    âˆƒ (g : C(G, â„)), HasCompactSupport g âˆ§ 0 â‰¤ g âˆ§ g 1 â‰  0 := exists_continuous_nonneg_pos 1
  have Z := integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼ Î¼ g_cont g_comp
  have int_g_pos : 0 < âˆ« x, g x âˆ‚Î¼ := by
    apply (integral_pos_iff_support_of_nonneg g_nonneg _).2
    Â· exact IsOpen.measure_pos Î¼ g_cont.isOpen_support âŸ¨1, g_oneâŸ©
    Â· exact g_cont.integrable_of_hasCompactSupport g_comp
  rw [integral_smul_nnreal_measure, eq_comm] at Z
  change (haarScalarFactor Î¼ Î¼ : â„) * âˆ« (x : G), g x âˆ‚Î¼ = âˆ« (x : G), g x âˆ‚Î¼ at Z
  simpa [mul_eq_rightâ‚€ (Mâ‚€ := â„), int_g_pos.ne'] using Z

  @[to_additive]","error:  unexpected token '@['; expected 'abbrev', 'alias', 'axiom', 'binder_predicate', 'builtin_initialize', 'class', 'def', 'elab', 'elab_rules', 'example', 'inductive', 'infix', 'infixl', 'infixr', 'initialize', 'instance', 'irreducible_def', 'lemma', 'macro', 'macro_rules', 'notation', 'notation3', 'opaque', 'postfix', 'prefix', 'proof_wanted', 'scoped', 'structure', 'syntax' or 'theorem'","lemma haarScalarFactor_self (Î¼ : Measure G) [IsHaarMeasure Î¼] :
    haarScalarFactor Î¼ Î¼ = 1 ",":= by
  by_cases hG : LocallyCompactSpace G; swap
  Â· simp [haarScalarFactor, hG]
  obtain âŸ¨âŸ¨g, g_contâŸ©, g_comp, g_nonneg, g_oneâŸ© :
    âˆƒ g : C(G, â„), HasCompactSupport g âˆ§ 0 â‰¤ g âˆ§ g 1 â‰  0 := exists_continuous_nonneg_pos 1
  have int_g_ne_zero : âˆ« x, g x âˆ‚Î¼ â‰  0 :=
    ne_of_gt (g_cont.integral_pos_of_hasCompactSupport_nonneg_nonzero g_comp g_nonneg g_one)
  apply NNReal.coe_injective
  calc
    haarScalarFactor Î¼ Î¼ = (âˆ« x, g x âˆ‚Î¼) / âˆ« x, g x âˆ‚Î¼ :=
      haarScalarFactor_eq_integral_div _ _ g_cont g_comp int_g_ne_zero
    _ = 1 := div_self int_g_ne_zero"
Mathlib/MeasureTheory/Group/Convolution.lean,MeasureTheory.Measure.mconv_comm,mconv_comm,0f75c4a28ad42f2fa1265303fe3992358964fd85,":= by
  unfold mconv
  rw [â† prod_swap, map_map (by fun_prop)]
  Â· simp [Function.comp_def, mul_comm]
  fun_prop","error:  `fun_prop` was unable to prove `Measurable Prod.swap`

Try running with discharger `fun_prop (disch:=aesop)` or with a different discharger tactic like `assumption`, `linarith`, `omega`.
Sometimes it is useful to run `fun_prop (disch:=trace_state; sorry)` which will print all the necessary subgoals for `fun_prop` to succeed.

Potential issues to fix:
  No theorems found for `Prod.swap` in order to prove Measurable fun a â†¦ a.swap
  Failed to synthesize instance TopologicalSpace (M Ã— M) when applying theorem measurable_of_continuousOn_compl_singleton.
  Failed to synthesize instance TopologicalSpace (M Ã— M) when applying theorem Continuous.measurable.

For more detailed information use `set_option trace.Meta.Tactic.fun_prop true`","theorem mconv_comm {M : Type*} [CommMonoid M] [MeasurableSpace M] [MeasurableMulâ‚‚ M] (Î¼ : Measure M)
    (Î½ : Measure M) [SFinite Î¼] [SFinite Î½] : Î¼ âˆ— Î½ = Î½ âˆ— Î¼ ",":= by
  unfold mconv
  rw [â† prod_swap, map_map]
  Â· simp [Function.comp_def, mul_comm]
  Â· 
    exact Measurable.mul measurable_fst measurable_snd
  measurability"
Mathlib/Order/Filter/NAry.lean,Filter.mapâ‚‚_distrib_le_right,mapâ‚‚_distrib_le_right,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rintro s âŸ¨tâ‚, âŸ¨u, hu, wâ‚, hwâ‚, htâ‚âŸ©, tâ‚‚, âŸ¨v, hv, wâ‚‚, hwâ‚‚, htâ‚‚âŸ©, hsâŸ©
  refine' âŸ¨_, image2_mem_mapâ‚‚ hu hv, wâ‚ âˆ© wâ‚‚, inter_mem hwâ‚ hwâ‚‚, _âŸ©
  refine' (image2_distrib_subset_right h_distrib).trans ((image2_subset _ _).trans hs)
  Â· exact (image2_subset_left <| inter_subset_left _ _).trans htâ‚
  Â· exact (image2_subset_left <| inter_subset_right _ _).trans htâ‚‚","error:  function expected at
  inter_subset_left ?m.17895
term has type
  ?m.17894 âˆˆ ?m.17892
error:  function expected at
  inter_subset_right ?m.18014
term has type
  ?m.18013 âˆˆ ?m.18012","theorem mapâ‚‚_distrib_le_right {m : Î´ â†’ Î³ â†’ Îµ} {n : Î± â†’ Î² â†’ Î´} {mâ‚ : Î± â†’ Î³ â†’ Î±'} {mâ‚‚ : Î² â†’ Î³ â†’ Î²'}
    {n' : Î±' â†’ Î²' â†’ Îµ} (h_distrib : âˆ€ a b c, m (n a b) c = n' (mâ‚ a c) (mâ‚‚ b c)) :
    mapâ‚‚ m (mapâ‚‚ n f g) h â‰¤ mapâ‚‚ n' (mapâ‚‚ mâ‚ f h) (mapâ‚‚ mâ‚‚ g h) ",":= by
  rintro s âŸ¨tâ‚, âŸ¨u, hu, wâ‚, hwâ‚, htâ‚âŸ©, tâ‚‚, âŸ¨v, hv, wâ‚‚, hwâ‚‚, htâ‚‚âŸ©, hsâŸ©
  refine âŸ¨_, image2_mem_mapâ‚‚ hu hv, wâ‚ âˆ© wâ‚‚, inter_mem hwâ‚ hwâ‚‚, ?_âŸ©
  refine (image2_distrib_subset_right h_distrib).trans ((image2_subset ?_ ?_).trans hs)
  Â· exact (image2_subset_left inter_subset_left).trans htâ‚
  Â· exact (image2_subset_left inter_subset_right).trans htâ‚‚"
Mathlib/Analysis/SpecialFunctions/NonIntegrable.lean,not_integrableOn_of_tendsto_norm_atTop_of_deriv_isBigO_filter,not_integrableOn_of_tendsto_norm_atTop_of_deriv_isBigO_filter,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  intro hgi
  obtain âŸ¨C, hCâ‚€, s, hsl, hsub, hfd, hgâŸ© :
    âˆƒ (C : â„) (_ : 0 â‰¤ C), âˆƒ s âˆˆ l, (âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, [[x, y]] âŠ† k) âˆ§
      (âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, âˆ€ z âˆˆ [[x, y]], DifferentiableAt â„ f z) âˆ§
        âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, âˆ€ z âˆˆ [[x, y]], â€–deriv f zâ€– â‰¤ C * â€–g zâ€– := by
    rcases hfg.exists_nonneg with âŸ¨C, Câ‚€, hCâŸ©
    have h : âˆ€á¶  x : â„ Ã— â„ in l.prod l,
        âˆ€ y âˆˆ [[x.1, x.2]], (DifferentiableAt â„ f y âˆ§ â€–deriv f yâ€– â‰¤ C * â€–g yâ€–) âˆ§ y âˆˆ k :=
      (tendsto_fst.uIcc tendsto_snd).eventually ((hd.and hC.bound).and hl).smallSets
    rcases mem_prod_self_iff.1 h with âŸ¨s, hsl, hsâŸ©
    simp only [prod_subset_iff, mem_setOf_eq] at hs
    exact âŸ¨C, Câ‚€, s, hsl, fun x hx y hy z hz => (hs x hx y hy z hz).2, fun x hx y hy z hz =>
      (hs x hx y hy z hz).1.1, fun x hx y hy z hz => (hs x hx y hy z hz).1.2âŸ©
  replace hgi : IntegrableOn (fun x â†¦ C * â€–g xâ€–) k := by exact hgi.norm.smul C
  obtain âŸ¨c, hc, d, hd, hltâŸ© : âˆƒ c âˆˆ s, âˆƒ d âˆˆ s, (â€–f câ€– + âˆ« y in k, C * â€–g yâ€–) < â€–f dâ€– := by
    rcases Filter.nonempty_of_mem hsl with âŸ¨c, hcâŸ©
    have : âˆ€á¶  x in l, (â€–f câ€– + âˆ« y in k, C * â€–g yâ€–) < â€–f xâ€– :=
      hf.eventually (eventually_gt_atTop _)
    exact âŸ¨c, hc, (this.and hsl).exists.imp fun d hd => âŸ¨hd.2, hd.1âŸ©âŸ©
  specialize hsub c hc d hd; specialize hfd c hc d hd
  replace hg : âˆ€ x âˆˆ Î™ c d, â€–deriv f xâ€– â‰¤ C * â€–g xâ€– :=
    fun z hz => hg c hc d hd z âŸ¨hz.1.le, hz.2âŸ©
  have hg_ae : âˆ€áµ x âˆ‚volume.restrict (Î™ c d), â€–deriv f xâ€– â‰¤ C * â€–g xâ€– :=
    (ae_restrict_mem measurableSet_uIoc).mono hg
  have hsub' : Î™ c d âŠ† k := Subset.trans Ioc_subset_Icc_self hsub
  have hfi : IntervalIntegrable (deriv f) volume c d := by
    rw [intervalIntegrable_iff]
    have : IntegrableOn (fun x â†¦ C * â€–g xâ€–) (Î™ c d) := IntegrableOn.mono hgi hsub' le_rfl
    exact Integrable.mono' this (aestronglyMeasurable_deriv _ _) hg_ae
  refine' hlt.not_le (sub_le_iff_le_add'.1 _)
  calc
    â€–f dâ€– - â€–f câ€– â‰¤ â€–f d - f câ€– := norm_sub_norm_le _ _
    _ = â€–âˆ« x in c..d, deriv f xâ€– := congr_arg _ (integral_deriv_eq_sub hfd hfi).symm
    _ = â€–âˆ« x in Î™ c d, deriv f xâ€– := norm_integral_eq_norm_integral_Ioc _
    _ â‰¤ âˆ« x in Î™ c d, â€–deriv f xâ€– := norm_integral_le_integral_norm _
    _ â‰¤ âˆ« x in Î™ c d, C * â€–g xâ€– :=
      set_integral_mono_on hfi.norm.def (hgi.mono_set hsub') measurableSet_uIoc hg
    _ â‰¤ âˆ« x in k, C * â€–g xâ€– := by
      apply set_integral_mono_set hgi
        (ae_of_all _ fun x => mul_nonneg hCâ‚€ (norm_nonneg _)) hsub'.eventuallyLE","warning:  `MeasureTheory.set_integral_mono_on` has been deprecated, use `MeasureTheory.setIntegral_mono_on` instead
error:  invalid field 'def', the environment does not contain 'IntervalIntegrable.def'
  IntervalIntegrable.norm hfi
has type
  IntervalIntegrable (fun x â†¦ â€–deriv f xâ€–) volume c d
error:  invalid field 'def', the environment does not contain 'And.def'
  IntervalIntegrable.norm hfi
has type
  IntegrableOn (fun x â†¦ â€–deriv f xâ€–) (Ioc c d) volume âˆ§ IntegrableOn (fun x â†¦ â€–deriv f xâ€–) (Ioc d c) volume
warning:  `MeasureTheory.set_integral_mono_set` has been deprecated, use `MeasureTheory.setIntegral_mono_set` instead","theorem not_integrableOn_of_tendsto_norm_atTop_of_deriv_isBigO_filter_aux
    [CompleteSpace E] {f : â„ â†’ E} {g : â„ â†’ F}
    {k : Set â„} (l : Filter â„) [NeBot l] [TendstoIxxClass Icc l l]
    (hl : k âˆˆ l) (hd : âˆ€á¶  x in l, DifferentiableAt â„ f x) (hf : Tendsto (fun x => â€–f xâ€–) l atTop)
    (hfg : deriv f =O[l] g) : Â¬IntegrableOn g k ",":= by
  intro hgi
  obtain âŸ¨C, hCâ‚€, s, hsl, hsub, hfd, hgâŸ© :
    âˆƒ (C : â„) (_ : 0 â‰¤ C), âˆƒ s âˆˆ l, (âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, [[x, y]] âŠ† k) âˆ§
      (âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, âˆ€ z âˆˆ [[x, y]], DifferentiableAt â„ f z) âˆ§
        âˆ€ x âˆˆ s, âˆ€ y âˆˆ s, âˆ€ z âˆˆ [[x, y]], â€–deriv f zâ€– â‰¤ C * â€–g zâ€– := by
    rcases hfg.exists_nonneg with âŸ¨C, Câ‚€, hCâŸ©
    have h : âˆ€á¶  x : â„ Ã— â„ in l.prod l,
        âˆ€ y âˆˆ [[x.1, x.2]], (DifferentiableAt â„ f y âˆ§ â€–deriv f yâ€– â‰¤ C * â€–g yâ€–) âˆ§ y âˆˆ k :=
      (tendsto_fst.uIcc tendsto_snd).eventually ((hd.and hC.bound).and hl).smallSets
    rcases mem_prod_self_iff.1 h with âŸ¨s, hsl, hsâŸ©
    simp only [prod_subset_iff, mem_setOf_eq] at hs
    exact âŸ¨C, Câ‚€, s, hsl, fun x hx y hy z hz => (hs x hx y hy z hz).2, fun x hx y hy z hz =>
      (hs x hx y hy z hz).1.1, fun x hx y hy z hz => (hs x hx y hy z hz).1.2âŸ©
  replace hgi : IntegrableOn (fun x â†¦ C * â€–g xâ€–) k := by exact hgi.norm.smul C
  obtain âŸ¨c, hc, d, hd, hltâŸ© : âˆƒ c âˆˆ s, âˆƒ d âˆˆ s, (â€–f câ€– + âˆ« y in k, C * â€–g yâ€–) < â€–f dâ€– := by
    rcases Filter.nonempty_of_mem hsl with âŸ¨c, hcâŸ©
    have : âˆ€á¶  x in l, (â€–f câ€– + âˆ« y in k, C * â€–g yâ€–) < â€–f xâ€– :=
      hf.eventually (eventually_gt_atTop _)
    exact âŸ¨c, hc, (this.and hsl).exists.imp fun d hd => âŸ¨hd.2, hd.1âŸ©âŸ©
  specialize hsub c hc d hd; specialize hfd c hc d hd
  replace hg : âˆ€ x âˆˆ Î™ c d, â€–deriv f xâ€– â‰¤ C * â€–g xâ€– :=
    fun z hz => hg c hc d hd z âŸ¨hz.1.le, hz.2âŸ©
  have hg_ae : âˆ€áµ x âˆ‚volume.restrict (Î™ c d), â€–deriv f xâ€– â‰¤ C * â€–g xâ€– :=
    (ae_restrict_mem measurableSet_uIoc).mono hg
  have hsub' : Î™ c d âŠ† k := Subset.trans Ioc_subset_Icc_self hsub
  have hfi : IntervalIntegrable (deriv f) volume c d := by
    rw [intervalIntegrable_iff]
    have : IntegrableOn (fun x â†¦ C * â€–g xâ€–) (Î™ c d) := IntegrableOn.mono hgi hsub' le_rfl
    exact Integrable.mono' this (aestronglyMeasurable_deriv _ _) hg_ae
  refine hlt.not_le (sub_le_iff_le_add'.1 ?_)
  calc
    â€–f dâ€– - â€–f câ€– â‰¤ â€–f d - f câ€– := norm_sub_norm_le _ _
    _ = â€–âˆ« x in c..d, deriv f xâ€– := congr_arg _ (integral_deriv_eq_sub hfd hfi).symm
    _ = â€–âˆ« x in Î™ c d, deriv f xâ€– := norm_integral_eq_norm_integral_Ioc _
    _ â‰¤ âˆ« x in Î™ c d, â€–deriv f xâ€– := norm_integral_le_integral_norm _
    _ â‰¤ âˆ« x in Î™ c d, C * â€–g xâ€– :=
      setIntegral_mono_on hfi.norm.def' (hgi.mono_set hsub') measurableSet_uIoc hg
    _ â‰¤ âˆ« x in k, C * â€–g xâ€– := by
      apply setIntegral_mono_set hgi
        (ae_of_all _ fun x => mul_nonneg hCâ‚€ (norm_nonneg _)) hsub'.eventuallyLE"
Mathlib/AlgebraicGeometry/Pullbacks.lean,AlgebraicGeometry.Scheme.Pullback.gluedLift_p2,gluedLift_p2,8d72f500a692fb12cb594b710bb3ac6e29534e0d,":= by
  rw [â† cancel_epi (ğ’°.pullbackCover s.fst).fromGlued]
  apply Multicoequalizer.hom_ext
  intro b
  erw [Multicoequalizer.inj_desc_assoc, Multicoequalizer.inj_desc_assoc]
  delta gluedLift
  simp_rw [â† Category.assoc]
  rw [(ğ’°.pullbackCover s.fst).Î¹_glueMorphisms]
  simp_rw [Category.assoc]
  erw [Multicoequalizer.inj_desc, pullback.lift_snd]
  rw [pullbackSymmetry_hom_comp_snd_assoc]
  rfl","error:  unknown identifier 'Multicoequalizer.inj_desc_assoc'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.314526
case h
C : Type u
instâœÂ¹ : Category.{v, u} C
X Y Z : Scheme
ğ’° : X.OpenCover
f : X âŸ¶ Z
g : Y âŸ¶ Z
instâœ : âˆ€ (i : ğ’°.J), HasPullback (ğ’°.map i â‰« f) g
s : PullbackCone f g
b : (ğ’°.pullbackCover s.fst).gluedCover.diagram.R
âŠ¢ Multicoequalizer.Ï€ (ğ’°.pullbackCover s.fst).gluedCover.diagram b â‰«
      (ğ’°.pullbackCover s.fst).fromGlued â‰« gluedLift ğ’° f g s â‰« p2 ğ’° f g =
    Multicoequalizer.Ï€ (ğ’°.pullbackCover s.fst).gluedCover.diagram b â‰« (ğ’°.pullbackCover s.fst).fromGlued â‰« s.snd",theorem gluedLift_p2 : gluedLift ğ’° f g s â‰« p2 ğ’° f g = s.snd ,":= by
  rw [â† cancel_epi (ğ’°.pullbackCover s.fst).fromGlued]
  apply Multicoequalizer.hom_ext
  intro b
  simp_rw [OpenCover.fromGlued, Multicoequalizer.Ï€_desc_assoc, gluedLift, â† Category.assoc]
  simp_rw [(ğ’°.pullbackCover s.fst).Î¹_glueMorphisms]
  simp [p2, pullback.condition]"
Mathlib/Geometry/Manifold/InteriorBoundary.lean,ModelWithCorners.isInteriorPoint_or_isBoundaryPoint,isInteriorPoint_or_isBoundaryPoint,3d820bebc5531535db5d7f827511175724fb4593,":= by
  by_cases extChartAt I x x âˆˆ interior (extChartAt I x).target
  Â· exact Or.inl h
  Â· exact Or.inr h","error:  unknown identifier 'h'
error:  unknown identifier 'h'",lemma isInteriorPoint_or_isBoundaryPoint (x : M) : I.IsInteriorPoint x âˆ¨ I.IsBoundaryPoint x ,":= by
  rw [IsInteriorPoint, or_iff_not_imp_left, I.isBoundaryPoint_iff, â† closure_diff_interior,
    I.isClosed_range.closure_eq, mem_diff]
  exact fun h => âŸ¨mem_range_self _, hâŸ©"
Mathlib/Data/Nat/Choose/Multinomial.lean,Finset.sum_pow,sum_pow,e7753f2103cd793aee9a41168ed9c57bf3351c5a,":= by
  induction' s using Finset.induction with a s ha ih
  Â· rw [sum_empty]
    rintro (_ | n)
    Â· haveI : Subsingleton (Sym Î± 0) := Unique.instSubsingleton
      rw [_root_.pow_zero, Fintype.sum_subsingleton]
      swap
      Â· have : Zero (Sym Î± 0) := Sym.instZeroSym
        exact âŸ¨0, by simp [eq_iff_true_of_subsingleton]âŸ©
      convert (@one_mul R _ _).symm
      convert @Nat.cast_one R _
    Â· rw [_root_.pow_succ, mul_zero]
      haveI : IsEmpty (Finset.sym (âˆ… : Finset Î±) n.succ) := Finset.instIsEmpty
      apply (Fintype.sum_empty _).symm
  intro n; specialize ih (hc.mono <| s.subset_insert a)
  rw [sum_insert ha, (Commute.sum_right s _ _ _).add_pow, sum_range]; swap
  Â· exact fun _ hb => hc (mem_insert_self a s) (mem_insert_of_mem hb)
      (ne_of_mem_of_not_mem hb ha).symm
  Â· simp_rw [ih, mul_sum, sum_mul, sum_sigma', univ_sigma_univ]
    refine (Fintype.sum_equiv (symInsertEquiv ha) _ _ fun m => ?_).symm
    rw [m.1.1.multinomial_filter_ne a]
    conv in m.1.1.map _ => rw [â† m.1.1.filter_add_not (a = Â·), Multiset.map_add]
    simp_rw [Multiset.noncommProd_add, m.1.1.filter_eq, Multiset.map_replicate, m.1.2]
    rw [Multiset.noncommProd_eq_pow_card _ _ _ fun _ => Multiset.eq_of_mem_replicate]
    rw [Multiset.card_replicate, Nat.cast_mul, mul_assoc, Nat.cast_comm]
    congr 1; simp_rw [â† mul_assoc, Nat.cast_comm]; rfl","error:  unsolved goals
case h.e'_2.h.e'_3
Î± : Type u_1
instâœÂ¹ : DecidableEq Î±
s : Finset Î±
R : Type u_2
instâœ : Semiring R
x : Î± â†’ R
hc : (â†‘âˆ…).Pairwise fun i j â†¦ Commute (x i) (x j)
this : Subsingleton (Sym Î± 0)
âŠ¢ (â†‘â†‘(let_fun this_1 := Sym.instZeroSym;
          âŸ¨0, â‹¯âŸ©)).multinomial =
    1","theorem sum_pow_of_commute [Semiring R] (x : Î± â†’ R)
    (hc : (s : Set Î±).Pairwise fun i j => Commute (x i) (x j)) :
    âˆ€ n,
      s.sum x ^ n =
        âˆ‘ k : s.sym n,
          k.1.1.multinomial *
            (k.1.1.map <| x).noncommProd
              (Multiset.map_set_pairwise <| hc.mono <| mem_sym_iff.1 k.2) ",":= by
  induction' s using Finset.induction with a s ha ih
  Â· rw [sum_empty]
    rintro (_ | n)
    Â· haveI : Subsingleton (Sym Î± 0) := Unique.instSubsingleton
      rw [_root_.pow_zero, Fintype.sum_subsingleton]
      swap
      Â· have : Zero (Sym Î± 0) := Sym.instZeroSym
        exact âŸ¨0, by simp [eq_iff_true_of_subsingleton]âŸ©
      convert (@one_mul R _ _).symm
      convert @Nat.cast_one R _
      simp
    Â· rw [_root_.pow_succ, mul_zero]
      haveI : IsEmpty (Finset.sym (âˆ… : Finset Î±) n.succ) := Finset.instIsEmpty
      apply (Fintype.sum_empty _).symm
  intro n; specialize ih (hc.mono <| s.subset_insert a)
  rw [sum_insert ha, (Commute.sum_right s _ _ _).add_pow, sum_range]; swap
  Â· exact fun _ hb => hc (mem_insert_self a s) (mem_insert_of_mem hb)
      (ne_of_mem_of_not_mem hb ha).symm
  Â· simp_rw [ih, mul_sum, sum_mul, sum_sigma', univ_sigma_univ]
    refine (Fintype.sum_equiv (symInsertEquiv ha) _ _ fun m => ?_).symm
    rw [m.1.1.multinomial_filter_ne a]
    conv in m.1.1.map _ => rw [â† m.1.1.filter_add_not (a = Â·), Multiset.map_add]
    simp_rw [Multiset.noncommProd_add, m.1.1.filter_eq, Multiset.map_replicate, m.1.2]
    rw [Multiset.noncommProd_eq_pow_card _ _ _ fun _ => Multiset.eq_of_mem_replicate]
    rw [Multiset.card_replicate, Nat.cast_mul, mul_assoc, Nat.cast_comm]
    congr 1; simp_rw [â† mul_assoc, Nat.cast_comm]; rfl"
Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean,Complex.betaIntegral_recurrence,betaIntegral_recurrence,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  let F : â„ â†’ â„‚ := fun x => (x : â„‚) ^ u * (1 - (x : â„‚)) ^ v
  have hu' : 0 < re (u + 1) := by rw [add_re, one_re]; positivity
  have hv' : 0 < re (v + 1) := by rw [add_re, one_re]; positivity
  have hc : ContinuousOn F (Icc 0 1) := by
    refine' (ContinuousAt.continuousOn fun x hx => _).mul (ContinuousAt.continuousOn fun x hx => _)
    Â· refine' (continuousAt_cpow_const_of_re_pos (Or.inl _) hu).comp continuous_ofReal.continuousAt
      rw [ofReal_re]; exact hx.1
    Â· refine' (continuousAt_cpow_const_of_re_pos (Or.inl _) hv).comp
        (continuous_const.sub continuous_ofReal).continuousAt
      rw [sub_re, one_re, ofReal_re, sub_nonneg]
      exact hx.2
  have hder : âˆ€ x : â„, x âˆˆ Ioo (0 : â„) 1 â†’
      HasDerivAt F (u * ((x : â„‚) ^ (u - 1) * (1 - (x : â„‚)) ^ v) -
        v * ((x : â„‚) ^ u * (1 - (x : â„‚)) ^ (v - 1))) x := by
    intro x hx
    have U : HasDerivAt (fun y : â„‚ => y ^ u) (u * (x : â„‚) ^ (u - 1)) â†‘x := by
      have := @HasDerivAt.cpow_const _ _ _ u (hasDerivAt_id (x : â„‚)) (Or.inl ?_)
      simp only [id_eq, mul_one] at this
      Â· exact this
      Â· rw [id_eq, ofReal_re]; exact hx.1
    have V : HasDerivAt (fun y : â„‚ => (1 - y) ^ v) (-v * (1 - (x : â„‚)) ^ (v - 1)) â†‘x := by
      have A := @HasDerivAt.cpow_const _ _ _ v (hasDerivAt_id (1 - (x : â„‚))) (Or.inl ?_)
      swap; Â· rw [id.def, sub_re, one_re, ofReal_re, sub_pos]; exact hx.2
      simp_rw [id.def] at A
      have B : HasDerivAt (fun y : â„‚ => 1 - y) (-1) â†‘x := by
        apply HasDerivAt.const_sub; apply hasDerivAt_id
      convert HasDerivAt.comp (â†‘x) A B using 1
      ring
    convert (U.mul V).comp_ofReal using 1
    ring
  have h_int := ((betaIntegral_convergent hu hv').const_mul u).sub
    ((betaIntegral_convergent hu' hv).const_mul v)
  rw [add_sub_cancel, add_sub_cancel] at h_int
  have int_ev := intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le zero_le_one hc hder h_int
  have hF0 : F 0 = 0 := by
    simp only [mul_eq_zero, ofReal_zero, cpow_eq_zero_iff, eq_self_iff_true, Ne.def, true_and_iff,
      sub_zero, one_cpow, one_ne_zero, or_false_iff]
    contrapose! hu; rw [hu, zero_re]
  have hF1 : F 1 = 0 := by
    simp only [mul_eq_zero, ofReal_one, one_cpow, one_ne_zero, sub_self, cpow_eq_zero_iff,
      eq_self_iff_true, Ne.def, true_and_iff, false_or_iff]
    contrapose! hv; rw [hv, zero_re]
  rw [hF0, hF1, sub_zero, intervalIntegral.integral_sub, intervalIntegral.integral_const_mul,
    intervalIntegral.integral_const_mul] at int_ev
  Â· rw [betaIntegral, betaIntegral, â† sub_eq_zero]
    convert int_ev <;> ring
  Â· apply IntervalIntegrable.const_mul
    convert betaIntegral_convergent hu hv'; ring
  Â· apply IntervalIntegrable.const_mul
    convert betaIntegral_convergent hu' hv; ring","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.32184 â†’ ?m.32184
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.32186
case refine_1
u v : â„‚
hu : 0 < u.re
hv : 0 < v.re
F : â„ â†’ â„‚ := fun x â†¦ â†‘x ^ u * (1 - â†‘x) ^ v
hu' : 0 < (u + 1).re
hv' : 0 < (v + 1).re
hc : ContinuousOn F (Icc 0 1)
x : â„
hx : x âˆˆ Ioo 0 1
U : HasDerivAt (fun y â†¦ y ^ u) (u * â†‘x ^ (u - 1)) â†‘x
âŠ¢ 0 < (id (1 - â†‘x)).re
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.32329 â†’ ?m.32329
error:  simp made no progress
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + (?b - ?a)
u v : â„‚
hu : 0 < u.re
hv : 0 < v.re
F : â„ â†’ â„‚ := fun x â†¦ â†‘x ^ u * (1 - â†‘x) ^ v
hu' : 0 < (u + 1).re
hv' : 0 < (v + 1).re
hc : ContinuousOn F (Icc 0 1)
hder : âˆ€ x âˆˆ Ioo 0 1, HasDerivAt F (u * (â†‘x ^ (u - 1) * (1 - â†‘x) ^ v) - v * (â†‘x ^ u * (1 - â†‘x) ^ (v - 1))) x
h_int :
  IntervalIntegrable (fun x â†¦ u * (â†‘x ^ (u - 1) * (1 - â†‘x) ^ (v + 1 - 1)) - v * (â†‘x ^ (u + 1 - 1) * (1 - â†‘x) ^ (v - 1)))
    volume 0 1
âŠ¢ u * u.betaIntegral (v + 1) = v * (u + 1).betaIntegral v","theorem betaIntegral_recurrence {u v : â„‚} (hu : 0 < re u) (hv : 0 < re v) :
    u * betaIntegral u (v + 1) = v * betaIntegral (u + 1) v ",":= by
  let F : â„ â†’ â„‚ := fun x => (x : â„‚) ^ u * (1 - (x : â„‚)) ^ v
  have hu' : 0 < re (u + 1) := by rw [add_re, one_re]; positivity
  have hv' : 0 < re (v + 1) := by rw [add_re, one_re]; positivity
  have hc : ContinuousOn F (Icc 0 1) := by
    refine (ContinuousAt.continuousOn fun x hx => ?_).mul (ContinuousAt.continuousOn fun x hx => ?_)
    Â· refine (continuousAt_cpow_const_of_re_pos (Or.inl ?_) hu).comp continuous_ofReal.continuousAt
      rw [ofReal_re]; exact hx.1
    Â· refine (continuousAt_cpow_const_of_re_pos (Or.inl ?_) hv).comp
        (continuous_const.sub continuous_ofReal).continuousAt
      rw [sub_re, one_re, ofReal_re, sub_nonneg]
      exact hx.2
  have hder : âˆ€ x : â„, x âˆˆ Ioo (0 : â„) 1 â†’
      HasDerivAt F (u * ((x : â„‚) ^ (u - 1) * (1 - (x : â„‚)) ^ v) -
        v * ((x : â„‚) ^ u * (1 - (x : â„‚)) ^ (v - 1))) x := by
    intro x hx
    have U : HasDerivAt (fun y : â„‚ => y ^ u) (u * (x : â„‚) ^ (u - 1)) â†‘x := by
      have := @HasDerivAt.cpow_const _ _ _ u (hasDerivAt_id (x : â„‚)) (Or.inl ?_)
      Â· simp only [id_eq, mul_one] at this
        exact this
      Â· rw [id_eq, ofReal_re]; exact hx.1
    have V : HasDerivAt (fun y : â„‚ => (1 - y) ^ v) (-v * (1 - (x : â„‚)) ^ (v - 1)) â†‘x := by
      have A := @HasDerivAt.cpow_const _ _ _ v (hasDerivAt_id (1 - (x : â„‚))) (Or.inl ?_)
      swap; Â· rw [id, sub_re, one_re, ofReal_re, sub_pos]; exact hx.2
      simp_rw [id] at A
      have B : HasDerivAt (fun y : â„‚ => 1 - y) (-1) â†‘x := by
        apply HasDerivAt.const_sub; apply hasDerivAt_id
      convert HasDerivAt.comp (â†‘x) A B using 1
      ring
    convert (U.mul V).comp_ofReal using 1
    ring
  have h_int := ((betaIntegral_convergent hu hv').const_mul u).sub
    ((betaIntegral_convergent hu' hv).const_mul v)
  rw [add_sub_cancel_right, add_sub_cancel_right] at h_int
  have int_ev := intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le zero_le_one hc hder h_int
  have hF0 : F 0 = 0 := by
    simp only [F, mul_eq_zero, ofReal_zero, cpow_eq_zero_iff, eq_self_iff_true, Ne,
      true_and_iff, sub_zero, one_cpow, one_ne_zero, or_false_iff]
    contrapose! hu; rw [hu, zero_re]
  have hF1 : F 1 = 0 := by
    simp only [F, mul_eq_zero, ofReal_one, one_cpow, one_ne_zero, sub_self, cpow_eq_zero_iff,
      eq_self_iff_true, Ne, true_and_iff, false_or_iff]
    contrapose! hv; rw [hv, zero_re]
  rw [hF0, hF1, sub_zero, intervalIntegral.integral_sub, intervalIntegral.integral_const_mul,
    intervalIntegral.integral_const_mul] at int_ev
  Â· rw [betaIntegral, betaIntegral, â† sub_eq_zero]
    convert int_ev <;> ring
  Â· apply IntervalIntegrable.const_mul
    convert betaIntegral_convergent hu hv'; ring
  Â· apply IntervalIntegrable.const_mul
    convert betaIntegral_convergent hu' hv; ring"
Mathlib/Computability/Halting.lean,Partrec.merge',merge',b912476b37f2ea41ee51af7e63439f4a769be095,":= by
  obtain âŸ¨cf, rflâŸ© := Code.exists_code.1 hf
  obtain âŸ¨cg, rflâŸ© := Code.exists_code.1 hg
  have := Primrec.option_orElse.to_comp.toâ‚‚.compâ‚‚
    (Code.evaln_prim.to_comp.comp <| (snd.pair (const cf)).pair fst)
    (Code.evaln_prim.to_comp.comp <| (snd.pair (const cg)).pair fst)
  refine âŸ¨_, Partrec.nat_iff.1 <| Partrec.rfindOpt this.toâ‚‚, fun n => ?_âŸ©
  have (x)
      (h : x âˆˆ rfindOpt fun k â†¦ HOrElse.hOrElse (Code.evaln k cf n) fun _x â†¦ Code.evaln k cg n) :
      x âˆˆ Code.eval cf n âˆ¨ x âˆˆ Code.eval cg n := by
    let âŸ¨k, eâŸ© := Nat.rfindOpt_spec h
    revert e
    simp only [Option.mem_def]
    cases e' : cf.evaln k n
    Â· exact fun e => Or.inr (Code.evaln_sound e)
    Â· rintro âŸ¨âŸ©; exact Or.inl (Code.evaln_sound e')
  refine âŸ¨this, âŸ¨fun h => (this _ âŸ¨h, rflâŸ©).imp Exists.fst Exists.fst, ?_âŸ©âŸ©
  intro h
  rw [Nat.rfindOpt_dom]
  simp only [dom_iff_mem, Code.evaln_complete, Option.mem_def] at h
  obtain âŸ¨x, k, eâŸ© | âŸ¨x, k, eâŸ© := h
  Â· refine âŸ¨k, x, ?_âŸ©
    simp only [e, Option.some_orElse, Option.mem_def]
  Â· refine âŸ¨k, ?_âŸ©
    cases cf.evaln k n with
    | none => exact âŸ¨x, by simp only [e, Option.mem_def, Option.none_orElse]âŸ©
    | some y => exact âŸ¨y, by simp only [Option.some_orElse, Option.mem_def]âŸ©","error:  application type mismatch
  Computableâ‚‚.compâ‚‚ (toâ‚‚ (Primrecâ‚‚.to_comp Primrec.option_orElse))
    (Computable.comp (Primrec.to_comp Code.evaln_prim) (Computable.pair (Computable.pair snd (const cf)) fst))
argument
  Computable.comp (Primrec.to_comp Code.evaln_prim) (Computable.pair (Computable.pair snd (const cf)) fst)
has type
  Computable fun a â†¦ Code.evaln ((a.2, cf), a.1).1.1 ((a.2, cf), a.1).1.2 ((a.2, cf), a.1).2 : Prop
but is expected to have type
  Computableâ‚‚ ?m.421 : Prop
error:  unsolved goals
case intro.intro
cf : Code
hf : Partrec cf.eval
cg : Code
hg : Partrec cg.eval
âŠ¢ âˆƒ h,
    Partrec h âˆ§ âˆ€ (a : â„•), (âˆ€ x âˆˆ h a, x âˆˆ cf.eval a âˆ¨ x âˆˆ cg.eval a) âˆ§ ((h a).Dom â†” (cf.eval a).Dom âˆ¨ (cg.eval a).Dom)","theorem merge' {f g} (hf : Nat.Partrec f) (hg : Nat.Partrec g) :
    âˆƒ h, Nat.Partrec h âˆ§
      âˆ€ a, (âˆ€ x âˆˆ h a, x âˆˆ f a âˆ¨ x âˆˆ g a) âˆ§ ((h a).Dom â†” (f a).Dom âˆ¨ (g a).Dom) ",":= by
  obtain âŸ¨cf, rflâŸ© := Code.exists_code.1 hf
  obtain âŸ¨cg, rflâŸ© := Code.exists_code.1 hg
  have : Nat.Partrec fun n => Nat.rfindOpt fun k => cf.evaln k n <|> cg.evaln k n :=
    Partrec.nat_iff.1
      (Partrec.rfindOpt <|
        Primrec.option_orElse.to_comp.comp
          (Code.evaln_prim.to_comp.comp <| (snd.pair (const cf)).pair fst)
          (Code.evaln_prim.to_comp.comp <| (snd.pair (const cg)).pair fst))
  refine âŸ¨_, this, fun n => ?_âŸ©
  have : âˆ€ x âˆˆ rfindOpt fun k â†¦ HOrElse.hOrElse (Code.evaln k cf n) fun _x â†¦ Code.evaln k cg n,
      x âˆˆ Code.eval cf n âˆ¨ x âˆˆ Code.eval cg n := by
    intro x h
    obtain âŸ¨k, eâŸ© := Nat.rfindOpt_spec h
    revert e
    simp only [Option.mem_def]
    cases' e' : cf.evaln k n with y <;> simp <;> intro e
    Â· exact Or.inr (Code.evaln_sound e)
    Â· subst y
      exact Or.inl (Code.evaln_sound e')
  refine âŸ¨this, âŸ¨fun h => (this _ âŸ¨h, rflâŸ©).imp Exists.fst Exists.fst, ?_âŸ©âŸ©
  intro h
  rw [Nat.rfindOpt_dom]
  simp only [dom_iff_mem, Code.evaln_complete, Option.mem_def] at h
  obtain âŸ¨x, k, eâŸ© | âŸ¨x, k, eâŸ© := h
  Â· refine âŸ¨k, x, ?_âŸ©
    simp only [e, Option.some_orElse, Option.mem_def]
  Â· refine âŸ¨k, ?_âŸ©
    cases' cf.evaln k n with y
    Â· exact âŸ¨x, by simp only [e, Option.mem_def, Option.none_orElse]âŸ©
    Â· exact âŸ¨y, by simp only [Option.some_orElse, Option.mem_def]âŸ©"
Mathlib/Combinatorics/SimpleGraph/StronglyRegular.lean,SimpleGraph.IsSRGWith.param_eq,IsSRGWith.param_eq,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  rw [â† h.card, Fintype.card_pos_iff] at hn
  obtain âŸ¨vâŸ© := hn
  convert card_mul_eq_card_mul G.Adj (s := G.neighborFinset v) (t := Gá¶œ.neighborFinset v) _ _
  Â· simp [h.regular v]
  Â· simp [h.compl.regular v]
  Â· intro w hw
    rw [mem_neighborFinset] at hw
    simp_rw [bipartiteAbove, show G.Adj w = fun a => G.Adj w a by rfl, â† mem_neighborFinset,
      filter_mem_eq_inter]
    have s : {v} âŠ† G.neighborFinset w \ G.neighborFinset v := by
      rw [singleton_subset_iff, mem_sdiff, mem_neighborFinset]
      exact âŸ¨hw.symm, G.not_mem_neighborFinset_self vâŸ©
    rw [inter_comm, neighborFinset_compl, inter_sdiff, â† sdiff_eq_inter_compl, card_sdiff s,
      card_singleton, â† sdiff_inter_self_left, card_sdiff (by apply inter_subset_left)]
    congr
    Â· simp [h.regular w]
    Â· simp_rw [inter_comm, neighborFinset_def, â† Set.toFinset_inter, â† h.of_adj v w hw,
        â† Set.toFinset_card]
      congr!
  Â· intro w hw
    simp_rw [neighborFinset_compl, mem_sdiff, mem_compl, mem_singleton, mem_neighborFinset,
      â† Ne.def] at hw
    simp_rw [bipartiteBelow, adj_comm, â† mem_neighborFinset, filter_mem_eq_inter,
      neighborFinset_def, â† Set.toFinset_inter, â† h.of_not_adj v w hw.2.symm hw.1,
      â† Set.toFinset_card]
    congr!","error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.53878 â†’ ?m.53878 â†’ Prop
error:  simp made no progress","theorem IsSRGWith.param_eq (h : G.IsSRGWith n k â„“ Î¼) (hn : 0 < n) :
    k * (k - â„“ - 1) = (n - k - 1) * Î¼ ",":= by
  letI := Classical.decEq V
  rw [â† h.card, Fintype.card_pos_iff] at hn
  obtain âŸ¨vâŸ© := hn
  convert card_mul_eq_card_mul G.Adj (s := G.neighborFinset v) (t := Gá¶œ.neighborFinset v) _ _
  Â· simp [h.regular v]
  Â· simp [h.compl.regular v]
  Â· intro w hw
    rw [mem_neighborFinset] at hw
    simp_rw [bipartiteAbove]
    change Finset.card (filter (fun a => Adj G w a) _) = _
    simp_rw [â† mem_neighborFinset, filter_mem_eq_inter]
    have s : {v} âŠ† G.neighborFinset w \ G.neighborFinset v := by
      rw [singleton_subset_iff, mem_sdiff, mem_neighborFinset]
      exact âŸ¨hw.symm, G.not_mem_neighborFinset_self vâŸ©
    rw [inter_comm, neighborFinset_compl, â† inter_sdiff_assoc, â† sdiff_eq_inter_compl, card_sdiff s,
      card_singleton, â† sdiff_inter_self_left, card_sdiff (by apply inter_subset_left)]
    congr
    Â· simp [h.regular w]
    Â· simp_rw [inter_comm, neighborFinset_def, â† Set.toFinset_inter, â† h.of_adj v w hw,
        â† Set.toFinset_card]
      congr!
  Â· intro w hw
    simp_rw [neighborFinset_compl, mem_sdiff, mem_compl, mem_singleton, mem_neighborFinset,
      â† Ne.eq_def] at hw
    simp_rw [bipartiteBelow, adj_comm, â† mem_neighborFinset, filter_mem_eq_inter,
      neighborFinset_def, â† Set.toFinset_inter, â† h.of_not_adj hw.2.symm hw.1,
      â† Set.toFinset_card]
    congr!"
Mathlib/MeasureTheory/MeasurableSpace/CountablyGenerated.lean,MeasurableSpace.measurableSet_generateFrom_memPartition_iff,measurableSet_generateFrom_memPartition_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine âŸ¨fun h â†¦ ?_, fun âŸ¨S, hS_subset, hS_eqâŸ© â†¦ ?_âŸ©
  Â· refine MeasurableSpace.generateFrom_induction
      (p := fun u â†¦ âˆƒ S : Finset (Set Î±), â†‘S âŠ† memPartition t n âˆ§ u = â‹ƒâ‚€ â†‘S)
      (C := memPartition t n) ?_ ?_ ?_ ?_ h
    Â· exact fun u hu â†¦ âŸ¨{u}, by simp [hu], by simpâŸ©
    Â· exact âŸ¨âˆ…, by simp, by simpâŸ©
    Â· rintro u âŸ¨S, hS_subset, rflâŸ©
      classical
      refine âŸ¨(memPartition t n).toFinset \ S, ?_, ?_âŸ©
      Â· simp only [Finset.coe_sdiff, coe_toFinset]
        exact diff_subset _ _
      Â· simp only [Finset.coe_sdiff, coe_toFinset]
        refine (IsCompl.eq_compl âŸ¨?_, ?_âŸ©).symm
        Â· refine Set.disjoint_sUnion_right.mpr fun u huS => ?_
          refine Set.disjoint_sUnion_left.mpr fun v huV => ?_
          refine disjoint_memPartition t n (mem_of_mem_diff huV) (hS_subset huS) ?_
          exact ne_of_mem_of_not_mem huS (not_mem_of_mem_diff huV) |>.symm
        Â· rw [codisjoint_iff]
          simp only [sup_eq_union, top_eq_univ]
          rw [â† sUnion_memPartition t n, union_comm, â† sUnion_union, union_diff_cancel hS_subset]
    Â· intro f h
      choose S hS_subset hS_eq using h
      have : Fintype (â‹ƒ n, (S n : Set (Set Î±))) := by
        refine (Finite.subset (finite_memPartition t n) ?_).fintype
        simp only [iUnion_subset_iff]
        exact hS_subset
      refine âŸ¨(â‹ƒ n, (S n : Set (Set Î±))).toFinset, ?_, ?_âŸ©
      Â· simp only [coe_toFinset, iUnion_subset_iff]
        exact hS_subset
      Â· simp only [coe_toFinset, sUnion_iUnion, hS_eq]
  Â· rw [hS_eq, sUnion_eq_biUnion]
    refine MeasurableSet.biUnion ?_ (fun t ht â†¦ ?_)
    Â· exact S.countable_toSet
    Â· exact measurableSet_generateFrom (hS_subset ht)","error:  function expected at
  diff_subset ?m.43731
term has type
  ?m.43730 âˆˆ ?m.43728","lemma measurableSet_generateFrom_memPartition_iff (t : â„• â†’ Set Î±) (n : â„•) (s : Set Î±) :
    MeasurableSet[generateFrom (memPartition t n)] s
      â†” âˆƒ S : Finset (Set Î±), â†‘S âŠ† memPartition t n âˆ§ s = â‹ƒâ‚€ S ",":= by
  refine âŸ¨fun h â†¦ ?_, fun âŸ¨S, hS_subset, hS_eqâŸ© â†¦ ?_âŸ©
  Â· refine MeasurableSpace.generateFrom_induction
      (p := fun u â†¦ âˆƒ S : Finset (Set Î±), â†‘S âŠ† memPartition t n âˆ§ u = â‹ƒâ‚€ â†‘S)
      (C := memPartition t n) ?_ ?_ ?_ ?_ h
    Â· exact fun u hu â†¦ âŸ¨{u}, by simp [hu], by simpâŸ©
    Â· exact âŸ¨âˆ…, by simp, by simpâŸ©
    Â· rintro u âŸ¨S, hS_subset, rflâŸ©
      classical
      refine âŸ¨(memPartition t n).toFinset \ S, ?_, ?_âŸ©
      Â· simp only [Finset.coe_sdiff, coe_toFinset]
        exact diff_subset
      Â· simp only [Finset.coe_sdiff, coe_toFinset]
        refine (IsCompl.eq_compl âŸ¨?_, ?_âŸ©).symm
        Â· refine Set.disjoint_sUnion_right.mpr fun u huS => ?_
          refine Set.disjoint_sUnion_left.mpr fun v huV => ?_
          refine disjoint_memPartition t n (mem_of_mem_diff huV) (hS_subset huS) ?_
          exact ne_of_mem_of_not_mem huS (not_mem_of_mem_diff huV) |>.symm
        Â· rw [codisjoint_iff]
          simp only [sup_eq_union, top_eq_univ]
          rw [â† sUnion_memPartition t n, union_comm, â† sUnion_union, union_diff_cancel hS_subset]
    Â· intro f h
      choose S hS_subset hS_eq using h
      have : Fintype (â‹ƒ n, (S n : Set (Set Î±))) := by
        refine (Finite.subset (finite_memPartition t n) ?_).fintype
        simp only [iUnion_subset_iff]
        exact hS_subset
      refine âŸ¨(â‹ƒ n, (S n : Set (Set Î±))).toFinset, ?_, ?_âŸ©
      Â· simp only [coe_toFinset, iUnion_subset_iff]
        exact hS_subset
      Â· simp only [coe_toFinset, sUnion_iUnion, hS_eq]
  Â· rw [hS_eq, sUnion_eq_biUnion]
    refine MeasurableSet.biUnion ?_ (fun t ht â†¦ ?_)
    Â· exact S.countable_toSet
    Â· exact measurableSet_generateFrom (hS_subset ht)"
Mathlib/Analysis/Calculus/SmoothSeries.lean,contDiff_tsum_of_eventually,contDiff_tsum_of_eventually,ce9aa44e3261a9b6ccf452610ff9fa98bcae7bc3,":= by
  classical
    refine contDiff_iff_forall_nat_le.2 fun m hm => ?_
    let t : Set Î± :=
      { i : Î± | Â¬âˆ€ k : â„•, k âˆˆ Finset.range (m + 1) â†’ âˆ€ x, â€–iteratedFDeriv ğ•œ k (f i) xâ€– â‰¤ v k i }
    have ht : Set.Finite t :=
      haveI A :
        âˆ€á¶  i in (Filter.cofinite : Filter Î±),
          âˆ€ k : â„•, k âˆˆ Finset.range (m + 1) â†’ âˆ€ x : E, â€–iteratedFDeriv ğ•œ k (f i) xâ€– â‰¤ v k i := by
        rw [eventually_all_finset]
        intro i hi
        apply h'f
        simp only [Finset.mem_range_succ_iff] at hi
        exact (WithTop.coe_le_coe.2 hi).trans hm
      eventually_cofinite.2 A
    let T : Finset Î± := ht.toFinset
    have : (fun x => âˆ‘' i, f i x) = (fun x => âˆ‘ i in T, f i x) +
        fun x => âˆ‘' i : { i // i âˆ‰ T }, f i x := by
      ext1 x
      refine' (sum_add_tsum_subtype_compl _ T).symm
      refine' .of_norm_bounded_eventually _ (hv 0 (zero_le _)) _
      filter_upwards [h'f 0 (zero_le _)] with i hi
      simpa only [norm_iteratedFDeriv_zero] using hi x
    rw [this]
    apply (ContDiff.sum fun i _ => (hf i).of_le hm).add
    have h'u : âˆ€ k : â„•, (k : â„•âˆ) â‰¤ m â†’ Summable (v k âˆ˜ ((â†‘) : { i // i âˆ‰ T } â†’ Î±)) := fun k hk =>
      (hv k (hk.trans hm)).subtype _
    refine' contDiff_tsum (fun i => (hf i).of_le hm) h'u _
    rintro k âŸ¨i, hiâŸ© x hk
    dsimp
    simp only [T, Finite.mem_toFinset, mem_setOf_eq, Finset.mem_range, not_forall, not_le,
      exists_prop, not_exists, not_and, not_lt] at hi
    exact hi k (Nat.lt_succ_iff.2 (WithTop.coe_le_coe.1 hk)) x","error:  application type mismatch
  hi k
argument
  k
has type
  â„• : Type
but is expected to have type
  i âˆˆ t : Prop","theorem contDiff_tsum_of_eventually (hf : âˆ€ i, ContDiff ğ•œ N (f i))
    (hv : âˆ€ k : â„•, (k : â„•âˆ) â‰¤ N â†’ Summable (v k))
    (h'f :
      âˆ€ k : â„•,
        (k : â„•âˆ) â‰¤ N â†’
          âˆ€á¶  i in (Filter.cofinite : Filter Î±), âˆ€ x : E, â€–iteratedFDeriv ğ•œ k (f i) xâ€– â‰¤ v k i) :
    ContDiff ğ•œ N fun x => âˆ‘' i, f i x ",":= by
  classical
    refine contDiff_iff_forall_nat_le.2 fun m hm => ?_
    let t : Set Î± :=
      { i : Î± | Â¬âˆ€ k : â„•, k âˆˆ Finset.range (m + 1) â†’ âˆ€ x, â€–iteratedFDeriv ğ•œ k (f i) xâ€– â‰¤ v k i }
    have ht : Set.Finite t :=
      haveI A :
        âˆ€á¶  i in (Filter.cofinite : Filter Î±),
          âˆ€ k : â„•, k âˆˆ Finset.range (m + 1) â†’ âˆ€ x : E, â€–iteratedFDeriv ğ•œ k (f i) xâ€– â‰¤ v k i := by
        rw [eventually_all_finset]
        intro i hi
        apply h'f
        simp only [Finset.mem_range_succ_iff] at hi
        exact (WithTop.coe_le_coe.2 hi).trans hm
      eventually_cofinite.2 A
    let T : Finset Î± := ht.toFinset
    have : (fun x => âˆ‘' i, f i x) = (fun x => âˆ‘ i âˆˆ T, f i x) +
        fun x => âˆ‘' i : { i // i âˆ‰ T }, f i x := by
      ext1 x
      refine (sum_add_tsum_subtype_compl ?_ T).symm
      refine .of_norm_bounded_eventually _ (hv 0 (zero_le _)) ?_
      filter_upwards [h'f 0 (zero_le _)] with i hi
      simpa only [norm_iteratedFDeriv_zero] using hi x
    rw [this]
    apply (ContDiff.sum fun i _ => (hf i).of_le hm).add
    have h'u : âˆ€ k : â„•, (k : â„•âˆ) â‰¤ m â†’ Summable (v k âˆ˜ ((â†‘) : { i // i âˆ‰ T } â†’ Î±)) := fun k hk =>
      (hv k (hk.trans hm)).subtype _
    refine contDiff_tsum (fun i => (hf i).of_le hm) h'u ?_
    rintro k âŸ¨i, hiâŸ© x hk
    simp only [t, T, Finite.mem_toFinset, mem_setOf_eq, Finset.mem_range, not_forall, not_le,
      exists_prop, not_exists, not_and, not_lt] at hi
    exact hi k (Nat.lt_succ_iff.2 (WithTop.coe_le_coe.1 hk)) x"
Mathlib/Topology/Algebra/InfiniteSum/Basic.lean,Function.Injective.tprod_eq,Function.Injective.tprod_eq,5bc1ad1d20d0d38fd328824a49d24b475a371d9e,":= by
  have : mulSupport f = g '' mulSupport (f âˆ˜ g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [â† Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  Â· have hfg_fin : (mulSupport (f âˆ˜ g)).Finite := hf_fin.preimage (hg.injOn _)
    lift g to Î³ â†ª Î² using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, â† Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ â†¦ rfl
    simp [this]
  Â· have hf_fin' : Â¬ Set.Finite (mulSupport (f âˆ˜ g)) := by
      rwa [this, Set.finite_image_iff (hg.injOn _)] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      hg.hasProd_iff (mulSupport_subset_iff'.1 hf)]","error:  application type mismatch
  Set.Finite.preimage (injOn hg ?m.107093)
argument
  injOn hg ?m.107093
has type
  âˆ€ â¦ƒxâ‚‚ : Î³â¦„, xâ‚‚ âˆˆ ?m.107091 â†’ g ?m.107092 = g xâ‚‚ â†’ ?m.107092 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn ?m.107033 (?m.107033 â»Â¹' ?m.107034) : Prop
error:  application type mismatch
  Set.finite_image_iff (injOn hg ?m.112448)
argument
  injOn hg ?m.112448
has type
  âˆ€ â¦ƒxâ‚‚ : Î³â¦„, xâ‚‚ âˆˆ ?m.112446 â†’ g ?m.112447 = g xâ‚‚ â†’ ?m.112447 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn ?m.112425 ?m.112424 : Prop
error:  unsolved goals
case neg
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Î´ : Type u_4
instâœÂ¹ : CommMonoid Î±
instâœ : TopologicalSpace Î±
fâœ gâœ : Î² â†’ Î±
a aâ‚ aâ‚‚ : Î±
g : Î³ â†’ Î²
hg : Injective g
f : Î² â†’ Î±
hf : mulSupport f âŠ† Set.range g
this : mulSupport f = g '' mulSupport (f âˆ˜ g)
hf_fin : Â¬(mulSupport f).Finite
hf_fin' : Â¬(mulSupport (f âˆ˜ g)).Finite
âŠ¢ (if h : âˆƒ a, HasProd f a then Exists.choose â‹¯ else 1) =
    if h : âˆƒ a, HasProd (fun b â†¦ f b) a then Exists.choose â‹¯ else 1","theorem Function.Injective.tprod_eq {g : Î³ â†’ Î²} (hg : Injective g) {f : Î² â†’ Î±}
    (hf : mulSupport f âŠ† Set.range g) : âˆ' c, f (g c) = âˆ' b, f b ",":= by
  have : mulSupport f = g '' mulSupport (f âˆ˜ g) := by
    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]
  rw [â† Function.comp_def]
  by_cases hf_fin : (mulSupport f).Finite
  Â· have hfg_fin : (mulSupport (f âˆ˜ g)).Finite := hf_fin.preimage hg.injOn
    lift g to Î³ â†ª Î² using hg
    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,
      comp_apply, â† Finset.prod_map]
    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ â†¦ rfl
    simp [this]
  Â· have hf_fin' : Â¬ Set.Finite (mulSupport (f âˆ˜ g)) := by
      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin
    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,
      funext fun a => propext <| hg.hasProd_iff (mulSupport_subset_iff'.1 hf) (a := a)]"
Mathlib/Topology/Sober.lean,OpenEmbedding.quasiSober,OpenEmbedding.quasiSober,596865180ecc63dcd1d95809202e31027ac3ae38,"  sober hS hS' := by
    have hS'' := hS.image f hf.continuous.continuousOn
    obtain âŸ¨x, hxâŸ© := QuasiSober.sober hS''.closure isClosed_closure
    obtain âŸ¨T, hT, rflâŸ© := hf.toInducing.isClosed_iff.mp hS'
    rw [image_preimage_eq_inter_range] at hx hS''
    have hxT : x âˆˆ T := by
      rw [â† hT.closure_eq]
      exact closure_mono (inter_subset_left _ _) hx.mem
    obtain âŸ¨y, rflâŸ© : x âˆˆ range f := by
      rw [hx.mem_open_set_iff hf.isOpen_range]
      refine Nonempty.mono ?_ hS''.1
      simpa using subset_closure
    use y
    change _ = _
    rw [hf.toEmbedding.closure_eq_preimage_closure_image, image_singleton, show _ = _ from hx]
    apply image_injective.mpr hf.inj
    ext z
    simp only [image_preimage_eq_inter_range, mem_inter_iff, and_congr_left_iff]
    exact fun hy => âŸ¨fun h => hT.closure_eq â–¸ closure_mono (inter_subset_left _ _) h,
      fun h => subset_closure âŸ¨h, hyâŸ©âŸ©","error:  function expected at
  inter_subset_left ?m.11445
term has type
  ?m.11444 âˆˆ ?m.11442
error:  function expected at
  inter_subset_left ?m.12575
term has type
  ?m.12574 âˆˆ ?m.12572","theorem OpenEmbedding.quasiSober {f : Î± â†’ Î²} (hf : OpenEmbedding f) [QuasiSober Î²] :
    QuasiSober Î± where
","  sober hS hS' := by
    have hS'' := hS.image f hf.continuous.continuousOn
    obtain âŸ¨x, hxâŸ© := QuasiSober.sober hS''.closure isClosed_closure
    obtain âŸ¨T, hT, rflâŸ© := hf.toInducing.isClosed_iff.mp hS'
    rw [image_preimage_eq_inter_range] at hx hS''
    have hxT : x âˆˆ T := by
      rw [â† hT.closure_eq]
      exact closure_mono inter_subset_left hx.mem
    obtain âŸ¨y, rflâŸ© : x âˆˆ range f := by
      rw [hx.mem_open_set_iff hf.isOpen_range]
      refine Nonempty.mono ?_ hS''.1
      simpa using subset_closure
    use y
    change _ = _
    rw [hf.toEmbedding.closure_eq_preimage_closure_image, image_singleton, show _ = _ from hx]
    apply image_injective.mpr hf.inj
    ext z
    simp only [image_preimage_eq_inter_range, mem_inter_iff, and_congr_left_iff]
    exact fun hy => âŸ¨fun h => hT.closure_eq â–¸ closure_mono inter_subset_left h,
      fun h => subset_closure âŸ¨h, hyâŸ©âŸ©"
Mathlib/Data/Finset/Image.lean,Finset.image_inter,image_inter,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  subset_inter (image_subset_image <| inter_subset_left _ _) <|
    image_subset_image <| inter_subset_right _ _","error:  function expected at
  inter_subset_left ?m.62987
term has type
  ?m.62986 âˆˆ ?m.62984
error:  function expected at
  inter_subset_right ?m.63182
term has type
  ?m.63181 âˆˆ ?m.63180","theorem image_inter_subset [DecidableEq Î±] (f : Î± â†’ Î²) (s t : Finset Î±) :
    (s âˆ© t).image f âŠ† s.image f âˆ© t.image f ",":=
  (image_mono f).map_inf_le s t"
Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean,Real.Angle.two_nsmul_eq_pi_iff,two_nsmul_eq_pi_iff,453c456b049db19d87dc21aed1a69aaf23bd5e15,":= by
  have h : (Ï€ : Angle) = ((2 : â„•) â€¢ (Ï€ / 2 : â„) :) : = by rw [two_nsmul, add_halves]
  nth_rw 1 [h]
  rw [coe_nsmul, two_nsmul_eq_iff]
  convert Iff.rfl
  rw [add_comm, â† coe_add, â† sub_eq_zero, â† coe_sub, neg_div, â† neg_sub, sub_neg_eq_add, add_assoc,
    add_halves, â† two_mul, coe_neg, coe_two_pi, neg_zero]","error:  unexpected token ':'; expected '|'
error:  unsolved goals
Î¸ : Angle
h : â†‘Ï€ = â†‘(2 â€¢ (Ï€ / 2))
âŠ¢ 2 â€¢ Î¸ = â†‘Ï€ â†” Î¸ = â†‘(Ï€ / 2) âˆ¨ Î¸ = â†‘(-Ï€ / 2)",theorem two_nsmul_eq_pi_iff {Î¸ : Angle} : (2 : â„•) â€¢ Î¸ = Ï€ â†” Î¸ = (Ï€ / 2 : â„) âˆ¨ Î¸ = (-Ï€ / 2 : â„) ,":= by
  have h : (Ï€ : Angle) = ((2 : â„•) â€¢ (Ï€ / 2 : â„) :) := by rw [two_nsmul, add_halves]
  nth_rw 1 [h]
  rw [coe_nsmul, two_nsmul_eq_iff]
  convert Iff.rfl
  rw [add_comm, â† coe_add, â† sub_eq_zero, â† coe_sub, neg_div, â† neg_sub, sub_neg_eq_add, add_assoc,
    add_halves, â† two_mul, coe_neg, coe_two_pi, neg_zero]"
Mathlib/MeasureTheory/Measure/MeasureSpace.lean,MeasureTheory.measure_iUnion_congr_of_subset,measure_iUnion_congr_of_subset,ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  rcases Classical.em (âˆƒ b, Î¼ (t b) = âˆ) with (âŸ¨b, hbâŸ© | htop)
  Â· calc
      Î¼ (â‹ƒ b, s b) = âˆ := top_unique (hb â–¸ (h_le b).trans <| measure_mono <| subset_iUnion _ _)
      _ = Î¼ (â‹ƒ b, t b) := Eq.symm <| top_unique <| hb â–¸ measure_mono (subset_iUnion _ _)
  push_neg at htop
  refine le_antisymm (measure_mono (iUnion_mono hsub)) ?_
  set M := toMeasurable Î¼
  have H : âˆ€ b, (M (t b) âˆ© M (â‹ƒ b, s b) : Set Î±).toPred =áµ[Î¼] (M (t b)).toPred := by
    refine fun b => ae_eq_of_subset_of_measure_ge inter_subset_left ?_ ?_ ?_
    Â· calc
        Î¼ (M (t b)) = Î¼ (t b) := measure_toMeasurable _
        _ â‰¤ Î¼ (s b) := h_le b
        _ â‰¤ Î¼ (M (t b) âˆ© M (â‹ƒ b, s b)) :=
          measure_mono <|
            subset_inter ((hsub b).trans <| subset_toMeasurable _ _)
              ((subset_iUnion _ _).trans <| subset_toMeasurable _ _)
    Â· exact (measurableSet_toMeasurable _ _).inter (measurableSet_toMeasurable _ _)
    Â· rw [measure_toMeasurable]
      exact htop b
  calc
    Î¼ (â‹ƒ b, t b) â‰¤ Î¼ (â‹ƒ b, M (t b)) := measure_mono (iUnion_mono fun b => subset_toMeasurable _ _)
    _ = Î¼ (â‹ƒ b, M (t b) âˆ© M (â‹ƒ b, s b)) := measure_congr (EventuallyEq.countable_iUnion H).symm
    _ â‰¤ Î¼ (M (â‹ƒ b, s b)) := measure_mono (iUnion_subset fun b => inter_subset_right)
    _ = Î¼ (â‹ƒ b, s b) := measure_toMeasurable _","error:  invalid field 'toPred', the environment does not contain 'Set.toPred'
  M (t b) âˆ© M (â‹ƒ b, s b)
has type
  Set Î±
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  M (t b) âˆ© M (â‹ƒ b, s b)
has type
  Î± â†’ Prop
error:  invalid field 'toPred', the environment does not contain 'Set.toPred'
  M (t b)
has type
  Set Î±
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  M (t b)
has type
  Î± â†’ Prop
error:  unsolved goals
case inr
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Î´ : Type u_4
Î¹ : Type u_5
R : Type u_6
R' : Type u_7
m : MeasurableSpace Î±
Î¼ Î¼â‚ Î¼â‚‚ : Measure Î±
sâœ sâ‚ sâ‚‚ tâœ : Set Î±
instâœ : Countable Î²
s t : Î² â†’ Set Î±
hsub : âˆ€ (b : Î²), s b âŠ† t b
h_le : âˆ€ (b : Î²), Î¼ (t b) â‰¤ Î¼ (s b)
htop : âˆ€ (b : Î²), Î¼ (t b) â‰  âŠ¤
M : Set Î± â†’ Set Î± := toMeasurable Î¼
âŠ¢ Î¼ (â‹ƒ b, t b) â‰¤ Î¼ (â‹ƒ b, s b)
warning:  @Measure.AbsolutelyContinuous does not have a doc string","theorem measure_iUnion_congr_of_subset [Countable Î²] {s : Î² â†’ Set Î±} {t : Î² â†’ Set Î±}
    (hsub : âˆ€ b, s b âŠ† t b) (h_le : âˆ€ b, Î¼ (t b) â‰¤ Î¼ (s b)) : Î¼ (â‹ƒ b, s b) = Î¼ (â‹ƒ b, t b) ",":= by
  rcases Classical.em (âˆƒ b, Î¼ (t b) = âˆ) with (âŸ¨b, hbâŸ© | htop)
  Â· calc
      Î¼ (â‹ƒ b, s b) = âˆ := top_unique (hb â–¸ (h_le b).trans <| measure_mono <| subset_iUnion _ _)
      _ = Î¼ (â‹ƒ b, t b) := Eq.symm <| top_unique <| hb â–¸ measure_mono (subset_iUnion _ _)
  push_neg at htop
  refine le_antisymm (measure_mono (iUnion_mono hsub)) ?_
  set M := toMeasurable Î¼
  have H : âˆ€ b, (M (t b) âˆ© M (â‹ƒ b, s b) : Set Î±) =áµ[Î¼] M (t b) := by
    refine fun b => ae_eq_of_subset_of_measure_ge inter_subset_left ?_ ?_ ?_
    Â· calc
        Î¼ (M (t b)) = Î¼ (t b) := measure_toMeasurable _
        _ â‰¤ Î¼ (s b) := h_le b
        _ â‰¤ Î¼ (M (t b) âˆ© M (â‹ƒ b, s b)) :=
          measure_mono <|
            subset_inter ((hsub b).trans <| subset_toMeasurable _ _)
              ((subset_iUnion _ _).trans <| subset_toMeasurable _ _)
    Â· exact (measurableSet_toMeasurable _ _).inter (measurableSet_toMeasurable _ _)
    Â· rw [measure_toMeasurable]
      exact htop b
  calc
    Î¼ (â‹ƒ b, t b) â‰¤ Î¼ (â‹ƒ b, M (t b)) := measure_mono (iUnion_mono fun b => subset_toMeasurable _ _)
    _ = Î¼ (â‹ƒ b, M (t b) âˆ© M (â‹ƒ b, s b)) := measure_congr (EventuallyEq.countable_iUnion H).symm
    _ â‰¤ Î¼ (M (â‹ƒ b, s b)) := measure_mono (iUnion_subset fun b => inter_subset_right)
    _ = Î¼ (â‹ƒ b, s b) := measure_toMeasurable _"
Mathlib/Data/Real/Irrational.lean,irrational_nrt_of_notint_nrt,irrational_nrt_of_notint_nrt,bb997ebae7d037781f6e811e46f3f898622a1536,":= by
  rintro âŸ¨âŸ¨N, D, P, CâŸ©, rflâŸ©
  rw [â† cast_pow] at hxr
  have c1 : ((D : â„¤) : â„) â‰  0 := by
    rw [Int.cast_ne_zero, Int.natCast_ne_zero]
    exact P
  have c2 : ((D : â„¤) : â„) ^ n â‰  0 := pow_ne_zero _ c1
  rw [mk'_eq_divInt, cast_pow, cast_mk, div_pow, div_eq_iff_mul_eq c2, â† Int.cast_pow,
    â† Int.cast_pow, â† Int.cast_mul, Int.cast_inj] at hxr
  have hdivn : (D : â„¤) ^ n âˆ£ N ^ n := Dvd.intro_left m hxr
  rw [â† Int.dvd_natAbs, â† Int.coe_nat_pow, Int.natCast_dvd_natCast, Int.natAbs_pow,
    Nat.pow_dvd_pow_iff hnpos] at hdivn
  obtain rfl : D = 1 := by rw [â† Nat.gcd_eq_right hdivn, C.gcd_eq_one]
  refine' hv âŸ¨N, _âŸ©
  rw [mk'_eq_divInt, Int.ofNat_one, divInt_one, cast_intCast]","warning:  `Int.coe_nat_pow` has been deprecated, use `Int.natCast_pow` instead
error:  application type mismatch
  Nat.pow_dvd_pow_iff hnpos
argument
  hnpos
has type
  0 < n : Prop
but is expected to have type
  ?m.3205 â‰  0 : Prop","theorem irrational_nrt_of_notint_nrt {x : â„} (n : â„•) (m : â„¤) (hxr : x ^ n = m)
    (hv : Â¬âˆƒ y : â„¤, x = y) (hnpos : 0 < n) : Irrational x ",":= by
  rintro âŸ¨âŸ¨N, D, P, CâŸ©, rflâŸ©
  rw [â† cast_pow] at hxr
  have c1 : ((D : â„¤) : â„) â‰  0 := by
    rw [Int.cast_ne_zero, Int.natCast_ne_zero]
    exact P
  have c2 : ((D : â„¤) : â„) ^ n â‰  0 := pow_ne_zero _ c1
  rw [mk'_eq_divInt, cast_pow, cast_mk, div_pow, div_eq_iff_mul_eq c2, â† Int.cast_pow,
    â† Int.cast_pow, â† Int.cast_mul, Int.cast_inj] at hxr
  have hdivn : (D : â„¤) ^ n âˆ£ N ^ n := Dvd.intro_left m hxr
  rw [â† Int.dvd_natAbs, â† Int.natCast_pow, Int.natCast_dvd_natCast, Int.natAbs_pow,
    Nat.pow_dvd_pow_iff hnpos.ne'] at hdivn
  obtain rfl : D = 1 := by rw [â† Nat.gcd_eq_right hdivn, C.gcd_eq_one]
  refine hv âŸ¨N, ?_âŸ©
  rw [mk'_eq_divInt, Int.ofNat_one, divInt_one, cast_intCast]"
Mathlib/Order/ConditionallyCompleteLattice/Basic.lean,WithTop.isGLB_sInf,isGLB_sInf,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  constructor
  Â· show ite _ _ _ âˆˆ _
    split_ifs with h
    Â· intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    Â· rintro (âŸ¨âŸ© | a) ha
      Â· exact le_top
      refine some_le_some.2 (csInf_le ?_ ha)
      rcases hs with âŸ¨âŸ¨âŸ© | b, hbâŸ©
      Â· exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, â† top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact some_le_some.1 (hb hc)
  Â· show ite _ _ _ âˆˆ _
    split_ifs with h
    Â· intro _ _
      exact le_top
    Â· rintro (âŸ¨âŸ© | a) ha
      Â· exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      Â· refine some_le_some.2 (le_csInf ?_ ?_)
        Â· classical
            contrapose! h
            rintro (âŸ¨âŸ© | a) ha
            Â· exact mem_singleton âŠ¤
            Â· exact (not_nonempty_iff_eq_empty.2 h âŸ¨a, haâŸ©).elim
        Â· intro b hb
          rw [â† some_le_some]
          exact ha hb","error:  function expected at
  h
term has type
  s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.intro.none
Î± : Type u_1
Î²âœ : Type u_2
Î³ : Type u_3
Î¹ : Sort u_4
instâœÂ¹ : ConditionallyCompleteLinearOrderBot Î±
Î² : Type u_5
instâœ : ConditionallyCompleteLattice Î²
s : Set (WithTop Î²)
h : Â¬(s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s)
a : Î²
ha : Option.some a âˆˆ s
hb : none âˆˆ lowerBounds s
âŠ¢ s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.none
Î± : Type u_1
Î²âœ : Type u_2
Î³ : Type u_3
Î¹ : Sort u_4
instâœÂ¹ : ConditionallyCompleteLinearOrderBot Î±
Î² : Type u_5
instâœ : ConditionallyCompleteLattice Î²
s : Set (WithTop Î²)
hs : BddBelow s
h : Â¬(s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s)
ha : none âˆˆ lowerBounds s
âŠ¢ s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s
warning:  Don't mix Option and WithTop
error:  tactic 'introN' failed, insufficient number of binders
case neg.some.refine_1
Î± : Type u_1
Î²âœ : Type u_2
Î³ : Type u_3
Î¹ : Sort u_4
instâœÂ¹ : ConditionallyCompleteLinearOrderBot Î±
Î² : Type u_5
instâœ : ConditionallyCompleteLattice Î²
s : Set (WithTop Î²)
hs : BddBelow s
a : Î²
ha : Option.some a âˆˆ lowerBounds s
h : (fun a â†¦ â†‘a) â»Â¹' s = âˆ…
âŠ¢ s âŠ† {âŠ¤} âˆ¨ Â¬BddBelow s
warning:  Don't mix Option and WithTop","theorem isGLB_sInf' {Î² : Type*} [ConditionallyCompleteLattice Î²] {s : Set (WithTop Î²)}
    (hs : BddBelow s) : IsGLB s (sInf s) ",":= by
  constructor
  Â· show ite _ _ _ âˆˆ _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    Â· intro a ha
      exact top_le_iff.2 (Set.mem_singleton_iff.1 (h ha))
    Â· rintro (âŸ¨âŸ© | a) ha
      Â· exact le_top
      refine coe_le_coe.2 (csInf_le ?_ ha)
      rcases hs with âŸ¨âŸ¨âŸ© | b, hbâŸ©
      Â· exfalso
        apply h
        intro c hc
        rw [mem_singleton_iff, â† top_le_iff]
        exact hb hc
      use b
      intro c hc
      exact coe_le_coe.1 (hb hc)
  Â· show ite _ _ _ âˆˆ _
    simp only [hs, not_true_eq_false, or_false]
    split_ifs with h
    Â· intro _ _
      exact le_top
    Â· rintro (âŸ¨âŸ© | a) ha
      Â· exfalso
        apply h
        intro b hb
        exact Set.mem_singleton_iff.2 (top_le_iff.1 (ha hb))
      Â· refine coe_le_coe.2 (le_csInf ?_ ?_)
        Â· classical
            contrapose! h
            rintro (âŸ¨âŸ© | a) ha
            Â· exact mem_singleton âŠ¤
            Â· exact (not_nonempty_iff_eq_empty.2 h âŸ¨a, haâŸ©).elim
        Â· intro b hb
          rw [â† coe_le_coe]
          exact ha hb"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.ne_iff,ne_iff,fd88ffb8632619a5f956d8e317da257875d2c74c,:= FunLike.ne_iff,"warning:  Finsupp does not have a doc string
error:  type mismatch
  Function.ne_iff
has type
  ?m.3602 â‰  ?m.3603 â†” âˆƒ a, ?m.3602 a â‰  ?m.3603 a : Prop
but is expected to have type
  f â‰  g â†” âˆƒ a, f a â‰  g a : Prop","lemma ne_iff {f g : Î± â†’â‚€ M} : f â‰  g â†” âˆƒ a, f a â‰  g a ",:= DFunLike.ne_iff
Mathlib/Data/Nat/Bitwise.lean,Nat.bitwise_bit,bitwise_bit,8de3e1022420e90d40e4474715aa75e6852b50fe,":= by
  simp only [â†bitwise'_eq_bitwise, bitwise'_bit h]","warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  unknown identifier 'bitwise'_eq_bitwise'
error:  unknown identifier 'bitwise'_bit'
error:  simp made no progress
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `Nat.mul_lt_mul'` has been deprecated, use `Nat.mul_lt_mul_of_le_of_lt` instead
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated","lemma bitwise_bit {f : Bool â†’ Bool â†’ Bool} (h : f false false = false := by rfl) (a m b n) :
    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n) ",":= by
  conv_lhs => unfold bitwise
  simp only [bit, ite_apply, bit1, bit0, Bool.cond_eq_ite]
  have h1 x :     (x + x) % 2 = 0 := by rw [â† two_mul, mul_comm]; apply mul_mod_left
  have h2 x : (x + x + 1) % 2 = 1 := by rw [â† two_mul, add_comm]; apply add_mul_mod_self_left
  have h3 x :     (x + x) / 2 = x := by omega
  have h4 x : (x + x + 1) / 2 = x := by rw [â† two_mul, add_comm]; simp [add_mul_div_left]
  cases a <;> cases b <;> simp [h1, h2, h3, h4] <;> split_ifs
    <;> simp_all (config := {decide := true})"
Mathlib/Algebra/Lie/Classical.lean,LieAlgebra.Orthogonal.pso_inv,pso_inv,26f90e4ce49659c658c9028446001537e0f5211a,":= by
  ext (x y); rcases x with âŸ¨xâŸ©|âŸ¨xâŸ© <;> rcases y with âŸ¨yâŸ©|âŸ¨yâŸ©
  Â· 
    by_cases h : x = y <;>
    simp [Pso, indefiniteDiagonal, h]
  Â· 
    simp [Pso, indefiniteDiagonal]
  Â· 
    simp [Pso, indefiniteDiagonal]
  Â· 
    by_cases h : x = y <;>
    simp [Pso, indefiniteDiagonal, h, hi]","error:  unsolved goals
case pos
n : Type u_1
p : Type u_2
q : Type u_3
l : Type u_4
R : Type uâ‚‚
instâœâ¶ : DecidableEq n
instâœâµ : DecidableEq p
instâœâ´ : DecidableEq q
instâœÂ³ : DecidableEq l
instâœÂ² : CommRing R
instâœÂ¹ : Fintype p
instâœ : Fintype q
i : R
hi : i * i = -1
x y : p
h : x = y
âŠ¢ 1 = 1 (Sum.inl x) (Sum.inl y)
error:  unsolved goals
case pos
n : Type u_1
p : Type u_2
q : Type u_3
l : Type u_4
R : Type uâ‚‚
instâœâ¶ : DecidableEq n
instâœâµ : DecidableEq p
instâœâ´ : DecidableEq q
instâœÂ³ : DecidableEq l
instâœÂ² : CommRing R
instâœÂ¹ : Fintype p
instâœ : Fintype q
i : R
hi : i * i = -1
x y : q
h : x = y
âŠ¢ 1 = 1 (Sum.inr x) (Sum.inr y)",theorem pso_inv {i : R} (hi : i * i = -1) : Pso p q R i * Pso p q R (-i) = 1 ,":= by
  ext (x y); rcases x with âŸ¨xâŸ©|âŸ¨xâŸ© <;> rcases y with âŸ¨yâŸ©|âŸ¨yâŸ©
  Â· 
    by_cases h : x = y <;>
    simp [Pso, indefiniteDiagonal, h, one_apply]
  Â· 
    simp [Pso, indefiniteDiagonal]
  Â· 
    simp [Pso, indefiniteDiagonal]
  Â· 
    by_cases h : x = y <;>
    simp [Pso, indefiniteDiagonal, h, hi, one_apply]"
Mathlib/NumberTheory/NumberField/Discriminant.lean,NumberField.hermiteTheorem.minkowskiBound_lt_boundOfDiscBdd,minkowskiBound_lt_boundOfDiscBdd,9fa7007ae9f521f1867108ea567226fa0733f67f,":= by
  have : boundOfDiscBdd N - 1 < boundOfDiscBdd N := by norm_num
  refine lt_of_le_of_lt ?_ (coe_lt_coe.mpr this)
  rw [minkowskiBound, volume_fundamentalDomain_fractionalIdealLatticeBasis, boundOfDiscBdd,
    add_tsub_cancel_right, Units.val_one, FractionalIdeal.absNorm_one, Rat.cast_one,
    ENNReal.ofReal_one, one_mul, mixedEmbedding.finrank, volume_fundamentalDomain_latticeBasis,
    coe_mul, ENNReal.coe_pow, coe_ofNat, show sqrt N = (1:â„â‰¥0âˆ) * sqrt N by rw [one_mul]]
  gcongr
  Â· exact pow_le_one _ (by positivity) (by norm_num)
  Â· rwa [sqrt_le_sqrt, â† NNReal.coe_le_coe, coe_nnnorm, Int.norm_eq_abs, â† Int.cast_abs,
      NNReal.coe_nat_cast, â† Int.cast_ofNat, Int.cast_le]
  Â· exact one_le_two
  Â· exact rank_le_rankOfDiscrBdd hK","warning:  `NNReal.coe_nat_cast` has been deprecated, use `NNReal.coe_natCast` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  OfNat.ofNat ?n
case hâ‚.hâ‚‚.a
K : Type u_1
instâœÂ³ : Field K
instâœÂ² : NumberField K
A : Type u_2
instâœÂ¹ : Field A
instâœ : CharZero A
N : â„•
hK : |discr K| â‰¤ â†‘N
this : boundOfDiscBdd N - 1 < boundOfDiscBdd N
âŠ¢ â†‘|discr K| â‰¤ â†‘N",theorem minkowskiBound_lt_boundOfDiscBdd : minkowskiBound K â†‘1 < boundOfDiscBdd N ,":= by
  have : boundOfDiscBdd N - 1 < boundOfDiscBdd N := by
    simp_rw [boundOfDiscBdd, add_tsub_cancel_right, lt_add_iff_pos_right, zero_lt_one]
  refine lt_of_le_of_lt ?_ (coe_lt_coe.mpr this)
  rw [minkowskiBound, volume_fundamentalDomain_fractionalIdealLatticeBasis, boundOfDiscBdd,
    add_tsub_cancel_right, Units.val_one, FractionalIdeal.absNorm_one, Rat.cast_one,
    ENNReal.ofReal_one, one_mul, mixedEmbedding.finrank, volume_fundamentalDomain_latticeBasis,
    coe_mul, ENNReal.coe_pow, coe_ofNat, show sqrt N = (1:â„â‰¥0âˆ) * sqrt N by rw [one_mul]]
  gcongr
  Â· exact pow_le_one _ (by positivity) (by norm_num)
  Â· rwa [sqrt_le_sqrt, â† NNReal.coe_le_coe, coe_nnnorm, Int.norm_eq_abs, â† Int.cast_abs,
      NNReal.coe_natCast, â† Int.cast_natCast, Int.cast_le]
  Â· exact one_le_two
  Â· exact rank_le_rankOfDiscrBdd hK"
Mathlib/RingTheory/IsAdjoinRoot.lean,IsAdjoinRootMonic.basis_repr,basis_repr,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  change (h.modByMonicHom x).toFinsupp.comapDomain _ ( Fin.val_injective.injOn _) i = _
  rw [Finsupp.comapDomain_apply, Polynomial.toFinsupp_apply]","error:  application type mismatch
  Finsupp.comapDomain ?m.188826 (h.modByMonicHom x).toFinsupp â‹¯
argument
  Function.Injective.injOn Fin.val_injective ?m.188850
has type
  âˆ€ â¦ƒxâ‚‚ : Fin ?m.188827â¦„, xâ‚‚ âˆˆ ?m.188848 â†’ â†‘?m.188849 = â†‘xâ‚‚ â†’ ?m.188849 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn ?m.188826 (?m.188826 â»Â¹' â†‘(h.modByMonicHom x).toFinsupp.support) : Prop","theorem basis_repr (h : IsAdjoinRootMonic S f) (x : S) (i : Fin (natDegree f)) :
    h.basis.repr x i = (h.modByMonicHom x).coeff (i : â„•) ",":= by
  change (h.modByMonicHom x).toFinsupp.comapDomain _ Fin.val_injective.injOn i = _
  rw [Finsupp.comapDomain_apply, Polynomial.toFinsupp_apply]"
Mathlib/RingTheory/ChainOfDivisors.lean,DivisorChain.eq_pow_second_of_chain_of_has_chain,eq_pow_second_of_chain_of_has_chain,1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493,":= by
  classical
    obtain âŸ¨i, hi'âŸ© := element_of_chain_eq_pow_second_of_chain hn hâ‚ (@fun r => hâ‚‚) (dvd_refl q) hq
    convert hi'
    refine (Nat.lt_succ_iff.1 i.prop).antisymm' (Nat.le_of_succ_le_succ ?_)
    calc
      n + 1 = (Finset.univ : Finset (Fin (n + 1))).card := (Finset.card_fin _).symm
      _ = (Finset.univ.image c).card := (Finset.card_image_iff.mpr (hâ‚.injective.injOn _)).symm
      _ â‰¤ (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : â„•)).card :=
        (Finset.card_le_card ?_)
      _ â‰¤ (Finset.univ : Finset (Fin (i + 1))).card := Finset.card_image_le
      _ = i + 1 := Finset.card_fin _
    intro r hr
    obtain âŸ¨j, -, rflâŸ© := Finset.mem_image.1 hr
    have := hâ‚‚.2 âŸ¨j, rflâŸ©
    rw [hi'] at this
    have h := (dvd_prime_pow (show Prime (c 1) from ?_) i).1 this
    Â· rcases h with âŸ¨u, hu, hu'âŸ©
      refine Finset.mem_image.mpr âŸ¨u, Finset.mem_univ _, ?_âŸ©
      rw [associated_iff_eq] at hu'
      rw [Fin.val_cast_of_lt (Nat.lt_succ_of_le hu), hu']
    Â· rw [â† irreducible_iff_prime]
      exact second_of_chain_is_irreducible hn hâ‚ (@hâ‚‚) hq","error:  application type mismatch
  Finset.card_image_iff.mpr (Function.Injective.injOn (StrictMono.injective hâ‚) ?m.37447)
argument
  Function.Injective.injOn (StrictMono.injective hâ‚) ?m.37447
has type
  âˆ€ â¦ƒxâ‚‚ : Fin (n + 1)â¦„, xâ‚‚ âˆˆ ?m.37445 â†’ c ?m.37446 = c xâ‚‚ â†’ ?m.37446 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn ?m.37126 â†‘?m.37125 : Prop","theorem eq_pow_second_of_chain_of_has_chain {q : Associates M} {n : â„•} (hn : n â‰  0)
    {c : Fin (n + 1) â†’ Associates M} (hâ‚ : StrictMono c)
    (hâ‚‚ : âˆ€ {r : Associates M}, r â‰¤ q â†” âˆƒ i, r = c i) (hq : q â‰  0) : q = c 1 ^ n ",":= by
  classical
    obtain âŸ¨i, hi'âŸ© := element_of_chain_eq_pow_second_of_chain hn hâ‚ (@fun r => hâ‚‚) (dvd_refl q) hq
    convert hi'
    refine (Nat.lt_succ_iff.1 i.prop).antisymm' (Nat.le_of_succ_le_succ ?_)
    calc
      n + 1 = (Finset.univ : Finset (Fin (n + 1))).card := (Finset.card_fin _).symm
      _ = (Finset.univ.image c).card := (Finset.card_image_iff.mpr hâ‚.injective.injOn).symm
      _ â‰¤ (Finset.univ.image fun m : Fin (i + 1) => c 1 ^ (m : â„•)).card :=
        (Finset.card_le_card ?_)
      _ â‰¤ (Finset.univ : Finset (Fin (i + 1))).card := Finset.card_image_le
      _ = i + 1 := Finset.card_fin _
    intro r hr
    obtain âŸ¨j, -, rflâŸ© := Finset.mem_image.1 hr
    have := hâ‚‚.2 âŸ¨j, rflâŸ©
    rw [hi'] at this
    have h := (dvd_prime_pow (show Prime (c 1) from ?_) i).1 this
    Â· rcases h with âŸ¨u, hu, hu'âŸ©
      refine Finset.mem_image.mpr âŸ¨u, Finset.mem_univ _, ?_âŸ©
      rw [associated_iff_eq] at hu'
      rw [Fin.val_cast_of_lt (Nat.lt_succ_of_le hu), hu']
    Â· rw [â† irreducible_iff_prime]
      exact second_of_chain_is_irreducible hn hâ‚ (@hâ‚‚) hq"
Mathlib/RepresentationTheory/FdRep.lean,FdRep.Iso.conj_Ï,Iso.conj_Ï,4edd6891cdab07363f52c0ee03314b62868883bb,":= by
  erw [FdRep.isoToLinearEquiv, â† FGModuleCat.Iso.conj_eq_conj, Iso.conj_apply]
  rw [Iso.eq_inv_comp ((Action.forget (FGModuleCat k) G).mapIso i)]
  exact (i.hom.comm g).symm","error:  application type mismatch
  Action.forget (FGModuleCat k) G
argument
  G
has type
  Type u : Type (u + 1)
but is expected to have type
  MonCat : Type (u + 1)","theorem Iso.conj_Ï {V W : FdRep k G} (i : V â‰… W) (g : G) :
    W.Ï g = (FdRep.isoToLinearEquiv i).conj (V.Ï g) ",":= by
  erw [FdRep.isoToLinearEquiv, â† FGModuleCat.Iso.conj_eq_conj, Iso.conj_apply]
  rw [Iso.eq_inv_comp ((Action.forget (FGModuleCat k) (MonCat.of G)).mapIso i)]
  exact (i.hom.comm g).symm"
Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean,jacobiSym.even_odd,even_odd,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain âŸ¨a, rflâŸ© := Int.dvd_of_emod_eq_zero ha2
  rw [Int.mul_ediv_cancel_left _ (by decide), jacobiSym.mul_left,
    jacobiSym.at_two (Nat.odd_iff.mpr hb2), ZMod.Ï‡â‚ˆ_nat_eq_if_mod_eight,
    if_neg (Nat.mod_two_ne_zero.mpr hb2)]
  have := Nat.mod_lt b (by decide : 0 < 8)
  interval_cases h : b % 8 <;> simp_all <;>
    exact absurd (hb2 â–¸ h â–¸ Nat.mod_mod_of_dvd b (by decide : 2 âˆ£ 8)) zero_ne_one","warning:  jacobiSym does not have a doc string
error:  type mismatch
  hb2 â–¸ h â–¸ mod_mod_of_dvd b (of_decide_eq_true (Eq.refl true))
has type
  2 % 2 = 1 : Prop
but is expected to have type
  0 = 1 : Prop
error:  type mismatch
  hb2 â–¸ h â–¸ mod_mod_of_dvd b (of_decide_eq_true (Eq.refl true))
has type
  4 % 2 = 1 : Prop
but is expected to have type
  0 = 1 : Prop
error:  type mismatch
  hb2 â–¸ h â–¸ mod_mod_of_dvd b (of_decide_eq_true (Eq.refl true))
has type
  6 % 2 = 1 : Prop
but is expected to have type
  0 = 1 : Prop
error:  unsolved goals
case intro.Â«2Â»
b : â„•
hb2 : b % 2 = 1
a : â„¤
h : b % 8 = 2
âŠ¢ J(a | b) = 0

case intro.Â«4Â»
b : â„•
hb2 : b % 2 = 1
a : â„¤
h : b % 8 = 4
âŠ¢ J(a | b) = 0

case intro.Â«6Â»
b : â„•
hb2 : b % 2 = 1
a : â„¤
h : b % 8 = 6
âŠ¢ J(a | b) = 0","theorem even_odd {a : â„¤} {b : â„•} (ha2 : a % 2 = 0) (hb2 : b % 2 = 1) :
    (if b % 8 = 3 âˆ¨ b % 8 = 5 then -J(a / 2 | b) else J(a / 2 | b)) = J(a | b) ",":= by
  obtain âŸ¨a, rflâŸ© := Int.dvd_of_emod_eq_zero ha2
  rw [Int.mul_ediv_cancel_left _ (by decide), jacobiSym.mul_left,
    jacobiSym.at_two (Nat.odd_iff.mpr hb2), ZMod.Ï‡â‚ˆ_nat_eq_if_mod_eight,
    if_neg (Nat.mod_two_ne_zero.mpr hb2)]
  have := Nat.mod_lt b (by decide : 0 < 8)
  interval_cases h : b % 8 <;> simp_all <;>
  Â· have := hb2 â–¸ h â–¸ Nat.mod_mod_of_dvd b (by decide : 2 âˆ£ 8)
    simp_all"
Mathlib/RingTheory/FinitePresentation.lean,RingHom.FinitePresentation.of_finiteType,of_finiteType,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  refine' âŸ¨fun h => _, Algebra.FiniteType.of_finitePresentationâŸ©
  obtain âŸ¨n, f, hfâŸ© := Algebra.FiniteType.iff_quotient_mvPolynomial''.1 h
  refine' âŸ¨n, f, hf, _âŸ©
  have hnoet : IsNoetherianRing (MvPolynomial (Fin n) R) := by infer_instance
  rw [isNoetherianRing_iff] at hnoet
  letI : Module (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R) := Semiring.toModule
  have := hnoet.noetherian (RingHom.ker f.toRingHom)
  convert this","error:  failed to synthesize
  FinitePresentation ?m.5343 ?m.5344
use `set_option diagnostics true` to get diagnostic information",theorem of_finiteType [IsNoetherianRing R] : FiniteType R A â†” FinitePresentation R A ,":= by
  refine âŸ¨fun h => ?_, fun hfp => Algebra.FiniteType.of_finitePresentationâŸ©
  obtain âŸ¨n, f, hfâŸ© := Algebra.FiniteType.iff_quotient_mvPolynomial''.1 h
  refine âŸ¨n, f, hf, ?_âŸ©
  have hnoet : IsNoetherianRing (MvPolynomial (Fin n) R) := by infer_instance
  rw [isNoetherianRing_iff] at hnoet
  letI : Module (MvPolynomial (Fin n) R) (MvPolynomial (Fin n) R) := Semiring.toModule
  have := hnoet.noetherian (RingHom.ker f.toRingHom)
  convert this"
Mathlib/Analysis/Convex/Combination.lean,convexHull_eq_union_convexHull_finite_subsets,convexHull_eq_union_convexHull_finite_subsets,9e34a191034458a56331f976ff7400a26407c888,":= by
  refine' Subset.antisymm _ _
  Â· rw [_root_.convexHull_eq]
    rintro x âŸ¨Î¹ : Type u_1, t, w, z, hwâ‚€, hwâ‚, hz, rflâŸ©
    simp only [mem_iUnion]
    refine' âŸ¨t.image z, _, _âŸ©
    Â· rw [coe_image, Set.image_subset_iff]
      exact hz
    Â· apply t.centerMass_mem_convexHull hwâ‚€
      Â· simp only [hwâ‚, zero_lt_one]
      Â· exact fun i hi => Finset.mem_coe.2 (Finset.mem_image_of_mem _ hi)
  Â· exact iUnion_subset fun i => iUnion_subset convexHull_mono","error:  rcases: scrutinee has type
  Type : Type 1
but is expected to have type
  Type u_1 : Type (u_1 + 1)","theorem convexHull_eq_union_convexHull_finite_subsets (s : Set E) :
    convexHull R s = â‹ƒ (t : Finset E) (w : â†‘t âŠ† s), convexHull R â†‘t ",":= by
  refine Subset.antisymm ?_ ?_
  Â· rw [_root_.convexHull_eq]
    rintro x âŸ¨Î¹, t, w, z, hwâ‚€, hwâ‚, hz, rflâŸ©
    simp only [mem_iUnion]
    refine âŸ¨t.image z, ?_, ?_âŸ©
    Â· rw [coe_image, Set.image_subset_iff]
      exact hz
    Â· apply t.centerMass_mem_convexHull hwâ‚€
      Â· simp only [hwâ‚, zero_lt_one]
      Â· exact fun i hi => Finset.mem_coe.2 (Finset.mem_image_of_mem _ hi)
  Â· exact iUnion_subset fun i => iUnion_subset convexHull_mono"
Mathlib/Algebra/Homology/QuasiIso.lean,quasiIso_iff,quasiIso_iff,4773ba7abb162ea632c1ff5810cd5f45a1289422,":= by
  dsimp [HomologicalComplex.qis]
  simp only [â† quasiIsoAt_iff_isIso_homologyMap f]
  constructor
  Â· intro h i
    infer_instance
  Â· intro h
    exact âŸ¨hâŸ©","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  HomologicalComplex
has type
  (V : Type ?u.117196) â†’
    [inst : Category.{?u.117197, ?u.117196} V] â†’
      [inst : HasZeroMorphisms V] â†’ ComplexShape ?m.117198 â†’ Type (max (max ?u.117196 ?u.117195) ?u.117197)
error:  dsimp made no progress","lemma quasiIso_iff (f : K âŸ¶ L) [âˆ€ i, K.HasHomology i] [âˆ€ i, L.HasHomology i] :
    QuasiIso f â†” âˆ€ i, QuasiIsoAt f i ",":=
  âŸ¨fun h => h.quasiIsoAt, fun h => âŸ¨hâŸ©âŸ©"
Mathlib/Probability/ProbabilityMassFunction/Monad.lean,PMF.bindOnSupport_bindOnSupport,bindOnSupport_bindOnSupport,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  refine PMF.ext fun a => ?_
  dsimp only [bindOnSupport_apply]
  simp only [â† tsum_dite_right, ENNReal.tsum_mul_left.symm, ENNReal.tsum_mul_right.symm]
  simp only [ENNReal.tsum_eq_zero, dite_eq_left_iff]
  refine' ENNReal.tsum_comm.trans (tsum_congr fun a' => tsum_congr fun b => _)
  split_ifs with h _ h_1 _ h_2
  any_goals ring1
  Â· have := h_1 a'
    simp? [h] at this says simp only [h, â†“reduceDite, mul_eq_zero, false_or] at this
    contradiction
  Â· simp [h_2]",error:  unknown identifier 'reduceDite',"theorem bindOnSupport_bindOnSupport (p : PMF Î±) (f : âˆ€ a âˆˆ p.support, PMF Î²)
    (g : âˆ€ b âˆˆ (p.bindOnSupport f).support, PMF Î³) :
    (p.bindOnSupport f).bindOnSupport g =
      p.bindOnSupport fun a ha =>
        (f a ha).bindOnSupport fun b hb =>
          g b ((mem_support_bindOnSupport_iff f b).mpr âŸ¨a, ha, hbâŸ©) ",":= by
  refine PMF.ext fun a => ?_
  dsimp only [bindOnSupport_apply]
  simp only [â† tsum_dite_right, ENNReal.tsum_mul_left.symm, ENNReal.tsum_mul_right.symm]
  simp only [ENNReal.tsum_eq_zero, dite_eq_left_iff]
  refine ENNReal.tsum_comm.trans (tsum_congr fun a' => tsum_congr fun b => ?_)
  split_ifs with h _ h_1 _ h_2
  any_goals ring1
  Â· have := h_1 a'
    simp? [h] at this says simp only [h, â†“reduceDIte, mul_eq_zero, false_or] at this
    contradiction
  Â· simp [h_2]"
Mathlib/Topology/Category/Stonean/Basic.lean,Stonean.epi_iff_surjective,epi_iff_surjective,e2426ff5dc46051d5747537177e0e66c5dc771e7,":= by
  refine âŸ¨?_, ConcreteCategory.epi_of_surjective _âŸ©
  dsimp [Function.Surjective]
  intro h y
  by_contra' hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := Cá¶œ
  have hUy : U âˆˆ nhds y := by
    simp only [Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain âŸ¨V, hV, hyV, hVUâŸ© := isTopologicalBasis_clopen.mem_nhds_iff.mp hUy
  classical
  let g : Y âŸ¶ mkFinite (ULift (Fin 2)) :=
    âŸ¨(LocallyConstant.ofClopen hV).map ULift.up, LocallyConstant.continuous _âŸ©
  let h : Y âŸ¶ mkFinite (ULift (Fin 2)) := âŸ¨fun _ => âŸ¨1âŸ©, continuous_constâŸ©
  have H : h = g := by
    rw [â† cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU Â·) ?_ 
    simpa only [Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H","error:  unknown tactic
error:  unsolved goals
X Y : Stonean
f : X âŸ¶ Y
h : Epi f
y : CoeSort.coe Y
âŠ¢ âˆƒ a, f a = y","lemma epi_iff_surjective {X Y : Stonean} (f : X âŸ¶ Y) :
    Epi f â†” Function.Surjective f ",":= by
  refine âŸ¨?_, ConcreteCategory.epi_of_surjective _âŸ©
  dsimp [Function.Surjective]
  intro h y
  by_contra! hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := Cá¶œ
  have hUy : U âˆˆ ğ“ y := by
    simp only [C, Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain âŸ¨V, hV, hyV, hVUâŸ© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy
  classical
  let g : Y âŸ¶ mkFinite (ULift (Fin 2)) :=
    âŸ¨(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _âŸ©
  let h : Y âŸ¶ mkFinite (ULift (Fin 2)) := âŸ¨fun _ => âŸ¨1âŸ©, continuous_constâŸ©
  have H : h = g := by
    rw [â† cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU Â·) ?_ 
    simpa only [U, Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,difference_quotients_converge_uniformly,difference_quotients_converge_uniformly,0939faa78a0c4506a8aee4e86b897d6e84c6cb96,":= by
  let : NormedSpace â„ E; exact NormedSpace.restrictScalars â„ ğ•œ _
  rcases eq_or_ne l âŠ¥ with (hl | hl)
  Â· simp only [hl, TendstoUniformlyOnFilter, bot_prod, eventually_bot, imp_true_iff]
  haveI : NeBot l := âŸ¨hlâŸ©
  refine'
    UniformCauchySeqOnFilter.tendstoUniformlyOnFilter_of_tendsto _
      ((hfg.and (eventually_const.mpr hfg.self_of_nhds)).mono fun y hy =>
        (hy.1.sub hy.2).const_smul _)
  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero]
  rw [Metric.tendstoUniformlyOnFilter_iff]
  have hfg' := hf'.uniformCauchySeqOnFilter
  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero] at hfg'
  rw [Metric.tendstoUniformlyOnFilter_iff] at hfg'
  intro Îµ hÎµ
  obtain âŸ¨q, hqpos, hqÎµâŸ© := exists_pos_rat_lt hÎµ
  specialize hfg' (q : â„) (by simp [hqpos])
  have := (tendsto_swap4_prod.eventually (hf.prod_mk hf)).diag_of_prod_right
  obtain âŸ¨a, b, c, d, eâŸ© := eventually_prod_iff.1 (hfg'.and this)
  obtain âŸ¨r, hr, hr'âŸ© := Metric.nhds_basis_ball.eventually_iff.mp d
  rw [eventually_prod_iff]
  refine'
    âŸ¨_, b, fun e : E => Metric.ball x r e,
      eventually_mem_set.mpr (Metric.nhds_basis_ball.mem_of_mem hr), fun {n} hn {y} hy => _âŸ©
  simp only [Pi.zero_apply, dist_zero_left]
  rw [â† smul_sub, norm_smul, norm_inv, IsROrC.norm_coe_norm]
  refine' lt_of_le_of_lt _ hqÎµ
  by_cases hyz' : x = y; Â· simp [hyz', hqpos.le]
  have hyz : 0 < â€–y - xâ€– := by rw [norm_pos_iff]; intro hy'; exact hyz' (eq_of_sub_eq_zero hy').symm
  rw [inv_mul_le_iff hyz, mul_comm, sub_sub_sub_comm]
  simp only [Pi.zero_apply, dist_zero_left] at e
  refine'
    Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le
      (fun y hy => ((e hn (hr' hy)).2.1.sub (e hn (hr' hy)).2.2).hasFDerivWithinAt)
      (fun y hy => (e hn (hr' hy)).1.le) (convex_ball x r) (Metric.mem_ball_self hr) hy","error:  unexpected token ':'; expected '_', identifier or term
error:  unsolved goals
Î¹ : Type u_1
l : Filter Î¹
E : Type u_2
instâœâ´ : NormedAddCommGroup E
ğ•œ : Type u_3
instâœÂ³ : RCLike ğ•œ
instâœÂ² : NormedSpace ğ•œ E
G : Type u_4
instâœÂ¹ : NormedAddCommGroup G
instâœ : NormedSpace ğ•œ G
f : Î¹ â†’ E â†’ G
g : E â†’ G
f' : Î¹ â†’ E â†’ E â†’L[ğ•œ] G
g' : E â†’ E â†’L[ğ•œ] G
x : E
hf' : TendstoUniformlyOnFilter f' g' l (ğ“ x)
hf : âˆ€á¶  (n : Î¹ Ã— E) in l Ã—Ë¢ ğ“ x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2
hfg : âˆ€á¶  (y : E) in ğ“ x, Tendsto (fun n â†¦ f n y) l (ğ“ (g y))
âŠ¢ TendstoUniformlyOnFilter (fun n y â†¦ (â†‘â€–y - xâ€–)â»Â¹ â€¢ (f n y - f n x)) (fun y â†¦ (â†‘â€–y - xâ€–)â»Â¹ â€¢ (g y - g x)) l (ğ“ x)","theorem difference_quotients_converge_uniformly (hf' : TendstoUniformlyOnFilter f' g' l (ğ“ x))
    (hf : âˆ€á¶  n : Î¹ Ã— E in l Ã—Ë¢ ğ“ x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : âˆ€á¶  y : E in ğ“ x, Tendsto (fun n => f n y) l (ğ“ (g y))) :
    TendstoUniformlyOnFilter (fun n : Î¹ => fun y : E => (â€–y - xâ€–â»Â¹ : ğ•œ) â€¢ (f n y - f n x))
      (fun y : E => (â€–y - xâ€–â»Â¹ : ğ•œ) â€¢ (g y - g x)) l (ğ“ x) ",":= by
  let A : NormedSpace â„ E := NormedSpace.restrictScalars â„ ğ•œ _
  rcases eq_or_ne l âŠ¥ with (hl | hl)
  Â· simp only [hl, TendstoUniformlyOnFilter, bot_prod, eventually_bot, imp_true_iff]
  haveI : NeBot l := âŸ¨hlâŸ©
  refine
    UniformCauchySeqOnFilter.tendstoUniformlyOnFilter_of_tendsto ?_
      ((hfg.and (eventually_const.mpr hfg.self_of_nhds)).mono fun y hy =>
        (hy.1.sub hy.2).const_smul _)
  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero]
  rw [Metric.tendstoUniformlyOnFilter_iff]
  have hfg' := hf'.uniformCauchySeqOnFilter
  rw [SeminormedAddGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_zero] at hfg'
  rw [Metric.tendstoUniformlyOnFilter_iff] at hfg'
  intro Îµ hÎµ
  obtain âŸ¨q, hqpos, hqÎµâŸ© := exists_pos_rat_lt hÎµ
  specialize hfg' (q : â„) (by simp [hqpos])
  have := (tendsto_swap4_prod.eventually (hf.prod_mk hf)).diag_of_prod_right
  obtain âŸ¨a, b, c, d, eâŸ© := eventually_prod_iff.1 (hfg'.and this)
  obtain âŸ¨r, hr, hr'âŸ© := Metric.nhds_basis_ball.eventually_iff.mp d
  rw [eventually_prod_iff]
  refine
    âŸ¨_, b, fun e : E => Metric.ball x r e,
      eventually_mem_set.mpr (Metric.nhds_basis_ball.mem_of_mem hr), fun {n} hn {y} hy => ?_âŸ©
  simp only [Pi.zero_apply, dist_zero_left]
  rw [â† smul_sub, norm_smul, norm_inv, RCLike.norm_coe_norm]
  refine lt_of_le_of_lt ?_ hqÎµ
  by_cases hyz' : x = y; Â· simp [hyz', hqpos.le]
  have hyz : 0 < â€–y - xâ€– := by rw [norm_pos_iff]; intro hy'; exact hyz' (eq_of_sub_eq_zero hy').symm
  rw [inv_mul_le_iff hyz, mul_comm, sub_sub_sub_comm]
  simp only [Pi.zero_apply, dist_zero_left] at e
  refine
    Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le
      (fun y hy => ((e hn (hr' hy)).2.1.sub (e hn (hr' hy)).2.2).hasFDerivWithinAt)
      (fun y hy => (e hn (hr' hy)).1.le) (convex_ball x r) (Metric.mem_ball_self hr) hy"
Mathlib/LinearAlgebra/AffineSpace/Independent.lean,exists_subset_affineIndependent_affineSpan_eq_top,exists_subset_affineIndependent_affineSpan_eq_top,141b72620243c872cad4ebe6d1abbfc83a8f9ece,":= by
  rcases s.eq_empty_or_nonempty with (rfl | âŸ¨pâ‚, hpâ‚âŸ©)
  Â· have pâ‚ : P := AddTorsor.nonempty.some
    let hsv := Basis.ofVectorSpace k V
    have hsvi := hsv.linearIndependent
    have hsvt := hsv.span_eq
    rw [Basis.coe_ofVectorSpace] at hsvi hsvt
    have h0 : âˆ€ v : V, v âˆˆ Basis.ofVectorSpaceIndex _ _ â†’ v â‰  0 := by
      intro v hv
      simpa using hsv.ne_zero âŸ¨v, hvâŸ©
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 pâ‚] at hsvi
    exact
      âŸ¨{pâ‚} âˆª (fun v => v +áµ¥ pâ‚) '' _, Set.empty_subset _, hsvi,
        affineSpan_singleton_union_vadd_eq_top_of_span_eq_top pâ‚ hsvtâŸ©
  Â· rw [affineIndependent_set_iff_linearIndependent_vsub k hpâ‚] at h
    let bsv := Basis.extend h
    have hsvi := bsv.linearIndependent
    have hsvt := bsv.span_eq
    rw [Basis.coe_extend] at hsvi hsvt
    have hsv := h.subset_extend (Set.subset_univ _)
    have h0 : âˆ€ v : V, v âˆˆ h.extend _ â†’ v â‰  0 := by
      intro v hv
      simpa using bsv.ne_zero âŸ¨v, hvâŸ©
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 pâ‚] at hsvi
    refine' âŸ¨{pâ‚} âˆª (fun v => v +áµ¥ pâ‚) '' h.extend (Set.subset_univ _), _, _âŸ©
    Â· refine' Set.Subset.trans _ (Set.union_subset_union_right _ (Set.image_subset _ hsv))
      simp [Set.image_image]
    Â· use hsvi
      exact affineSpan_singleton_union_vadd_eq_top_of_span_eq_top pâ‚ hsvt","error:  typeclass instance problem is stuck, it is often due to metavariables
  Module (?m.225306 v) V","theorem exists_subset_affineIndependent_affineSpan_eq_top {s : Set P}
    (h : AffineIndependent k (fun p => p : s â†’ P)) :
    âˆƒ t : Set P, s âŠ† t âˆ§ AffineIndependent k (fun p => p : t â†’ P) âˆ§ affineSpan k t = âŠ¤ ",":= by
  rcases s.eq_empty_or_nonempty with (rfl | âŸ¨pâ‚, hpâ‚âŸ©)
  Â· have pâ‚ : P := AddTorsor.nonempty.some
    let hsv := Basis.ofVectorSpace k V
    have hsvi := hsv.linearIndependent
    have hsvt := hsv.span_eq
    rw [Basis.coe_ofVectorSpace] at hsvi hsvt
    have h0 : âˆ€ v : V, v âˆˆ Basis.ofVectorSpaceIndex k V â†’ v â‰  0 := by
      intro v hv
      simpa [hsv] using hsv.ne_zero âŸ¨v, hvâŸ©
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 pâ‚] at hsvi
    exact
      âŸ¨{pâ‚} âˆª (fun v => v +áµ¥ pâ‚) '' _, Set.empty_subset _, hsvi,
        affineSpan_singleton_union_vadd_eq_top_of_span_eq_top pâ‚ hsvtâŸ©
  Â· rw [affineIndependent_set_iff_linearIndependent_vsub k hpâ‚] at h
    let bsv := Basis.extend h
    have hsvi := bsv.linearIndependent
    have hsvt := bsv.span_eq
    rw [Basis.coe_extend] at hsvi hsvt
    have hsv := h.subset_extend (Set.subset_univ _)
    have h0 : âˆ€ v : V, v âˆˆ h.extend (Set.subset_univ _) â†’ v â‰  0 := by
      intro v hv
      simpa [bsv] using bsv.ne_zero âŸ¨v, hvâŸ©
    rw [linearIndependent_set_iff_affineIndependent_vadd_union_singleton k h0 pâ‚] at hsvi
    refine âŸ¨{pâ‚} âˆª (fun v => v +áµ¥ pâ‚) '' h.extend (Set.subset_univ _), ?_, ?_âŸ©
    Â· refine Set.Subset.trans ?_ (Set.union_subset_union_right _ (Set.image_subset _ hsv))
      simp [Set.image_image]
    Â· use hsvi
      exact affineSpan_singleton_union_vadd_eq_top_of_span_eq_top pâ‚ hsvt"
Mathlib/Probability/Kernel/Disintegration/Density.lean,ProbabilityTheory.kernel.tendsto_integral_density_of_antitone,tendsto_integral_density_of_antitone,dcf636eee4f43e91d2c17805ebddc392c3ab5605,":= by
  have : IsFiniteKernel Îº := isFiniteKernel_of_isFiniteKernel_fst (h := isFiniteKernel_of_le hÎºÎ½)
  simp_rw [integral_density hÎºÎ½ a (hseq_meas _)]
  rw [â† ENNReal.zero_toReal]
  have h_cont := ENNReal.continuousOn_toReal.continuousAt (x := 0) ?_
  swap
  Â· rw [mem_nhds_iff]
    refine âŸ¨Iio 1, fun x hx â†¦ ne_top_of_lt (?_ : x < 1), isOpen_Iio, ?_âŸ©
    Â· simpa using hx
    Â· simp
  refine h_cont.tendsto.comp ?_
  have h := tendsto_measure_iInter (s := fun m â†¦ univ Ã—Ë¢ seq m) (Î¼ := Îº a)
    (fun m â†¦ MeasurableSet.univ.prod (hseq_meas m)) ?_ ?_
  rotate_left
  Â· intro n m hnm x; simp only [mem_prod, mem_univ, true_and]; exact fun h â†¦ hseq hnm h
  Â· exact âŸ¨0, measure_ne_top _ _âŸ©
  convert h
  rw [â† prod_iInter, hseq_iInter]
  simp only [ne_eq, prod_empty, OuterMeasure.empty', forall_exists_index]","warning:  `MeasureTheory.OuterMeasure.empty'` has been deprecated, use `MeasureTheory.measure_empty` instead
error:  unsolved goals
case h.e'_5.h.e'_3
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
mÎ± : MeasurableSpace Î±
mÎ² : MeasurableSpace Î²
mÎ³ : MeasurableSpace Î³
instâœÂ¹ : CountablyGenerated Î³
Îº : â†¥(kernel Î± (Î³ Ã— Î²))
Î½ : â†¥(kernel Î± Î³)
hÎºÎ½ : fst Îº â‰¤ Î½
instâœ : IsFiniteKernel Î½
a : Î±
seq : â„• â†’ Set Î²
hseq : Antitone seq
hseq_iInter : â‹‚ i, seq i = âˆ…
hseq_meas : âˆ€ (m : â„•), MeasurableSet (seq m)
this : IsFiniteKernel Îº
h_cont : ContinuousAt ENNReal.toReal 0
h : Tendsto (â‡‘(Îº a) âˆ˜ fun m â†¦ univ Ã—Ë¢ seq m) atTop (ğ“ ((Îº a) (â‹‚ n, (fun m â†¦ univ Ã—Ë¢ seq m) n)))
âŠ¢ 0 = (Îº a) âˆ…","lemma tendsto_integral_density_of_antitone (hÎºÎ½ : fst Îº â‰¤ Î½) [IsFiniteKernel Î½] (a : Î±)
    (seq : â„• â†’ Set Î²) (hseq : Antitone seq) (hseq_iInter : â‹‚ i, seq i = âˆ…)
    (hseq_meas : âˆ€ m, MeasurableSet (seq m)) :
    Tendsto (fun m â†¦ âˆ« x, density Îº Î½ a x (seq m) âˆ‚(Î½ a)) atTop (ğ“ 0) ",":= by
  have : IsFiniteKernel Îº := isFiniteKernel_of_isFiniteKernel_fst (h := isFiniteKernel_of_le hÎºÎ½)
  simp_rw [integral_density hÎºÎ½ a (hseq_meas _)]
  rw [â† ENNReal.zero_toReal]
  have h_cont := ENNReal.continuousOn_toReal.continuousAt (x := 0) ?_
  swap
  Â· rw [mem_nhds_iff]
    refine âŸ¨Iio 1, fun x hx â†¦ ne_top_of_lt (?_ : x < 1), isOpen_Iio, ?_âŸ©
    Â· simpa using hx
    Â· simp
  refine h_cont.tendsto.comp ?_
  have h := tendsto_measure_iInter (s := fun m â†¦ univ Ã—Ë¢ seq m) (Î¼ := Îº a)
    (fun m â†¦ MeasurableSet.univ.prod (hseq_meas m)) ?_ ?_
  rotate_left
  Â· intro n m hnm x; simp only [mem_prod, mem_univ, true_and]; exact fun h â†¦ hseq hnm h
  Â· refine âŸ¨0, measure_ne_top _ _âŸ©
  convert h
  rw [â† prod_iInter, hseq_iInter]
  simp"
Mathlib/Topology/Separation.lean,connectedComponent_eq_iInter_isClopen,connectedComponent_eq_iInter_isClopen,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  apply Subset.antisymm connectedComponent_subset_iInter_isClopen
  refine' IsPreconnected.subset_connectedComponent _ (mem_iInter.2 fun s => s.2.2)
  have hs : @IsClosed X _ (â‹‚ s : { s : Set X // IsClopen s âˆ§ x âˆˆ s }, s) :=
    isClosed_iInter fun s => s.2.1.1
  rw [isPreconnected_iff_subset_of_fully_disjoint_closed hs]
  intro a b ha hb hab ab_disj
  rcases normal_separation ha hb ab_disj with âŸ¨u, v, hu, hv, hau, hbv, huvâŸ©
  obtain âŸ¨s, HâŸ© : âˆƒ s : Set X, IsClopen s âˆ§ x âˆˆ s âˆ§ s âŠ† u âˆª v
  Â· have H1 := (hu.union hv).isClosed_compl.isCompact.inter_iInter_nonempty
      (fun s : { s : Set X // IsClopen s âˆ§ x âˆˆ s } => s) fun s => s.2.1.1
    rw [â† not_disjoint_iff_nonempty_inter, imp_not_comm, not_forall] at H1
    cases' H1 (disjoint_compl_left_iff_subset.2 <| hab.trans <| union_subset_union hau hbv)
      with si H2
    refine âŸ¨â‹‚ U âˆˆ si, Subtype.val U, ?_, ?_, ?_ âŸ©
    Â· exact isClopen_biInter_finset fun s _ => s.2.1
    Â· exact mem_iInterâ‚‚.2 fun s _ => s.2.2
    Â· rwa [â† disjoint_compl_left_iff_subset, disjoint_iff_inter_eq_empty,
        â† not_nonempty_iff_eq_empty]
  Â· have H1 := isClopen_inter_of_disjoint_cover_clopen H.1 H.2.2 hu hv huv
    rw [union_comm] at H
    have H2 := isClopen_inter_of_disjoint_cover_clopen H.1 H.2.2 hv hu huv.symm
    by_cases hxu : x âˆˆ u <;> [left; right]
    Â· suffices â‹‚ s : { s : Set X // IsClopen s âˆ§ x âˆˆ s }, â†‘s âŠ† u
        from Disjoint.left_le_of_le_sup_right hab (huv.mono this hbv)
      Â· apply Subset.trans _ (inter_subset_right s u)
        exact iInter_subset (fun s : { s : Set X // IsClopen s âˆ§ x âˆˆ s } => s.1)
          âŸ¨s âˆ© u, H1, mem_inter H.2.1 hxuâŸ©
    Â· have h1 : x âˆˆ v :=
        (hab.trans (union_subset_union hau hbv) (mem_iInter.2 fun i => i.2.2)).resolve_left hxu
      suffices â‹‚ s : { s : Set X // IsClopen s âˆ§ x âˆˆ s }, â†‘s âŠ† v
        from (huv.symm.mono this hau).left_le_of_le_sup_left hab
      Â· refine Subset.trans ?_ (inter_subset_right s v)
        exact iInter_subset (fun s : { s : Set X // IsClopen s âˆ§ x âˆˆ s } => s.1)
          âŸ¨s âˆ© v, H2, mem_inter H.2.1 h1âŸ©","error:  application type mismatch
  inter_subset_right s
argument
  s
has type
  Set X : Type u_1
but is expected to have type
  ?m.213270 âˆˆ ?m.213268 âˆ© ?m.213269 : Prop
error:  application type mismatch
  inter_subset_right s
argument
  s
has type
  Set X : Type u_1
but is expected to have type
  ?m.214224 âˆˆ ?m.214222 âˆ© ?m.214223 : Prop","theorem connectedComponent_eq_iInter_isClopen [T2Space X] [CompactSpace X] (x : X) :
    connectedComponent x = â‹‚ s : { s : Set X // IsClopen s âˆ§ x âˆˆ s }, s ",":= by
  apply Subset.antisymm connectedComponent_subset_iInter_isClopen
  refine IsPreconnected.subset_connectedComponent ?_ (mem_iInter.2 fun s => s.2.2)
  have hs : @IsClosed X _ (â‹‚ s : { s : Set X // IsClopen s âˆ§ x âˆˆ s }, s) :=
    isClosed_iInter fun s => s.2.1.1
  rw [isPreconnected_iff_subset_of_fully_disjoint_closed hs]
  intro a b ha hb hab ab_disj
  rcases normal_separation ha hb ab_disj with âŸ¨u, v, hu, hv, hau, hbv, huvâŸ©
  obtain âŸ¨s, HâŸ© : âˆƒ s : Set X, IsClopen s âˆ§ x âˆˆ s âˆ§ s âŠ† u âˆª v := by
    have H1 := (hu.union hv).isClosed_compl.isCompact.inter_iInter_nonempty
      (fun s : { s : Set X // IsClopen s âˆ§ x âˆˆ s } => s) fun s => s.2.1.1
    rw [â† not_disjoint_iff_nonempty_inter, imp_not_comm, not_forall] at H1
    cases' H1 (disjoint_compl_left_iff_subset.2 <| hab.trans <| union_subset_union hau hbv)
      with si H2
    refine âŸ¨â‹‚ U âˆˆ si, Subtype.val U, ?_, ?_, ?_âŸ©
    Â· exact isClopen_biInter_finset fun s _ => s.2.1
    Â· exact mem_iInterâ‚‚.2 fun s _ => s.2.2
    Â· rwa [â† disjoint_compl_left_iff_subset, disjoint_iff_inter_eq_empty,
        â† not_nonempty_iff_eq_empty]
  Â· have H1 := isClopen_inter_of_disjoint_cover_clopen H.1 H.2.2 hu hv huv
    rw [union_comm] at H
    have H2 := isClopen_inter_of_disjoint_cover_clopen H.1 H.2.2 hv hu huv.symm
    by_cases hxu : x âˆˆ u <;> [left; right]
    Â· suffices â‹‚ s : { s : Set X // IsClopen s âˆ§ x âˆˆ s }, â†‘s âŠ† u
        from Disjoint.left_le_of_le_sup_right hab (huv.mono this hbv)
      Â· apply Subset.trans _ s.inter_subset_right
        exact iInter_subset (fun s : { s : Set X // IsClopen s âˆ§ x âˆˆ s } => s.1)
          âŸ¨s âˆ© u, H1, mem_inter H.2.1 hxuâŸ©
    Â· have h1 : x âˆˆ v :=
        (hab.trans (union_subset_union hau hbv) (mem_iInter.2 fun i => i.2.2)).resolve_left hxu
      suffices â‹‚ s : { s : Set X // IsClopen s âˆ§ x âˆˆ s }, â†‘s âŠ† v
        from (huv.symm.mono this hau).left_le_of_le_sup_left hab
      Â· refine Subset.trans ?_ s.inter_subset_right
        exact iInter_subset (fun s : { s : Set X // IsClopen s âˆ§ x âˆˆ s } => s.1)
          âŸ¨s âˆ© v, H2, mem_inter H.2.1 h1âŸ©"
Mathlib/NumberTheory/DirichletCharacter/Basic.lean,DirichletCharacter.conductor_le_conductor_mem_conductorSet,conductor_le_conductor_mem_conductorSet,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine Nat.sInf_le <| (mem_conductorSet_iff Ï‡).mpr <|
    âŸ¨dvd_trans (conductor_dvd_level _) hd.1,
     (factorsThrough_conductor (Classical.choose hd.2)).2.choose, ?_âŸ©
  rw [changeLevel_trans _ (conductor_dvd_level _) (FactorsThrough.dvd _ hd),
      â† (factorsThrough_conductor (Classical.choose hd.2)).2.choose_spec]
  exact FactorsThrough.eq_changeLevel Ï‡ hd","error:  function expected at
  FactorsThrough.dvd ?m.103481
term has type
  ?m.103480 âˆ£ ?m.103478
error:  application type mismatch
  FactorsThrough.eq_changeLevel Ï‡
argument
  Ï‡
has type
  DirichletCharacter R n : Type u_1
but is expected to have type
  ?m.103668.FactorsThrough ?m.103669 : Prop","lemma conductor_le_conductor_mem_conductorSet {d : â„•} (hd : d âˆˆ conductorSet Ï‡) :
    Ï‡.conductor â‰¤ (Classical.choose hd.2).conductor ",":= by
  refine Nat.sInf_le <| (mem_conductorSet_iff Ï‡).mpr <|
    âŸ¨dvd_trans (conductor_dvd_level _) hd.1,
     (factorsThrough_conductor (Classical.choose hd.2)).2.choose, ?_âŸ©
  rw [changeLevel_trans _ (conductor_dvd_level _) hd.dvd,
      â† (factorsThrough_conductor (Classical.choose hd.2)).2.choose_spec]
  exact hd.eq_changeLevel"
Mathlib/Analysis/MellinTransform.lean,hasMellin_one_Ioc,hasMellin_one_Ioc,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  have aux1 : -1 < (s - 1).re := by
    simpa only [sub_re, one_re, sub_eq_add_neg] using lt_add_of_pos_left _ hs
  have aux2 : s â‰  0 := by contrapose! hs; rw [hs, zero_re]
  have aux3 : MeasurableSet (Ioc (0 : â„) 1) := measurableSet_Ioc
  simp_rw [HasMellin, mellin, MellinConvergent, â† indicator_smul, IntegrableOn,
    integrable_indicator_iff aux3, smul_eq_mul, integral_indicator aux3, mul_one, IntegrableOn,
    Measure.restrict_restrict_of_subset Ioc_subset_Ioi_self]
  rw [â† IntegrableOn, â† intervalIntegrable_iff_integrable_Ioc_of_le zero_le_one]
  refine' âŸ¨intervalIntegral.intervalIntegrable_cpow' aux1, _âŸ©
  rw [â† intervalIntegral.integral_of_le zero_le_one, integral_cpow (Or.inl aux1), sub_add_cancel,
    ofReal_zero, ofReal_one, one_cpow, zero_cpow aux2, sub_zero]","error:  unknown identifier 'intervalIntegrable_iff_integrable_Ioc_of_le'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.211172
E : Type u_1
instâœ : NormedAddCommGroup E
s : â„‚
hs : 0 < s.re
aux1 : -1 < (s - 1).re
aux2 : s â‰  0
aux3 : MeasurableSet (Ioc 0 1)
âŠ¢ IntegrableOn (fun a â†¦ â†‘a ^ (s - 1)) (Ioc 0 1) volume âˆ§ âˆ« (a : â„) in Ioc 0 1, â†‘a ^ (s - 1) âˆ‚volume = 1 / s","theorem hasMellin_one_Ioc {s : â„‚} (hs : 0 < re s) :
    HasMellin (indicator (Ioc 0 1) (fun _ => 1 : â„ â†’ â„‚)) s (1 / s) ",":= by
  have aux1 : -1 < (s - 1).re := by
    simpa only [sub_re, one_re, sub_eq_add_neg] using lt_add_of_pos_left _ hs
  have aux2 : s â‰  0 := by contrapose! hs; rw [hs, zero_re]
  have aux3 : MeasurableSet (Ioc (0 : â„) 1) := measurableSet_Ioc
  simp_rw [HasMellin, mellin, MellinConvergent, â† indicator_smul, IntegrableOn,
    integrable_indicator_iff aux3, smul_eq_mul, integral_indicator aux3, mul_one, IntegrableOn,
    Measure.restrict_restrict_of_subset Ioc_subset_Ioi_self]
  rw [â† IntegrableOn, â† intervalIntegrable_iff_integrableOn_Ioc_of_le zero_le_one]
  refine âŸ¨intervalIntegral.intervalIntegrable_cpow' aux1, ?_âŸ©
  rw [â† intervalIntegral.integral_of_le zero_le_one, integral_cpow (Or.inl aux1), sub_add_cancel,
    ofReal_zero, ofReal_one, one_cpow, zero_cpow aux2, sub_zero]"
Mathlib/RingTheory/Finiteness.lean,Submodule.fg_iff_compact,fg_iff_compact,678c85769fb083a09fe9e4be1a8102fa2846e702,":= by
  classical
    let sp : M â†’ Submodule R M := fun a => span R {a}
    have supr_rw : âˆ€ t : Finset M, â¨† x âˆˆ t, sp x = â¨† x âˆˆ (â†‘t : Set M), sp x := fun t => by rfl
    constructor
    Â· rintro âŸ¨t, rflâŸ©
      rw [span_eq_iSup_of_singleton_spans, â† supr_rw, â† Finset.sup_eq_iSup t sp]
      apply CompleteLattice.isCompactElement_finsetSup
      exact fun n _ => singleton_span_isCompactElement n
    Â· intro h
      have sSup' : s = sSup (sp '' â†‘s) := by
        rw [sSup_eq_iSup, iSup_image, â† span_eq_iSup_of_singleton_spans, eq_comm, span_eq]
      obtain âŸ¨u, âŸ¨huspan, husupâŸ©âŸ© := h (sp '' â†‘s) (le_of_eq sSup')
      have ssup : s = u.sup id := by
        suffices : u.sup id â‰¤ s
        exact le_antisymm husup this
        rw [sSup', Finset.sup_id_eq_sSup]
        exact sSup_le_sSup huspan
      have := Finset.subset_image_iff.mp huspan
      obtain âŸ¨t, âŸ¨-, rflâŸ©âŸ© := this
      rw [Finset.sup_image, Function.comp.left_id, Finset.sup_eq_iSup, supr_rw, â†
        span_eq_iSup_of_singleton_spans, eq_comm] at ssup
      exact âŸ¨t, ssupâŸ©","error:  unexpected token ':'; expected term
error:  unsolved goals
case mpr.intro.intro
R : Type u_1
M : Type u_2
instâœâ´ : Semiring R
instâœÂ³ : AddCommMonoid M
instâœÂ² : Module R M
P : Type u_3
instâœÂ¹ : AddCommMonoid P
instâœ : Module R P
f : M â†’â‚—[R] P
s : Submodule R M
sp : M â†’ Submodule R M := fun a â†¦ span R {a}
supr_rw : âˆ€ (t : Finset M), â¨† x âˆˆ t, sp x = â¨† x âˆˆ â†‘t, sp x
h : CompleteLattice.IsCompactElement s
sSup' : s = sSup (sp '' â†‘s)
u : Finset (Submodule R M)
huspan : â†‘u âŠ† sp '' â†‘s
husup : s â‰¤ u.sup id
ssup : s = u.sup id
âŠ¢ s.FG
warning:  Module.Finite does not have a doc string",theorem fg_iff_compact (s : Submodule R M) : s.FG â†” CompleteLattice.IsCompactElement s ,":= by
  classical
    let sp : M â†’ Submodule R M := fun a => span R {a}
    have supr_rw : âˆ€ t : Finset M, â¨† x âˆˆ t, sp x = â¨† x âˆˆ (â†‘t : Set M), sp x := fun t => by rfl
    constructor
    Â· rintro âŸ¨t, rflâŸ©
      rw [span_eq_iSup_of_singleton_spans, â† supr_rw, â† Finset.sup_eq_iSup t sp]
      apply CompleteLattice.isCompactElement_finsetSup
      exact fun n _ => singleton_span_isCompactElement n
    Â· intro h
      have sSup' : s = sSup (sp '' â†‘s) := by
        rw [sSup_eq_iSup, iSup_image, â† span_eq_iSup_of_singleton_spans, eq_comm, span_eq]
      obtain âŸ¨u, âŸ¨huspan, husupâŸ©âŸ© := h (sp '' â†‘s) (le_of_eq sSup')
      have ssup : s = u.sup id := by
        suffices u.sup id â‰¤ s from le_antisymm husup this
        rw [sSup', Finset.sup_id_eq_sSup]
        exact sSup_le_sSup huspan
      have := Finset.subset_image_iff.mp huspan
      obtain âŸ¨t, âŸ¨-, rflâŸ©âŸ© := this
      rw [Finset.sup_image, Function.id_comp, Finset.sup_eq_iSup, supr_rw, â†
        span_eq_iSup_of_singleton_spans, eq_comm] at ssup
      exact âŸ¨t, ssupâŸ©"
Mathlib/Algebra/CharP/Basic.lean,CharP.char_is_prime,char_is_prime,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  suffices âˆ€ (d) (_ : d âˆ£ p), d = 1 âˆ¨ d = p from Nat.prime_def_lt''.mpr âŸ¨hp, thisâŸ©
  fun (d : â„•) (hdvd : âˆƒ e, p = d * e) =>
  let âŸ¨e, hmulâŸ© := hdvd
  have : (p : R) = 0 := (cast_eq_zero_iff R p p).mpr (dvd_refl p)
  have : (d : R) * e = 0 := @Nat.cast_mul R _ d e â–¸ hmul â–¸ this
  Or.elim (eq_zero_or_eq_zero_of_mul_eq_zero this)
    (fun hd : (d : R) = 0 =>
      have : p âˆ£ d := (cast_eq_zero_iff R p d).mp hd
      show d = 1 âˆ¨ d = p from Or.inr (this.antisymm' âŸ¨e, hmulâŸ©))
    fun he : (e : R) = 0 =>
    have : p âˆ£ e := (cast_eq_zero_iff R p e).mp he
    have : e âˆ£ p := dvd_of_mul_left_eq d (Eq.symm hmul)
    have : e = p := â€¹e âˆ£ pâ€º.antisymm â€¹p âˆ£ eâ€º
    have hâ‚€ : 0 < p := two_pos.trans_le hp
    have : d * p = 1 * p := by rw [â€¹e = pâ€º] at hmul; rw [one_mul]; exact Eq.symm hmul
    show d = 1 âˆ¨ d = p from Or.inl (mul_right_cancelâ‚€ hâ‚€.ne' this)","error:  unknown identifier 'hp'
error:  unknown identifier 'hp'",theorem char_is_prime (p : â„•) [CharP R p] : p.Prime ,":=
  Or.resolve_right (char_is_prime_or_zero R p) (char_ne_zero_of_finite R p)"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.addHaar_image_le_lintegral_abs_det_fderiv_aux1,addHaar_image_le_lintegral_abs_det_fderiv_aux1,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  have :
    âˆ€ A : E â†’L[â„] E,
      âˆƒ Î´ : â„â‰¥0,
        0 < Î´ âˆ§
          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§
            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’
              Î¼ (g '' t) â‰¤ (ENNReal.ofReal |A.det| + Îµ) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©
    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt Îµ Îµpos
    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©
    refine' âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), _, _âŸ©
    Â· intro B hB
      rw [â† Real.dist_eq]
      apply (hÎ´' B _).le
      rw [dist_eq_norm]
      calc
        â€–B - Aâ€– â‰¤ (min Î´ Î´'' : â„â‰¥0) := hB
        _ â‰¤ Î´'' := by simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
        _ < Î´' := half_lt_self Î´'pos
    Â· intro t g htg
      exact h t g (htg.mono_num (min_le_left _ _))
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (ENNReal.ofReal |(A n).det| + Îµ) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2.2
      exact ht n
    _ = âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by
      simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
    _ â‰¤ âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono (inter_subset_left _ _)]
      intro x hx
      have I : |(A n).det| â‰¤ |(f' x).det| + Îµ :=
        calc
          |(A n).det| = |(f' x).det - ((f' x).det - (A n).det)| := by congr 1; abel
          _ â‰¤ |(f' x).det| + |(f' x).det - (A n).det| := abs_sub _ _
          _ â‰¤ |(f' x).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(A n).det| + Îµ â‰¤ ENNReal.ofReal (|(f' x).det| + Îµ) + Îµ := by gcongr
        _ = ENNReal.ofReal |(f' x).det| + 2 * Îµ := by
          simp only [ENNReal.ofReal_add, abs_nonneg, two_mul, add_assoc, NNReal.zero_le_coe,
            ENNReal.ofReal_coe_nnreal]
    _ = âˆ«â» x in â‹ƒ n, s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      have M : âˆ€ n : â„•, MeasurableSet (s âˆ© t n) := fun n => hs.inter (t_meas n)
      rw [lintegral_iUnion M]
      exact pairwise_disjoint_mono t_disj fun n => inter_subset_right _ _
    _ = âˆ«â» x in s, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      rw [â† inter_iUnion, inter_eq_self_of_subset_left t_cover]
    _ = (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s := by
      simp only [lintegral_add_right' _ aemeasurable_const, set_lintegral_const]","error:  function expected at
  inter_subset_left ?m.432033
term has type
  ?m.432032 âˆˆ ?m.432030
error:  function expected at
  inter_subset_right ?m.446838
term has type
  ?m.446837 âˆˆ ?m.446836
warning:  `MeasureTheory.set_lintegral_const` has been deprecated, use `MeasureTheory.setLIntegral_const` instead","theorem addHaar_image_le_lintegral_abs_det_fderiv_aux1 (hs : MeasurableSet s)
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) {Îµ : â„â‰¥0} (Îµpos : 0 < Îµ) :
    Î¼ (f '' s) â‰¤ (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s ",":= by
  have :
    âˆ€ A : E â†’L[â„] E,
      âˆƒ Î´ : â„â‰¥0,
        0 < Î´ âˆ§
          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§
            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’
              Î¼ (g '' t) â‰¤ (ENNReal.ofReal |A.det| + Îµ) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©
    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt Îµ Îµpos
    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©
    refine âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), ?_, ?_âŸ©
    Â· intro B hB
      rw [â† Real.dist_eq]
      apply (hÎ´' B _).le
      rw [dist_eq_norm]
      calc
        â€–B - Aâ€– â‰¤ (min Î´ Î´'' : â„â‰¥0) := hB
        _ â‰¤ Î´'' := by simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
        _ < Î´' := half_lt_self Î´'pos
    Â· intro t g htg
      exact h t g (htg.mono_num (min_le_left _ _))
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (ENNReal.ofReal |(A n).det| + Îµ) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2.2
      exact ht n
    _ = âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by
      simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
    _ â‰¤ âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono inter_subset_left]
      intro x hx
      have I : |(A n).det| â‰¤ |(f' x).det| + Îµ :=
        calc
          |(A n).det| = |(f' x).det - ((f' x).det - (A n).det)| := by congr 1; abel
          _ â‰¤ |(f' x).det| + |(f' x).det - (A n).det| := abs_sub _ _
          _ â‰¤ |(f' x).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(A n).det| + Îµ â‰¤ ENNReal.ofReal (|(f' x).det| + Îµ) + Îµ := by gcongr
        _ = ENNReal.ofReal |(f' x).det| + 2 * Îµ := by
          simp only [ENNReal.ofReal_add, abs_nonneg, two_mul, add_assoc, NNReal.zero_le_coe,
            ENNReal.ofReal_coe_nnreal]
    _ = âˆ«â» x in â‹ƒ n, s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      have M : âˆ€ n : â„•, MeasurableSet (s âˆ© t n) := fun n => hs.inter (t_meas n)
      rw [lintegral_iUnion M]
      exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
    _ = âˆ«â» x in s, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      rw [â† inter_iUnion, inter_eq_self_of_subset_left t_cover]
    _ = (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s := by
      simp only [lintegral_add_right' _ aemeasurable_const, setLIntegral_const]"
Mathlib/Data/List/Intervals.lean,List.Ico.filter_le_of_bot,filter_le_of_bot,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [â† filter_lt_of_succ_bot hnm]
  exact filter_congr' fun _ _ => by
    rw [decide_eq_true_eq, decide_eq_true_eq]
    exact Nat.lt_succ_iff.symm","warning:  `List.filter_congr'` has been deprecated, use `List.filter_congr` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  decide ?m.11360 = true
n m : â„•
hnm : n < m
xâœÂ¹ : â„•
xâœ : xâœÂ¹ âˆˆ Ico n m
âŠ¢ decide (xâœÂ¹ â‰¤ n) = decide (xâœÂ¹ < n + 1)",theorem filter_le_of_bot {n m : â„•} (hnm : n < m) : ((Ico n m).filter fun x => x â‰¤ n) = [n] ,":= by
  rw [â† filter_lt_of_succ_bot hnm]
  exact filter_congr fun _ _ => by
    simpa using Nat.lt_succ_iff.symm"
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow_ne_two,discr_prime_pow_ne_two,22e97510854d6906cc856e022d297bf9cf8c9b3a,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hÎ¶.powerBasis_gen _, â†
    hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), succ_sub_one]
  have coe_two : ((2 : â„•+) : â„•) = 2 := rfl
  have hp2 : p = 2 â†’ k â‰  0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  Â· rcases eq_or_ne p 2 with (rfl | hp2)
    Â· rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with âŸ¨k, rflâŸ©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      Â· simp
      Â· norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    Â· replace hp2 : (p : â„•) â‰  2
      Â· rwa [Ne.def, â† coe_two, PNat.coe_inj]
      have hpo : Odd (p : â„•) := hp.out.odd_of_ne_two hp2
      obtain âŸ¨a, haâŸ© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]; Â· norm_cast
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, â† ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  Â· have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, â† PNat.pow_coe,
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Î¶ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Î¶ ^ (p : â„•) ^ k - 1) = (p : K) ^ (p : â„•) ^ k := by
      by_cases hp : p = 2
      Â· exact mod_cast hÎ¶.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      Â· exact mod_cast hÎ¶.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, â† map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, â† succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hÎ¶.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, â† pow_mul, â† mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [â† succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : â„•) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    Â· simp only [H, mul_comm _ (k + 1)]; norm_cast
    Â· 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by linarith)] at this
      exact absurd (pow_eq_zero h) this","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case e_a.inr
p : â„•+
k : â„•
K : Type u
L : Type v
Î¶ : L
instâœÂ³ : Field K
instâœÂ² : Field L
instâœÂ¹ : Algebra K L
instâœ : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime â†‘p)
hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))
hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1))) K)
hk : p ^ (k + 1) â‰  2
hne : NeZero â†‘â†‘(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : â†‘2 = 2
hp2âœ : p = 2 â†’ k â‰  0
hp2 : â†‘p â‰  2
âŠ¢ (-1) ^ (â†‘p ^ k * (â†‘p - 1) * (â†‘p ^ k * (â†‘p - 1) - 1) / 2) = (-1) ^ (â†‘p ^ k * (â†‘p - 1) / 2)
error:  unsolved goals
case e_a
p : â„•+
k : â„•
K : Type u
L : Type v
Î¶ : L
instâœÂ³ : Field K
instâœÂ² : Field L
instâœÂ¹ : Algebra K L
instâœ : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime â†‘p)
hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))
hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1))) K)
hk : p ^ (k + 1) â‰  2
hne : NeZero â†‘â†‘(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : â†‘2 = 2
hp2 : p = 2 â†’ k â‰  0
âŠ¢ (Algebra.norm K) ((aeval Î¶) (derivative (cyclotomic (â†‘p ^ (k + 1)) K))) = â†‘â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : â„•).Prime]
    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1)) : â„•) K))
    (hk : p ^ (k + 1) â‰  2) : discr K (hÎ¶.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : â„•).totient / 2) * p ^ ((p : â„•) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hÎ¶.powerBasis_gen _, â†
    hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : â„•+) : â„•) = 2 := rfl
  have hp2 : p = 2 â†’ k â‰  0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  Â· rcases eq_or_ne p 2 with (rfl | hp2)
    Â· rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with âŸ¨k, rflâŸ©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      Â· simp
      Â· simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    Â· replace hp2 : (p : â„•) â‰  2 := by rwa [Ne, â† coe_two, PNat.coe_inj]
      have hpo : Odd (p : â„•) := hp.out.odd_of_ne_two hp2
      obtain âŸ¨a, haâŸ© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, â† ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  Â· have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, â† PNat.pow_coe,
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Î¶ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Î¶ ^ (p : â„•) ^ k - 1) = (p : K) ^ (p : â„•) ^ k := by
      by_cases hp : p = 2
      Â· exact mod_cast hÎ¶.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      Â· exact mod_cast hÎ¶.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, â† map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, â† succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hÎ¶.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, â† pow_mul, â† mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [â† succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : â„•) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    Â· simp only [H, mul_comm _ (k + 1)]; norm_cast
    Â· 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this"
Mathlib/AlgebraicGeometry/Gluing.lean,AlgebraicGeometry.Scheme.OpenCover.hom_ext,hom_ext,3d5fc7e7734a13ea90a514ce40f9888d52a5332a,":= by
  rw [â† cancel_epi ğ’°.fromGlued]
  apply Multicoequalizer.hom_ext
  intro x
  erw [Multicoequalizer.inj_desc_assoc]
  erw [Multicoequalizer.inj_desc_assoc]
  exact h x","error:  unknown identifier 'Multicoequalizer.inj_desc_assoc'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.168013
case h
X : Scheme
ğ’° : X.OpenCover
Y : Scheme
fâ‚ fâ‚‚ : X âŸ¶ Y
h : âˆ€ (x : ğ’°.J), ğ’°.map x â‰« fâ‚ = ğ’°.map x â‰« fâ‚‚
x : ğ’°.gluedCover.diagram.R
âŠ¢ Multicoequalizer.Ï€ ğ’°.gluedCover.diagram x â‰« ğ’°.fromGlued â‰« fâ‚ =
    Multicoequalizer.Ï€ ğ’°.gluedCover.diagram x â‰« ğ’°.fromGlued â‰« fâ‚‚","theorem hom_ext {Y : Scheme} (fâ‚ fâ‚‚ : X âŸ¶ Y) (h : âˆ€ x, ğ’°.map x â‰« fâ‚ = ğ’°.map x â‰« fâ‚‚) : fâ‚ = fâ‚‚ ",":= by
  rw [â† cancel_epi ğ’°.fromGlued]
  apply Multicoequalizer.hom_ext
  intro x
  erw [Multicoequalizer.Ï€_desc_assoc]
  erw [Multicoequalizer.Ï€_desc_assoc]
  exact h x"
Mathlib/NumberTheory/Cyclotomic/Basic.lean,IsCyclotomicExtension.integral,integral,9e34a191034458a56331f976ff7400a26407c888,":=
  isIntegral_of_noetherian <| isNoetherian_of_fg_of_noetherian' <|
    (IsCyclotomicExtension.finite S A B).out",error:  unknown identifier 'isNoetherian_of_fg_of_noetherian'',"theorem integral [IsDomain B] [IsNoetherianRing A] [Finite S] [IsCyclotomicExtension S A B] :
    Algebra.IsIntegral A B ",":=
  have := IsCyclotomicExtension.finite S A B
  âŸ¨isIntegral_of_noetherian inferInstanceâŸ©"
Mathlib/MeasureTheory/Covering/BesicovitchVectorSpace.lean,Besicovitch.exists_goodÎ´,exists_goodÎ´,58eef79b1520d17ff085f58b599690c112a47e6b,":= by
  classical
  by_contra! h
  set N := multiplicity E + 1 with hN
  have :
    âˆ€ Î´ : â„, 0 < Î´ â†’ âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§
      âˆ€ i j, i â‰  j â†’ 1 - Î´ â‰¤ â€–f i - f jâ€– := by
    intro Î´ hÎ´
    rcases lt_or_le Î´ 1 with (hÎ´' | hÎ´')
    Â· rcases h Î´ hÎ´ hÎ´' with âŸ¨s, hs, h's, s_cardâŸ©
      obtain âŸ¨f, f_inj, hfsâŸ© : âˆƒ f : Fin N â†’ E, Function.Injective f âˆ§ range f âŠ† â†‘s := by
        have : Fintype.card (Fin N) â‰¤ s.card := by simp only [Fintype.card_fin]; exact s_card
        rcases Function.Embedding.exists_of_card_le_finset this with âŸ¨f, hfâŸ©
        exact âŸ¨f, f.injective, hfâŸ©
      simp only [range_subset_iff, Finset.mem_coe] at hfs
      refine' âŸ¨f, fun i => hs _ (hfs i), fun i j hij => h's _ (hfs i) _ (hfs j) (f_inj.ne hij)âŸ©
    Â· exact
        âŸ¨fun _ => 0, fun i => by simp; norm_num, fun i j _ => by
          simpa only [norm_zero, sub_nonpos, sub_self]âŸ©
  choose! F hF using this
  have : âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§ âˆ€ i j, i â‰  j â†’ 1 â‰¤ â€–f i - f jâ€– := by
    obtain âŸ¨u, _, zero_lt_u, huâŸ© :
      âˆƒ u : â„• â†’ â„,
        (âˆ€ m n : â„•, m < n â†’ u n < u m) âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Filter.Tendsto u Filter.atTop (ğ“ 0) :=
      exists_seq_strictAnti_tendsto (0 : â„)
    have A : âˆ€ n, F (u n) âˆˆ closedBall (0 : Fin N â†’ E) 2 := by
      intro n
      simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right,
        (hF (u n) (zero_lt_u n)).left, forall_const]
    obtain âŸ¨f, fmem, Ï†, Ï†_mono, hfâŸ© :
      âˆƒ f âˆˆ closedBall (0 : Fin N â†’ E) 2,
        âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (ğ“ f) :=
      IsCompact.tendsto_subseq (isCompact_closedBall _ _) A
    refine' âŸ¨f, fun i => _, fun i j hij => _âŸ©
    Â· simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right] at fmem
      exact fmem i
    Â· have A : Tendsto (fun n => â€–F (u (Ï† n)) i - F (u (Ï† n)) jâ€–) atTop (ğ“ â€–f i - f jâ€–) :=
        ((hf.apply i).sub (hf.apply j)).norm
      have B : Tendsto (fun n => 1 - u (Ï† n)) atTop (ğ“ (1 - 0)) :=
        tendsto_const_nhds.sub (hu.comp Ï†_mono.tendsto_atTop)
      rw [sub_zero] at B
      exact le_of_tendsto_of_tendsto' B A fun n => (hF (u (Ï† n)) (zero_lt_u _)).2 i j hij
  rcases this with âŸ¨f, hf, h'fâŸ©
  have finj : Function.Injective f := by
    intro i j hij
    by_contra h
    have : 1 â‰¤ â€–f i - f jâ€– := h'f i j h
    simp only [hij, norm_zero, sub_self] at this
    exact lt_irrefl _ (this.trans_lt zero_lt_one)
  let s := Finset.image f Finset.univ
  have s_card : s.card = N := by rw [Finset.card_image_of_injective _ finj]; exact Finset.card_fin N
  have hs : âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2 := by
    simp only [hf, forall_apply_eq_imp_iff, forall_const, forall_exists_index, Finset.mem_univ,
      Finset.mem_image, true_and]
  have h's : âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 â‰¤ â€–c - dâ€– := by
    simp only [forall_apply_eq_imp_iff, forall_exists_index, Finset.mem_univ, Finset.mem_image,
      Ne.def, exists_true_left, forall_apply_eq_imp_iff, forall_true_left, true_and]
    intro i j hij
    have : i â‰  j := fun h => by rw [h] at hij; exact hij rfl
    exact h'f i j this
  have : s.card â‰¤ multiplicity E := card_le_multiplicity hs h's
  rw [s_card, hN] at this
  exact lt_irrefl _ ((Nat.lt_succ_self (multiplicity E)).trans_le this)","error:  no goals to be solved
error:  application type mismatch
  Tendsto.apply hf
argument
  hf
has type
  Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (ğ“ f) : Prop
but is expected to have type
  Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (Filter.pi ?m.76660) : Prop
error:  application type mismatch
  Tendsto.apply hf
argument
  hf
has type
  Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (ğ“ f) : Prop
but is expected to have type
  Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (Filter.pi ?m.77067) : Prop
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.81536 â†’ ?m.81536 â†’ Prop
error:  simp made no progress","theorem exists_goodÎ´ :
    âˆƒ Î´ : â„, 0 < Î´ âˆ§ Î´ < 1 âˆ§ âˆ€ s : Finset E, (âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2) â†’
      (âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 - Î´ â‰¤ â€–c - dâ€–) â†’ s.card â‰¤ multiplicity E ",":= by
  classical
  by_contra! h
  set N := multiplicity E + 1 with hN
  have :
    âˆ€ Î´ : â„, 0 < Î´ â†’ âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§
      Pairwise fun i j => 1 - Î´ â‰¤ â€–f i - f jâ€– := by
    intro Î´ hÎ´
    rcases lt_or_le Î´ 1 with (hÎ´' | hÎ´')
    Â· rcases h Î´ hÎ´ hÎ´' with âŸ¨s, hs, h's, s_cardâŸ©
      obtain âŸ¨f, f_inj, hfsâŸ© : âˆƒ f : Fin N â†’ E, Function.Injective f âˆ§ range f âŠ† â†‘s := by
        have : Fintype.card (Fin N) â‰¤ s.card := by simp only [Fintype.card_fin]; exact s_card
        rcases Function.Embedding.exists_of_card_le_finset this with âŸ¨f, hfâŸ©
        exact âŸ¨f, f.injective, hfâŸ©
      simp only [range_subset_iff, Finset.mem_coe] at hfs
      exact âŸ¨f, fun i => hs _ (hfs i), fun i j hij => h's _ (hfs i) _ (hfs j) (f_inj.ne hij)âŸ©
    Â· exact
        âŸ¨fun _ => 0, by simp, fun i j _ => by
          simpa only [norm_zero, sub_nonpos, sub_self]âŸ©
  choose! F hF using this
  have : âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§ Pairwise fun i j => 1 â‰¤ â€–f i - f jâ€– := by
    obtain âŸ¨u, _, zero_lt_u, huâŸ© :
      âˆƒ u : â„• â†’ â„,
        (âˆ€ m n : â„•, m < n â†’ u n < u m) âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Filter.Tendsto u Filter.atTop (ğ“ 0) :=
      exists_seq_strictAnti_tendsto (0 : â„)
    have A : âˆ€ n, F (u n) âˆˆ closedBall (0 : Fin N â†’ E) 2 := by
      intro n
      simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right,
        (hF (u n) (zero_lt_u n)).left, forall_const]
    obtain âŸ¨f, fmem, Ï†, Ï†_mono, hfâŸ© :
      âˆƒ f âˆˆ closedBall (0 : Fin N â†’ E) 2,
        âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (ğ“ f) :=
      IsCompact.tendsto_subseq (isCompact_closedBall _ _) A
    refine âŸ¨f, fun i => ?_, fun i j hij => ?_âŸ©
    Â· simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right] at fmem
      exact fmem i
    Â· have A : Tendsto (fun n => â€–F (u (Ï† n)) i - F (u (Ï† n)) jâ€–) atTop (ğ“ â€–f i - f jâ€–) :=
        ((hf.apply_nhds i).sub (hf.apply_nhds j)).norm
      have B : Tendsto (fun n => 1 - u (Ï† n)) atTop (ğ“ (1 - 0)) :=
        tendsto_const_nhds.sub (hu.comp Ï†_mono.tendsto_atTop)
      rw [sub_zero] at B
      exact le_of_tendsto_of_tendsto' B A fun n => (hF (u (Ï† n)) (zero_lt_u _)).2 hij
  rcases this with âŸ¨f, hf, h'fâŸ©
  have finj : Function.Injective f := by
    intro i j hij
    by_contra h
    have : 1 â‰¤ â€–f i - f jâ€– := h'f h
    simp only [hij, norm_zero, sub_self] at this
    exact lt_irrefl _ (this.trans_lt zero_lt_one)
  let s := Finset.image f Finset.univ
  have s_card : s.card = N := by rw [Finset.card_image_of_injective _ finj]; exact Finset.card_fin N
  have hs : âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2 := by
    simp only [s, hf, forall_apply_eq_imp_iff, forall_const, forall_exists_index, Finset.mem_univ,
      Finset.mem_image, true_and]
  have h's : âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 â‰¤ â€–c - dâ€– := by
    simp only [s, forall_apply_eq_imp_iff, forall_exists_index, Finset.mem_univ, Finset.mem_image,
      Ne, exists_true_left, forall_apply_eq_imp_iff, forall_true_left, true_and]
    intro i j hij
    have : i â‰  j := fun h => by rw [h] at hij; exact hij rfl
    exact h'f this
  have : s.card â‰¤ multiplicity E := card_le_multiplicity hs h's
  rw [s_card, hN] at this
  exact lt_irrefl _ ((Nat.lt_succ_self (multiplicity E)).trans_le this)"
Mathlib/SetTheory/Ordinal/CantorNormalForm.lean,Ordinal.CNF_sorted,CNF_sorted,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  refine' CNFRec b _ (fun o ho IH â†¦ _) o
  Â· simp only [CNF_zero]
  Â· cases' le_or_lt b 1 with hb hb
    Â· simp only [CNF_of_le_one hb ho, map]
    Â· cases' lt_or_le o b with hob hbo
      Â· simp only [CNF_of_lt ho hob, map]
      Â· rw [CNF_ne_zero ho, map_cons, sorted_cons]
        refine' âŸ¨fun a H â†¦ _, IHâŸ©
        rw [mem_map] at H
        rcases H with âŸ¨âŸ¨a, a'âŸ©, H, rflâŸ©
        exact (CNF_fst_le_log H).trans_lt (log_mod_opow_log_lt_log_self hb ho hbo)","error:  unsolved goals
case refine'_1
b o : Ordinal.{u_1}
âŠ¢ Sorted (fun x x_1 â†¦ x > x_1) (map Prod.fst [])
error:  unsolved goals
case refine'_2.inl
b oâœ o : Ordinal.{u_1}
ho : o â‰  0
IH : Sorted (fun x x_1 â†¦ x > x_1) (map Prod.fst (CNF b (o % b ^ log b o)))
hb : b â‰¤ 1
âŠ¢ Sorted (fun x x_1 â†¦ x > x_1) [0]
error:  unsolved goals
case refine'_2.inr.inl
b oâœ o : Ordinal.{u_1}
ho : o â‰  0
IH : Sorted (fun x x_1 â†¦ x > x_1) (map Prod.fst (CNF b (o % b ^ log b o)))
hb : 1 < b
hob : o < b
âŠ¢ Sorted (fun x x_1 â†¦ x > x_1) [0]",theorem CNF_sorted (b o : Ordinal) : ((CNF b o).map Prod.fst).Sorted (Â· > Â·) ,":= by
  refine CNFRec b ?_ (fun o ho IH â†¦ ?_) o
  Â· simp only [gt_iff_lt, CNF_zero, map_nil, sorted_nil]
  Â· rcases le_or_lt b 1 with hb | hb
    Â· simp only [CNF_of_le_one hb ho, gt_iff_lt, map_cons, map, sorted_singleton]
    Â· cases' lt_or_le o b with hob hbo
      Â· simp only [CNF_of_lt ho hob, gt_iff_lt, map_cons, map, sorted_singleton]
      Â· rw [CNF_ne_zero ho, map_cons, sorted_cons]
        refine âŸ¨fun a H â†¦ ?_, IHâŸ©
        rw [mem_map] at H
        rcases H with âŸ¨âŸ¨a, a'âŸ©, H, rflâŸ©
        exact (CNF_fst_le_log H).trans_lt (log_mod_opow_log_lt_log_self hb ho hbo)"
Mathlib/MeasureTheory/Measure/Sub.lean,MeasureTheory.Measure.restrict_sub_eq_restrict_sub_restrict,restrict_sub_eq_restrict_sub_restrict,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  repeat rw [sub_def]
  have h_nonempty : { d | Î¼ â‰¤ d + Î½ }.Nonempty := âŸ¨Î¼, Measure.le_add_right le_rflâŸ©
  rw [restrict_sInf_eq_sInf_restrict h_nonempty h_meas_s]
  apply le_antisymm
  Â· refine sInf_le_sInf_of_forall_exists_le ?_
    intro Î½' h_Î½'_in
    rw [mem_setOf_eq] at h_Î½'_in
    refine âŸ¨Î½'.restrict s, ?_, restrict_le_selfâŸ©
    refine âŸ¨Î½' + (âŠ¤ : Measure Î±).restrict sá¶œ, ?_,? _âŸ©
    Â· rw [mem_setOf_eq, add_right_comm, Measure.le_iff]
      intro t h_meas_t
      repeat rw [â† measure_inter_add_diff t h_meas_s]
      refine add_le_add ?_ ?_
      Â· rw [add_apply, add_apply]
        apply le_add_right _
        rw [â† restrict_eq_self Î¼ (inter_subset_right _ _),
          â† restrict_eq_self Î½ (inter_subset_right _ _)]
        apply h_Î½'_in
      Â· rw [add_apply, restrict_apply (h_meas_t.diff h_meas_s), diff_eq, inter_assoc, inter_self,
          â† add_apply]
        have h_mu_le_add_top : Î¼ â‰¤ Î½' + Î½ + âŠ¤ := by simp only [add_top, le_top]
        exact Measure.le_iff'.1 h_mu_le_add_top _
    Â· ext1 t h_meas_t
      simp [restrict_apply h_meas_t, restrict_apply (h_meas_t.inter h_meas_s), inter_assoc]
  Â· refine sInf_le_sInf_of_forall_exists_le ?_
    refine forall_mem_image.2 fun t h_t_in => âŸ¨t.restrict s, ?_, le_rflâŸ©
    rw [Set.mem_setOf_eq, â† restrict_add]
    exact restrict_mono Subset.rfl h_t_in","error:  function expected at
  inter_subset_right ?m.12759
term has type
  ?m.12758 âˆˆ ?m.12757
error:  function expected at
  inter_subset_right ?m.12812
term has type
  ?m.12811 âˆˆ ?m.12810","theorem restrict_sub_eq_restrict_sub_restrict (h_meas_s : MeasurableSet s) :
    (Î¼ - Î½).restrict s = Î¼.restrict s - Î½.restrict s ",":= by
  repeat rw [sub_def]
  have h_nonempty : { d | Î¼ â‰¤ d + Î½ }.Nonempty := âŸ¨Î¼, Measure.le_add_right le_rflâŸ©
  rw [restrict_sInf_eq_sInf_restrict h_nonempty h_meas_s]
  apply le_antisymm
  Â· refine sInf_le_sInf_of_forall_exists_le ?_
    intro Î½' h_Î½'_in
    rw [mem_setOf_eq] at h_Î½'_in
    refine âŸ¨Î½'.restrict s, ?_, restrict_le_selfâŸ©
    refine âŸ¨Î½' + (âŠ¤ : Measure Î±).restrict sá¶œ, ?_, ?_âŸ©
    Â· rw [mem_setOf_eq, add_right_comm, Measure.le_iff]
      intro t h_meas_t
      repeat rw [â† measure_inter_add_diff t h_meas_s]
      refine add_le_add ?_ ?_
      Â· rw [add_apply, add_apply]
        apply le_add_right _
        rw [â† restrict_eq_self Î¼ inter_subset_right,
          â† restrict_eq_self Î½ inter_subset_right]
        apply h_Î½'_in
      Â· rw [add_apply, restrict_apply (h_meas_t.diff h_meas_s), diff_eq, inter_assoc, inter_self,
          â† add_apply]
        have h_mu_le_add_top : Î¼ â‰¤ Î½' + Î½ + âŠ¤ := by simp only [add_top, le_top]
        exact Measure.le_iff'.1 h_mu_le_add_top _
    Â· ext1 t h_meas_t
      simp [restrict_apply h_meas_t, restrict_apply (h_meas_t.inter h_meas_s), inter_assoc]
  Â· refine sInf_le_sInf_of_forall_exists_le ?_
    refine forall_mem_image.2 fun t h_t_in => âŸ¨t.restrict s, ?_, le_rflâŸ©
    rw [Set.mem_setOf_eq, â† restrict_add]
    exact restrict_mono Subset.rfl h_t_in"
Mathlib/Analysis/Convex/Strict.lean,StrictConvex.add_smul_mem,StrictConvex.add_smul_mem,9b5d788d575748c82ffdfc08ef4aaf0a3c6023f0,":= by
  have h : x + t â€¢ y = (1 - t) â€¢ x + t â€¢ (x + y) := by
    rw [smul_add, â† add_assoc, â† _root_.add_smul, sub_add_cancel, one_smul]
  rw [h]
  refine hs hx hxy (fun h => hy <| add_left_cancel ?_) (sub_pos_of_lt htâ‚) htâ‚€ (sub_add_cancel _ _)
  rw [â† h, add_zero]","error:  don't know how to synthesize implicit argument 'a'
  @add_left_cancel E AddCommMagma.toAdd IsCancelAdd.toIsLeftCancelAdd (?m.156026 h) y 0 ?m.155511
context:
ğ•œ : Type u_1
ğ• : Type u_2
E : Type u_3
F : Type u_4
Î² : Type u_5
instâœâ¶ : OrderedRing ğ•œ
instâœâµ : TopologicalSpace E
instâœâ´ : TopologicalSpace F
instâœÂ³ : AddCommGroup E
instâœÂ² : AddCommGroup F
instâœÂ¹ : Module ğ•œ E
instâœ : Module ğ•œ F
s tâœ : Set E
x y : E
hs : StrictConvex ğ•œ s
hx : x âˆˆ s
hxy : x + y âˆˆ s
hy : y â‰  0
t : ğ•œ
htâ‚€ : 0 < t
htâ‚ : t < 1
hâœ : x + t â€¢ y = (1 - t) â€¢ x + t â€¢ (x + y)
h : x = x + y
âŠ¢ E
error:  unsolved goals
ğ•œ : Type u_1
ğ• : Type u_2
E : Type u_3
F : Type u_4
Î² : Type u_5
instâœâ¶ : OrderedRing ğ•œ
instâœâµ : TopologicalSpace E
instâœâ´ : TopologicalSpace F
instâœÂ³ : AddCommGroup E
instâœÂ² : AddCommGroup F
instâœÂ¹ : Module ğ•œ E
instâœ : Module ğ•œ F
s tâœ : Set E
x y : E
hs : StrictConvex ğ•œ s
hx : x âˆˆ s
hxy : x + y âˆˆ s
hy : y â‰  0
t : ğ•œ
htâ‚€ : 0 < t
htâ‚ : t < 1
h : x + t â€¢ y = (1 - t) â€¢ x + t â€¢ (x + y)
âŠ¢ (1 - t) â€¢ x + t â€¢ (x + y) âˆˆ interior s","theorem StrictConvex.add_smul_mem (hs : StrictConvex ğ•œ s) (hx : x âˆˆ s) (hxy : x + y âˆˆ s)
    (hy : y â‰  0) {t : ğ•œ} (htâ‚€ : 0 < t) (htâ‚ : t < 1) : x + t â€¢ y âˆˆ interior s ",":= by
  have h : x + t â€¢ y = (1 - t) â€¢ x + t â€¢ (x + y) := by
    rw [smul_add, â† add_assoc, â† _root_.add_smul, sub_add_cancel, one_smul]
  rw [h]
  exact hs hx hxy (fun h => hy <| add_left_cancel (a := x) (by rw [â† h, add_zero]))
    (sub_pos_of_lt htâ‚) htâ‚€ (sub_add_cancel 1 t)"
Mathlib/Geometry/Manifold/BumpFunction.lean,SmoothBumpFunction.nhds_basis_support,nhds_basis_support,20100f1475ea197bf6dea643b6ee137219455a51,":=
  ((nhds_basis_tsupport I c).restrict_subset hs).to_has_basis'
    (fun f hf => âŸ¨f, hf.2, subset_closureâŸ©) fun f _ => f.support_mem_nhds","error:  invalid field 'to_has_basis'', the environment does not contain 'Filter.HasBasis.to_has_basis''
  HasBasis.restrict_subset (nhds_basis_tsupport I c) hs
has type
  (ğ“ c).HasBasis (fun i â†¦ True âˆ§ tsupport â†‘i âŠ† s) fun f â†¦ tsupport â†‘f","theorem nhds_basis_support {s : Set M} (hs : s âˆˆ ğ“ c) :
    (ğ“ c).HasBasis (fun f : SmoothBumpFunction I c => tsupport f âŠ† s) fun f => support f ",":=
  ((nhds_basis_tsupport I c).restrict_subset hs).to_hasBasis'
    (fun f hf => âŸ¨f, hf.2, subset_closureâŸ©) fun f _ => f.support_mem_nhds"
Mathlib/NumberTheory/NumberField/CanonicalEmbedding/Basic.lean,NumberField.mixedEmbedding.norm_smul,norm_smul,26c98a3923b1984522d26e2b662f3c26ce414004,":= by
  simp_rw [norm_apply, normAtPlace_smul, mul_pow, Finset.prod_mul_distrib,
    Finset.prod_pow_eq_pow_sum, sum_mult_eq]","error:  unknown identifier 'norm_apply'
error:  simp made no progress","theorem norm_smul (c : â„) (x : E K) :
    mixedEmbedding.norm (c â€¢ x) = |c| ^ finrank â„š K * (mixedEmbedding.norm x) ",":= by
  simp_rw [mixedEmbedding.norm_apply, normAtPlace_smul, mul_pow, prod_mul_distrib,
    prod_pow_eq_pow_sum, sum_mult_eq]"
Mathlib/GroupTheory/Transfer.lean,MonoidHom.transfer_eq_pow,transfer_eq_pow,a3708498bec5c2641fd86b158487e675e90d687a,":= by
  by_cases hH : H.index = 0
  Â· rw [hH, pow_zero]
    exact H.one_mem
  letI := fintypeOfIndexNeZero hH
  classical
    replace key : âˆ€ (k : â„•) (gâ‚€ : G), gâ‚€â»Â¹ * g ^ k * gâ‚€ âˆˆ H â†’ g ^ k âˆˆ H := fun k gâ‚€ hk =>
      (_root_.congr_arg (Â· âˆˆ H) (key k gâ‚€ hk)).mp hk
    replace key : âˆ€ q : G â§¸ H, g ^ Function.minimalPeriod ((Â· â€¢ Â·) g) q âˆˆ H := fun q =>
      key (Function.minimalPeriod ((Â· â€¢ Â·) g) q) q.out'
        (QuotientGroup.out'_conj_pow_minimalPeriod_mem H g q)
    let f : Quotient (orbitRel (zpowers g) (G â§¸ H)) â†’ zpowers g := fun q =>
      (âŸ¨g, mem_zpowers gâŸ© : zpowers g) ^ Function.minimalPeriod ((Â· â€¢ Â·) g) q.out'
    have hf : âˆ€ q, f q âˆˆ H.subgroupOf (zpowers g) := fun q => key q.out'
    replace key :=
      Subgroup.prod_mem (H.subgroupOf (zpowers g)) fun q (_ : q âˆˆ Finset.univ) => hf q
    simpa only [minimalPeriod_eq_card, Finset.prod_pow_eq_pow_sum, Fintype.card_sigma,
      Fintype.card_congr (selfEquivSigmaOrbits (zpowers g) (G â§¸ H)), index_eq_card] using key","error:  type mismatch
  hâœ
has type
  âˆ c : Quotient (orbitRel (â†¥(zpowers g)) (G â§¸ H)), f c âˆˆ H.subgroupOf (zpowers g) : Prop
but is expected to have type
  g ^ âˆ‘ i : orbitRel.Quotient (â†¥(zpowers g)) (G â§¸ H), Fintype.card â†‘(orbit (â†¥(zpowers g)) (Quotient.out' i)) âˆˆ H : Prop","theorem transfer_eq_pow_aux (g : G)
    (key : âˆ€ (k : â„•) (gâ‚€ : G), gâ‚€â»Â¹ * g ^ k * gâ‚€ âˆˆ H â†’ gâ‚€â»Â¹ * g ^ k * gâ‚€ = g ^ k) :
    g ^ H.index âˆˆ H ",":= by
  by_cases hH : H.index = 0
  Â· rw [hH, pow_zero]
    exact H.one_mem
  letI := fintypeOfIndexNeZero hH
  classical
    replace key : âˆ€ (k : â„•) (gâ‚€ : G), gâ‚€â»Â¹ * g ^ k * gâ‚€ âˆˆ H â†’ g ^ k âˆˆ H := fun k gâ‚€ hk =>
      (_root_.congr_arg (Â· âˆˆ H) (key k gâ‚€ hk)).mp hk
    replace key : âˆ€ q : G â§¸ H, g ^ Function.minimalPeriod (g â€¢ Â·) q âˆˆ H := fun q =>
      key (Function.minimalPeriod (g â€¢ Â·) q) q.out'
        (QuotientGroup.out'_conj_pow_minimalPeriod_mem H g q)
    let f : Quotient (orbitRel (zpowers g) (G â§¸ H)) â†’ zpowers g := fun q =>
      (âŸ¨g, mem_zpowers gâŸ© : zpowers g) ^ Function.minimalPeriod (g â€¢ Â·) q.out'
    have hf : âˆ€ q, f q âˆˆ H.subgroupOf (zpowers g) := fun q => key q.out'
    replace key :=
      Subgroup.prod_mem (H.subgroupOf (zpowers g)) fun q (_ : q âˆˆ Finset.univ) => hf q
    simpa only [f, minimalPeriod_eq_card, Finset.prod_pow_eq_pow_sum, Fintype.card_sigma,
      Fintype.card_congr (selfEquivSigmaOrbits (zpowers g) (G â§¸ H)), index_eq_card] using key"
Mathlib/Topology/MetricSpace/GromovHausdorffRealized.lean,GromovHausdorff.HD_below_aux1,HD_below_aux1,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  let âŸ¨cf, hcfâŸ© := (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1
  âŸ¨cf + C, forall_mem_range.2 fun _ => add_le_add_right ((fun x => hcf (mem_range_self x)) _) _âŸ©","error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  ?m.171778","theorem HD_below_aux1 {f : Cb X Y} (C : â„) {x : X} :
    BddBelow (range fun y : Y => f (inl x, inr y) + C) ",":=
  let âŸ¨cf, hcfâŸ© := f.isBounded_range.bddBelow
  âŸ¨cf + C, forall_mem_range.2 fun _ => add_le_add_right ((fun x => hcf (mem_range_self x)) _) _âŸ©"
Mathlib/Analysis/Calculus/FDeriv/Basic.lean,hasFDerivWithinAt_of_nmem_closure,hasFDerivWithinAt_of_nmem_closure,30e974bdfa5857c1b068086dfe767f91b6240c51,":= by
  simp only [mem_closure_iff_nhdsWithin_neBot, neBot_iff, Ne.def, Classical.not_not] at h
  simp [HasFDerivWithinAt, HasFDerivAtFilter, h, IsLittleO, IsBigOWith]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.287445 â†’ ?m.287445 â†’ Prop
error:  unsolved goals
ğ•œ : Type u_1
instâœâ¸ : NontriviallyNormedField ğ•œ
E : Type u_2
instâœâ· : NormedAddCommGroup E
instâœâ¶ : NormedSpace ğ•œ E
F : Type u_3
instâœâµ : NormedAddCommGroup F
instâœâ´ : NormedSpace ğ•œ F
G : Type u_4
instâœÂ³ : NormedAddCommGroup G
instâœÂ² : NormedSpace ğ•œ G
G' : Type u_5
instâœÂ¹ : NormedAddCommGroup G'
instâœ : NormedSpace ğ•œ G'
f fâ‚€ fâ‚ g : E â†’ F
f' fâ‚€' fâ‚' g' e : E â†’L[ğ•œ] F
x : E
s t : Set E
L Lâ‚ Lâ‚‚ : Filter E
h : ğ“[s] x = âŠ¥
âŠ¢ HasFDerivAtFilter f f' x âŠ¥",theorem hasFDerivWithinAt_of_nmem_closure (h : x âˆ‰ closure s) : HasFDerivWithinAt f f' s x ,":=
  .of_nhdsWithin_eq_bot <| eq_bot_mono (nhdsWithin_mono _ diff_subset) <| by
    rwa [mem_closure_iff_nhdsWithin_neBot, not_neBot] at h"
Mathlib/RingTheory/MvPolynomial/Homogeneous.lean,MvPolynomial.IsHomogeneous.totalDegree_le,totalDegree_le,b271affacf1fa368c4e879d75cd5aaf54b75b7ed,":= by
  apply Finset.sup_le
  intro d hd
  rw [mem_support_iff] at hd
  rw [Finsupp.sum, hÏ† hd]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (weightedDegree 1) d
case a
Ïƒ : Type u_1
Ï„ : Type u_2
R : Type u_3
S : Type u_4
instâœÂ² instâœÂ¹ : CommSemiring R
instâœ : CommSemiring S
Ï† Ïˆ : MvPolynomial Ïƒ R
m n : â„•
hÏ† : Ï†.IsHomogeneous n
d : Ïƒ â†’â‚€ â„•
hd : coeff d Ï† â‰  0
âŠ¢ âˆ‘ a âˆˆ d.support, d a â‰¤ n",lemma totalDegree_le (hÏ† : IsHomogeneous Ï† n) : Ï†.totalDegree â‰¤ n ,":= by
  apply Finset.sup_le
  intro d hd
  rw [mem_support_iff] at hd
  rw [Finsupp.sum, â† hÏ† hd, weightedDegree_apply]
  simp only [Pi.one_apply, smul_eq_mul, mul_one]
  exact Nat.le.refl"
Mathlib/RingTheory/Trace.lean,IntermediateField.AdjoinSimple.trace_gen_eq_zero,trace_gen_eq_zero,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  rw [trace_eq_zero_of_not_exists_basis, LinearMap.zero_apply]
  contrapose! hx
  obtain âŸ¨s, âŸ¨bâŸ©âŸ© := hx
  refine .of_mem_of_fg KâŸ®xâŸ¯.toSubalgebra ?_ x? _
  Â· exact (Submodule.fg_iff_finiteDimensional _).mpr (FiniteDimensional.of_fintype_basis b)
  Â· exact subset_adjoin K _ (Set.mem_singleton x)",error:  unknown identifier 'x?',"theorem trace_gen_eq_zero {x : L} (hx : Â¬IsIntegral K x) :
    Algebra.trace K KâŸ®xâŸ¯ (AdjoinSimple.gen K x) = 0 ",":= by
  rw [trace_eq_zero_of_not_exists_basis, LinearMap.zero_apply]
  contrapose! hx
  obtain âŸ¨s, âŸ¨bâŸ©âŸ© := hx
  refine .of_mem_of_fg KâŸ®xâŸ¯.toSubalgebra ?_ x ?_
  Â· exact (Submodule.fg_iff_finiteDimensional _).mpr (FiniteDimensional.of_fintype_basis b)
  Â· exact subset_adjoin K _ (Set.mem_singleton x)"
Mathlib/GroupTheory/Exponent.lean,Group.one_lt_exponent,Group.one_lt_exponent,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  let _inst := Fintype.ofFinite G
  obtain âŸ¨g, hgâŸ© := exists_ne (1 : G)
  rw [â† Monoid.lcm_orderOf_eq_exponent]
  have hg' : 2 â‰¤ orderOf g := Nat.lt_of_le_of_ne (orderOf_pos g) <| by
    simpa [eq_comm, orderOf_eq_one_iff] using hg
  refine hg'.trans <| Nat.le_of_dvd ?_ <| Finset.dvd_lcm (by simp)
  rw [Nat.pos_iff_ne_zero, Ne.def, Finset.lcm_eq_zero_iff]
  rintro âŸ¨x, -, hxâŸ©
  exact (orderOf_pos x).ne' hx","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.80232 â†’ ?m.80232 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.80234
case intro
G : Type u
instâœÂ² : Group G
instâœÂ¹ : Finite G
instâœ : Nontrivial G
_inst : Fintype G := Fintype.ofFinite G
g : G
hg : g â‰  1
hg' : 2 â‰¤ orderOf g
âŠ¢ Finset.univ.lcm orderOf â‰  0",lemma Group.one_lt_exponent [Finite G] [Nontrivial G] : 1 < Monoid.exponent G ,":=
  Monoid.one_lt_exponent"
Mathlib/Topology/Algebra/Group/OpenMapping.lean,smul_singleton_mem_nhds_of_sigmaCompact,smul_singleton_mem_nhds_of_sigmaCompact,b097a5ad56536766f778dae9c0cc7631485165db,":= by
  obtain âŸ¨V, V_mem, V_closed, V_symm, VUâŸ© : âˆƒ V âˆˆ ğ“ (1 : G), IsClosed V âˆ§ Vâ»Â¹ = V âˆ§ V * V âŠ† U :=
    exists_closed_nhds_one_inv_eq_mul_subset hU
  obtain âŸ¨s, s_count, hsâŸ© : âˆƒ (s : Set G), s.Countable âˆ§ â‹ƒ g âˆˆ s, g â€¢ V = univ := by
    apply countable_cover_nhds_of_sigma_compact (fun g â†¦ ?_)
    convert smul_mem_nhds g V_mem
    simp only [smul_eq_mul, mul_one]
  let K : â„• â†’ Set G := compactCovering G
  let F : â„• Ã— s â†’ Set X := fun p â†¦ (K p.1 âˆ© (p.2 : G) â€¢ V) â€¢ ({x} : Set X)
  obtain âŸ¨âŸ¨n, âŸ¨g, hgâŸ©âŸ©, hiâŸ© : âˆƒ i, (interior (F i)).Nonempty := by
    have : Nonempty X := âŸ¨xâŸ©
    have : Encodable s := Countable.toEncodable s_count
    apply nonempty_interior_of_iUnion_of_closed
    Â· rintro âŸ¨n, âŸ¨g, hgâŸ©âŸ©
      apply IsCompact.isClosed
      suffices H : IsCompact ((fun (g : G) â†¦ g â€¢ x) '' (K n âˆ© g â€¢ V)) by
        simpa only [smul_singleton] using H
      apply IsCompact.image
      Â· exact (isCompact_compactCovering G n).inter_right (V_closed.smul g)
      Â· exact continuous_id.smul continuous_const
    Â· apply eq_univ_iff_forall.2 (fun y â†¦ ?_)
      obtain âŸ¨h, rflâŸ© : âˆƒ h, h â€¢ x = y := exists_smul_eq G x y
      obtain âŸ¨n, hnâŸ© : âˆƒ n, h âˆˆ K n := exists_mem_compactCovering h
      obtain âŸ¨g, gs, hgâŸ© : âˆƒ g âˆˆ s, h âˆˆ g â€¢ V := exists_set_mem_of_union_eq_top s _ hs _
      simp only [smul_singleton, mem_iUnion, mem_image, mem_inter_iff, Prod.exists, Subtype.exists,
        exists_prop]
      exact âŸ¨n, g, gs, h, âŸ¨hn, hgâŸ©, rflâŸ©
  have I : (interior ((g â€¢ V) â€¢ {x})).Nonempty := by
    apply hi.mono
    apply interior_mono
    exact smul_subset_smul_right (inter_subset_right _ _)
  obtain âŸ¨y, hyâŸ© : (interior (V â€¢ ({x} : Set X))).Nonempty := by
    rw [smul_assoc, interior_smul] at I
    exact smul_set_nonempty.1 I
  obtain âŸ¨g', hg', rflâŸ© : âˆƒ g' âˆˆ V, g' â€¢ x = y := by simpa using interior_subset hy
  have J : (g' â»Â¹ â€¢ V) â€¢ {x} âˆˆ ğ“ x := by
    apply mem_interior_iff_mem_nhds.1
    rwa [smul_assoc, interior_smul, mem_inv_smul_set_iff]
  have : (g'â»Â¹ â€¢ V) â€¢ {x} âŠ† U â€¢ ({x} : Set X) := by
    apply smul_subset_smul_right
    apply Subset.trans (smul_set_subset_smul (inv_mem_inv.2 hg')) ?_
    rw [V_symm]
    exact VU
  exact Filter.mem_of_superset J this","error:  type mismatch
  hâœ
has type
  IsCompact ((fun g â†¦ g â€¢ x) '' (K n âˆ© g â€¢ V)) : Prop
but is expected to have type
  IsCompact (F (n, âŸ¨g, hgâŸ©)) : Prop
error:  application type mismatch
  âŸ¨âŸ¨hn, hgâŸ©, rflâŸ©
argument
  rfl
has type
  ?m.24384 = ?m.24384 : Prop
but is expected to have type
  âˆƒ b âˆˆ {x}, (fun x x_1 â†¦ x â€¢ x_1) h b = h â€¢ x : Prop
error:  function expected at
  inter_subset_right ?m.27242
term has type
  ?m.27241 âˆˆ ?m.27240","theorem smul_singleton_mem_nhds_of_sigmaCompact
    {U : Set G} (hU : U âˆˆ ğ“ 1) (x : X) : U â€¢ {x} âˆˆ ğ“ x ",":= by
  obtain âŸ¨V, V_mem, V_closed, V_symm, VUâŸ© : âˆƒ V âˆˆ ğ“ (1 : G), IsClosed V âˆ§ Vâ»Â¹ = V âˆ§ V * V âŠ† U :=
    exists_closed_nhds_one_inv_eq_mul_subset hU
  obtain âŸ¨s, s_count, hsâŸ© : âˆƒ (s : Set G), s.Countable âˆ§ â‹ƒ g âˆˆ s, g â€¢ V = univ := by
    apply countable_cover_nhds_of_sigma_compact (fun g â†¦ ?_)
    convert smul_mem_nhds g V_mem
    simp only [smul_eq_mul, mul_one]
  let K : â„• â†’ Set G := compactCovering G
  let F : â„• Ã— s â†’ Set X := fun p â†¦ (K p.1 âˆ© (p.2 : G) â€¢ V) â€¢ ({x} : Set X)
  obtain âŸ¨âŸ¨n, âŸ¨g, hgâŸ©âŸ©, hiâŸ© : âˆƒ i, (interior (F i)).Nonempty := by
    have : Nonempty X := âŸ¨xâŸ©
    have : Encodable s := Countable.toEncodable s_count
    apply nonempty_interior_of_iUnion_of_closed
    Â· rintro âŸ¨n, âŸ¨g, hgâŸ©âŸ©
      apply IsCompact.isClosed
      suffices H : IsCompact ((fun (g : G) â†¦ g â€¢ x) '' (K n âˆ© g â€¢ V)) by
        simpa only [F, smul_singleton] using H
      apply IsCompact.image
      Â· exact (isCompact_compactCovering G n).inter_right (V_closed.smul g)
      Â· exact continuous_id.smul continuous_const
    Â· apply eq_univ_iff_forall.2 (fun y â†¦ ?_)
      obtain âŸ¨h, rflâŸ© : âˆƒ h, h â€¢ x = y := exists_smul_eq G x y
      obtain âŸ¨n, hnâŸ© : âˆƒ n, h âˆˆ K n := exists_mem_compactCovering h
      obtain âŸ¨g, gs, hgâŸ© : âˆƒ g âˆˆ s, h âˆˆ g â€¢ V := exists_set_mem_of_union_eq_top s _ hs _
      simp only [F, smul_singleton, mem_iUnion, mem_image, mem_inter_iff, Prod.exists,
        Subtype.exists, exists_prop]
      exact âŸ¨n, g, gs, h, âŸ¨hn, hgâŸ©, rflâŸ©
  have I : (interior ((g â€¢ V) â€¢ {x})).Nonempty := by
    apply hi.mono
    apply interior_mono
    exact smul_subset_smul_right inter_subset_right
  obtain âŸ¨y, hyâŸ© : (interior (V â€¢ ({x} : Set X))).Nonempty := by
    rw [smul_assoc, interior_smul] at I
    exact smul_set_nonempty.1 I
  obtain âŸ¨g', hg', rflâŸ© : âˆƒ g' âˆˆ V, g' â€¢ x = y := by simpa using interior_subset hy
  have J : (g' â»Â¹ â€¢ V) â€¢ {x} âˆˆ ğ“ x := by
    apply mem_interior_iff_mem_nhds.1
    rwa [smul_assoc, interior_smul, mem_inv_smul_set_iff]
  have : (g'â»Â¹ â€¢ V) â€¢ {x} âŠ† U â€¢ ({x} : Set X) := by
    apply smul_subset_smul_right
    apply Subset.trans (smul_set_subset_smul (inv_mem_inv.2 hg')) ?_
    rw [V_symm]
    exact VU
  exact Filter.mem_of_superset J this"
Mathlib/Analysis/Calculus/Deriv/Slope.lean,range_derivWithin_subset_closure_span_image,range_derivWithin_subset_closure_span_image,1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493,":= by
  rintro - âŸ¨x, rflâŸ©
  rcases eq_or_neBot (ğ“[s \ {x}] x) with H|H
  Â· simp [derivWithin, fderivWithin, H]
    exact subset_closure (zero_mem _)
  by_cases H' : DifferentiableWithinAt ğ•œ f s x; swap
  Â· rw [derivWithin_zero_of_not_differentiableWithinAt H']
    exact subset_closure (zero_mem _)
  have I : (ğ“[(s âˆ© t) \ {x}] x).NeBot := by
    rw [â† mem_closure_iff_nhdsWithin_neBot] at H âŠ¢
    have A : closure (s \ {x}) âŠ† closure (closure (s âˆ© t) \ {x}) :=
      closure_mono (diff_subset_diff_left h)
    have B : closure (s âˆ© t) \ {x} âŠ† closure ((s âˆ© t) \ {x}) := by
      convert closure_diff; exact closure_singleton.symm
    simpa using A.trans (closure_mono B) H
  have : Tendsto (slope f x) (ğ“[(s âˆ© t) \ {x}] x) (ğ“ (derivWithin f s x)) := by
    apply Tendsto.mono_left (hasDerivWithinAt_iff_tendsto_slope.1 H'.hasDerivWithinAt)
    rw [inter_comm, inter_diff_assoc]
    exact nhdsWithin_mono _ (inter_subset_right _ _)
  rw [â† closure_closure, â† Submodule.topologicalClosure_coe]
  apply mem_closure_of_tendsto this
  filter_upwards [self_mem_nhdsWithin] with y hy
  simp only [slope, vsub_eq_sub, SetLike.mem_coe]
  refine Submodule.smul_mem _ _ (Submodule.sub_mem _ ?_ ?_)
  Â· apply Submodule.le_topologicalClosure
    apply Submodule.subset_span
    exact mem_image_of_mem _ hy.1.2
  Â· apply Submodule.closure_subset_topologicalClosure_span
    suffices A : f x âˆˆ closure (f '' (s âˆ© t)) from
      closure_mono (image_subset _ (inter_subset_right _ _)) A
    apply ContinuousWithinAt.mem_closure_image
    Â· apply H'.continuousWithinAt.mono (inter_subset_left _ _)
    rw [mem_closure_iff_nhdsWithin_neBot]
    exact I.mono (nhdsWithin_mono _ (diff_subset _ _))","error:  function expected at
  inter_subset_right ?m.50806
term has type
  ?m.50805 âˆˆ ?m.50804
error:  function expected at
  inter_subset_right ?m.58546
term has type
  ?m.58545 âˆˆ ?m.58544
error:  function expected at
  inter_subset_left ?m.58875
term has type
  ?m.58874 âˆˆ ?m.58872
error:  function expected at
  diff_subset ?m.59125
term has type
  ?m.59124 âˆˆ ?m.59122","theorem range_derivWithin_subset_closure_span_image
    (f : ğ•œ â†’ F) {s t : Set ğ•œ} (h : s âŠ† closure (s âˆ© t)) :
    range (derivWithin f s) âŠ† closure (Submodule.span ğ•œ (f '' t)) ",":= by
  rintro - âŸ¨x, rflâŸ©
  rcases eq_or_neBot (ğ“[s \ {x}] x) with H|H
  Â· simp [derivWithin, fderivWithin, H]
    exact subset_closure (zero_mem _)
  by_cases H' : DifferentiableWithinAt ğ•œ f s x; swap
  Â· rw [derivWithin_zero_of_not_differentiableWithinAt H']
    exact subset_closure (zero_mem _)
  have I : (ğ“[(s âˆ© t) \ {x}] x).NeBot := by
    rw [â† mem_closure_iff_nhdsWithin_neBot] at H âŠ¢
    have A : closure (s \ {x}) âŠ† closure (closure (s âˆ© t) \ {x}) :=
      closure_mono (diff_subset_diff_left h)
    have B : closure (s âˆ© t) \ {x} âŠ† closure ((s âˆ© t) \ {x}) := by
      convert closure_diff; exact closure_singleton.symm
    simpa using A.trans (closure_mono B) H
  have : Tendsto (slope f x) (ğ“[(s âˆ© t) \ {x}] x) (ğ“ (derivWithin f s x)) := by
    apply Tendsto.mono_left (hasDerivWithinAt_iff_tendsto_slope.1 H'.hasDerivWithinAt)
    rw [inter_comm, inter_diff_assoc]
    exact nhdsWithin_mono _ inter_subset_right
  rw [â† closure_closure, â† Submodule.topologicalClosure_coe]
  apply mem_closure_of_tendsto this
  filter_upwards [self_mem_nhdsWithin] with y hy
  simp only [slope, vsub_eq_sub, SetLike.mem_coe]
  refine Submodule.smul_mem _ _ (Submodule.sub_mem _ ?_ ?_)
  Â· apply Submodule.le_topologicalClosure
    apply Submodule.subset_span
    exact mem_image_of_mem _ hy.1.2
  Â· apply Submodule.closure_subset_topologicalClosure_span
    suffices A : f x âˆˆ closure (f '' (s âˆ© t)) from
      closure_mono (image_subset _ inter_subset_right) A
    apply ContinuousWithinAt.mem_closure_image
    Â· apply H'.continuousWithinAt.mono inter_subset_left
    rw [mem_closure_iff_nhdsWithin_neBot]
    exact I.mono (nhdsWithin_mono _ diff_subset)"
Mathlib/Analysis/Analytic/Basic.lean,FormalMultilinearSeries.changeOrigin_eval,changeOrigin_eval,6eb9f7b3857e15a807352d127e949865f5f9ba97,":= by
  have radius_pos : 0 < p.radius := lt_of_le_of_lt (zero_le _) h
  have x_mem_ball : x âˆˆ EMetric.ball (0 : E) p.radius :=
    mem_emetric_ball_zero_iff.2 ((le_add_right le_rfl).trans_lt h)
  have y_mem_ball : y âˆˆ EMetric.ball (0 : E) (p.changeOrigin x).radius := by
    refine' mem_emetric_ball_zero_iff.2 (lt_of_lt_of_le _ p.changeOrigin_radius)
    rwa [lt_tsub_iff_right, add_comm]
  have x_add_y_mem_ball : x + y âˆˆ EMetric.ball (0 : E) p.radius := by
    refine' mem_emetric_ball_zero_iff.2 (lt_of_le_of_lt _ h)
    exact_mod_cast nnnorm_add_le x y
  set f : (Î£k l : â„•, { s : Finset (Fin (k + l)) // s.card = l }) â†’ F := fun s =>
    p.changeOriginSeriesTerm s.1 s.2.1 s.2.2 s.2.2.2 (fun _ => x) fun _ => y
  have hsf : Summable f := by
    refine' .of_nnnorm_bounded _ (p.changeOriginSeries_summable_auxâ‚ h) _
    rintro âŸ¨k, l, s, hsâŸ©
    dsimp only [Subtype.coe_mk]
    exact p.nnnorm_changeOriginSeriesTerm_apply_le _ _ _ _ _ _
  have hf : HasSum f ((p.changeOrigin x).sum y) := by
    refine' HasSum.sigma_of_hasSum ((p.changeOrigin x).summable y_mem_ball).hasSum (fun k => _) hsf
    Â· dsimp only
      refine' ContinuousMultilinearMap.hasSum_eval _ _
      have := (p.hasFPowerSeriesOnBall_changeOrigin k radius_pos).hasSum x_mem_ball
      rw [zero_add] at this
      refine' HasSum.sigma_of_hasSum this (fun l => _) _
      Â· simp only [changeOriginSeries, ContinuousMultilinearMap.sum_apply]
        apply hasSum_fintype
      Â· refine' .of_nnnorm_bounded _
          (p.changeOriginSeries_summable_auxâ‚‚ (mem_emetric_ball_zero_iff.1 x_mem_ball) k) fun s => _
        refine' (ContinuousMultilinearMap.le_op_nnnorm _ _).trans_eq _
        simp
  refine' hf.unique (changeOriginIndexEquiv.symm.hasSum_iff.1 _)
  refine' HasSum.sigma_of_hasSum
    (p.hasSum x_add_y_mem_ball) (fun n => _) (changeOriginIndexEquiv.symm.summable_iff.2 hsf)
  erw [(p n).map_add_univ (fun _ => x) fun _ => y]
  convert hasSum_fintype (fun c : Finset (Fin n) => f (changeOriginIndexEquiv.symm âŸ¨n, câŸ©))
  rename_i s _
  dsimp only [changeOriginSeriesTerm, (Â· âˆ˜ Â·), changeOriginIndexEquiv_symm_apply_fst,
    changeOriginIndexEquiv_symm_apply_snd_fst, changeOriginIndexEquiv_symm_apply_snd_snd_coe]
  rw [ContinuousMultilinearMap.curryFinFinset_apply_const]
  have : âˆ€ (m) (hm : n = m), p n (s.piecewise (fun _ => x) fun _ => y) =
      p m ((s.map (Fin.castIso hm).toEquiv.toEmbedding).piecewise (fun _ => x) fun _ => y) := by
    rintro m rfl
    simp [Finset.piecewise]
  apply this","error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  invalid field 'changeOrigin_eval', the environment does not contain 'FormalMultilinearSeries.changeOrigin_eval'
  p
has type
  FormalMultilinearSeries ğ•œ E F
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  p
has type
  (n : â„•) â†’ ContinuousMultilinearMap ğ•œ (fun i â†¦ E) F
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.1409746
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
G : Type u_4
instâœâ· : NontriviallyNormedField ğ•œ
instâœâ¶ : NormedAddCommGroup E
instâœâµ : NormedSpace ğ•œ E
instâœâ´ : NormedAddCommGroup F
instâœÂ³ : NormedSpace ğ•œ F
instâœÂ² : NormedAddCommGroup G
instâœÂ¹ : NormedSpace ğ•œ G
instâœ : CompleteSpace F
f : E â†’ F
p : FormalMultilinearSeries ğ•œ E F
x y : E
r : â„â‰¥0âˆ
hf : HasFPowerSeriesOnBall f p x r
h : â†‘â€–yâ€–â‚Š < r
z : E
hz : â†‘â€–yâ€–â‚Š + â†‘â€–zâ€–â‚Š < r
âŠ¢ f (x + y + z) = (p.changeOrigin y).sum z","theorem changeOrigin_eval (h : (â€–xâ€–â‚Š + â€–yâ€–â‚Š : â„â‰¥0âˆ) < p.radius) :
    (p.changeOrigin x).sum y = p.sum (x + y) ",":= by
  have radius_pos : 0 < p.radius := lt_of_le_of_lt (zero_le _) h
  have x_mem_ball : x âˆˆ EMetric.ball (0 : E) p.radius :=
    mem_emetric_ball_zero_iff.2 ((le_add_right le_rfl).trans_lt h)
  have y_mem_ball : y âˆˆ EMetric.ball (0 : E) (p.changeOrigin x).radius := by
    refine mem_emetric_ball_zero_iff.2 (lt_of_lt_of_le ?_ p.changeOrigin_radius)
    rwa [lt_tsub_iff_right, add_comm]
  have x_add_y_mem_ball : x + y âˆˆ EMetric.ball (0 : E) p.radius := by
    refine mem_emetric_ball_zero_iff.2 (lt_of_le_of_lt ?_ h)
    exact mod_cast nnnorm_add_le x y
  set f : (Î£ k l : â„•, { s : Finset (Fin (k + l)) // s.card = l }) â†’ F := fun s =>
    p.changeOriginSeriesTerm s.1 s.2.1 s.2.2 s.2.2.2 (fun _ => x) fun _ => y
  have hsf : Summable f := by
    refine .of_nnnorm_bounded _ (p.changeOriginSeries_summable_auxâ‚ h) ?_
    rintro âŸ¨k, l, s, hsâŸ©
    dsimp only [Subtype.coe_mk]
    exact p.nnnorm_changeOriginSeriesTerm_apply_le _ _ _ _ _ _
  have hf : HasSum f ((p.changeOrigin x).sum y) := by
    refine HasSum.sigma_of_hasSum ((p.changeOrigin x).summable y_mem_ball).hasSum (fun k => ?_) hsf
    Â· dsimp only [f]
      refine ContinuousMultilinearMap.hasSum_eval ?_ _
      have := (p.hasFPowerSeriesOnBall_changeOrigin k radius_pos).hasSum x_mem_ball
      rw [zero_add] at this
      refine HasSum.sigma_of_hasSum this (fun l => ?_) ?_
      Â· simp only [changeOriginSeries, ContinuousMultilinearMap.sum_apply]
        apply hasSum_fintype
      Â· refine .of_nnnorm_bounded _
          (p.changeOriginSeries_summable_auxâ‚‚ (mem_emetric_ball_zero_iff.1 x_mem_ball) k)
            fun s => ?_
        refine (ContinuousMultilinearMap.le_opNNNorm _ _).trans_eq ?_
        simp
  refine hf.unique (changeOriginIndexEquiv.symm.hasSum_iff.1 ?_)
  refine HasSum.sigma_of_hasSum
    (p.hasSum x_add_y_mem_ball) (fun n => ?_) (changeOriginIndexEquiv.symm.summable_iff.2 hsf)
  erw [(p n).map_add_univ (fun _ => x) fun _ => y]
  simp_rw [â† changeOriginSeriesTerm_changeOriginIndexEquiv_symm]
  exact hasSum_fintype (fun c => f (changeOriginIndexEquiv.symm âŸ¨n, câŸ©))"
Mathlib/Data/LazyList/Basic.lean,LazyList.append_nil,append_nil,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' xs using LazyList.rec with _ _ _ _ ih
  Â· rfl
  Â· simpa only [append, cons.injEq, true_and]
  Â· ext; apply ih","error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case nil
Î± : Type u_1
âŠ¢ nil.append (Thunk.pure nil) = nil",theorem append_nil {Î±} (xs : LazyList Î±) : xs.append (Thunk.pure LazyList.nil) = xs ,":= by
  induction' xs using LazyList.rec with _ _ _ _ ih
  Â· simp only [Thunk.pure, append, Thunk.get]
  Â· simpa only [append, cons.injEq, true_and]
  Â· ext; apply ih"
Mathlib/Algebra/Homology/HomotopyCategory/HomComplex.lean,CochainComplex.HomComplex.Î´_shape,Î´_shape,2c367bb7cdc3187abec81c2896087d55449d9b24,":= by
  ext âŸ¨p, q, hpqâŸ©
  dsimp [Î´, Cochain.v, Cochain.mk]
  rw [F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  . rfl
  all_goals
    change Â¬ _=_
    rintro h
    apply hnm
    linarith","error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case h.ofNat.zero.a
C : Type u
instâœÂ³ : Category.{v, u} C
instâœÂ² : Preadditive C
R : Type u_1
instâœÂ¹ : Ring R
instâœ : Linear R C
F G K L : CochainComplex C â„¤
n m : â„¤
hnm : Â¬n + 1 = m
z : Cochain F G n
qâœ : â„¤
hpqâœ : Int.ofNat 0 + m = qâœ
âŠ¢ Â¬(ComplexShape.up â„¤).Rel (0 + n) qâœ
error:  unsolved goals
case h.ofNat.succ
C : Type u
instâœÂ³ : Category.{v, u} C
instâœÂ² : Preadditive C
R : Type u_1
instâœÂ¹ : Ring R
instâœ : Linear R C
F G K L : CochainComplex C â„¤
n m : â„¤
hnm : Â¬n + 1 = m
z : Cochain F G n
nâœ : â„•
qâœ : â„¤
hpqâœ : Int.ofNat (nâœ + 1) + m = qâœ
âŠ¢ (Î´ n m z).v (Int.ofNat (nâœ + 1)) qâœ hpqâœ = Cochain.v 0 (Int.ofNat (nâœ + 1)) qâœ hpqâœ

case h.negSucc
C : Type u
instâœÂ³ : Category.{v, u} C
instâœÂ² : Preadditive C
R : Type u_1
instâœÂ¹ : Ring R
instâœ : Linear R C
F G K L : CochainComplex C â„¤
n m : â„¤
hnm : Â¬n + 1 = m
z : Cochain F G n
aâœ : â„•
qâœ : â„¤
hpqâœ : Int.negSucc aâœ + m = qâœ
âŠ¢ (Î´ n m z).v (Int.negSucc aâœ) qâœ hpqâœ = Cochain.v 0 (Int.negSucc aâœ) qâœ hpqâœ",lemma Î´_shape (hnm : Â¬ n + 1 = m) (z : Cochain F G n) : Î´ n m z = 0 ,":= by
  ext p q hpq
  dsimp only [Î´]
  rw [Cochain.mk_v, Cochain.zero_v, F.shape, G.shape, comp_zero, zero_add, zero_comp, smul_zero]
  all_goals
    simp only [ComplexShape.up_Rel]
    exact fun _ => hnm (by omega)"
Mathlib/MeasureTheory/Integral/PeakFunction.lean,integrableOn_peak_smul_of_integrableOn_of_tendsto,integrableOn_peak_smul_of_integrableOn_of_tendsto,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  obtain âŸ¨u, u_open, xâ‚€u, ut, huâŸ© :
      âˆƒ u, IsOpen u âˆ§ xâ‚€ âˆˆ u âˆ§ s âˆ© u âŠ† t âˆ§ âˆ€ x âˆˆ u âˆ© s, g x âˆˆ ball a 1 := by
    rcases mem_nhdsWithin.1 (Filter.inter_mem h'st (hcg (ball_mem_nhds _ zero_lt_one)))
      with âŸ¨u, u_open, xâ‚€u, huâŸ©
    refine âŸ¨u, u_open, xâ‚€u, ?_, hu.trans (inter_subset_right _ _)âŸ©
    rw [inter_comm]
    exact hu.trans (inter_subset_left _ _)
  rw [tendsto_iff_norm_sub_tendsto_zero] at hiÏ†
  filter_upwards [tendstoUniformlyOn_iff.1 (hlÏ† u u_open xâ‚€u) 1 zero_lt_one,
    (tendsto_order.1 hiÏ†).2 1 zero_lt_one, h'iÏ†] with i hi h'i h''i
  have I : IntegrableOn (Ï† i) t Î¼ := .of_integral_ne_zero (fun h â†¦ by simp [h] at h'i)
  have A : IntegrableOn (fun x => Ï† i x â€¢ g x) (s \ u) Î¼ := by
    refine' Integrable.smul_of_top_right (hmg.mono (diff_subset _ _) le_rfl) _
    apply memâ„’p_top_of_bound (h''i.mono_set (diff_subset _ _)) 1
    filter_upwards [self_mem_ae_restrict (hs.diff u_open.measurableSet)] with x hx
    simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le
  have B : IntegrableOn (fun x => Ï† i x â€¢ g x) (s âˆ© u) Î¼ := by
    apply Integrable.smul_of_top_left
    Â· exact IntegrableOn.mono_set I ut
    Â· apply
        memâ„’p_top_of_bound (hmg.mono_set (inter_subset_left _ _)).aestronglyMeasurable (â€–aâ€– + 1)
      filter_upwards [self_mem_ae_restrict (hs.inter u_open.measurableSet)] with x hx
      rw [inter_comm] at hx
      exact (norm_lt_of_mem_ball (hu x hx)).le
  convert A.union B
  simp only [diff_union_inter]","error:  function expected at
  inter_subset_right ?m.4674
term has type
  ?m.4673 âˆˆ ?m.4672
error:  function expected at
  inter_subset_left ?m.4820
term has type
  ?m.4819 âˆˆ ?m.4817
error:  function expected at
  diff_subset ?m.10020
term has type
  ?m.10019 âˆˆ ?m.10017
error:  function expected at
  diff_subset ?m.10459
term has type
  ?m.10458 âˆˆ ?m.10456
error:  function expected at
  inter_subset_left ?m.11346
term has type
  ?m.11345 âˆˆ ?m.11343","theorem integrableOn_peak_smul_of_integrableOn_of_tendsto
    (hs : MeasurableSet s) (h'st : t âˆˆ ğ“[s] xâ‚€)
    (hlÏ† : âˆ€ u : Set Î±, IsOpen u â†’ xâ‚€ âˆˆ u â†’ TendstoUniformlyOn Ï† 0 l (s \ u))
    (hiÏ† : Tendsto (fun i â†¦ âˆ« x in t, Ï† i x âˆ‚Î¼) l (ğ“ 1))
    (h'iÏ† : âˆ€á¶  i in l, AEStronglyMeasurable (Ï† i) (Î¼.restrict s))
    (hmg : IntegrableOn g s Î¼) (hcg : Tendsto g (ğ“[s] xâ‚€) (ğ“ a)) :
    âˆ€á¶  i in l, IntegrableOn (fun x => Ï† i x â€¢ g x) s Î¼ ",":= by
  obtain âŸ¨u, u_open, xâ‚€u, ut, huâŸ© :
      âˆƒ u, IsOpen u âˆ§ xâ‚€ âˆˆ u âˆ§ s âˆ© u âŠ† t âˆ§ âˆ€ x âˆˆ u âˆ© s, g x âˆˆ ball a 1 := by
    rcases mem_nhdsWithin.1 (Filter.inter_mem h'st (hcg (ball_mem_nhds _ zero_lt_one)))
      with âŸ¨u, u_open, xâ‚€u, huâŸ©
    refine âŸ¨u, u_open, xâ‚€u, ?_, hu.trans inter_subset_rightâŸ©
    rw [inter_comm]
    exact hu.trans inter_subset_left
  rw [tendsto_iff_norm_sub_tendsto_zero] at hiÏ†
  filter_upwards [tendstoUniformlyOn_iff.1 (hlÏ† u u_open xâ‚€u) 1 zero_lt_one,
    (tendsto_order.1 hiÏ†).2 1 zero_lt_one, h'iÏ†] with i hi h'i h''i
  have I : IntegrableOn (Ï† i) t Î¼ := .of_integral_ne_zero (fun h â†¦ by simp [h] at h'i)
  have A : IntegrableOn (fun x => Ï† i x â€¢ g x) (s \ u) Î¼ := by
    refine Integrable.smul_of_top_right (hmg.mono diff_subset le_rfl) ?_
    apply memâ„’p_top_of_bound (h''i.mono_set diff_subset) 1
    filter_upwards [self_mem_ae_restrict (hs.diff u_open.measurableSet)] with x hx
    simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le
  have B : IntegrableOn (fun x => Ï† i x â€¢ g x) (s âˆ© u) Î¼ := by
    apply Integrable.smul_of_top_left
    Â· exact IntegrableOn.mono_set I ut
    Â· apply
        memâ„’p_top_of_bound (hmg.mono_set inter_subset_left).aestronglyMeasurable (â€–aâ€– + 1)
      filter_upwards [self_mem_ae_restrict (hs.inter u_open.measurableSet)] with x hx
      rw [inter_comm] at hx
      exact (norm_lt_of_mem_ball (hu x hx)).le
  convert A.union B
  simp only [diff_union_inter]"
Mathlib/Analysis/InnerProductSpace/MeanErgodic.lean,LinearMap.tendsto_birkhoffAverage_of_ker_subset_closure,LinearMap.tendsto_birkhoffAverage_of_ker_subset_closure,0939faa78a0c4506a8aee4e86b897d6e84c6cb96,":= by
  obtain âŸ¨y, hy, z, hz, rflâŸ© : âˆƒ y, g y = 0 âˆ§ âˆƒ z, IsFixedPt f z âˆ§ x = y + z :=
    âŸ¨x - g x, by simp [hg_proj], g x, (g x).2, by simpâŸ©
  suffices Tendsto (birkhoffAverage ğ•œ f _root_.id Â· y) atTop (ğ“ 0) by
    have hgz : g z = z := congr_arg Subtype.val (hg_proj âŸ¨z, hzâŸ©)
    simpa [hy, hgz, birkhoffAverage, birkhoffSum, Finset.sum_add_distrib, smul_add]
      using this.add (hz.tendsto_birkhoffAverage ğ•œ _root_.id)
  have : IsClosed {x | Tendsto (birkhoffAverage ğ•œ f _root_.id Â· x) atTop (ğ“ 0)} :=
    isClosed_setOf_tendsto_birkhoffAverage ğ•œ hf uniformContinuous_id continuous_const
  refine closure_minimal (Set.forall_range_iff.2 fun x â†¦ ?_) this (hg_ker hy)
  have : IsBounded (Set.range (_root_.id <| f^[Â·] x)) :=
    isBounded_iff_forall_norm_le.2 âŸ¨â€–xâ€–, Set.forall_range_iff.2 fun n â†¦ by
      have H : f^[n] 0 = 0 := (f : E â†’+ E).iterate_map_zero n
      simpa [H] using (hf.iterate n).dist_le_mul x 0âŸ©
  have H : âˆ€ n x y, f^[n] (x - y) = f^[n] x - f^[n] y := (f : E â†’+ E).iterate_map_sub
  simpa [birkhoffAverage, birkhoffSum, Finset.sum_sub_distrib, smul_sub, H]
    using tendsto_birkhoffAverage_apply_sub_birkhoffAverage ğ•œ this","warning:  `Set.forall_range_iff` has been deprecated, use `Set.forall_mem_range` instead
warning:  `Set.forall_range_iff` has been deprecated, use `Set.forall_mem_range` instead
error:  invalid field 'iterate_map_zero', the environment does not contain 'AddMonoidHom.iterate_map_zero'
  â†‘f
has type
  E â†’+ E
error:  invalid field 'iterate_map_sub', the environment does not contain 'AddMonoidHom.iterate_map_sub'
  â†‘f
has type
  E â†’+ E","theorem LinearMap.tendsto_birkhoffAverage_of_ker_subset_closure [NormedSpace ğ•œ E]
    (f : E â†’â‚—[ğ•œ] E) (hf : LipschitzWith 1 f) (g : E â†’L[ğ•œ] LinearMap.eqLocus f 1)
    (hg_proj : âˆ€ x : LinearMap.eqLocus f 1, g x = x)
    (hg_ker : (LinearMap.ker g : Set E) âŠ† closure (LinearMap.range (f - 1))) (x : E) :
    Tendsto (birkhoffAverage ğ•œ f _root_.id Â· x) atTop (ğ“ (g x)) ",":= by
  obtain âŸ¨y, hy, z, hz, rflâŸ© : âˆƒ y, g y = 0 âˆ§ âˆƒ z, IsFixedPt f z âˆ§ x = y + z :=
    âŸ¨x - g x, by simp [hg_proj], g x, (g x).2, by simpâŸ©
  suffices Tendsto (birkhoffAverage ğ•œ f _root_.id Â· y) atTop (ğ“ 0) by
    have hgz : g z = z := congr_arg Subtype.val (hg_proj âŸ¨z, hzâŸ©)
    simpa [hy, hgz, birkhoffAverage, birkhoffSum, Finset.sum_add_distrib, smul_add]
      using this.add (hz.tendsto_birkhoffAverage ğ•œ _root_.id)
  have : IsClosed {x | Tendsto (birkhoffAverage ğ•œ f _root_.id Â· x) atTop (ğ“ 0)} :=
    isClosed_setOf_tendsto_birkhoffAverage ğ•œ hf uniformContinuous_id continuous_const
  refine closure_minimal (Set.forall_mem_range.2 fun x â†¦ ?_) this (hg_ker hy)
  have : IsBounded (Set.range (_root_.id <| f^[Â·] x)) :=
    isBounded_iff_forall_norm_le.2 âŸ¨â€–xâ€–, Set.forall_mem_range.2 fun n â†¦ by
      have H : f^[n] 0 = 0 := iterate_map_zero (f : E â†’+ E) n
      simpa [H] using (hf.iterate n).dist_le_mul x 0âŸ©
  have H : âˆ€ n x y, f^[n] (x - y) = f^[n] x - f^[n] y := iterate_map_sub (f : E â†’+ E)
  simpa [birkhoffAverage, birkhoffSum, Finset.sum_sub_distrib, smul_sub, H]
    using tendsto_birkhoffAverage_apply_sub_birkhoffAverage ğ•œ this"
Mathlib/GroupTheory/ClassEquation.lean,sum_conjClasses_card_eq_card,sum_conjClasses_card_eq_card,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  suffices : (Î£ x : ConjClasses G, x.carrier) â‰ƒ G
  Â· simpa using (Fintype.card_congr this)
  simpa [carrier_eq_preimage_mk] using Equiv.sigmaFiberEquiv ConjClasses.mk",error:  unexpected token ':'; expected term,"theorem sum_conjClasses_card_eq_card [Fintype <| ConjClasses G] [Fintype G]
    [âˆ€ x : ConjClasses G, Fintype x.carrier] :
    âˆ‘ x : ConjClasses G, x.carrier.toFinset.card = Fintype.card G ",":= by
  suffices (Î£ x : ConjClasses G, x.carrier) â‰ƒ G by simpa using (Fintype.card_congr this)
  simpa [carrier_eq_preimage_mk] using Equiv.sigmaFiberEquiv ConjClasses.mk"
Mathlib/RingTheory/AlgebraicIndependent.lean,algebraicIndependent_bounded_of_finset_algebraicIndependent_bounded,algebraicIndependent_bounded_of_finset_algebraicIndependent_bounded,ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  intro s li
  apply Cardinal.card_le_of
  intro t
  rw [â† Finset.card_map (Embedding.subtype s.toPred)]
  apply H
  apply algebraicIndependent_finset_map_embedding_subtype _ li","error:  invalid field 'toPred', the environment does not contain 'Set.toPred'
  s
has type
  Set A
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  s
has type
  A â†’ Prop","theorem algebraicIndependent_bounded_of_finset_algebraicIndependent_bounded {n : â„•}
    (H : âˆ€ s : Finset A, (AlgebraicIndependent R fun i : s => (i : A)) â†’ s.card â‰¤ n) :
    âˆ€ s : Set A, AlgebraicIndependent R ((â†‘) : s â†’ A) â†’ Cardinal.mk s â‰¤ n ",":= by
  intro s li
  apply Cardinal.card_le_of
  intro t
  rw [â† Finset.card_map (Embedding.subtype s)]
  apply H
  apply algebraicIndependent_finset_map_embedding_subtype _ li"
Mathlib/Analysis/Calculus/ContDiff/Bounds.lean,norm_iteratedFDerivWithin_comp_le,norm_iteratedFDerivWithin_comp_le,5ac3430b427e70f2e706ce82ce6bfb8b850f6fab,":= by
  induction' n using Nat.case_strong_induction_on with n IH generalizing Gu
  Â· simpa [norm_iteratedFDerivWithin_zero, Nat.factorial_zero, algebraMap.coe_one, one_mul,
      pow_zero, mul_one, comp_apply] using hC 0 le_rfl
  have M : (n : â„•âˆ) < n.succ := Nat.cast_lt.2 n.lt_succ_self
  have Cnonneg : 0 â‰¤ C := (norm_nonneg _).trans (hC 0 bot_le)
  have Dnonneg : 0 â‰¤ D := by
    have : 1 â‰¤ n + 1 := by simp only [le_add_iff_nonneg_left, zero_le']
    simpa only [pow_one] using (norm_nonneg _).trans (hD 1 le_rfl this)
  have I : âˆ€ i âˆˆ Finset.range (n + 1),
      â€–iteratedFDerivWithin ğ•œ i (fderivWithin ğ•œ g t âˆ˜ f) s xâ€– â‰¤ i ! * C * D ^ i
  Â· intro i hi
    simp only [Finset.mem_range_succ_iff] at hi
    apply IH i hi
    Â· apply hg.fderivWithin ht
      simp only [Nat.cast_succ]
      exact add_le_add_right (Nat.cast_le.2 hi) _
    Â· apply hf.of_le (Nat.cast_le.2 (hi.trans n.le_succ))
    Â· intro j hj
      have : â€–iteratedFDerivWithin ğ•œ j (fderivWithin ğ•œ g t) t (f x)â€– =
          â€–iteratedFDerivWithin ğ•œ (j + 1) g t (f x)â€– :=
        by rw [iteratedFDerivWithin_succ_eq_comp_right ht (hst hx), comp_apply,
          LinearIsometryEquiv.norm_map]
      rw [this]
      exact hC (j + 1) (add_le_add (hj.trans hi) le_rfl)
    Â· intro j hj h'j
      exact hD j hj (h'j.trans (hi.trans n.le_succ))
  have J : âˆ€ i, â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– â‰¤ D ^ (n - i + 1) := by
    intro i
    have : â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– =
        â€–iteratedFDerivWithin ğ•œ (n - i + 1) f s xâ€–
    Â· rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply, LinearIsometryEquiv.norm_map]
    rw [this]
    apply hD
    Â· simp only [le_add_iff_nonneg_left, zero_le']
    Â· apply Nat.succ_le_succ tsub_le_self
  calc
    â€–iteratedFDerivWithin ğ•œ (n + 1) (g âˆ˜ f) s xâ€– =
        â€–iteratedFDerivWithin ğ•œ n (fun y : E => fderivWithin ğ•œ (g âˆ˜ f) s y) s xâ€– := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply,
        LinearIsometryEquiv.norm_map]
    _ = â€–iteratedFDerivWithin ğ•œ n (fun y : E => ContinuousLinearMap.compL ğ•œ E Fu Gu
        (fderivWithin ğ•œ g t (f y)) (fderivWithin ğ•œ f s y)) s xâ€– := by
      have L : (1 : â„•âˆ) â‰¤ n.succ := by simpa only [ENat.coe_one, Nat.one_le_cast] using n.succ_pos
      congr 1
      refine' iteratedFDerivWithin_congr (fun y hy => _) hx _
      apply fderivWithin.comp _ _ _ hst (hs y hy)
      Â· exact hg.differentiableOn L _ (hst hy)
      Â· exact hf.differentiableOn L _ hy
    _ â‰¤ âˆ‘ i in Finset.range (n + 1),
        (n.choose i : â„) * â€–iteratedFDerivWithin ğ•œ i (fderivWithin ğ•œ g t âˆ˜ f) s xâ€– *
          â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– := by
      have A : ContDiffOn ğ•œ n (fderivWithin ğ•œ g t âˆ˜ f) s := by
        apply ContDiffOn.comp _ (hf.of_le M.le) hst
        apply hg.fderivWithin ht
        simp only [Nat.cast_succ, le_refl]
      have B : ContDiffOn ğ•œ n (fderivWithin ğ•œ f s) s := by
        apply hf.fderivWithin hs
        simp only [Nat.cast_succ, le_refl]
      exact (ContinuousLinearMap.compL ğ•œ E Fu Gu).norm_iteratedFDerivWithin_le_of_bilinear_of_le_one
        A B hs hx le_rfl (ContinuousLinearMap.norm_compL_le ğ•œ E Fu Gu)
    _ â‰¤ âˆ‘ i in Finset.range (n + 1), (n.choose i : â„) * (i ! * C * D ^ i) * D ^ (n - i + 1) := by
      apply Finset.sum_le_sum fun i hi => ?_
      simp only [mul_assoc (n.choose i : â„)]
      refine' mul_le_mul_of_nonneg_left _ (Nat.cast_nonneg _)
      apply mul_le_mul (I i hi) (J i) (norm_nonneg _)
      positivity
    _ = âˆ‘ i in Finset.range (n + 1),
        (n ! : â„) * ((i ! : â„)â»Â¹ * i !) * C * (D ^ i * D ^ (n - i + 1)) * ((n - i)! : â„)â»Â¹ := by
      apply Finset.sum_congr rfl fun i hi => ?_
      simp only [Nat.cast_choose â„ (Finset.mem_range_succ_iff.1 hi), div_eq_inv_mul, mul_inv]
      ring
    _ = âˆ‘ i in Finset.range (n + 1), (n ! : â„) * 1 * C * D ^ (n + 1) * ((n - i)! : â„)â»Â¹ := by
      apply Finset.sum_congr rfl fun i hi => ?_
      congr 2
      Â· congr
        apply inv_mul_cancel
        simpa only [Ne.def, Nat.cast_eq_zero] using i.factorial_ne_zero
      Â· rw [â† pow_add]
        congr 1
        rw [Nat.add_succ, Nat.succ_inj']
        exact Nat.add_sub_of_le (Finset.mem_range_succ_iff.1 hi)
    _ â‰¤ âˆ‘ i in Finset.range (n + 1), (n ! : â„) * 1 * C * D ^ (n + 1) * 1 := by
      apply Finset.sum_le_sum fun i _hi => ?_
      refine' mul_le_mul_of_nonneg_left _ (by positivity)
      apply inv_le_one
      simpa only [Nat.one_le_cast] using (n - i).factorial_pos
    _ = (n + 1)! * C * D ^ (n + 1) := by
      simp only [mul_assoc, mul_one, Finset.sum_const, Finset.card_range, nsmul_eq_mul,
        Nat.factorial_succ, Nat.cast_mul]","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case hi
ğ•œ : Type u_1
instâœÂ¹Â² : NontriviallyNormedField ğ•œ
Dâœ : Type uD
instâœÂ¹Â¹ : NormedAddCommGroup Dâœ
instâœÂ¹â° : NormedSpace ğ•œ Dâœ
E : Type uE
instâœâ¹ : NormedAddCommGroup E
instâœâ¸ : NormedSpace ğ•œ E
F : Type uF
instâœâ· : NormedAddCommGroup F
instâœâ¶ : NormedSpace ğ•œ F
G : Type uG
instâœâµ : NormedAddCommGroup G
instâœâ´ : NormedSpace ğ•œ G
sâœ sâ‚ tâœ u : Set E
Fu : Type u
instâœÂ³ : NormedAddCommGroup Fu
instâœÂ² : NormedSpace ğ•œ Fu
f : E â†’ Fu
s : Set E
t : Set Fu
x : E
ht : UniqueDiffOn ğ•œ t
hs : UniqueDiffOn ğ•œ s
hst : MapsTo f s t
hx : x âˆˆ s
C D : â„
n : â„•
IH :
  âˆ€ m â‰¤ n,
    âˆ€ {Gu : Type u} [inst : NormedAddCommGroup Gu] [inst_1 : NormedSpace ğ•œ Gu] {g : Fu â†’ Gu},
      ContDiffOn ğ•œ (â†‘m) g t â†’
        ContDiffOn ğ•œ (â†‘m) f s â†’
          (âˆ€ i â‰¤ m, â€–iteratedFDerivWithin ğ•œ i g t (f x)â€– â‰¤ C) â†’
            (âˆ€ (i : â„•), 1 â‰¤ i â†’ i â‰¤ m â†’ â€–iteratedFDerivWithin ğ•œ i f s xâ€– â‰¤ D ^ i) â†’
              â€–iteratedFDerivWithin ğ•œ m (g âˆ˜ f) s xâ€– â‰¤ â†‘m ! * C * D ^ m
Gu : Type u
instâœÂ¹ : NormedAddCommGroup Gu
instâœ : NormedSpace ğ•œ Gu
g : Fu â†’ Gu
hg : ContDiffOn ğ•œ (â†‘n.succ) g t
hf : ContDiffOn ğ•œ (â†‘n.succ) f s
hC : âˆ€ i â‰¤ n.succ, â€–iteratedFDerivWithin ğ•œ i g t (f x)â€– â‰¤ C
hD : âˆ€ (i : â„•), 1 â‰¤ i â†’ i â‰¤ n.succ â†’ â€–iteratedFDerivWithin ğ•œ i f s xâ€– â‰¤ D ^ i
M : â†‘n < â†‘n.succ
Cnonneg : 0 â‰¤ C
Dnonneg : 0 â‰¤ D
I : âˆ€ i âˆˆ Finset.range (n + 1), â€–iteratedFDerivWithin ğ•œ i (fderivWithin ğ•œ g t âˆ˜ f) s xâ€– â‰¤ â†‘i ! * C * D ^ i
âŠ¢ â€–iteratedFDerivWithin ğ•œ n.succ (g âˆ˜ f) s xâ€– â‰¤ â†‘n.succ ! * C * D ^ n.succ","theorem norm_iteratedFDerivWithin_comp_le_aux {Fu Gu : Type u} [NormedAddCommGroup Fu]
    [NormedSpace ğ•œ Fu] [NormedAddCommGroup Gu] [NormedSpace ğ•œ Gu] {g : Fu â†’ Gu} {f : E â†’ Fu} {n : â„•}
    {s : Set E} {t : Set Fu} {x : E} (hg : ContDiffOn ğ•œ n g t) (hf : ContDiffOn ğ•œ n f s)
    (ht : UniqueDiffOn ğ•œ t) (hs : UniqueDiffOn ğ•œ s) (hst : MapsTo f s t) (hx : x âˆˆ s) {C : â„}
    {D : â„} (hC : âˆ€ i, i â‰¤ n â†’ â€–iteratedFDerivWithin ğ•œ i g t (f x)â€– â‰¤ C)
    (hD : âˆ€ i, 1 â‰¤ i â†’ i â‰¤ n â†’ â€–iteratedFDerivWithin ğ•œ i f s xâ€– â‰¤ D ^ i) :
    â€–iteratedFDerivWithin ğ•œ n (g âˆ˜ f) s xâ€– â‰¤ n ! * C * D ^ n ",":= by
  induction' n using Nat.case_strong_induction_on with n IH generalizing Gu
  Â· simpa [norm_iteratedFDerivWithin_zero, Nat.factorial_zero, algebraMap.coe_one, one_mul,
      pow_zero, mul_one, comp_apply] using hC 0 le_rfl
  have M : (n : â„•âˆ) < n.succ := Nat.cast_lt.2 n.lt_succ_self
  have Cnonneg : 0 â‰¤ C := (norm_nonneg _).trans (hC 0 bot_le)
  have Dnonneg : 0 â‰¤ D := by
    have : 1 â‰¤ n + 1 := by simp only [le_add_iff_nonneg_left, zero_le']
    simpa only [pow_one] using (norm_nonneg _).trans (hD 1 le_rfl this)
  have I : âˆ€ i âˆˆ Finset.range (n + 1),
      â€–iteratedFDerivWithin ğ•œ i (fderivWithin ğ•œ g t âˆ˜ f) s xâ€– â‰¤ i ! * C * D ^ i := by
    intro i hi
    simp only [Finset.mem_range_succ_iff] at hi
    apply IH i hi
    Â· apply hg.fderivWithin ht
      simp only [Nat.cast_succ]
      exact add_le_add_right (Nat.cast_le.2 hi) _
    Â· apply hf.of_le (Nat.cast_le.2 (hi.trans n.le_succ))
    Â· intro j hj
      have : â€–iteratedFDerivWithin ğ•œ j (fderivWithin ğ•œ g t) t (f x)â€– =
          â€–iteratedFDerivWithin ğ•œ (j + 1) g t (f x)â€– := by
        rw [iteratedFDerivWithin_succ_eq_comp_right ht (hst hx), comp_apply,
          LinearIsometryEquiv.norm_map]
      rw [this]
      exact hC (j + 1) (add_le_add (hj.trans hi) le_rfl)
    Â· intro j hj h'j
      exact hD j hj (h'j.trans (hi.trans n.le_succ))
  have J : âˆ€ i, â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– â‰¤ D ^ (n - i + 1) := by
    intro i
    have : â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– =
        â€–iteratedFDerivWithin ğ•œ (n - i + 1) f s xâ€– := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply, LinearIsometryEquiv.norm_map]
    rw [this]
    apply hD
    Â· simp only [le_add_iff_nonneg_left, zero_le']
    Â· apply Nat.succ_le_succ tsub_le_self
  calc
    â€–iteratedFDerivWithin ğ•œ (n + 1) (g âˆ˜ f) s xâ€– =
        â€–iteratedFDerivWithin ğ•œ n (fun y : E => fderivWithin ğ•œ (g âˆ˜ f) s y) s xâ€– := by
      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply,
        LinearIsometryEquiv.norm_map]
    _ = â€–iteratedFDerivWithin ğ•œ n (fun y : E => ContinuousLinearMap.compL ğ•œ E Fu Gu
        (fderivWithin ğ•œ g t (f y)) (fderivWithin ğ•œ f s y)) s xâ€– := by
      have L : (1 : â„•âˆ) â‰¤ n.succ := by simpa only [ENat.coe_one, Nat.one_le_cast] using n.succ_pos
      congr 1
      refine iteratedFDerivWithin_congr (fun y hy => ?_) hx _
      apply fderivWithin.comp _ _ _ hst (hs y hy)
      Â· exact hg.differentiableOn L _ (hst hy)
      Â· exact hf.differentiableOn L _ hy
    _ â‰¤ âˆ‘ i âˆˆ Finset.range (n + 1),
        (n.choose i : â„) * â€–iteratedFDerivWithin ğ•œ i (fderivWithin ğ•œ g t âˆ˜ f) s xâ€– *
          â€–iteratedFDerivWithin ğ•œ (n - i) (fderivWithin ğ•œ f s) s xâ€– := by
      have A : ContDiffOn ğ•œ n (fderivWithin ğ•œ g t âˆ˜ f) s := by
        apply ContDiffOn.comp _ (hf.of_le M.le) hst
        apply hg.fderivWithin ht
        simp only [Nat.cast_succ, le_refl]
      have B : ContDiffOn ğ•œ n (fderivWithin ğ•œ f s) s := by
        apply hf.fderivWithin hs
        simp only [Nat.cast_succ, le_refl]
      exact (ContinuousLinearMap.compL ğ•œ E Fu Gu).norm_iteratedFDerivWithin_le_of_bilinear_of_le_one
        A B hs hx le_rfl (ContinuousLinearMap.norm_compL_le ğ•œ E Fu Gu)
    _ â‰¤ âˆ‘ i âˆˆ Finset.range (n + 1), (n.choose i : â„) * (i ! * C * D ^ i) * D ^ (n - i + 1) := by
      gcongr with i hi
      Â· exact I i hi
      Â· exact J i
    _ = âˆ‘ i âˆˆ Finset.range (n + 1),
        (n ! : â„) * ((i ! : â„)â»Â¹ * i !) * C * (D ^ i * D ^ (n - i + 1)) * ((n - i)! : â„)â»Â¹ := by
      congr! 1 with i hi
      simp only [Nat.cast_choose â„ (Finset.mem_range_succ_iff.1 hi), div_eq_inv_mul, mul_inv]
      ring
    _ = âˆ‘ i âˆˆ Finset.range (n + 1), (n ! : â„) * 1 * C * D ^ (n + 1) * ((n - i)! : â„)â»Â¹ := by
      congr! with i hi
      Â· apply inv_mul_cancel
        simpa only [Ne, Nat.cast_eq_zero] using i.factorial_ne_zero
      Â· rw [â† pow_add]
        congr 1
        rw [Nat.add_succ, Nat.succ_inj']
        exact Nat.add_sub_of_le (Finset.mem_range_succ_iff.1 hi)
    _ â‰¤ âˆ‘ i âˆˆ Finset.range (n + 1), (n ! : â„) * 1 * C * D ^ (n + 1) * 1 := by
      gcongr with i
      apply inv_le_one
      simpa only [Nat.one_le_cast] using (n - i).factorial_pos
    _ = (n + 1)! * C * D ^ (n + 1) := by
      simp only [mul_assoc, mul_one, Finset.sum_const, Finset.card_range, nsmul_eq_mul,
        Nat.factorial_succ, Nat.cast_mul]"
Mathlib/Data/Set/Basic.lean,Set.ite_subset_union,ite_subset_union,70dcc1355b9ce0a6754f8d809c95a171072d3aac,":=
  union_subset_union (inter_subset_left _ _) (diff_subset _ _)","error:  function expected at
  inter_subset_left ?m.135713
term has type
  ?m.135712 âˆˆ ?m.135710
error:  function expected at
  diff_subset ?m.135755
term has type
  ?m.135754 âˆˆ ?m.135752",theorem ite_subset_union (t s s' : Set Î±) : t.ite s s' âŠ† s âˆª s' ,":=
  union_subset_union inter_subset_left diff_subset"
Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean,TopCat.range_pullback_map,range_pullback_map,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  ext
  constructor
  Â· rintro âŸ¨y, rflâŸ©
    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range, â† comp_apply, limit.lift_Ï€,
      PullbackCone.mk_pt, PullbackCone.mk_Ï€_app]
    simp only [comp_apply, exists_apply_eq_apply, and_self]
  rintro âŸ¨âŸ¨xâ‚, hxâ‚âŸ©, âŸ¨xâ‚‚, hxâ‚‚âŸ©âŸ©
  have : fâ‚ xâ‚ = fâ‚‚ xâ‚‚ := by
    apply (TopCat.mono_iff_injective _).mp Hâ‚ƒ
    simp only [â† comp_apply, eqâ‚, eqâ‚‚]
    simp only [comp_apply, hxâ‚, hxâ‚‚]
    simp only [â† comp_apply, pullback.condition]
  use (pullbackIsoProdSubtype fâ‚ fâ‚‚).inv âŸ¨âŸ¨xâ‚, xâ‚‚âŸ©, thisâŸ©
  apply Concrete.limit_ext
  rintro (_ | _ | _) <;>
  simp only [â† comp_apply, Category.assoc, limit.lift_Ï€, PullbackCone.mk_Ï€_app_one]
  Â· simp only [cospan_one, pullbackIsoProdSubtype_inv_fst_assoc, comp_apply,
      pullbackFst_apply, hxâ‚]
    rw [â† limit.w _ WalkingCospan.Hom.inl, cospan_map_inl, comp_apply (g := gâ‚)]
  Â· simp [hxâ‚]
  Â· simp [hxâ‚‚]","error:  simp made no progress
error:  simp made no progress
error:  tactic 'apply' failed, failed to unify
  ?x = ?y
with
  (pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚) ((pullbackIsoProdSubtype fâ‚ fâ‚‚).inv âŸ¨(xâ‚, xâ‚‚), thisâŸ©) = xâœ
case h
J : Type v
instâœ : SmallCategory J
Xâœ Yâœ Zâœ : TopCat
W X Y Z S T : TopCat
fâ‚ : W âŸ¶ S
fâ‚‚ : X âŸ¶ S
gâ‚ : Y âŸ¶ T
gâ‚‚ : Z âŸ¶ T
iâ‚ : W âŸ¶ Y
iâ‚‚ : X âŸ¶ Z
iâ‚ƒ : S âŸ¶ T
Hâ‚ƒ : Mono iâ‚ƒ
eqâ‚ : fâ‚ â‰« iâ‚ƒ = iâ‚ â‰« gâ‚
eqâ‚‚ : fâ‚‚ â‰« iâ‚ƒ = iâ‚‚ â‰« gâ‚‚
xâœ : â†‘(pullback gâ‚ gâ‚‚)
xâ‚ : â†‘W
hxâ‚ : iâ‚ xâ‚ = pullback.fst xâœ
xâ‚‚ : â†‘X
hxâ‚‚ : iâ‚‚ xâ‚‚ = pullback.snd xâœ
this : fâ‚ xâ‚ = fâ‚‚ xâ‚‚
âŠ¢ (pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚) ((pullbackIsoProdSubtype fâ‚ fâ‚‚).inv âŸ¨(xâ‚, xâ‚‚), thisâŸ©) = xâœ","theorem range_pullback_map {W X Y Z S T : TopCat} (fâ‚ : W âŸ¶ S) (fâ‚‚ : X âŸ¶ S) (gâ‚ : Y âŸ¶ T)
    (gâ‚‚ : Z âŸ¶ T) (iâ‚ : W âŸ¶ Y) (iâ‚‚ : X âŸ¶ Z) (iâ‚ƒ : S âŸ¶ T) [Hâ‚ƒ : Mono iâ‚ƒ] (eqâ‚ : fâ‚ â‰« iâ‚ƒ = iâ‚ â‰« gâ‚)
    (eqâ‚‚ : fâ‚‚ â‰« iâ‚ƒ = iâ‚‚ â‰« gâ‚‚) :
    Set.range (pullback.map fâ‚ fâ‚‚ gâ‚ gâ‚‚ iâ‚ iâ‚‚ iâ‚ƒ eqâ‚ eqâ‚‚) =
      (pullback.fst : pullback gâ‚ gâ‚‚ âŸ¶ _) â»Â¹' Set.range iâ‚ âˆ©
        (pullback.snd : pullback gâ‚ gâ‚‚ âŸ¶ _) â»Â¹' Set.range iâ‚‚ ",":= by
  ext
  constructor
  Â· rintro âŸ¨y, rflâŸ©
    simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range]
    erw [â† comp_apply, â† comp_apply] 
    simp only [limit.lift_Ï€, PullbackCone.mk_pt, PullbackCone.mk_Ï€_app, comp_apply]
    exact âŸ¨exists_apply_eq_apply _ _, exists_apply_eq_apply _ _âŸ©
  rintro âŸ¨âŸ¨xâ‚, hxâ‚âŸ©, âŸ¨xâ‚‚, hxâ‚‚âŸ©âŸ©
  have : fâ‚ xâ‚ = fâ‚‚ xâ‚‚ := by
    apply (TopCat.mono_iff_injective _).mp Hâ‚ƒ
    erw [â† comp_apply, eqâ‚, â† comp_apply, eqâ‚‚, 
      comp_apply, comp_apply, hxâ‚, hxâ‚‚, â† comp_apply, pullback.condition]
    rfl 
  use (pullbackIsoProdSubtype fâ‚ fâ‚‚).inv âŸ¨âŸ¨xâ‚, xâ‚‚âŸ©, thisâŸ©
  change (forget TopCat).map _ _ = _
  apply Concrete.limit_ext
  rintro (_ | _ | _) <;>
  erw [â† comp_apply, â† comp_apply] 
  simp only [Category.assoc, limit.lift_Ï€, PullbackCone.mk_Ï€_app_one]
  Â· simp only [cospan_one, pullbackIsoProdSubtype_inv_fst_assoc, comp_apply]
    erw [pullbackFst_apply, hxâ‚]
    rw [â† limit.w _ WalkingCospan.Hom.inl, cospan_map_inl, comp_apply (g := gâ‚)]
    rfl 
  Â· simp only [cospan_left, limit.lift_Ï€, PullbackCone.mk_pt, PullbackCone.mk_Ï€_app,
      pullbackIsoProdSubtype_inv_fst_assoc, comp_apply]
    erw [hxâ‚] 
    rfl 
  Â· simp only [cospan_right, limit.lift_Ï€, PullbackCone.mk_pt, PullbackCone.mk_Ï€_app,
      pullbackIsoProdSubtype_inv_snd_assoc, comp_apply]
    erw [hxâ‚‚] 
    rfl "
Mathlib/Analysis/ODE/PicardLindelof.lean,PicardLindelof.FunSpace.dist_iterate_next_apply_le,dist_iterate_next_apply_le,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' n with n ihn generalizing t
  Â· rw [Nat.zero_eq, pow_zero, Nat.factorial_zero, Nat.cast_one, div_one, one_mul]
    exact dist_apply_le_dist fâ‚ fâ‚‚ t
  Â· rw [iterate_succ_apply', iterate_succ_apply']
    exact dist_next_apply_le_of_le ihn _","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
case zero
E : Type u_1
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
v : PicardLindelof E
f : v.FunSpace
instâœ : CompleteSpace E
fâ‚ fâ‚‚ : v.FunSpace
t : â†‘(Icc v.tMin v.tMax)
âŠ¢ dist ((next^[0] fâ‚).toFun t) ((next^[0] fâ‚‚).toFun t) â‰¤ (â†‘v.L * |â†‘t - â†‘v.tâ‚€|) ^ 0 / â†‘0! * dist fâ‚ fâ‚‚","theorem dist_iterate_next_apply_le (fâ‚ fâ‚‚ : FunSpace v) (n : â„•) (t : Icc v.tMin v.tMax) :
    dist (next^[n] fâ‚ t) (next^[n] fâ‚‚ t) â‰¤ (v.L * |t.1 - v.tâ‚€|) ^ n / n ! * dist fâ‚ fâ‚‚ ",":= by
  induction' n with n ihn generalizing t
  Â· rw [pow_zero, Nat.factorial_zero, Nat.cast_one, div_one, one_mul]
    exact dist_apply_le_dist fâ‚ fâ‚‚ t
  Â· rw [iterate_succ_apply', iterate_succ_apply']
    exact dist_next_apply_le_of_le ihn _"
Mathlib/Probability/Kernel/Disintegration/Density.lean,ProbabilityTheory.kernel.densityProcess_mono_set,densityProcess_mono_set,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  unfold densityProcess
  by_cases h0 : Î½ a (countablePartitionSet n x) = 0
  Â· rw [h0, ENNReal.toReal_div, ENNReal.toReal_div]
    simp
  have h_ne_top : âˆ€ s,
      Îº a (countablePartitionSet n x Ã—Ë¢ s) / Î½ a (countablePartitionSet n x) â‰  âŠ¤ := by
    intro s
    rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    refine fun h_top â†¦ eq_top_mono ?_ h_top
    exact meas_countablePartitionSet_le_of_fst_le hÎºÎ½ n a x s
  rw [ENNReal.toReal_le_toReal (h_ne_top s) (h_ne_top s')]
  gcongr
  simp [prod_subset_prod_iff, subset_rfl, h]",error:  no goals to be solved,"lemma densityProcess_mono_set (hÎºÎ½ : fst Îº â‰¤ Î½) (n : â„•) (a : Î±) (x : Î³)
    {s s' : Set Î²} (h : s âŠ† s') :
    densityProcess Îº Î½ n a x s â‰¤ densityProcess Îº Î½ n a x s' ",":= by
  unfold densityProcess
  by_cases h0 : Î½ a (countablePartitionSet n x) = 0
  Â· rw [h0, ENNReal.toReal_div, ENNReal.toReal_div]
    simp
  have h_ne_top : âˆ€ s,
      Îº a (countablePartitionSet n x Ã—Ë¢ s) / Î½ a (countablePartitionSet n x) â‰  âŠ¤ := by
    intro s
    rw [ne_eq, ENNReal.div_eq_top]
    simp only [ne_eq, h0, and_false, false_or, not_and, not_not]
    refine fun h_top â†¦ eq_top_mono ?_ h_top
    exact meas_countablePartitionSet_le_of_fst_le hÎºÎ½ n a x s
  rw [ENNReal.toReal_le_toReal (h_ne_top s) (h_ne_top s')]
  gcongr"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.TauPackage.color_lt,color_lt,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  induction' i using Ordinal.induction with i IH
  let A : Set â„• :=
    â‹ƒ (j : { j // j < i })
      (_ : (closedBall (p.c (p.index j)) (p.r (p.index j)) âˆ©
        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty),
      {p.color j}
  have color_i : p.color i = sInf (univ \ A) := by rw [color]
  rw [color_i]
  have N_mem : N âˆˆ univ \ A := by
    simp only [not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff, mem_closedBall,
      not_and, mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]
    intro j ji _
    exact (IH j ji (ji.trans hi)).ne'
  suffices sInf (univ \ A) â‰  N by
    rcases (csInf_le (OrderBot.bddBelow (univ \ A)) N_mem).lt_or_eq with (H | H)
    Â· exact H
    Â· exact (this H).elim
  intro Inf_eq_N
  have :
    âˆ€ k, k < N â†’ âˆƒ j, j < i âˆ§
      (closedBall (p.c (p.index j)) (p.r (p.index j)) âˆ©
        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty âˆ§ k = p.color j := by
    intro k hk
    rw [â† Inf_eq_N] at hk
    have : k âˆˆ A := by
      simpa only [true_and_iff, mem_univ, Classical.not_not, mem_diff] using
        Nat.not_mem_of_lt_sInf hk
    simp only [mem_iUnion, mem_singleton_iff, exists_prop, Subtype.exists, exists_and_right,
      and_assoc] at this
    simpa only [exists_prop, mem_iUnion, mem_singleton_iff, mem_closedBall, Subtype.exists,
      Subtype.coe_mk]
  choose! g hg using this
  let G : â„• â†’ Ordinal := fun n => if n = N then i else g n
  have color_G : âˆ€ n, n â‰¤ N â†’ p.color (G n) = n := by
    intro n hn
    rcases hn.eq_or_lt with (rfl | H)
    Â· simp only; simp only [color_i, Inf_eq_N, if_true, eq_self_iff_true]
    Â· simp only; simp only [H.ne, (hg n H).right.right.symm, if_false]
  have G_lt_last : âˆ€ n, n â‰¤ N â†’ G n < p.lastStep := by
    intro n hn
    rcases hn.eq_or_lt with (rfl | H)
    Â· simp only; simp only [hi, if_true, eq_self_iff_true]
    Â· simp only; simp only [H.ne, (hg n H).left.trans hi, if_false]
  have fGn :
      âˆ€ n, n â‰¤ N â†’
        p.c (p.index (G n)) âˆ‰ p.iUnionUpTo (G n) âˆ§ p.R (G n) â‰¤ p.Ï„ * p.r (p.index (G n)) := by
    intro n hn
    have :
      p.index (G n) =
        Classical.epsilon fun t => p.c t âˆ‰ p.iUnionUpTo (G n) âˆ§ p.R (G n) â‰¤ p.Ï„ * p.r t :=
      by rw [index]; rfl
    rw [this]
    have : âˆƒ t, p.c t âˆ‰ p.iUnionUpTo (G n) âˆ§ p.R (G n) â‰¤ p.Ï„ * p.r t := by
      simpa only [not_exists, exists_prop, not_and, not_lt, not_le, mem_setOf_eq, not_forall] using
        not_mem_of_lt_csInf (G_lt_last n hn) (OrderBot.bddBelow _)
    exact Classical.epsilon_spec this
  have Gab :
    âˆ€ a b : Fin (Nat.succ N),
      G a < G b â†’
        p.r (p.index (G a)) â‰¤ dist (p.c (p.index (G a))) (p.c (p.index (G b))) âˆ§
          p.r (p.index (G b)) â‰¤ p.Ï„ * p.r (p.index (G a)) := by
    intro a b G_lt
    have ha : (a : â„•) â‰¤ N := Nat.lt_succ_iff.1 a.2
    have hb : (b : â„•) â‰¤ N := Nat.lt_succ_iff.1 b.2
    constructor
    Â· have := (fGn b hb).1
      simp only [iUnionUpTo, not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_le,
        Subtype.exists, Subtype.coe_mk] at this
      simpa only [dist_comm, mem_ball, not_lt] using this (G a) G_lt
    Â· apply le_trans _ (fGn a ha).2
      have B : p.c (p.index (G b)) âˆ‰ p.iUnionUpTo (G a) := by
        intro H; exact (fGn b hb).1 (p.monotone_iUnionUpTo G_lt.le H)
      let b' : { t // p.c t âˆ‰ p.iUnionUpTo (G a) } := âŸ¨p.index (G b), BâŸ©
      apply @le_ciSup _ _ _ (fun t : { t // p.c t âˆ‰ p.iUnionUpTo (G a) } => p.r t) _ b'
      refine' âŸ¨p.r_bound, fun t ht => _âŸ©
      simp only [exists_prop, mem_range, Subtype.exists, Subtype.coe_mk] at ht
      rcases ht with âŸ¨u, huâŸ©
      rw [â† hu.2]
      exact p.r_le _
  let sc : SatelliteConfig Î± N p.Ï„ :=
    { c := fun k => p.c (p.index (G k))
      r := fun k => p.r (p.index (G k))
      rpos := fun k => p.rpos (p.index (G k))
      h := by
        intro a b a_ne_b
        wlog G_le : G a â‰¤ G b generalizing a b
        Â· exact (this a_ne_b.symm (le_of_not_le G_le)).symm
        have G_lt : G a < G b := by
          rcases G_le.lt_or_eq with (H | H); Â· exact H
          have A : (a : â„•) â‰  b := Fin.val_injective.ne a_ne_b
          rw [â† color_G a (Nat.lt_succ_iff.1 a.2), â† color_G b (Nat.lt_succ_iff.1 b.2), H] at A
          exact (A rfl).elim
        exact Or.inl (Gab a b G_lt)
      hlast := by
        intro a ha
        have I : (a : â„•) < N := ha
        have : G a < G (Fin.last N) := by dsimp; simp [I.ne, (hg a I).1]
        exact Gab _ _ this
      inter := by
        intro a ha
        have I : (a : â„•) < N := ha
        have J : G (Fin.last N) = i := by dsimp; simp only [if_true, eq_self_iff_true]
        have K : G a = g a := by dsimp; simp [I.ne, (hg a I).1]
        convert dist_le_add_of_nonempty_closedBall_inter_closedBall (hg _ I).2.1 }
  exact hN.false sc","error:  tactic 'introN' failed, insufficient number of binders
Î± : Type u_1
instâœÂ¹ : MetricSpace Î±
Î² : Type u
instâœ : Nonempty Î²
p : TauPackage Î² Î±
N : â„•
hN : IsEmpty (SatelliteConfig Î± N p.Ï„)
i : Ordinal.{u}
IH : âˆ€ k < i, k < p.lastStep â†’ p.color k < N
hi : i < p.lastStep
A : Set â„• :=
  â‹ƒ j,
    â‹ƒ (_ :
      (closedBall (p.c (p.index â†‘j)) (p.r (p.index â†‘j)) âˆ© closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty),
      {p.color â†‘j}
color_i : p.color i = sInf (univ \ A)
j : N âˆˆ A
âŠ¢ False
error:  tactic 'assumption' failed
Î± : Type u_1
instâœÂ¹ : MetricSpace Î±
Î² : Type u
instâœ : Nonempty Î²
p : TauPackage Î² Î±
N : â„•
hN : IsEmpty (SatelliteConfig Î± N p.Ï„)
i : Ordinal.{u}
IH : âˆ€ k < i, k < p.lastStep â†’ p.color k < N
hi : i < p.lastStep
A : Set â„• :=
  â‹ƒ j,
    â‹ƒ (_ :
      (closedBall (p.c (p.index â†‘j)) (p.r (p.index â†‘j)) âˆ© closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty),
      {p.color â†‘j}
color_i : p.color i = sInf (univ \ A)
N_mem : N âˆˆ univ \ A
Inf_eq_N : sInf (univ \ A) = N
k : â„•
hk : k < sInf (univ \ A)
this : k âˆˆ A
âŠ¢ âˆƒ j < i,
    (closedBall (p.c (p.index j)) (p.r (p.index j)) âˆ© closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty âˆ§
      k = p.color j
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress","theorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : â„•}
    (hN : IsEmpty (SatelliteConfig Î± N p.Ï„)) : p.color i < N ",":= by
  induction' i using Ordinal.induction with i IH
  let A : Set â„• :=
    â‹ƒ (j : { j // j < i })
      (_ : (closedBall (p.c (p.index j)) (p.r (p.index j)) âˆ©
        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty),
      {p.color j}
  have color_i : p.color i = sInf (univ \ A) := by rw [color]
  rw [color_i]
  have N_mem : N âˆˆ univ \ A := by
    simp only [A, not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff,
      mem_closedBall, not_and, mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]
    intro j ji _
    exact (IH j ji (ji.trans hi)).ne'
  suffices sInf (univ \ A) â‰  N by
    rcases (csInf_le (OrderBot.bddBelow (univ \ A)) N_mem).lt_or_eq with (H | H)
    Â· exact H
    Â· exact (this H).elim
  intro Inf_eq_N
  have :
    âˆ€ k, k < N â†’ âˆƒ j, j < i âˆ§
      (closedBall (p.c (p.index j)) (p.r (p.index j)) âˆ©
        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty âˆ§ k = p.color j := by
    intro k hk
    rw [â† Inf_eq_N] at hk
    have : k âˆˆ A := by
      simpa only [true_and_iff, mem_univ, Classical.not_not, mem_diff] using
        Nat.not_mem_of_lt_sInf hk
    simp only [mem_iUnion, mem_singleton_iff, exists_prop, Subtype.exists, exists_and_right,
      and_assoc] at this
    simpa only [A, exists_prop, mem_iUnion, mem_singleton_iff, mem_closedBall, Subtype.exists,
      Subtype.coe_mk]
  choose! g hg using this
  let G : â„• â†’ Ordinal := fun n => if n = N then i else g n
  have color_G : âˆ€ n, n â‰¤ N â†’ p.color (G n) = n := by
    intro n hn
    rcases hn.eq_or_lt with (rfl | H)
    Â· simp only [G]; simp only [color_i, Inf_eq_N, if_true, eq_self_iff_true]
    Â· simp only [G]; simp only [H.ne, (hg n H).right.right.symm, if_false]
  have G_lt_last : âˆ€ n, n â‰¤ N â†’ G n < p.lastStep := by
    intro n hn
    rcases hn.eq_or_lt with (rfl | H)
    Â· simp only [G]; simp only [hi, if_true, eq_self_iff_true]
    Â· simp only [G]; simp only [H.ne, (hg n H).left.trans hi, if_false]
  have fGn :
      âˆ€ n, n â‰¤ N â†’
        p.c (p.index (G n)) âˆ‰ p.iUnionUpTo (G n) âˆ§ p.R (G n) â‰¤ p.Ï„ * p.r (p.index (G n)) := by
    intro n hn
    have :
      p.index (G n) =
        Classical.epsilon fun t => p.c t âˆ‰ p.iUnionUpTo (G n) âˆ§ p.R (G n) â‰¤ p.Ï„ * p.r t := by
      rw [index]; rfl
    rw [this]
    have : âˆƒ t, p.c t âˆ‰ p.iUnionUpTo (G n) âˆ§ p.R (G n) â‰¤ p.Ï„ * p.r t := by
      simpa only [not_exists, exists_prop, not_and, not_lt, not_le, mem_setOf_eq, not_forall] using
        not_mem_of_lt_csInf (G_lt_last n hn) (OrderBot.bddBelow _)
    exact Classical.epsilon_spec this
  have Gab :
    âˆ€ a b : Fin (Nat.succ N),
      G a < G b â†’
        p.r (p.index (G a)) â‰¤ dist (p.c (p.index (G a))) (p.c (p.index (G b))) âˆ§
          p.r (p.index (G b)) â‰¤ p.Ï„ * p.r (p.index (G a)) := by
    intro a b G_lt
    have ha : (a : â„•) â‰¤ N := Nat.lt_succ_iff.1 a.2
    have hb : (b : â„•) â‰¤ N := Nat.lt_succ_iff.1 b.2
    constructor
    Â· have := (fGn b hb).1
      simp only [iUnionUpTo, not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_le,
        Subtype.exists, Subtype.coe_mk] at this
      simpa only [dist_comm, mem_ball, not_lt] using this (G a) G_lt
    Â· apply le_trans _ (fGn a ha).2
      have B : p.c (p.index (G b)) âˆ‰ p.iUnionUpTo (G a) := by
        intro H; exact (fGn b hb).1 (p.monotone_iUnionUpTo G_lt.le H)
      let b' : { t // p.c t âˆ‰ p.iUnionUpTo (G a) } := âŸ¨p.index (G b), BâŸ©
      apply @le_ciSup _ _ _ (fun t : { t // p.c t âˆ‰ p.iUnionUpTo (G a) } => p.r t) _ b'
      refine âŸ¨p.r_bound, fun t ht => ?_âŸ©
      simp only [exists_prop, mem_range, Subtype.exists, Subtype.coe_mk] at ht
      rcases ht with âŸ¨u, huâŸ©
      rw [â† hu.2]
      exact p.r_le _
  let sc : SatelliteConfig Î± N p.Ï„ :=
    { c := fun k => p.c (p.index (G k))
      r := fun k => p.r (p.index (G k))
      rpos := fun k => p.rpos (p.index (G k))
      h := by
        intro a b a_ne_b
        wlog G_le : G a â‰¤ G b generalizing a b
        Â· exact (this a_ne_b.symm (le_of_not_le G_le)).symm
        have G_lt : G a < G b := by
          rcases G_le.lt_or_eq with (H | H); Â· exact H
          have A : (a : â„•) â‰  b := Fin.val_injective.ne a_ne_b
          rw [â† color_G a (Nat.lt_succ_iff.1 a.2), â† color_G b (Nat.lt_succ_iff.1 b.2), H] at A
          exact (A rfl).elim
        exact Or.inl (Gab a b G_lt)
      hlast := by
        intro a ha
        have I : (a : â„•) < N := ha
        have : G a < G (Fin.last N) := by dsimp; simp [G, I.ne, (hg a I).1]
        exact Gab _ _ this
      inter := by
        intro a ha
        have I : (a : â„•) < N := ha
        have J : G (Fin.last N) = i := by dsimp; simp only [G, if_true, eq_self_iff_true]
        have K : G a = g a := by dsimp [G]; simp [I.ne, (hg a I).1]
        convert dist_le_add_of_nonempty_closedBall_inter_closedBall (hg _ I).2.1 }
  exact hN.false sc"
Mathlib/GroupTheory/PGroup.lean,IsPGroup.of_bot,of_bot,8c7e2497d6b5ded2cb20ad30538ebffa5560f7a2,":=
  of_card (Subgroup.nat_card_bot.trans (pow_zero p).symm)",error:  unknown constant 'Subgroup.nat_card_bot.trans',theorem of_bot : IsPGroup p (âŠ¥ : Subgroup G) ,":=
  of_card (by rw [â† Nat.card_eq_fintype_card, Subgroup.card_bot, pow_zero])"
Mathlib/MeasureTheory/MeasurableSpace/Basic.lean,MeasurableSet.measurableAtom_of_countable,MeasurableSet.measurableAtom_of_countable,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have : âˆ€ (y : Î²), y âˆ‰ measurableAtom x â†’ âˆƒ s, MeasurableSet s âˆ§ x âˆˆ s âˆ§ y âˆ‰ s :=
    fun y hy â†¦ by simpa [measurableAtom] using hy
  choose! s hs using this
  have : measurableAtom x = â‹‚ (y âˆˆ (measurableAtom x)á¶œ), s y := by
    apply Subset.antisymm
    Â· intro z hz
      simp only [mem_iInter, mem_compl_iff]
      intro i hi
      show z âˆˆ s i
      exact mem_of_mem_measurableAtom hz (hs i hi).1 (hs i hi).2.1
    Â· apply compl_subset_compl.1
      intro z hz
      simp only [compl_iInter, mem_iUnion, mem_compl_iff, exists_prop]
      exact âŸ¨z, hz, (hs z hz).2.2âŸ©
  rw [this]
  exact MeasurableSet.biInter (to_countable (measurableAtom x)á¶œ) (fun i hi â†¦ (hs i hi).1)","error:  type mismatch
  hâœ
has type
  âˆƒ x_1, x âˆˆ x_1 âˆ§ MeasurableSet x_1 âˆ§ y âˆ‰ x_1 : Prop
but is expected to have type
  âˆƒ s, MeasurableSet s âˆ§ x âˆˆ s âˆ§ y âˆ‰ s : Prop","lemma MeasurableSet.measurableAtom_of_countable [Countable Î²] (x : Î²) :
    MeasurableSet (measurableAtom x) ",":= by
  have : âˆ€ (y : Î²), y âˆ‰ measurableAtom x â†’ âˆƒ s, x âˆˆ s âˆ§ MeasurableSet s âˆ§ y âˆ‰ s :=
    fun y hy â†¦ by simpa [measurableAtom] using hy
  choose! s hs using this
  have : measurableAtom x = â‹‚ (y âˆˆ (measurableAtom x)á¶œ), s y := by
    apply Subset.antisymm
    Â· intro z hz
      simp only [mem_iInter, mem_compl_iff]
      intro i hi
      show z âˆˆ s i
      exact mem_of_mem_measurableAtom hz (hs i hi).2.1 (hs i hi).1
    Â· apply compl_subset_compl.1
      intro z hz
      simp only [compl_iInter, mem_iUnion, mem_compl_iff, exists_prop]
      exact âŸ¨z, hz, (hs z hz).2.2âŸ©
  rw [this]
  exact MeasurableSet.biInter (to_countable (measurableAtom x)á¶œ) (fun i hi â†¦ (hs i hi).2.1)"
Mathlib/RingTheory/Polynomial/Pochhammer.lean,ascPochhammer_natDegree,ascPochhammer_natDegree,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' n with n hn
  Â· simp
  Â· have : natDegree (X + (n : S[X])) = 1 := natDegree_X_add_C (n : S)
    rw [ascPochhammer_succ_right,
        natDegree_mul _ (ne_zero_of_natDegree_gt <| this.symm â–¸ Nat.zero_lt_one), hn, this]
    cases n
    Â· simp
    Â· refine' ne_zero_of_natDegree_gt <| hn.symm â–¸ Nat.succ_pos _","error:  invalid `â–¸` notation, the equality
  Eq.symm hn
has type 
  nâœ + 1 = (ascPochhammer S (nâœ + 1)).natDegree
but neither side of the equality is mentioned in the type
  0 < ?m.29969.succ
error:  unsolved goals
case succ
S : Type u
instâœÂ² : Semiring S
instâœÂ¹ : NoZeroDivisors S
instâœ : Nontrivial S
nâœ : â„•
hn : (ascPochhammer S (nâœ + 1)).natDegree = nâœ + 1
this : (X + â†‘(nâœ + 1)).natDegree = 1
âŠ¢ â„•","theorem ascPochhammer_natDegree (n : â„•) [NoZeroDivisors S] [Nontrivial S] :
    (ascPochhammer S n).natDegree = n ",":= by
  induction' n with n hn
  Â· simp
  Â· have : natDegree (X + (n : S[X])) = 1 := natDegree_X_add_C (n : S)
    rw [ascPochhammer_succ_right,
        natDegree_mul _ (ne_zero_of_natDegree_gt <| this.symm â–¸ Nat.zero_lt_one), hn, this]
    cases n
    Â· simp
    Â· refine ne_zero_of_natDegree_gt <| hn.symm â–¸ Nat.add_one_pos _"
Mathlib/Topology/ShrinkingLemma.lean,ShrinkingLemma.PartialRefinement.exists_gt,exists_gt,92f5c622103f0c81143145b8c00c1b88256de70e,":= by
  have I : (s âˆ© â‹‚ (j) (_hj : j â‰  i), v já¶œ) âŠ† v i := by
    simp only [subset_def, mem_inter_iff, mem_iInter, and_imp]
    intro x hxs H
    rcases mem_iUnion.1 (v.subset_iUnion hxs) with âŸ¨j, hjâŸ©
    exact (em (j = i)).elim (fun h => h â–¸ hj) fun h => (H j h hj).elim
  have C : IsClosed (s âˆ© â‹‚ (j) (_hj : j â‰  i), v já¶œ) :=
    IsClosed.inter hs (isClosed_biInter fun _ _ => isClosed_compl_iff.2 <| v.isOpen _)
  rcases normal_exists_closure_subset C (v.isOpen i) I with âŸ¨vi, ovi, hvi, cviâŸ©
  refine' âŸ¨âŸ¨update v i vi, insert i v.carrier, _, _, _, _âŸ©, _, _âŸ©
  Â· intro j
    rcases eq_or_ne j i with (rfl| hne) <;> simp [*, v.isOpen]
  Â· refine' fun x hx => mem_iUnion.2 _
    rcases em (âˆƒ (j : _)(_ : j â‰  i), x âˆˆ v j) with (âŸ¨j, hji, hjâŸ© | h)
    Â· use j
      rwa [update_noteq hji]
    Â· push_neg  at h
      use i
      rw [update_same]
      exact hvi âŸ¨hx, mem_biInter hâŸ©
  Â· rintro j (rfl | hj)
    Â· rwa [update_same, â† v.apply_eq hi]
    Â· rw [update_noteq (ne_of_mem_of_not_mem hj hi)]
      exact v.closure_subset hj
  Â· intro j hj
    rw [mem_insert_iff, not_or] at hj
    rw [update_noteq hj.1, v.apply_eq hj.2]
  Â· refine' âŸ¨subset_insert _ _, fun j hj => _âŸ©
    exact (update_noteq (ne_of_mem_of_not_mem hj hi) _ _).symm
  Â· exact fun hle => hi (hle.1 <| mem_insert _ _)","error:  failed to synthesize
  HasCompl Î¹
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  HasCompl Î¹
use `set_option diagnostics true` to get diagnostic information","theorem exists_gt (v : PartialRefinement u s) (hs : IsClosed s) (i : Î¹) (hi : i âˆ‰ v.carrier) :
    âˆƒ v' : PartialRefinement u s, v < v' ",":= by
  have I : (s âˆ© â‹‚ (j) (_ : j â‰  i), (v j)á¶œ) âŠ† v i := by
    simp only [subset_def, mem_inter_iff, mem_iInter, and_imp]
    intro x hxs H
    rcases mem_iUnion.1 (v.subset_iUnion hxs) with âŸ¨j, hjâŸ©
    exact (em (j = i)).elim (fun h => h â–¸ hj) fun h => (H j h hj).elim
  have C : IsClosed (s âˆ© â‹‚ (j) (_ : j â‰  i), (v j)á¶œ) :=
    IsClosed.inter hs (isClosed_biInter fun _ _ => isClosed_compl_iff.2 <| v.isOpen _)
  rcases normal_exists_closure_subset C (v.isOpen i) I with âŸ¨vi, ovi, hvi, cviâŸ©
  refine âŸ¨âŸ¨update v i vi, insert i v.carrier, ?_, ?_, ?_, ?_âŸ©, ?_, ?_âŸ©
  Â· intro j
    rcases eq_or_ne j i with (rfl| hne) <;> simp [*, v.isOpen]
  Â· refine fun x hx => mem_iUnion.2 ?_
    rcases em (âˆƒ j â‰  i, x âˆˆ v j) with (âŸ¨j, hji, hjâŸ© | h)
    Â· use j
      rwa [update_noteq hji]
    Â· push_neg at h
      use i
      rw [update_same]
      exact hvi âŸ¨hx, mem_biInter hâŸ©
  Â· rintro j (rfl | hj)
    Â· rwa [update_same, â† v.apply_eq hi]
    Â· rw [update_noteq (ne_of_mem_of_not_mem hj hi)]
      exact v.closure_subset hj
  Â· intro j hj
    rw [mem_insert_iff, not_or] at hj
    rw [update_noteq hj.1, v.apply_eq hj.2]
  Â· refine âŸ¨subset_insert _ _, fun j hj => ?_âŸ©
    exact (update_noteq (ne_of_mem_of_not_mem hj hi) _ _).symm
  Â· exact fun hle => hi (hle.1 <| mem_insert _ _)"
Mathlib/Data/Fintype/Card.lean,Fintype.card_pos,card_pos,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  pos_iff_ne_zero.trans <| not_iff_comm.mp <| not_nonempty_iff.trans card_eq_zero_iff.symm","error:  type mismatch
  Iff.trans pos_iff_ne_zero (not_iff_comm.mp (Iff.trans not_nonempty_iff ?m.19372))
has type
  @OfNat.ofNat â„• 0 Zero.toOfNat0 < ?m.19257 â†” Nonempty ?m.19301 : Prop
but is expected to have type
  @OfNat.ofNat â„• 0 (instOfNatNat 0) < card Î± â†” Nonempty Î± : Prop",theorem card_pos_iff : 0 < card Î± â†” Nonempty Î± ,":=
  Nat.pos_iff_ne_zero.trans <| not_iff_comm.mp <| not_nonempty_iff.trans card_eq_zero_iff.symm"
Mathlib/RingTheory/DedekindDomain/Ideal.lean,exists_multiset_prod_cons_le_and_prod_not_le,exists_multiset_prod_cons_le_and_prod_not_le,c3ab0e431ee2be2cbb5176e1e0c1ef11b3cd98cc,":= by
  obtain âŸ¨Zâ‚€, hZâ‚€âŸ© := PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain hNF hI0
  obtain âŸ¨Z, âŸ¨hZI, hprodZâŸ©, h_eraseZâŸ© :=
    Multiset.wellFounded_lt.has_min
      (fun Z => (Z.map PrimeSpectrum.asIdeal).prod â‰¤ I âˆ§ (Z.map PrimeSpectrum.asIdeal).prod â‰  âŠ¥)
      âŸ¨Zâ‚€, hZâ‚€âŸ©
  have hZM : Multiset.prod (Z.map PrimeSpectrum.asIdeal) â‰¤ M := le_trans hZI hIM
  have hZ0 : Z â‰  0 := by rintro rfl; simp [hM.ne_top] at hZM
  obtain âŸ¨_, hPZ', hPMâŸ© := (hM.isPrime.multiset_prod_le (mt Multiset.map_eq_zero.mp hZ0)).mp hZM
  obtain âŸ¨P, hPZ, rflâŸ© := Multiset.mem_map.mp hPZ'
  classical
    have := Multiset.map_erase PrimeSpectrum.asIdeal PrimeSpectrum.ext P Z
    obtain âŸ¨hP0, hZP0âŸ© : P.asIdeal â‰  âŠ¥ âˆ§ ((Z.erase P).map PrimeSpectrum.asIdeal).prod â‰  âŠ¥ := by
      rwa [Ne.def, â† Multiset.cons_erase hPZ', Multiset.prod_cons, Ideal.mul_eq_bot, not_or, â†
        this] at hprodZ
    have hPM' := (P.IsPrime.isMaximal hP0).eq_of_le hM.ne_top hPM
    subst hPM'
    refine âŸ¨Z.erase P, ?_, ?_âŸ©
    Â· convert hZI
      rw [this, Multiset.cons_erase hPZ']
    Â· refine fun h => h_eraseZ (Z.erase P) âŸ¨h, ?_âŸ© (Multiset.erase_lt.mpr hPZ)
      exact hZP0","error:  unknown constant 'Multiset.wellFounded_lt.has_min'
error:  rcases tactic failed: xâœ : ?m.159565 is not an inductive datatype","theorem exists_multiset_prod_cons_le_and_prod_not_le [IsDedekindDomain A] (hNF : Â¬IsField A)
    {I M : Ideal A} (hI0 : I â‰  âŠ¥) (hIM : I â‰¤ M) [hM : M.IsMaximal] :
    âˆƒ Z : Multiset (PrimeSpectrum A),
      (M ::â‚˜ Z.map PrimeSpectrum.asIdeal).prod â‰¤ I âˆ§
        Â¬Multiset.prod (Z.map PrimeSpectrum.asIdeal) â‰¤ I ",":= by
  obtain âŸ¨Zâ‚€, hZâ‚€âŸ© := PrimeSpectrum.exists_primeSpectrum_prod_le_and_ne_bot_of_domain hNF hI0
  obtain âŸ¨Z, âŸ¨hZI, hprodZâŸ©, h_eraseZâŸ© :=
    wellFounded_lt.has_min
      {Z | (Z.map PrimeSpectrum.asIdeal).prod â‰¤ I âˆ§ (Z.map PrimeSpectrum.asIdeal).prod â‰  âŠ¥}
      âŸ¨Zâ‚€, hZâ‚€.1, hZâ‚€.2âŸ©
  obtain âŸ¨_, hPZ', hPMâŸ© := hM.isPrime.multiset_prod_le.mp (hZI.trans hIM)
  obtain âŸ¨P, hPZ, rflâŸ© := Multiset.mem_map.mp hPZ'
  classical
    have := Multiset.map_erase PrimeSpectrum.asIdeal PrimeSpectrum.ext P Z
    obtain âŸ¨hP0, hZP0âŸ© : P.asIdeal â‰  âŠ¥ âˆ§ ((Z.erase P).map PrimeSpectrum.asIdeal).prod â‰  âŠ¥ := by
      rwa [Ne, â† Multiset.cons_erase hPZ', Multiset.prod_cons, Ideal.mul_eq_bot, not_or, â†
        this] at hprodZ
    have hPM' := (P.isPrime.isMaximal hP0).eq_of_le hM.ne_top hPM
    subst hPM'
    refine âŸ¨Z.erase P, ?_, ?_âŸ©
    Â· convert hZI
      rw [this, Multiset.cons_erase hPZ']
    Â· refine fun h => h_eraseZ (Z.erase P) âŸ¨h, ?_âŸ© (Multiset.erase_lt.mpr hPZ)
      exact hZP0"
Mathlib/Data/Set/NAry.lean,Set.image2_inter_union_subset,image2_inter_union_subset,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [image2_union_right]
  exact
    union_subset_union (image2_subset_right <| inter_subset_left _ _)
      (image2_subset_right <| inter_subset_right _ _)","error:  function expected at
  inter_subset_left ?m.46380
term has type
  ?m.46379 âˆˆ ?m.46377
error:  function expected at
  inter_subset_right ?m.46436
term has type
  ?m.46435 âˆˆ ?m.46434","theorem image2_inter_union_subset_union :
    image2 f (s âˆ© s') (t âˆª t') âŠ† image2 f s t âˆª image2 f s' t' ",":= by
  rw [image2_union_right]
  exact
    union_subset_union (image2_subset_right inter_subset_left)
      (image2_subset_right inter_subset_right)"
Mathlib/Combinatorics/HalesJewett.lean,Combinatorics.Line.exists_mono_in_high_dimension,exists_mono_in_high_dimension,2d8928f07c222f171d2f9371935aa5b8359f9d44,":=
  Finite.induction_empty_option
  (
  fun {Î± Î±'} e =>
    forall_imp fun Îº =>
      forall_imp fun _ =>
        Exists.imp fun Î¹ =>
          Exists.imp fun _ h C =>
            let âŸ¨l, c, lcâŸ© := h fun v => C (e âˆ˜ v)
            âŸ¨l.map e, c, e.forall_congr_left.mp fun x => by rw [â† lc x, Line.map_apply]âŸ©)
  (by
    intro Îº _
    by_cases h : Nonempty Îº
    Â· refine' âŸ¨Unit, inferInstance, fun C => âŸ¨default, Classical.arbitrary _, PEmpty.recâŸ©âŸ©
    Â· exact âŸ¨Empty, inferInstance, fun C => (h âŸ¨C (Empty.rec)âŸ©).elimâŸ©)
  (by
    intro Î± _ ihÎ± Îº _
    cases nonempty_fintype Îº
    by_cases h : Nonempty Î±
    case neg =>
      refine âŸ¨Unit, inferInstance, fun C => âŸ¨diagonal _ Unit, C fun _ => none, ?_âŸ©âŸ©
      rintro (_ | âŸ¨aâŸ©)
      Â· rfl
      Â· exact (h âŸ¨aâŸ©).elim
    suffices key :
      âˆ€ r : â„•,
        âˆƒ (Î¹ : Type) (_ : Fintype Î¹),
          âˆ€ C : (Î¹ â†’ Option Î±) â†’ Îº,
            (âˆƒ s : ColorFocused C, Multiset.card s.lines = r) âˆ¨ âˆƒ l, IsMono C l by
      obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := key (Fintype.card Îº + 1)
      refine' âŸ¨Î¹, _inst, fun C => (hÎ¹ C).resolve_left _âŸ©
      rintro âŸ¨s, srâŸ©
      apply Nat.not_succ_le_self (Fintype.card Îº)
      rw [â† Nat.add_one, â† sr, â† Multiset.card_map, â† Finset.card_mk]
      exact Finset.card_le_univ âŸ¨_, s.distinct_colorsâŸ©
    intro r
    induction' r with r ihr
    Â· exact âŸ¨Empty, inferInstance, fun C => Or.inl âŸ¨default, Multiset.card_zeroâŸ©âŸ©
    obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := ihr
    specialize ihÎ± ((Î¹ â†’ Option Î±) â†’ Îº)
    obtain âŸ¨Î¹', _inst, hÎ¹'âŸ© := ihÎ±
    refine' âŸ¨Sum Î¹ Î¹', inferInstance, _âŸ©
    intro C
    specialize hÎ¹' fun v' v => C (Sum.elim v (some âˆ˜ v'))
    obtain âŸ¨l', C', hl'âŸ© := hÎ¹'
    have mono_of_mono : (âˆƒ l, IsMono C' l) â†’ âˆƒ l, IsMono C l := by
      rintro âŸ¨l, c, hlâŸ©
      refine' âŸ¨l.horizontal (some âˆ˜ l' (Classical.arbitrary Î±)), c, fun x => _âŸ©
      rw [Line.horizontal_apply, â† hl, â† hl']
    specialize hÎ¹ C'
    rcases hÎ¹ with (âŸ¨s, srâŸ© | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : âˆƒ p âˆˆ s.lines, (p : AlmostMono _).color = C' s.focus
    Â· obtain âŸ¨p, p_mem, hpâŸ© := h
      refine' Or.inr (mono_of_mono âŸ¨p.line, p.color, _âŸ©)
      rintro (_ | _)
      Â· rw [hp, s.is_focused p p_mem]
      Â· apply p.has_color
    refine' Or.inl âŸ¨âŸ¨(s.lines.map _).cons âŸ¨(l'.map some).vertical s.focus, C' s.focus, fun x => _âŸ©,
            Sum.elim s.focus (l'.map some none), _, _âŸ©, _âŸ©
    Â· refine' fun p => âŸ¨p.line.prod (l'.map some), p.color, fun x => _âŸ©
      rw [Line.prod_apply, Line.map_apply, â† p.has_color, â† congr_fun (hl' x)]
    Â· rw [vertical_apply, â† congr_fun (hl' x), Line.map_apply]
    Â· simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | âŸ¨q, hq, rflâŸ©)
      Â· simp only [vertical_apply]
      Â· simp only [prod_apply, s.is_focused q hq]
    Â· rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact âŸ¨fun âŸ¨q, hq, heâŸ© => h âŸ¨q, hq, heâŸ©, s.distinct_colorsâŸ©
    Â· rw [Multiset.card_cons, Multiset.card_map, sr])","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  c
Î± Î±' : Type u
e : Î± â‰ƒ Î±'
Îº : Type (max v u)
xâœÂ¹ : Finite Îº
Î¹ : Type
xâœ : Fintype Î¹
h : âˆ€ (C : (Î¹ â†’ Î±) â†’ Îº), âˆƒ l, IsMono C l
C : (Î¹ â†’ Î±') â†’ Îº
l : Line Î± Î¹
c : Îº
lc : âˆ€ (x : Î±), (fun v â†¦ C (â‡‘e âˆ˜ v)) ((fun x i â†¦ (l.idxFun i).getD x) x) = c
x : Î±
âŠ¢ ?m.6437 x
error:  application type mismatch
  Exists.intro c ((Equiv.forall_congr_left e).mp fun x â†¦ ?m.6452 x)
argument
  (Equiv.forall_congr_left e).mp fun x â†¦ ?m.6452 x
has type
  âˆ€ (b : Î±'), ?m.6437 (e.symm b) : Prop
but is expected to have type
  âˆ€ (x : Î±'), C ((fun x i â†¦ ((map (â‡‘e) l).idxFun i).getD x) x) = c : Prop","theorem exists_mono_in_high_dimension' :
    âˆ€ (Î± : Type u) [Finite Î±] (Îº : Type max v u) [Finite Îº],
      âˆƒ (Î¹ : Type) (_ : Fintype Î¹), âˆ€ C : (Î¹ â†’ Î±) â†’ Îº, âˆƒ l : Line Î± Î¹, l.IsMono C ",":=
  Finite.induction_empty_option
  (
  fun {Î± Î±'} e =>
    forall_imp fun Îº =>
      forall_imp fun _ =>
        Exists.imp fun Î¹ =>
          Exists.imp fun _ h C =>
            let âŸ¨l, c, lcâŸ© := h fun v => C (e âˆ˜ v)
            âŸ¨l.map e, c, e.forall_congr_right.mp fun x => by rw [â† lc x, Line.map_apply]âŸ©)
  (by
    intro Îº _
    by_cases h : Nonempty Îº
    Â· refine âŸ¨Unit, inferInstance, fun C => âŸ¨default, Classical.arbitrary _, PEmpty.recâŸ©âŸ©
    Â· exact âŸ¨Empty, inferInstance, fun C => (h âŸ¨C (Empty.rec)âŸ©).elimâŸ©)
  (by
    intro Î± _ ihÎ± Îº _
    cases nonempty_fintype Îº
    by_cases h : Nonempty Î±
    case neg =>
      refine âŸ¨Unit, inferInstance, fun C => âŸ¨diagonal _ Unit, C fun _ => none, ?_âŸ©âŸ©
      rintro (_ | âŸ¨aâŸ©)
      Â· rfl
      Â· exact (h âŸ¨aâŸ©).elim
    suffices key :
      âˆ€ r : â„•,
        âˆƒ (Î¹ : Type) (_ : Fintype Î¹),
          âˆ€ C : (Î¹ â†’ Option Î±) â†’ Îº,
            (âˆƒ s : ColorFocused C, Multiset.card s.lines = r) âˆ¨ âˆƒ l, IsMono C l by
      obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := key (Fintype.card Îº + 1)
      refine âŸ¨Î¹, _inst, fun C => (hÎ¹ C).resolve_left ?_âŸ©
      rintro âŸ¨s, srâŸ©
      apply Nat.not_succ_le_self (Fintype.card Îº)
      rw [â† Nat.add_one, â† sr, â† Multiset.card_map, â† Finset.card_mk]
      exact Finset.card_le_univ âŸ¨_, s.distinct_colorsâŸ©
    intro r
    induction' r with r ihr
    Â· exact âŸ¨Empty, inferInstance, fun C => Or.inl âŸ¨default, Multiset.card_zeroâŸ©âŸ©
    obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := ihr
    specialize ihÎ± ((Î¹ â†’ Option Î±) â†’ Îº)
    obtain âŸ¨Î¹', _inst, hÎ¹'âŸ© := ihÎ±
    refine âŸ¨Sum Î¹ Î¹', inferInstance, ?_âŸ©
    intro C
    specialize hÎ¹' fun v' v => C (Sum.elim v (some âˆ˜ v'))
    obtain âŸ¨l', C', hl'âŸ© := hÎ¹'
    have mono_of_mono : (âˆƒ l, IsMono C' l) â†’ âˆƒ l, IsMono C l := by
      rintro âŸ¨l, c, hlâŸ©
      refine âŸ¨l.horizontal (some âˆ˜ l' (Classical.arbitrary Î±)), c, fun x => ?_âŸ©
      rw [Line.horizontal_apply, â† hl, â† hl']
    specialize hÎ¹ C'
    rcases hÎ¹ with (âŸ¨s, srâŸ© | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : âˆƒ p âˆˆ s.lines, (p : AlmostMono _).color = C' s.focus
    Â· obtain âŸ¨p, p_mem, hpâŸ© := h
      refine Or.inr (mono_of_mono âŸ¨p.line, p.color, ?_âŸ©)
      rintro (_ | _)
      Â· rw [hp, s.is_focused p p_mem]
      Â· apply p.has_color
    refine Or.inl âŸ¨âŸ¨(s.lines.map ?_).cons âŸ¨(l'.map some).vertical s.focus, C' s.focus, fun x => ?_âŸ©,
            Sum.elim s.focus (l'.map some none), ?_, ?_âŸ©, ?_âŸ©
    Â· refine fun p => âŸ¨p.line.prod (l'.map some), p.color, fun x => ?_âŸ©
      rw [Line.prod_apply, Line.map_apply, â† p.has_color, â† congr_fun (hl' x)]
    Â· rw [vertical_apply, â† congr_fun (hl' x), Line.map_apply]
    Â· simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | âŸ¨q, hq, rflâŸ©)
      Â· simp only [vertical_apply]
      Â· simp only [prod_apply, s.is_focused q hq]
    Â· rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact âŸ¨fun âŸ¨q, hq, heâŸ© => h âŸ¨q, hq, heâŸ©, s.distinct_colorsâŸ©
    Â· rw [Multiset.card_cons, Multiset.card_map, sr])"
Mathlib/Algebra/Module/Defs.lean,Convex.combo_eq_smul_sub_add,Convex.combo_eq_smul_sub_add,0ef23fba776dbe5bb848bbfc3337bedef4a59c82,":=
  calc
    a â€¢ x + b â€¢ y = b â€¢ y - b â€¢ x + (a â€¢ x + b â€¢ x) := by abel
    _ = b â€¢ (y - x) + x := by rw [smul_sub, Convex.combo_self h]","warning:  `bit0` has been deprecated
error:  unknown tactic
error:  unsolved goals
Î± : Type u_1
R : Type u_2
k : Type u_3
S : Type u_4
M : Type u_5
Mâ‚‚ : Type u_6
Mâ‚ƒ : Type u_7
Î¹ : Type u_8
instâœÂ² : Semiring R
instâœÂ¹ : AddCommGroup M
instâœ : Module R M
x y : M
a b : R
h : a + b = 1
âŠ¢ a â€¢ x + b â€¢ y = b â€¢ y - b â€¢ x + (a â€¢ x + b â€¢ x)","theorem Convex.combo_eq_smul_sub_add [Module R M] {x y : M} {a b : R} (h : a + b = 1) :
    a â€¢ x + b â€¢ y = b â€¢ (y - x) + x ",":=
  calc
    a â€¢ x + b â€¢ y = b â€¢ y - b â€¢ x + (a â€¢ x + b â€¢ x) := by rw [sub_add_add_cancel, add_comm]
    _ = b â€¢ (y - x) + x := by rw [smul_sub, Convex.combo_self h]"
Mathlib/RingTheory/IntegralRestrict.lean,Algebra.intNorm_eq_norm,Algebra.intNorm_eq_norm,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  ext x
  haveI : IsIntegralClosure B A (FractionRing B) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (Algebra.IsIntegral.of_finite A B)
  haveI : IsLocalization (algebraMapSubmonoid B Aâ°) (FractionRing B) :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
      (isAlgebraic_of_isFractionRing _ _ (Algebra.IsIntegral.of_finite A B))
  apply IsFractionRing.injective A (FractionRing A)
  rw [Algebra.algebraMap_intNorm_fractionRing, Algebra.norm_localization A Aâ°]","error:  function expected at
  IsIntegralClosure.of_isIntegrallyClosed ?m.573677 ?m.573678 ?m.573682
term has type
  IsIntegralClosure ?m.573677 ?m.573678 ?m.573682
error:  function expected at
  IsIntegralClosure.isLocalization ?m.575497 (FractionRing A) ?m.575510 ?m.575512
term has type
  IsLocalization (algebraMapSubmonoid ?m.575512 ?m.575497â°) ?m.575510",lemma Algebra.intNorm_eq_norm [Module.Free A B] : Algebra.intNorm A B = Algebra.norm A ,":= by
  ext x
  haveI : IsIntegralClosure B A (FractionRing B) :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  haveI : IsLocalization (algebraMapSubmonoid B Aâ°) (FractionRing B) :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  apply IsFractionRing.injective A (FractionRing A)
  rw [Algebra.algebraMap_intNorm_fractionRing, Algebra.norm_localization A Aâ°]"
Mathlib/Topology/Order/LocalExtr.lean,IsLocalMaxOn.inter,IsLocalMaxOn.inter,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  hf.on_subset (inter_subset_left s t)","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set Î± : Type u
but is expected to have type
  ?m.2804 âˆˆ ?m.2802 âˆ© ?m.2803 : Prop",theorem IsLocalMaxOn.inter (hf : IsLocalMaxOn f s a) (t) : IsLocalMaxOn f (s âˆ© t) a ,":=
  hf.on_subset inter_subset_left"
Mathlib/Order/Partition/Finpartition.lean,Finpartition.mem_part_ofSetoid_iff_rel,mem_part_ofSetoid_iff_rel,ca263f4356a58c37b84beae902ab555c06685291,":= by
  simp_rw [part, ofSetoid, mem_univ, reduceDite]
  generalize_proofs H
  have := choose_spec _ _ H
  simp only [mem_univ, mem_image, true_and] at this
  obtain âŸ¨âŸ¨_, hcâŸ©, thisâŸ© := this
  simp only [â† hc, mem_univ, mem_filter, true_and] at this âŠ¢
  exact âŸ¨s.trans (s.symm this), s.trans thisâŸ©","error:  unknown identifier 'reduceDite'
error:  simp made no progress","theorem mem_part_ofSetoid_iff_rel {s : Setoid Î±} [DecidableRel s.r] {b : Î±} :
    b âˆˆ (ofSetoid s).part a â†” s.r a b ",":= by
  simp_rw [part, ofSetoid, mem_univ, reduceDIte]
  generalize_proofs H
  have := choose_spec _ _ H
  simp only [mem_univ, mem_image, true_and] at this
  obtain âŸ¨âŸ¨_, hcâŸ©, thisâŸ© := this
  simp only [â† hc, mem_univ, mem_filter, true_and] at this âŠ¢
  exact âŸ¨s.trans (s.symm this), s.trans thisâŸ©"
Mathlib/RingTheory/WittVector/Verschiebung.lean,WittVector.ghostComponent_verschiebung,ghostComponent_verschiebung,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp only [ghostComponent_apply, aeval_wittPolynomial]
  rw [Finset.sum_range_succ', verschiebungFun_coeff, if_pos rfl,
    zero_pow (pow_ne_zero _ hp.1.ne_zero), mul_zero, add_zero, Finset.mul_sum, Finset.sum_congr rfl]
  rintro i -
  simp only [pow_succ', mul_assoc, verschiebungFun_coeff, if_neg (Nat.succ_ne_zero i),
    Nat.succ_sub_succ, tsub_zero]","error:  unsolved goals
p : â„•
R : Type u_1
S : Type u_2
hp : Fact (Nat.Prime p)
instâœÂ¹ : CommRing R
instâœ : CommRing S
x : ğ• R
n i : â„•
âŠ¢ â†‘p * (â†‘p ^ i * (if False then 0 else x.coeff i) ^ p ^ (n - i)) = â†‘p * (â†‘p ^ i * x.coeff i ^ p ^ (n - i))","theorem ghostComponent_verschiebungFun (x : ğ• R) (n : â„•) :
    ghostComponent (n + 1) (verschiebungFun x) = p * ghostComponent n x ",":= by
  simp only [ghostComponent_apply, aeval_wittPolynomial]
  rw [Finset.sum_range_succ', verschiebungFun_coeff, if_pos rfl,
    zero_pow (pow_ne_zero _ hp.1.ne_zero), mul_zero, add_zero, Finset.mul_sum, Finset.sum_congr rfl]
  rintro i -
  simp only [pow_succ', verschiebungFun_coeff_succ, Nat.succ_sub_succ_eq_sub, mul_assoc]"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,IsometryEquiv.hausdorffMeasure_image,hausdorffMeasure_image,3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine' ENNReal.tsum_le_tsum fun n => _
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left s) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set X : Type u_2
but is expected to have type
  ?m.169595 âˆˆ t n âˆ© ?m.169594 : Prop
error:  simp made no progress","theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s ",":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd"
Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean,MvPolynomial.weightedHomogeneousComponent_zero,weightedHomogeneousComponent_zero,b09462282225ca03a37b7e6afde435d1ab7552ef,":= by
  classical
  ext1 d
  rcases Classical.em (d = 0) with (rfl | hd)
  Â· simp only [coeff_weightedHomogeneousComponent, if_pos, map_zero, coeff_zero_C]
  Â· rw [coeff_weightedHomogeneousComponent, if_neg, coeff_C, if_neg (Ne.symm hd)]
    simp only [weightedDegree', LinearMap.toAddMonoidHom_coe, Finsupp.total_apply, Finsupp.sum,
      sum_eq_zero_iff, Finsupp.mem_support_iff, Ne.def, smul_eq_zero, not_forall, not_or,
      and_self_left, exists_prop]
    simp only [FunLike.ext_iff, Finsupp.coe_zero, Pi.zero_apply, not_forall] at hd
    obtain âŸ¨i, hiâŸ© := hd
    exact âŸ¨i, hi, hw iâŸ©","error:  unknown identifier 'weightedDegree''
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.114863 â†’ ?m.114863 â†’ Prop
error:  simp made no progress","theorem weightedHomogeneousComponent_zero [NoZeroSMulDivisors â„• M] (hw : âˆ€ i : Ïƒ, w i â‰  0) :
    weightedHomogeneousComponent w 0 Ï† = C (coeff 0 Ï†) ",":= by
  classical
  ext1 d
  rcases Classical.em (d = 0) with (rfl | hd)
  Â· simp only [coeff_weightedHomogeneousComponent, if_pos, map_zero, coeff_zero_C]
  Â· rw [coeff_weightedHomogeneousComponent, if_neg, coeff_C, if_neg (Ne.symm hd)]
    simp only [weightedDegree, LinearMap.toAddMonoidHom_coe, Finsupp.total_apply, Finsupp.sum,
      sum_eq_zero_iff, Finsupp.mem_support_iff, Ne, smul_eq_zero, not_forall, not_or,
      and_self_left, exists_prop]
    simp only [DFunLike.ext_iff, Finsupp.coe_zero, Pi.zero_apply, not_forall] at hd
    obtain âŸ¨i, hiâŸ© := hd
    exact âŸ¨i, hi, hw iâŸ©"
Mathlib/MeasureTheory/Integral/Periodic.lean,Function.Periodic.intervalIntegral_add_eq_of_pos,intervalIntegral_add_eq_of_pos,e80793ed2602b66d6dec49d0ef95cdf56a9ea10f,":= by
  simp only [integral_of_le, hT.le, le_add_iff_nonneg_right]
  haveI : VAddInvariantMeasure (AddSubgroup.zmultiples T) â„ volume :=
    âŸ¨fun c s _ => measure_preimage_add _ _ _âŸ©
  apply IsAddFundamentalDomain.set_integral_eq (G := AddSubgroup.zmultiples T)
  exacts [isAddFundamentalDomain_Ioc hT t, isAddFundamentalDomain_Ioc hT s, hf.map_vadd_zmultiples]",error:  unknown constant 'MeasureTheory.IsAddFundamentalDomain.set_integral_eq',"theorem intervalIntegral_add_eq_of_pos (hf : Periodic f T) (hT : 0 < T) (t s : â„) :
    âˆ« x in t..t + T, f x = âˆ« x in s..s + T, f x ",":= by
  simp only [integral_of_le, hT.le, le_add_iff_nonneg_right]
  haveI : VAddInvariantMeasure (AddSubgroup.zmultiples T) â„ volume :=
    âŸ¨fun c s _ => measure_preimage_add _ _ _âŸ©
  apply IsAddFundamentalDomain.setIntegral_eq (G := AddSubgroup.zmultiples T)
  exacts [isAddFundamentalDomain_Ioc hT t, isAddFundamentalDomain_Ioc hT s, hf.map_vadd_zmultiples]"
Mathlib/GroupTheory/Transfer.lean,MonoidHom.transfer_eq_pow_aux,transfer_eq_pow_aux,c255506b667a00b193c721ed412b7b1a2bafab5d,":= by
  by_cases hH : H.index = 0
  Â· rw [hH, pow_zero]
    exact H.one_mem
  letI := fintypeOfIndexNeZero hH
  classical
    replace key : âˆ€ (k : â„•) (gâ‚€ : G), gâ‚€â»Â¹ * g ^ k * gâ‚€ âˆˆ H â†’ g ^ k âˆˆ H := fun k gâ‚€ hk =>
      (_root_.congr_arg (Â· âˆˆ H) (key k gâ‚€ hk)).mp hk
    replace key : âˆ€ q : G â§¸ H, g ^ period g q âˆˆ H := fun q =>
      key (period g q) q.out'
        (QuotientGroup.out'_conj_pow_minimalPeriod_mem H g q)
    let f : Quotient (orbitRel (zpowers g) (G â§¸ H)) â†’ zpowers g := fun q =>
      (âŸ¨g, mem_zpowers gâŸ© : zpowers g) ^ period g q.out'
    have hf : âˆ€ q, f q âˆˆ H.subgroupOf (zpowers g) := fun q => key q.out'
    replace key :=
      Subgroup.prod_mem (H.subgroupOf (zpowers g)) fun q (_ : q âˆˆ Finset.univ) => hf q
    simpa only [period_eq_card_zpowers_orbit, Finset.prod_pow_eq_pow_sum, Fintype.card_sigma,
      Fintype.card_congr (selfEquivSigmaOrbits (zpowers g) (G â§¸ H)), index_eq_card] using key","error:  unknown identifier 'period_eq_card_zpowers_orbit'
error:  type mismatch
  hâœ
has type
  âˆ c : Quotient (orbitRel (â†¥(zpowers g)) (G â§¸ H)), f c âˆˆ H.subgroupOf (zpowers g) : Prop
but is expected to have type
  g ^ âˆ‘ i : orbitRel.Quotient (â†¥(zpowers g)) (G â§¸ H), Fintype.card â†‘(orbit (â†¥(zpowers g)) (Quotient.out' i)) âˆˆ H : Prop","theorem transfer_eq_pow_aux (g : G)
    (key : âˆ€ (k : â„•) (gâ‚€ : G), gâ‚€â»Â¹ * g ^ k * gâ‚€ âˆˆ H â†’ gâ‚€â»Â¹ * g ^ k * gâ‚€ = g ^ k) :
    g ^ H.index âˆˆ H ",":= by
  by_cases hH : H.index = 0
  Â· rw [hH, pow_zero]
    exact H.one_mem
  letI := fintypeOfIndexNeZero hH
  classical
    replace key : âˆ€ (k : â„•) (gâ‚€ : G), gâ‚€â»Â¹ * g ^ k * gâ‚€ âˆˆ H â†’ g ^ k âˆˆ H := fun k gâ‚€ hk =>
      (_root_.congr_arg (Â· âˆˆ H) (key k gâ‚€ hk)).mp hk
    replace key : âˆ€ q : G â§¸ H, g ^ Function.minimalPeriod (g â€¢ Â·) q âˆˆ H := fun q =>
      key (Function.minimalPeriod (g â€¢ Â·) q) q.out'
        (QuotientGroup.out'_conj_pow_minimalPeriod_mem H g q)
    let f : Quotient (orbitRel (zpowers g) (G â§¸ H)) â†’ zpowers g := fun q =>
      (âŸ¨g, mem_zpowers gâŸ© : zpowers g) ^ Function.minimalPeriod (g â€¢ Â·) q.out'
    have hf : âˆ€ q, f q âˆˆ H.subgroupOf (zpowers g) := fun q => key q.out'
    replace key :=
      Subgroup.prod_mem (H.subgroupOf (zpowers g)) fun q (_ : q âˆˆ Finset.univ) => hf q
    simpa only [f, minimalPeriod_eq_card, Finset.prod_pow_eq_pow_sum, Fintype.card_sigma,
      Fintype.card_congr (selfEquivSigmaOrbits (zpowers g) (G â§¸ H)), index_eq_card] using key"
Mathlib/Order/Birkhoff.lean,exists_birkhoff_representation,exists_birkhoff_representation,922953b0917dc9ad7275e31bed9ddb5b8bf62fe5,":= by
  classical
  cases nonempty_fintype Î±
  exact âŸ¨{a : Î± // SupIrred a}, _ , by infer_instance, _, LatticeHom.birkhoffFinset_injective _âŸ©","error:  application type mismatch
  Exists.intro ?m.88017 (LatticeHom.birkhoffFinset_injective ?m.88027)
argument
  LatticeHom.birkhoffFinset_injective ?m.88027
has type
  ?m.88025 = ?m.88026 : Prop
but is expected to have type
  Injective â‡‘?m.88017 : Prop
error:  unsolved goals
case intro
Î±âœ : Type u_1
instâœâµ : DistribLattice Î±âœ
instâœâ´ : OrderBot Î±âœ
instâœÂ³ : Fintype Î±âœ
instâœÂ² : DecidablePred SupIrred
Î± : Type u
instâœÂ¹ : Finite Î±
instâœ : DistribLattice Î±
valâœ : Fintype Î±
âŠ¢ âˆƒ Î² x x_1 f, Injective â‡‘f","lemma exists_birkhoff_representation.{u} (Î± : Type u) [Finite Î±] [DistribLattice Î±] :
    âˆƒ (Î² : Type u) (_ : DecidableEq Î²) (_ : Fintype Î²) (f : LatticeHom Î± (Finset Î²)),
      Injective f ",":= by
  classical
  cases nonempty_fintype Î±
  exact âŸ¨{a : Î± // SupIrred a}, _, inferInstance, _, LatticeHom.birkhoffFinset_injectiveâŸ©"
Mathlib/Data/Nat/Bits.lean,Nat.bodd_add_div2,bodd_add_div2,45f93f3f49de0d86f67da4656718c6e6d0dde158,"  | 0 => rfl
  | succ n => by
    simp only [bodd_succ, Bool.cond_not, div2_succ, Nat.mul_comm]
    refine' Eq.trans _ (congr_arg succ (bodd_add_div2 n))
    cases bodd n <;> simp [cond, not]
    Â· rw [Nat.add_comm]
    Â· rw [succ_mul, Nat.add_comm 1]","error:  unsolved goals
case true
m nâœ n : â„•
âŠ¢ (1 + n.div2) * 2 = 1 + (1 + n.div2 * 2)
error:  no goals to be solved
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated","lemma bodd_add_div2 : âˆ€ n, cond (bodd n) 1 0 + 2 * div2 n = n
","  | 0 => rfl
  | succ n => by
    simp only [bodd_succ, Bool.cond_not, div2_succ, Nat.mul_comm]
    refine Eq.trans ?_ (congr_arg succ (bodd_add_div2 n))
    cases bodd n
    Â· simp
    Â· simp; omega"
Mathlib/Combinatorics/SetFamily/HarrisKleitman.lean,IsLowerSet.le_card_inter_finset',IsLowerSet.le_card_inter_finset',40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  induction' s using Finset.induction with a s hs ih generalizing ğ’œ â„¬
  Â· simp_rw [subset_empty, â† subset_singleton_iff', subset_singleton_iff] at hğ’œs hâ„¬s
    obtain rfl | rfl := hğ’œs
    Â· simp only [card_empty, zero_mul, empty_inter, mul_zero, le_refl]
    obtain rfl | rfl := hâ„¬s
    Â· simp only [card_empty, inter_empty, mul_zero, zero_mul, le_refl]
    Â· simp only [card_empty, pow_zero, inter_singleton_of_mem, mem_singleton, card_singleton,
        le_refl]
  rw [card_insert_of_not_mem hs, â† card_memberSubfamily_add_card_nonMemberSubfamily a ğ’œ, â†
    card_memberSubfamily_add_card_nonMemberSubfamily a â„¬, add_mul, mul_add, mul_add,
    add_comm (_ * _), add_add_add_comm]
  refine'
    (add_le_add_right
          (mul_add_mul_le_mul_add_mul
              (card_le_of_subset hğ’œ.memberSubfamily_subset_nonMemberSubfamily) <|
            card_le_of_subset hâ„¬.memberSubfamily_subset_nonMemberSubfamily)
          _).trans
      _
  rw [â† two_mul, pow_succ, mul_assoc]
  have hâ‚€ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’
      âˆ€ t âˆˆ ğ’.nonMemberSubfamily a, t âŠ† s := by
    rintro ğ’ hğ’ t ht
    rw [mem_nonMemberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 (hğ’ _ ht.1)
  have hâ‚ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’
      âˆ€ t âˆˆ ğ’.memberSubfamily a, t âŠ† s := by
    rintro ğ’ hğ’ t ht
    rw [mem_memberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 ((subset_insert _ _).trans <| hğ’ _ ht.1)
  refine' mul_le_mul_left' _ _
  refine' (add_le_add (ih hğ’œ.memberSubfamily hâ„¬.memberSubfamily (hâ‚ _ hğ’œs) <| hâ‚ _ hâ„¬s) <|
    ih hğ’œ.nonMemberSubfamily hâ„¬.nonMemberSubfamily (hâ‚€ _ hğ’œs) <| hâ‚€ _ hâ„¬s).trans_eq _
  rw [â† mul_add, â† memberSubfamily_inter, â† nonMemberSubfamily_inter,
    card_memberSubfamily_add_card_nonMemberSubfamily]","warning:  `Finset.card_le_of_subset` has been deprecated, use `Finset.card_le_card` instead
warning:  `Finset.card_le_of_subset` has been deprecated, use `Finset.card_le_card` instead
error:  typeclass instance problem is stuck, it is often due to metavariables
  CovariantClass ?m.7655 ?m.7655 (fun x x_1 â†¦ x * x_1) fun x x_1 â†¦ x â‰¤ x_1","theorem IsLowerSet.le_card_inter_finset' (hğ’œ : IsLowerSet (ğ’œ : Set (Finset Î±)))
    (hâ„¬ : IsLowerSet (â„¬ : Set (Finset Î±))) (hğ’œs : âˆ€ t âˆˆ ğ’œ, t âŠ† s) (hâ„¬s : âˆ€ t âˆˆ â„¬, t âŠ† s) :
    ğ’œ.card * â„¬.card â‰¤ 2 ^ s.card * (ğ’œ âˆ© â„¬).card ",":= by
  induction' s using Finset.induction with a s hs ih generalizing ğ’œ â„¬
  Â· simp_rw [subset_empty, â† subset_singleton_iff', subset_singleton_iff] at hğ’œs hâ„¬s
    obtain rfl | rfl := hğ’œs
    Â· simp only [card_empty, zero_mul, empty_inter, mul_zero, le_refl]
    obtain rfl | rfl := hâ„¬s
    Â· simp only [card_empty, inter_empty, mul_zero, zero_mul, le_refl]
    Â· simp only [card_empty, pow_zero, inter_singleton_of_mem, mem_singleton, card_singleton,
        le_refl]
  rw [card_insert_of_not_mem hs, â† card_memberSubfamily_add_card_nonMemberSubfamily a ğ’œ, â†
    card_memberSubfamily_add_card_nonMemberSubfamily a â„¬, add_mul, mul_add, mul_add,
    add_comm (_ * _), add_add_add_comm]
  refine
    (add_le_add_right
          (mul_add_mul_le_mul_add_mul
              (card_le_card hğ’œ.memberSubfamily_subset_nonMemberSubfamily) <|
            card_le_card hâ„¬.memberSubfamily_subset_nonMemberSubfamily)
          _).trans
      ?_
  rw [â† two_mul, pow_succ', mul_assoc]
  have hâ‚€ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’
      âˆ€ t âˆˆ ğ’.nonMemberSubfamily a, t âŠ† s := by
    rintro ğ’ hğ’ t ht
    rw [mem_nonMemberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 (hğ’ _ ht.1)
  have hâ‚ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’
      âˆ€ t âˆˆ ğ’.memberSubfamily a, t âŠ† s := by
    rintro ğ’ hğ’ t ht
    rw [mem_memberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 ((subset_insert _ _).trans <| hğ’ _ ht.1)
  refine mul_le_mul_left' ?_ _
  refine (add_le_add (ih hğ’œ.memberSubfamily hâ„¬.memberSubfamily (hâ‚ _ hğ’œs) <| hâ‚ _ hâ„¬s) <|
    ih hğ’œ.nonMemberSubfamily hâ„¬.nonMemberSubfamily (hâ‚€ _ hğ’œs) <| hâ‚€ _ hâ„¬s).trans_eq ?_
  rw [â† mul_add, â† memberSubfamily_inter, â† nonMemberSubfamily_inter,
    card_memberSubfamily_add_card_nonMemberSubfamily]"
Mathlib/Algebra/CharP/MixedCharZero.lean,MixedCharZero.reduce_to_maximal_ideal,reduce_to_maximal_ideal,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  constructor
  Â· intro g
    rcases g with âŸ¨I, âŸ¨hI_not_top, _âŸ©âŸ©
    rcases Ideal.exists_le_maximal I hI_not_top with âŸ¨M, âŸ¨hM_max, hM_geâŸ©âŸ©
    use M
    constructor
    Â· exact hM_max
    Â· cases CharP.exists (R â§¸ M) with
      | intro r hr =>
        have hr := hr
        convert hr
        have r_dvd_p : r âˆ£ p
        Â· rw [â† CharP.cast_eq_zero_iff (R â§¸ M) r p]
          convert congr_arg (Ideal.Quotient.factor I M hM_ge) (CharP.cast_eq_zero (R â§¸ I) p)
        symm
        apply (Nat.Prime.eq_one_or_self_of_dvd hp r r_dvd_p).resolve_left
        exact CharP.char_ne_one (R â§¸ M) r
  Â· intro âŸ¨I, hI_max, h_charPâŸ©
    use I
    exact âŸ¨Ideal.IsMaximal.ne_top hI_max, h_charPâŸ©","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case h.e'_3
R : Type u_1
instâœ : CommRing R
p : â„•
hp : Nat.Prime p
I : Ideal R
hI_not_top : I â‰  âŠ¤
rightâœ : CharP (R â§¸ I) p
M : Ideal R
hM_max : M.IsMaximal
hM_ge : I â‰¤ M
r : â„•
hrâœ hr : CharP (R â§¸ M) r
r_dvd_p : r âˆ£ p
âŠ¢ p = r
error:  unsolved goals
case mpr
R : Type u_1
instâœ : CommRing R
p : â„•
hp : Nat.Prime p
âŠ¢ (âˆƒ I, I.IsMaximal âˆ§ CharP (R â§¸ I) p) â†’ âˆƒ I, I â‰  âŠ¤ âˆ§ CharP (R â§¸ I) p","theorem reduce_to_maximal_ideal {p : â„•} (hp : Nat.Prime p) :
    (âˆƒ I : Ideal R, I â‰  âŠ¤ âˆ§ CharP (R â§¸ I) p) â†” âˆƒ I : Ideal R, I.IsMaximal âˆ§ CharP (R â§¸ I) p ",":= by
  constructor
  Â· intro g
    rcases g with âŸ¨I, âŸ¨hI_not_top, _âŸ©âŸ©
    rcases Ideal.exists_le_maximal I hI_not_top with âŸ¨M, âŸ¨hM_max, hM_geâŸ©âŸ©
    use M
    constructor
    Â· exact hM_max
    Â· cases CharP.exists (R â§¸ M) with
      | intro r hr =>
        convert hr
        have r_dvd_p : r âˆ£ p := by
          rw [â† CharP.cast_eq_zero_iff (R â§¸ M) r p]
          convert congr_arg (Ideal.Quotient.factor I M hM_ge) (CharP.cast_eq_zero (R â§¸ I) p)
        symm
        apply (Nat.Prime.eq_one_or_self_of_dvd hp r r_dvd_p).resolve_left
        exact CharP.char_ne_one (R â§¸ M) r
  Â· intro âŸ¨I, hI_max, h_charPâŸ©
    use I
    exact âŸ¨Ideal.IsMaximal.ne_top hI_max, h_charPâŸ©"
Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean,MeasureTheory.SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge,SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' f using MeasureTheory.SimpleFunc.induction with c s hs fâ‚ fâ‚‚ _ hâ‚ hâ‚‚ generalizing Îµ
  Â· let f := SimpleFunc.piecewise s hs (SimpleFunc.const Î± c) (SimpleFunc.const Î± 0)
    by_cases h : âˆ«â» x, f x âˆ‚Î¼ = âŠ¤
    Â· refine'
        âŸ¨fun _ => c, fun x => _, lowerSemicontinuous_const, by
          simp only [_root_.top_add, le_top, h]âŸ©
      simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,
        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]
      exact Set.indicator_le_self _ _ _
    by_cases hc : c = 0
    Â· refine' âŸ¨fun _ => 0, _, lowerSemicontinuous_const, _âŸ©
      Â· classical
        simp only [hc, Set.indicator_zero', Pi.zero_apply, SimpleFunc.const_zero, imp_true_iff,
          eq_self_iff_true, SimpleFunc.coe_zero, Set.piecewise_eq_indicator,
          SimpleFunc.coe_piecewise, le_zero_iff]
      Â· simp only [lintegral_const, zero_mul, zero_le, ENNReal.coe_zero]
    have : Î¼ s < Î¼ s + Îµ / c := by
      have : (0 : â„â‰¥0âˆ) < Îµ / c := ENNReal.div_pos_iff.2 âŸ¨Îµ0, ENNReal.coe_ne_topâŸ©
      simpa using ENNReal.add_lt_add_left ?aux this
    case aux =>
      classical
      simpa [f, hs, hc, lt_top_iff_ne_top, true_and_iff, SimpleFunc.coe_const,
        Function.const_apply, lintegral_const, ENNReal.coe_indicator, Set.univ_inter,
        ENNReal.coe_ne_top, MeasurableSet.univ, ENNReal.mul_eq_top, SimpleFunc.const_zero,
        or_false_iff, lintegral_indicator, ENNReal.coe_eq_zero, Ne, not_false_iff,
        SimpleFunc.coe_zero, Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise, false_and_iff,
        restrict_apply] using h
    obtain âŸ¨u, su, u_open, Î¼uâŸ© : âˆƒ (u : _), u âŠ‡ s âˆ§ IsOpen u âˆ§ Î¼ u < Î¼ s + Îµ / c :=
      s.exists_isOpen_lt_of_lt _ this
    refine'
      âŸ¨Set.indicator u fun _ => c, fun x => _, u_open.lowerSemicontinuous_indicator (zero_le _), _âŸ©
    Â· simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,
        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]
      exact Set.indicator_le_indicator_of_subset su (fun x => zero_le _) _
    Â· suffices (c : â„â‰¥0âˆ) * Î¼ u â‰¤ c * Î¼ s + Îµ by
        classical
        simpa only [ENNReal.coe_indicator, u_open.measurableSet, lintegral_indicator,
          lintegral_const, MeasurableSet.univ, Measure.restrict_apply, Set.univ_inter, const_zero,
          coe_piecewise, coe_const, coe_zero, Set.piecewise_eq_indicator, Function.const_apply, hs]
      calc
        (c : â„â‰¥0âˆ) * Î¼ u â‰¤ c * (Î¼ s + Îµ / c) := mul_le_mul_left' Î¼u.le _
        _ = c * Î¼ s + Îµ := by
          simp_rw [mul_add]
          rw [ENNReal.mul_div_cancel' _ ENNReal.coe_ne_top]
          simpa using hc

  Â· rcases hâ‚ (ENNReal.half_pos Îµ0).ne' with âŸ¨gâ‚, fâ‚_le_gâ‚, gâ‚cont, gâ‚intâŸ©
    rcases hâ‚‚ (ENNReal.half_pos Îµ0).ne' with âŸ¨gâ‚‚, fâ‚‚_le_gâ‚‚, gâ‚‚cont, gâ‚‚intâŸ©
    refine'
      âŸ¨fun x => gâ‚ x + gâ‚‚ x, fun x => add_le_add (fâ‚_le_gâ‚ x) (fâ‚‚_le_gâ‚‚ x), gâ‚cont.add gâ‚‚cont, _âŸ©
    simp only [SimpleFunc.coe_add, ENNReal.coe_add, Pi.add_apply]
    rw [lintegral_add_left fâ‚.measurable.coe_nnreal_ennreal,
      lintegral_add_left gâ‚cont.measurable.coe_nnreal_ennreal]
    convert add_le_add gâ‚int gâ‚‚int using 1
    conv_lhs => rw [â† ENNReal.add_halves Îµ]
    abel","error:  Case tag 'aux' not found.

The only available case tag is 'neg._@.Mathlib.MeasureTheory.Integral.VitaliCaratheodory._hyg.739'.","theorem SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge (f : Î± â†’â‚› â„â‰¥0) {Îµ : â„â‰¥0âˆ}
    (Îµ0 : Îµ â‰  0) :
    âˆƒ g : Î± â†’ â„â‰¥0, (âˆ€ x, f x â‰¤ g x) âˆ§ LowerSemicontinuous g âˆ§
      (âˆ«â» x, g x âˆ‚Î¼) â‰¤ (âˆ«â» x, f x âˆ‚Î¼) + Îµ ",":= by
  induction' f using MeasureTheory.SimpleFunc.induction with c s hs fâ‚ fâ‚‚ _ hâ‚ hâ‚‚ generalizing Îµ
  Â· let f := SimpleFunc.piecewise s hs (SimpleFunc.const Î± c) (SimpleFunc.const Î± 0)
    by_cases h : âˆ«â» x, f x âˆ‚Î¼ = âŠ¤
    Â· refine
        âŸ¨fun _ => c, fun x => ?_, lowerSemicontinuous_const, by
          simp only [_root_.top_add, le_top, h]âŸ©
      simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,
        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]
      exact Set.indicator_le_self _ _ _
    by_cases hc : c = 0
    Â· refine âŸ¨fun _ => 0, ?_, lowerSemicontinuous_const, ?_âŸ©
      Â· classical
        simp only [hc, Set.indicator_zero', Pi.zero_apply, SimpleFunc.const_zero, imp_true_iff,
          eq_self_iff_true, SimpleFunc.coe_zero, Set.piecewise_eq_indicator,
          SimpleFunc.coe_piecewise, le_zero_iff]
      Â· simp only [lintegral_const, zero_mul, zero_le, ENNReal.coe_zero]
    have ne_top : Î¼ s â‰  âŠ¤ := by
      classical
      simpa [f, hs, hc, lt_top_iff_ne_top, true_and_iff, SimpleFunc.coe_const,
        Function.const_apply, lintegral_const, ENNReal.coe_indicator, Set.univ_inter,
        ENNReal.coe_ne_top, MeasurableSet.univ, ENNReal.mul_eq_top, SimpleFunc.const_zero,
        or_false_iff, lintegral_indicator, ENNReal.coe_eq_zero, Ne, not_false_iff,
        SimpleFunc.coe_zero, Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise, false_and_iff,
        restrict_apply] using h
    have : Î¼ s < Î¼ s + Îµ / c := by
      have : (0 : â„â‰¥0âˆ) < Îµ / c := ENNReal.div_pos_iff.2 âŸ¨Îµ0, ENNReal.coe_ne_topâŸ©
      simpa using ENNReal.add_lt_add_left ne_top this
    obtain âŸ¨u, su, u_open, Î¼uâŸ© : âˆƒ (u : _), u âŠ‡ s âˆ§ IsOpen u âˆ§ Î¼ u < Î¼ s + Îµ / c :=
      s.exists_isOpen_lt_of_lt _ this
    refine âŸ¨Set.indicator u fun _ => c,
            fun x => ?_, u_open.lowerSemicontinuous_indicator (zero_le _), ?_âŸ©
    Â· simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,
        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]
      exact Set.indicator_le_indicator_of_subset su (fun x => zero_le _) _
    Â· suffices (c : â„â‰¥0âˆ) * Î¼ u â‰¤ c * Î¼ s + Îµ by
        classical
        simpa only [ENNReal.coe_indicator, u_open.measurableSet, lintegral_indicator,
          lintegral_const, MeasurableSet.univ, Measure.restrict_apply, Set.univ_inter, const_zero,
          coe_piecewise, coe_const, coe_zero, Set.piecewise_eq_indicator, Function.const_apply, hs]
      calc
        (c : â„â‰¥0âˆ) * Î¼ u â‰¤ c * (Î¼ s + Îµ / c) := mul_le_mul_left' Î¼u.le _
        _ = c * Î¼ s + Îµ := by
          simp_rw [mul_add]
          rw [ENNReal.mul_div_cancel' _ ENNReal.coe_ne_top]
          simpa using hc

  Â· rcases hâ‚ (ENNReal.half_pos Îµ0).ne' with âŸ¨gâ‚, fâ‚_le_gâ‚, gâ‚cont, gâ‚intâŸ©
    rcases hâ‚‚ (ENNReal.half_pos Îµ0).ne' with âŸ¨gâ‚‚, fâ‚‚_le_gâ‚‚, gâ‚‚cont, gâ‚‚intâŸ©
    refine
      âŸ¨fun x => gâ‚ x + gâ‚‚ x, fun x => add_le_add (fâ‚_le_gâ‚ x) (fâ‚‚_le_gâ‚‚ x), gâ‚cont.add gâ‚‚cont, ?_âŸ©
    simp only [SimpleFunc.coe_add, ENNReal.coe_add, Pi.add_apply]
    rw [lintegral_add_left fâ‚.measurable.coe_nnreal_ennreal,
      lintegral_add_left gâ‚cont.measurable.coe_nnreal_ennreal]
    convert add_le_add gâ‚int gâ‚‚int using 1
    conv_lhs => rw [â† ENNReal.add_halves Îµ]
    abel"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.addHaar_image_eq_zero_of_differentiableOn_of_addHaar_eq_zero,addHaar_image_eq_zero_of_differentiableOn_of_addHaar_eq_zero,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  refine' le_antisymm _ (zero_le _)
  have :
      âˆ€ A : E â†’L[â„] E, âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§
        âˆ€ (t : Set E), ApproximatesLinearOn f A t Î´ â†’
          Î¼ (f '' t) â‰¤ (Real.toNNReal |A.det| + 1 : â„â‰¥0) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + 1
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, zero_lt_one, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, h'âŸ©
    exact âŸ¨Î´, h', fun t ht => h t f htâŸ©
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, _, _, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = fderivWithin â„ f s y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s (fderivWithin â„ f s)
      (fun x xs => (hf x xs).hasFDerivWithinAt) Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Real.toNNReal |(A n).det| + 1 : â„â‰¥0) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2
      exact ht n
    _ â‰¤ âˆ‘' n, ((Real.toNNReal |(A n).det| + 1 : â„â‰¥0) : â„â‰¥0âˆ) * 0 := by
      refine ENNReal.tsum_le_tsum fun n => mul_le_mul_left' ?_ _
      exact le_trans (measure_mono (inter_subset_left _ _)) (le_of_eq hs)
    _ = 0 := by simp only [tsum_zero, mul_zero]","error:  function expected at
  inter_subset_left ?m.312377
term has type
  ?m.312376 âˆˆ ?m.312374","theorem addHaar_image_eq_zero_of_differentiableOn_of_addHaar_eq_zero (hf : DifferentiableOn â„ f s)
    (hs : Î¼ s = 0) : Î¼ (f '' s) = 0 ",":= by
  refine le_antisymm ?_ (zero_le _)
  have :
      âˆ€ A : E â†’L[â„] E, âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§
        âˆ€ (t : Set E), ApproximatesLinearOn f A t Î´ â†’
          Î¼ (f '' t) â‰¤ (Real.toNNReal |A.det| + 1 : â„â‰¥0) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + 1
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, zero_lt_one, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, h'âŸ©
    exact âŸ¨Î´, h', fun t ht => h t f htâŸ©
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, _, _, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = fderivWithin â„ f s y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s (fderivWithin â„ f s)
      (fun x xs => (hf x xs).hasFDerivWithinAt) Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Real.toNNReal |(A n).det| + 1 : â„â‰¥0) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2
      exact ht n
    _ â‰¤ âˆ‘' n, ((Real.toNNReal |(A n).det| + 1 : â„â‰¥0) : â„â‰¥0âˆ) * 0 := by
      refine ENNReal.tsum_le_tsum fun n => mul_le_mul_left' ?_ _
      exact le_trans (measure_mono inter_subset_left) (le_of_eq hs)
    _ = 0 := by simp only [tsum_zero, mul_zero]"
Mathlib/CategoryTheory/Sites/Coherent/Comparison.lean,CategoryTheory.extensive_regular_generate_coherent,extensive_regular_generate_coherent,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  ext B S
  refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©
  Â· induction h with
    | of Y T hT =>
      apply Coverage.saturate.of
      simp only [Coverage.sup_covering, Set.mem_union] at hT
      exact Or.elim hT
        (fun âŸ¨Î±, x, X, Ï€, âŸ¨h, _âŸ©âŸ© â†¦ âŸ¨Î±, x, X, Ï€, âŸ¨h, inferInstanceâŸ©âŸ©)
        (fun âŸ¨Z, f, âŸ¨h, _âŸ©âŸ© â†¦ âŸ¨Unit, inferInstance, fun _ â†¦ Z, fun _ â†¦ f, âŸ¨h, inferInstanceâŸ©âŸ©)
    | top => apply Coverage.saturate.top
    | transitive Y T => apply Coverage.saturate.transitive Y T<;> [assumption; assumption]
  Â· induction h with
    | of Y T hT =>
      obtain âŸ¨I, hI, X, f, âŸ¨h, hTâŸ©âŸ© := hT
      let Ï† := fun (i : I) â†¦ Sigma.Î¹ X i
      let F := Sigma.desc f
      let Z := Sieve.generate T
      let Xs := (âˆ fun (i : I) => X i)
      let Zf := Sieve.generate (Presieve.ofArrows (fun (_ : Unit) â†¦ Xs) (fun (_ : Unit) â†¦ F))
      apply Coverage.saturate.transitive Y Zf
      Â· apply Coverage.saturate.of
        simp only [Coverage.sup_covering, extensiveCoverage, regularCoverage, Set.mem_union,
          Set.mem_setOf_eq]
        exact Or.inr âŸ¨Xs, F, âŸ¨rfl, inferInstanceâŸ©âŸ©
      Â· intro R g hZfg
        dsimp at hZfg
        rw [Presieve.ofArrows_pUnit] at hZfg
        obtain âŸ¨W, Ïˆ, Ïƒ, âŸ¨hW, hW'âŸ©âŸ© := hZfg
        induction hW
        rw [â† hW', Sieve.pullback_comp Z]
        suffices Sieve.pullback Ïˆ ((Sieve.pullback F) Z) âˆˆ GrothendieckTopology.sieves
          ((extensiveCoverage C) âŠ” (regularCoverage C)).toGrothendieck R by assumption
        apply GrothendieckTopology.pullback_stable'
        suffices Sieve.generate (Presieve.ofArrows X Ï†) â‰¤ Z.pullback F by
          apply Coverage.saturate_of_superset _ this
          apply Coverage.saturate.of
          simp only [Coverage.sup_covering, extensiveCoverage, regularCoverage, Set.mem_union,
            Set.mem_setOf_eq]
          refine Or.inl âŸ¨I, hI, X, Ï†, âŸ¨rfl, ?_âŸ©âŸ©
          suffices Sigma.desc Ï† = ğŸ™ _ by rw [this]; infer_instance
          ext
          simp only [colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app, Category.comp_id]
        intro Q q hq
        simp only [Sieve.pullback_apply, Sieve.generate_apply]
        simp only [Sieve.generate_apply] at hq
        obtain âŸ¨E, e, r, hqâŸ© := hq
        refine' âŸ¨E, e, r â‰« F, âŸ¨_, _âŸ©âŸ©
        Â· rw [h]
          induction hq.1
          simp only [colimit.Î¹_desc, Cofan.mk_pt, Cofan.mk_Î¹_app]
          exact Presieve.ofArrows.mk _
        Â· rw [â† hq.2]
          simp only [Category.assoc]
    | top => apply Coverage.saturate.top
    | transitive Y T => apply Coverage.saturate.transitive Y T<;> [assumption; assumption]",error:  dsimp made no progress,"theorem extensive_regular_generate_coherent [Preregular C] [FinitaryPreExtensive C] :
    ((extensiveCoverage C) âŠ” (regularCoverage C)).toGrothendieck =
    (coherentTopology C) ",":= by
  ext B S
  refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©
  Â· induction h with
    | of Y T hT =>
      apply Coverage.saturate.of
      simp only [Coverage.sup_covering, Set.mem_union] at hT
      exact Or.elim hT
        (fun âŸ¨Î±, x, X, Ï€, âŸ¨h, _âŸ©âŸ© â†¦ âŸ¨Î±, x, X, Ï€, âŸ¨h, inferInstanceâŸ©âŸ©)
        (fun âŸ¨Z, f, âŸ¨h, _âŸ©âŸ© â†¦ âŸ¨Unit, inferInstance, fun _ â†¦ Z, fun _ â†¦ f, âŸ¨h, inferInstanceâŸ©âŸ©)
    | top => apply Coverage.saturate.top
    | transitive Y T => apply Coverage.saturate.transitive Y T<;> [assumption; assumption]
  Â· induction h with
    | of Y T hT =>
      obtain âŸ¨I, _, X, f, rfl, hTâŸ© := hT
      apply Coverage.saturate.transitive Y (generate (Presieve.ofArrows
        (fun (_ : Unit) â†¦ (âˆ fun (i : I) => X i)) (fun (_ : Unit) â†¦ Sigma.desc f)))
      Â· apply Coverage.saturate.of
        simp only [Coverage.sup_covering, extensiveCoverage, regularCoverage, Set.mem_union,
          Set.mem_setOf_eq]
        exact Or.inr âŸ¨_, Sigma.desc f, âŸ¨rfl, inferInstanceâŸ©âŸ©
      Â· rintro R g âŸ¨W, Ïˆ, Ïƒ, âŸ¨âŸ©, rflâŸ©
        change _ âˆˆ sieves ((extensiveCoverage C) âŠ” (regularCoverage C)).toGrothendieck _
        rw [Sieve.pullback_comp]
        apply pullback_stable'
        have : generate (Presieve.ofArrows X fun (i : I) â†¦ Sigma.Î¹ X i) â‰¤
            (generate (Presieve.ofArrows X f)).pullback (Sigma.desc f) := by
          rintro Q q âŸ¨E, e, r, âŸ¨hq, rflâŸ©âŸ©
          exact âŸ¨E, e, r â‰« (Sigma.desc f), by cases hq; simpa using Presieve.ofArrows.mk _, by simpâŸ©
        apply Coverage.saturate_of_superset _ this
        apply Coverage.saturate.of
        refine Or.inl âŸ¨I, inferInstance, _, _, âŸ¨rfl, ?_âŸ©âŸ©
        convert IsIso.id _
        aesop
    | top => apply Coverage.saturate.top
    | transitive Y T => apply Coverage.saturate.transitive Y T<;> [assumption; assumption]"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.aemeasurable_fderivWithin,aemeasurable_fderivWithin,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine aemeasurable_of_unif_approx fun Îµ Îµpos => ?_
  let Î´ : â„â‰¥0 := âŸ¨Îµ, le_of_lt ÎµposâŸ©
  have Î´pos : 0 < Î´ := Îµpos
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, _âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) Î´) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Î´) fun _ =>
      Î´pos.ne'
  obtain âŸ¨g, g_meas, hgâŸ© :
      âˆƒ g : E â†’ E â†’L[â„] E, Measurable g âˆ§ âˆ€ (n : â„•) (x : E), x âˆˆ t n â†’ g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine âŸ¨g, g_meas.aemeasurable, ?_âŸ©
  suffices H : âˆ€áµ x : E âˆ‚sum fun n â†¦ Î¼.restrict (s âˆ© t n), dist (g x) (f' x) â‰¤ Îµ by
    have : Î¼.restrict s â‰¤ sum fun n => Î¼.restrict (s âˆ© t n) := by
      have : s = â‹ƒ n, s âˆ© t n := by
        rw [â† inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left _ _)
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have Eâ‚ : âˆ€áµ x : E âˆ‚Î¼.restrict (s âˆ© t n), â€–f' x - A nâ€–â‚Š â‰¤ Î´ :=
    (ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono (inter_subset_left _ _)
  have Eâ‚‚ : âˆ€áµ x : E âˆ‚Î¼.restrict (s âˆ© t n), g x = A n := by
    suffices H : âˆ€áµ x : E âˆ‚Î¼.restrict (t n), g x = A n from
      ae_mono (restrict_mono (inter_subset_right _ _) le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [Eâ‚, Eâ‚‚] with x hx1 hx2
  rw [â† nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1","error:  function expected at
  inter_subset_left ?m.375907
term has type
  ?m.375906 âˆˆ ?m.375904
error:  function expected at
  inter_subset_left ?m.377059
term has type
  ?m.377058 âˆˆ ?m.377056
error:  function expected at
  inter_subset_right ?m.377638
term has type
  ?m.377637 âˆˆ ?m.377636","theorem aemeasurable_fderivWithin (hs : MeasurableSet s)
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) : AEMeasurable f' (Î¼.restrict s) ",":= by
  refine aemeasurable_of_unif_approx fun Îµ Îµpos => ?_
  let Î´ : â„â‰¥0 := âŸ¨Îµ, le_of_lt ÎµposâŸ©
  have Î´pos : 0 < Î´ := Îµpos
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, _âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) Î´) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Î´) fun _ =>
      Î´pos.ne'
  obtain âŸ¨g, g_meas, hgâŸ© :
      âˆƒ g : E â†’ E â†’L[â„] E, Measurable g âˆ§ âˆ€ (n : â„•) (x : E), x âˆˆ t n â†’ g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine âŸ¨g, g_meas.aemeasurable, ?_âŸ©
  suffices H : âˆ€áµ x : E âˆ‚sum fun n â†¦ Î¼.restrict (s âˆ© t n), dist (g x) (f' x) â‰¤ Îµ by
    have : Î¼.restrict s â‰¤ sum fun n => Î¼.restrict (s âˆ© t n) := by
      have : s = â‹ƒ n, s âˆ© t n := by
        rw [â† inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have Eâ‚ : âˆ€áµ x : E âˆ‚Î¼.restrict (s âˆ© t n), â€–f' x - A nâ€–â‚Š â‰¤ Î´ :=
    (ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have Eâ‚‚ : âˆ€áµ x : E âˆ‚Î¼.restrict (s âˆ© t n), g x = A n := by
    suffices H : âˆ€áµ x : E âˆ‚Î¼.restrict (t n), g x = A n from
      ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [Eâ‚, Eâ‚‚] with x hx1 hx2
  rw [â† nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1"
Mathlib/Probability/Kernel/RadonNikodym.lean,ProbabilityTheory.kernel.measurable_rnDerivAux,measurable_rnDerivAux,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  measurable_density _ Î· MeasurableSet.univ","error:  failed to synthesize
  MeasurableSpace.CountablyGenerated Î³
use `set_option diagnostics true` to get diagnostic information","lemma measurable_rnDerivAux (Îº Î· : kernel Î± Î³) :
    Measurable (fun p : Î± Ã— Î³ â†¦ kernel.rnDerivAux Îº Î· p.1 p.2) ",":= by
  simp_rw [rnDerivAux]
  split_ifs with hÎ±
  Â· refine Measurable.ennreal_toReal ?_
    change Measurable ((fun q : Î³ Ã— Î± â†¦ (Îº q.2).rnDeriv (Î· q.2) q.1) âˆ˜ Prod.swap)
    refine (measurable_from_prod_countable' (fun a â†¦ ?_) ?_).comp measurable_swap
    Â· exact Measure.measurable_rnDeriv (Îº a) (Î· a)
    Â· intro a a' c ha'_mem_a
      have h_eq : âˆ€ Îº : kernel Î± Î³, Îº a' = Îº a := fun Îº â†¦ by
        ext s hs
        exact mem_of_mem_measurableAtom ha'_mem_a
          (kernel.measurable_coe Îº hs (measurableSet_singleton (Îº a s))) rfl
      rw [h_eq Îº, h_eq Î·]
  Â· have := hÎ±Î³.countableOrCountablyGenerated.resolve_left hÎ±
    exact measurable_density _ Î· MeasurableSet.univ"
Mathlib/RingTheory/PowerSeries/Trunc.lean,PowerSeries.trunc_coe_eq_self,trunc_coe_eq_self,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [â† Polynomial.coe_inj]
  ext m
  rw [coeff_coe, coeff_trunc]
  split
  case inl h => rfl
  case inr h =>
    rw [not_lt] at h
    rw [coeff_coe]; symm
    exact coeff_eq_zero_of_natDegree_lt <| lt_of_lt_of_le hn h","error:  Case tag 'inl' not found.

Available tags: 'h.isTrue', 'h.isFalse'",theorem trunc_coe_eq_self {n} {f : R[X]} (hn : natDegree f < n) : trunc n (f : RâŸ¦XâŸ§) = f ,":= by
  rw [â† Polynomial.coe_inj]
  ext m
  rw [coeff_coe, coeff_trunc]
  split
  case isTrue h => rfl
  case isFalse h =>
    rw [not_lt] at h
    rw [coeff_coe]; symm
    exact coeff_eq_zero_of_natDegree_lt <| lt_of_lt_of_le hn h"
Mathlib/RingTheory/DiscreteValuationRing/TFAE.lean,tfae_of_isNoetherianRing_of_localRing_of_isDomain,tfae_of_isNoetherianRing_of_localRing_of_isDomain,415d6b952a0c6bc1221dd68bc6ae84a0390ea21f,":= by
  tfae
    1 â†’ 2 := fun _ â†¦ inferInstance
    2 â†’ 1 := fun _ â†¦ ((IsBezout.TFAE (R := R)).out 0 1).mp â€¹_â€º
    1 â†’ 4
    | H => âŸ¨inferInstance, fun P hP hP' â†¦ eq_maximalIdeal (hP'.isMaximal hP)âŸ©
    4 â†’ 3
    | âŸ¨hâ‚, hâ‚‚âŸ© => { hâ‚ with maximalOfPrime := (hâ‚‚ _ Â· Â· â–¸ maximalIdeal.isMaximal R) }
    3 â†’ 5 := fun h â†¦ maximalIdeal_isPrincipal_of_isDedekindDomain R
    6 â†” 5 := finrank_cotangentSpace_le_one_iff
    5 â†’ 7 := exists_maximalIdeal_pow_eq_of_principal R
    7 â†’ 2 := by
      rw [ValuationRing.iff_ideal_total]
      intro H
      constructor
      intro I J
      let _ := Classical.decEq (Ideal R)
      by_cases hI : I = âŠ¥; Â· subst hI; left; exact bot_le
      by_cases hJ : J = âŠ¥; Â· subst hJ; right; exact bot_le
      obtain âŸ¨n, rflâŸ© := H I hI
      obtain âŸ¨m, rflâŸ© := H J hJ
      exact (le_total m n).imp Ideal.pow_le_pow_right Ideal.pow_le_pow_right","error:  unknown tactic
error:  unsolved goals
R : Type u_1
instâœâ¶ : CommRing R
K : Type u_2
instâœâµ : Field K
instâœâ´ : Algebra R K
instâœÂ³ : IsFractionRing R K
instâœÂ² : IsNoetherianRing R
instâœÂ¹ : LocalRing R
instâœ : IsDomain R
âŠ¢ [IsPrincipalIdealRing R, ValuationRing R, IsDedekindDomain R,
      IsIntegrallyClosed R âˆ§ âˆ€ (P : Ideal R), P â‰  âŠ¥ â†’ P.IsPrime â†’ P = maximalIdeal R,
      Submodule.IsPrincipal (maximalIdeal R), finrank (ResidueField R) (CotangentSpace R) â‰¤ 1,
      âˆ€ (I : Ideal R), I â‰  âŠ¥ â†’ âˆƒ n, I = maximalIdeal R ^ n].TFAE","theorem tfae_of_isNoetherianRing_of_localRing_of_isDomain
    [IsNoetherianRing R] [LocalRing R] [IsDomain R] :
    List.TFAE
      [IsPrincipalIdealRing R, ValuationRing R, IsDedekindDomain R,
        IsIntegrallyClosed R âˆ§ âˆ€ P : Ideal R, P â‰  âŠ¥ â†’ P.IsPrime â†’ P = maximalIdeal R,
        (maximalIdeal R).IsPrincipal,
        finrank (ResidueField R) (CotangentSpace R) â‰¤ 1,
        âˆ€ (I) (_ : I â‰  âŠ¥), âˆƒ n : â„•, I = maximalIdeal R ^ n] ",":= by
  tfae_have 1 â†’ 2
  Â· exact fun _ â†¦ inferInstance
  tfae_have 2 â†’ 1
  Â· exact fun _ â†¦ ((IsBezout.TFAE (R := R)).out 0 1).mp â€¹_â€º
  tfae_have 1 â†’ 4
  Â· intro H
    exact âŸ¨inferInstance, fun P hP hP' â†¦ eq_maximalIdeal (hP'.isMaximal hP)âŸ©
  tfae_have 4 â†’ 3
  Â· exact fun âŸ¨hâ‚, hâ‚‚âŸ© â†¦ { hâ‚ with maximalOfPrime := (hâ‚‚ _ Â· Â· â–¸ maximalIdeal.isMaximal R) }
  tfae_have 3 â†’ 5
  Â· exact fun h â†¦ maximalIdeal_isPrincipal_of_isDedekindDomain R
  tfae_have 6 â†” 5
  Â· exact finrank_cotangentSpace_le_one_iff
  tfae_have 5 â†’ 7
  Â· exact exists_maximalIdeal_pow_eq_of_principal R
  tfae_have 7 â†’ 2
  Â· rw [ValuationRing.iff_ideal_total]
    intro H
    constructor
    intro I J
    let _ := Classical.decEq (Ideal R)
    by_cases hI : I = âŠ¥; Â· subst hI; left; exact bot_le
    by_cases hJ : J = âŠ¥; Â· subst hJ; right; exact bot_le
    obtain âŸ¨n, rflâŸ© := H I hI
    obtain âŸ¨m, rflâŸ© := H J hJ
    exact (le_total m n).imp Ideal.pow_le_pow_right Ideal.pow_le_pow_right
  tfae_finish"
Mathlib/Data/Set/NAry.lean,Set.image2_distrib_subset_right,image2_distrib_subset_right,40d7ce18c4ab0f4427db2ca13c8c175781a09a5b,":= by
  rintro _ âŸ¨_, c, âŸ¨a, b, ha, hb, rflâŸ©, hc, rflâŸ©
  rw [h_distrib]
  exact mem_image2_of_mem (mem_image2_of_mem ha hc) (mem_image2_of_mem hb hc)",error:  rcases tactic failed: wâœ : Î³ is not an inductive datatype,"theorem image2_distrib_subset_right {f : Î´ â†’ Î³ â†’ Îµ} {g : Î± â†’ Î² â†’ Î´} {fâ‚ : Î± â†’ Î³ â†’ Î±'}
    {fâ‚‚ : Î² â†’ Î³ â†’ Î²'} {g' : Î±' â†’ Î²' â†’ Îµ} (h_distrib : âˆ€ a b c, f (g a b) c = g' (fâ‚ a c) (fâ‚‚ b c)) :
    image2 f (image2 g s t) u âŠ† image2 g' (image2 fâ‚ s u) (image2 fâ‚‚ t u) ",":= by
  rintro _ âŸ¨_, âŸ¨a, ha, b, hb, rflâŸ©, c, hc, rflâŸ©
  rw [h_distrib]
  exact mem_image2_of_mem (mem_image2_of_mem ha hc) (mem_image2_of_mem hb hc)"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicAt.order_eq_int_iff,order_eq_int_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  unfold order
  by_cases h : hf.choose_spec.order = âŠ¤
  Â· rw [h, WithTop.map_top, â† WithTop.coe_natCast, WithTop.top_sub_coe,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun âŸ¨g, hg_an, hg_ne, hg_eqâŸ© â†¦ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, â† AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq âŠ¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, â† mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  Â· obtain âŸ¨m, hâŸ© := WithTop.ne_top_iff_exists.mp h
    rw [â† h, WithTop.map_coe, â† WithTop.coe_natCast, â† WithTop.coe_sub, WithTop.coe_inj]
    obtain âŸ¨g, hg_an, hg_ne, hg_eqâŸ© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : âˆ€á¶  (z : ğ•œ) in ğ“[â‰ ] x, f z = (z - x) ^ (â†‘m - â†‘hf.choose : â„¤) â€¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [â† smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), â† mul_smul,
        â† zpow_addâ‚€ (sub_ne_zero.mpr hz), â† add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact âŸ¨fun h â†¦ âŸ¨g, hg_an, hg_ne, h â–¸ hg_eqâŸ©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero âŸ¨g, hg_an, hg_ne, hg_eqâŸ©âŸ©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  âŠ¤ - â†‘?m.79514
case pos
ğ•œ : Type u_1
instâœÂ² : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace ğ•œ E
f : ğ•œ â†’ E
x : ğ•œ
hf : MeromorphicAt f x
n : â„¤
h : â‹¯.order = âŠ¤
âŠ¢ âŠ¤ - â†‘â†‘(Exists.choose hf) = â†‘n â†” âˆƒ g, AnalyticAt ğ•œ g x âˆ§ g x â‰  0 âˆ§ âˆ€á¶  (z : ğ•œ) in ğ“[â‰ ] x, f z = (z - x) ^ n â€¢ g z
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â†‘?m.80098 - â†‘?m.80099
case neg.intro
ğ•œ : Type u_1
instâœÂ² : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace ğ•œ E
f : ğ•œ â†’ E
x : ğ•œ
hf : MeromorphicAt f x
n : â„¤
hâœ : Â¬â‹¯.order = âŠ¤
m : â„•
h : â†‘m = â‹¯.order
âŠ¢ â†‘â†‘m - â†‘â†‘(Exists.choose hf) = â†‘n â†” âˆƒ g, AnalyticAt ğ•œ g x âˆ§ g x â‰  0 âˆ§ âˆ€á¶  (z : ğ•œ) in ğ“[â‰ ] x, f z = (z - x) ^ n â€¢ g z","lemma order_eq_int_iff {f : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) (n : â„¤) : hf.order = n â†”
    âˆƒ g : ğ•œ â†’ E, AnalyticAt ğ•œ g x âˆ§ g x â‰  0 âˆ§ âˆ€á¶  z in ğ“[â‰ ] x, f z = (z - x) ^ n â€¢ g z ",":= by
  unfold order
  by_cases h : hf.choose_spec.order = âŠ¤
  Â· rw [h, WithTop.map_top, â† WithTop.coe_natCast, top_sub,
      eq_false_intro WithTop.top_ne_coe, false_iff]
    rw [AnalyticAt.order_eq_top_iff] at h
    refine fun âŸ¨g, hg_an, hg_ne, hg_eqâŸ© â†¦ hg_ne ?_
    apply EventuallyEq.eq_of_nhds
    rw [EventuallyEq, â† AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]
    apply Eventually.frequently
    rw [eventually_nhdsWithin_iff] at hg_eq âŠ¢
    filter_upwards [h, hg_eq] with z hfz hfz_eq hz
    rwa [hfz_eq hz, â† mul_smul, smul_eq_zero_iff_right] at hfz
    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))
  Â· obtain âŸ¨m, hâŸ© := WithTop.ne_top_iff_exists.mp h
    rw [â† h, WithTop.map_coe, â† WithTop.coe_natCast, â† coe_sub, WithTop.coe_inj]
    obtain âŸ¨g, hg_an, hg_ne, hg_eqâŸ© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm
    replace hg_eq : âˆ€á¶  (z : ğ•œ) in ğ“[â‰ ] x, f z = (z - x) ^ (â†‘m - â†‘hf.choose : â„¤) â€¢ g z := by
      rw [eventually_nhdsWithin_iff]
      filter_upwards [hg_eq] with z hg_eq hz
      rwa [â† smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), â† mul_smul,
        â† zpow_addâ‚€ (sub_ne_zero.mpr hz), â† add_sub_assoc, add_sub_cancel_left, zpow_natCast,
        zpow_natCast]
    exact âŸ¨fun h â†¦ âŸ¨g, hg_an, hg_ne, h â–¸ hg_eqâŸ©,
      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero âŸ¨g, hg_an, hg_ne, hg_eqâŸ©âŸ©"
Mathlib/Geometry/Manifold/ContMDiffMFDeriv.lean,ContMDiffOn.contMDiffOn_tangentMapWithin,ContMDiffOn.contMDiffOn_tangentMapWithin,f3695eb20c685cfcb5e45f75b1e68a59b8de7efb,":= by
  have m_le_n : m â‰¤ n := (le_add_right le_rfl).trans hmn
  have one_le_n : 1 â‰¤ n := (le_add_left le_rfl).trans hmn
  have U' : UniqueDiffOn ğ•œ (range I âˆ© I.symm â»Â¹' s) := fun y hy â†¦ by
    simpa only [UniqueMDiffOn, UniqueMDiffWithinAt, hy.1, inter_comm, mfld_simps]
      using hs (I.symm y) hy.2
  rw [contMDiffOn_iff]
  refine' âŸ¨hf.continuousOn_tangentMapWithin_aux one_le_n hs, fun p q => _âŸ©
  suffices h :
    ContDiffOn ğ•œ m
      (((fun p : H' Ã— E' => (I' p.fst, p.snd)) âˆ˜ TotalSpace.toProd H' E') âˆ˜
        tangentMapWithin I I' f s âˆ˜
          (TotalSpace.toProd H E).symm âˆ˜ fun p : E Ã— E => (I.symm p.fst, p.snd))
      ((range I âˆ© I.symm â»Â¹' s) Ã—Ë¢ univ)
  Â· 
    convert h using 1
    Â· ext1 âŸ¨x, yâŸ©
      simp only [mfld_simps]; rfl
    Â· simp only [mfld_simps]
      rw [inter_prod, prod_univ, prod_univ]
      rfl
  change
    ContDiffOn ğ•œ m
      (fun p : E Ã— E =>
        ((I' (f (I.symm p.fst)), (mfderivWithin I I' f s (I.symm p.fst) : E â†’ E') p.snd) : E' Ã— E'))
      ((range I âˆ© I.symm â»Â¹' s) Ã—Ë¢ univ)
  have hf' := contMDiffOn_iff.1 hf
  have A : ContDiffOn ğ•œ m (I' âˆ˜ f âˆ˜ I.symm) (range I âˆ© I.symm â»Â¹' s) := by
    simpa only [mfld_simps] using (hf'.2 (I.symm 0) (I'.symm 0)).of_le m_le_n
  have B : ContDiffOn ğ•œ m
      ((I' âˆ˜ f âˆ˜ I.symm) âˆ˜ Prod.fst) ((range I âˆ© I.symm â»Â¹' s) Ã—Ë¢ (univ : Set E)) :=
    A.comp contDiff_fst.contDiffOn (prod_subset_preimage_fst _ _)
  suffices C :
    ContDiffOn ğ•œ m
      (fun p : E Ã— E => (fderivWithin ğ•œ (I' âˆ˜ f âˆ˜ I.symm) (I.symm â»Â¹' s âˆ© range I) p.1 : _) p.2)
      ((range I âˆ© I.symm â»Â¹' s) Ã—Ë¢ (univ : Set E))
  Â· refine ContDiffOn.prod B ?_
    refine C.congr fun p hp => ?_
    simp only [mfld_simps] at hp
    simp only [mfderivWithin, hf.mdifferentiableOn one_le_n _ hp.2, hp.1, if_pos, mfld_simps]
  have D :
    ContDiffOn ğ•œ m (fun x => fderivWithin ğ•œ (I' âˆ˜ f âˆ˜ I.symm) (I.symm â»Â¹' s âˆ© range I) x)
      (range I âˆ© I.symm â»Â¹' s) := by
    have : ContDiffOn ğ•œ n (I' âˆ˜ f âˆ˜ I.symm) (range I âˆ© I.symm â»Â¹' s) := by
      simpa only [mfld_simps] using hf'.2 (I.symm 0) (I'.symm 0)
    simpa only [inter_comm] using this.fderivWithin U' hmn
  refine ContDiffOn.clm_apply ?_ contDiffOn_snd
  exact D.comp contDiff_fst.contDiffOn (prod_subset_preimage_fst _ _)",error:  unexpected token 'Â·'; expected 'by' or 'from',"theorem ContMDiffOn.contMDiffOn_tangentMapWithin_aux {f : H â†’ H'} {s : Set H}
    (hf : ContMDiffOn I I' n f s) (hmn : m + 1 â‰¤ n) (hs : UniqueMDiffOn I s) :
    ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s)
      (Ï€ E (TangentSpace I) â»Â¹' s) ",":= by
  have m_le_n : m â‰¤ n := (le_add_right le_rfl).trans hmn
  have one_le_n : 1 â‰¤ n := (le_add_left le_rfl).trans hmn
  have U' : UniqueDiffOn ğ•œ (range I âˆ© I.symm â»Â¹' s) := fun y hy â†¦ by
    simpa only [UniqueMDiffOn, UniqueMDiffWithinAt, hy.1, inter_comm, mfld_simps]
      using hs (I.symm y) hy.2
  rw [contMDiffOn_iff]
  refine âŸ¨hf.continuousOn_tangentMapWithin_aux one_le_n hs, fun p q => ?_âŸ©
  suffices h :
    ContDiffOn ğ•œ m
      (((fun p : H' Ã— E' => (I' p.fst, p.snd)) âˆ˜ TotalSpace.toProd H' E') âˆ˜
        tangentMapWithin I I' f s âˆ˜
          (TotalSpace.toProd H E).symm âˆ˜ fun p : E Ã— E => (I.symm p.fst, p.snd))
      ((range I âˆ© I.symm â»Â¹' s) Ã—Ë¢ univ) by
    convert h using 1
    Â· ext1 âŸ¨x, yâŸ©
      simp only [mfld_simps]; rfl
    Â· simp only [mfld_simps]
      rw [inter_prod, prod_univ, prod_univ]
      rfl
  change
    ContDiffOn ğ•œ m
      (fun p : E Ã— E =>
        ((I' (f (I.symm p.fst)), (mfderivWithin I I' f s (I.symm p.fst) : E â†’ E') p.snd) : E' Ã— E'))
      ((range I âˆ© I.symm â»Â¹' s) Ã—Ë¢ univ)
  have hf' := contMDiffOn_iff.1 hf
  have A : ContDiffOn ğ•œ m (I' âˆ˜ f âˆ˜ I.symm) (range I âˆ© I.symm â»Â¹' s) := by
    simpa only [mfld_simps] using (hf'.2 (I.symm 0) (I'.symm 0)).of_le m_le_n
  have B : ContDiffOn ğ•œ m
      ((I' âˆ˜ f âˆ˜ I.symm) âˆ˜ Prod.fst) ((range I âˆ© I.symm â»Â¹' s) Ã—Ë¢ (univ : Set E)) :=
    A.comp contDiff_fst.contDiffOn (prod_subset_preimage_fst _ _)
  suffices C :
    ContDiffOn ğ•œ m
      (fun p : E Ã— E => (fderivWithin ğ•œ (I' âˆ˜ f âˆ˜ I.symm) (I.symm â»Â¹' s âˆ© range I) p.1 : _) p.2)
      ((range I âˆ© I.symm â»Â¹' s) Ã—Ë¢ (univ : Set E)) by
    refine ContDiffOn.prod B ?_
    refine C.congr fun p hp => ?_
    simp only [mfld_simps] at hp
    simp only [mfderivWithin, hf.mdifferentiableOn one_le_n _ hp.2, hp.1, if_pos, mfld_simps]
    rfl
  have D :
    ContDiffOn ğ•œ m (fun x => fderivWithin ğ•œ (I' âˆ˜ f âˆ˜ I.symm) (I.symm â»Â¹' s âˆ© range I) x)
      (range I âˆ© I.symm â»Â¹' s) := by
    have : ContDiffOn ğ•œ n (I' âˆ˜ f âˆ˜ I.symm) (range I âˆ© I.symm â»Â¹' s) := by
      simpa only [mfld_simps] using hf'.2 (I.symm 0) (I'.symm 0)
    simpa only [inter_comm] using this.fderivWithin U' hmn
  refine ContDiffOn.clm_apply ?_ contDiffOn_snd
  exact D.comp contDiff_fst.contDiffOn (prod_subset_preimage_fst _ _)"
Mathlib/CategoryTheory/Localization/Predicate.lean,CategoryTheory.Functor.IsLocalization.of_equivalence_target,of_equivalence_target,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have h : W.IsInvertedBy L' := by
    rw [â† MorphismProperty.IsInvertedBy.iff_of_iso W e]
    exact MorphismProperty.IsInvertedBy.of_comp W L (Localization.inverts L W) eq.functor
  let Fâ‚ := Localization.Construction.lift L (Localization.inverts L W)
  let Fâ‚‚ := Localization.Construction.lift L' h
  let e' : Fâ‚ â‹™ eq.functor â‰… Fâ‚‚ := liftNatIso W.Q W (L â‹™ eq.functor) L' _ _ e
  exact
    { inverts := h
      nonempty_isEquivalence := Nonempty.intro (IsEquivalence.ofIso e' inferInstance) }",error:  'nonempty_isEquivalence' is not a field of structure 'CategoryTheory.Functor.IsLocalization',"theorem of_equivalence_target {E : Type*} [Category E] (L' : C â¥¤ E) (eq : D â‰Œ E)
    [L.IsLocalization W] (e : L â‹™ eq.functor â‰… L') : L'.IsLocalization W ",":= by
  have h : W.IsInvertedBy L' := by
    rw [â† MorphismProperty.IsInvertedBy.iff_of_iso W e]
    exact MorphismProperty.IsInvertedBy.of_comp W L (Localization.inverts L W) eq.functor
  let Fâ‚ := Localization.Construction.lift L (Localization.inverts L W)
  let Fâ‚‚ := Localization.Construction.lift L' h
  let e' : Fâ‚ â‹™ eq.functor â‰… Fâ‚‚ := liftNatIso W.Q W (L â‹™ eq.functor) L' _ _ e
  exact
    { inverts := h
      isEquivalence := Functor.isEquivalence_of_iso e' }"
Mathlib/Data/List/InsertNth.lean,List.length_insertNth_le_succ,length_insertNth_le_succ,df9cfef55a1b8cd650f6575f7f576b85ef124030,":= by
  rcases (Nat.lt_or_ge l.length n).symm with hn | hn
  Â· rw [length_insertNth _ _ hn]
    exact Nat.le_refl _
  Â· rw [insertNth_of_length_lt _ _ _ hn]
    exact Nat.le_of_lt (Nat.lt_succ_self _)","error:  no goals to be solved
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  try 'simp' instead of 'simpa'
note: this linter can be disabled with `set_option linter.unnecessarySimpa false`
warning:  try 'simp at h' instead of 'simpa using h'
note: this linter can be disabled with `set_option linter.unnecessarySimpa false`
warning:  try 'simp at h' instead of 'simpa using h'
note: this linter can be disabled with `set_option linter.unnecessarySimpa false`","theorem length_insertNth_le_succ (l : List Î±) (x : Î±) (n : â„•) :
    (insertNth n x l).length â‰¤ l.length + 1 ",":= by
  rcases le_or_lt n l.length with hn | hn
  Â· rw [length_insertNth _ _ hn]
  Â· rw [insertNth_of_length_lt _ _ _ hn]
    exact (Nat.lt_succ_self _).le"
Mathlib/Analysis/SpecialFunctions/Complex/LogBounds.lean,Complex.norm_log_sub_logTaylor_le,norm_log_sub_logTaylor_le,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  have help : IntervalIntegrable (fun t : â„ â†¦ t ^ n * (1 - â€–zâ€–)â»Â¹) MeasureTheory.volume 0 1 :=
    IntervalIntegrable.mul_const (Continuous.intervalIntegrable (by continuity) 0 1) (1 - â€–zâ€–)â»Â¹
  let f (z : â„‚) : â„‚ := log (1 + z) - logTaylor (n + 1) z
  let f' (z : â„‚) : â„‚ := (-z) ^ n * (1 + z)â»Â¹
  have hderiv : âˆ€ t âˆˆ Set.Icc (0 : â„) 1, HasDerivAt f (f' (0 + t * z)) (0 + t * z) := by
    intro t ht
    rw [zero_add]
    exact hasDerivAt_log_sub_logTaylor n <|
      StarConvex.add_smul_mem starConvex_one_slitPlane (mem_slitPlane_of_norm_lt_one hz) ht.1 ht.2
  have hcont : ContinuousOn (fun t : â„ â†¦ f' (0 + t * z)) (Set.Icc 0 1) := by
    simp only [zero_add, zero_le_one, not_true_eq_false]
    exact (Continuous.continuousOn (by continuity)).mul <|
      continuousOn_one_add_mul_inv <| mem_slitPlane_of_norm_lt_one hz
  have H : f z = z * âˆ« t in (0 : â„)..1, (-(t * z)) ^ n * (1 + t * z)â»Â¹ := by
    convert (integral_unitInterval_deriv_eq_sub hcont hderiv).symm using 1
    Â· simp only [zero_add, add_zero, log_one, logTaylor_at_zero, sub_self, sub_zero]
    Â· simp only [add_zero, log_one, logTaylor_at_zero, sub_self, real_smul, zero_add, smul_eq_mul]
  simp only [H, norm_mul]
  simp_rw [neg_pow (_ * z) n, mul_assoc, intervalIntegral.integral_const_mul, mul_pow,
    mul_comm _ (z ^ n), mul_assoc, intervalIntegral.integral_const_mul, norm_mul, norm_pow,
    norm_neg, norm_one, one_pow, one_mul, â† mul_assoc, â† pow_succ, mul_div_assoc]
  refine mul_le_mul_of_nonneg_left ?_ (pow_nonneg (norm_nonneg z) (n + 1))
  calc â€–âˆ« t in (0 : â„)..1, (t : â„‚) ^ n * (1 + t * z)â»Â¹â€–
    _ â‰¤ âˆ« t in (0 : â„)..1, â€–(t : â„‚) ^ n * (1 + t * z)â»Â¹â€– :=
        intervalIntegral.norm_integral_le_integral_norm zero_le_one
    _ = âˆ« t in (0 : â„)..1, t ^ n * â€–(1 + t * z)â»Â¹â€– := by
        refine intervalIntegral.integral_congr <| fun t ht â†¦ ?_
        rw [Set.uIcc_of_le zero_le_one, Set.mem_Icc] at ht
        simp_rw [norm_mul, norm_pow, norm_eq_abs, abs_of_nonneg ht.1]
    _ â‰¤ âˆ« t in (0 : â„)..1, t ^ n * (1 - â€–zâ€–)â»Â¹ :=
        intervalIntegral.integral_mono_on zero_le_one
          (integrable_pow_mul_norm_one_add_mul_inv n hz) help <|
          fun t ht â†¦ mul_le_mul_of_nonneg_left (norm_one_add_mul_inv_le ht hz)
                       (pow_nonneg ((Set.mem_Icc.mp ht).1) _)
    _ = (1 - â€–zâ€–)â»Â¹ / (n + 1) := by
        rw [intervalIntegral.integral_mul_const, mul_comm, integral_pow]
        field_simp","error:  unsolved goals
case h.e'_2
n : â„•
z : â„‚
hz : â€–zâ€– < 1
help : IntervalIntegrable (fun t â†¦ t ^ n * (1 - â€–zâ€–)â»Â¹) MeasureTheory.volume 0 1
f : â„‚ â†’ â„‚ := fun z â†¦ log (1 + z) - logTaylor (n + 1) z
f' : â„‚ â†’ â„‚ := fun z â†¦ (-z) ^ n * (1 + z)â»Â¹
hderiv : âˆ€ t âˆˆ Set.Icc 0 1, HasDerivAt f (f' (0 + â†‘t * z)) (0 + â†‘t * z)
hcont : ContinuousOn (fun t â†¦ f' (0 + â†‘t * z)) (Set.Icc 0 1)
âŠ¢ f z = f z - f 0
error:  simp made no progress","lemma norm_log_sub_logTaylor_le (n : â„•) {z : â„‚} (hz : â€–zâ€– < 1) :
    â€–log (1 + z) - logTaylor (n + 1) zâ€– â‰¤ â€–zâ€– ^ (n + 1) * (1 - â€–zâ€–)â»Â¹ / (n + 1) ",":= by
  have help : IntervalIntegrable (fun t : â„ â†¦ t ^ n * (1 - â€–zâ€–)â»Â¹) MeasureTheory.volume 0 1 :=
    IntervalIntegrable.mul_const (Continuous.intervalIntegrable (by fun_prop) 0 1) (1 - â€–zâ€–)â»Â¹
  let f (z : â„‚) : â„‚ := log (1 + z) - logTaylor (n + 1) z
  let f' (z : â„‚) : â„‚ := (-z) ^ n * (1 + z)â»Â¹
  have hderiv : âˆ€ t âˆˆ Set.Icc (0 : â„) 1, HasDerivAt f (f' (0 + t * z)) (0 + t * z) := by
    intro t ht
    rw [zero_add]
    exact hasDerivAt_log_sub_logTaylor n <|
      StarConvex.add_smul_mem starConvex_one_slitPlane (mem_slitPlane_of_norm_lt_one hz) ht.1 ht.2
  have hcont : ContinuousOn (fun t : â„ â†¦ f' (0 + t * z)) (Set.Icc 0 1) := by
    simp only [zero_add, zero_le_one, not_true_eq_false]
    exact (Continuous.continuousOn (by fun_prop)).mul <|
      continuousOn_one_add_mul_inv <| mem_slitPlane_of_norm_lt_one hz
  have H : f z = z * âˆ« t in (0 : â„)..1, (-(t * z)) ^ n * (1 + t * z)â»Â¹ := by
    convert (integral_unitInterval_deriv_eq_sub hcont hderiv).symm using 1
    Â· simp only [f, zero_add, add_zero, log_one, logTaylor_at_zero, sub_self, sub_zero]
    Â· simp only [add_zero, log_one, logTaylor_at_zero, sub_self, real_smul, zero_add, smul_eq_mul]
  unfold_let f at H
  simp only [H, norm_mul]
  simp_rw [neg_pow (_ * z) n, mul_assoc, intervalIntegral.integral_const_mul, mul_pow,
    mul_comm _ (z ^ n), mul_assoc, intervalIntegral.integral_const_mul, norm_mul, norm_pow,
    norm_neg, norm_one, one_pow, one_mul, â† mul_assoc, â† pow_succ', mul_div_assoc]
  refine mul_le_mul_of_nonneg_left ?_ (pow_nonneg (norm_nonneg z) (n + 1))
  calc â€–âˆ« t in (0 : â„)..1, (t : â„‚) ^ n * (1 + t * z)â»Â¹â€–
    _ â‰¤ âˆ« t in (0 : â„)..1, â€–(t : â„‚) ^ n * (1 + t * z)â»Â¹â€– :=
        intervalIntegral.norm_integral_le_integral_norm zero_le_one
    _ = âˆ« t in (0 : â„)..1, t ^ n * â€–(1 + t * z)â»Â¹â€– := by
        refine intervalIntegral.integral_congr <| fun t ht â†¦ ?_
        rw [Set.uIcc_of_le zero_le_one, Set.mem_Icc] at ht
        simp_rw [norm_mul, norm_pow, norm_eq_abs, abs_of_nonneg ht.1]
    _ â‰¤ âˆ« t in (0 : â„)..1, t ^ n * (1 - â€–zâ€–)â»Â¹ :=
        intervalIntegral.integral_mono_on zero_le_one
          (integrable_pow_mul_norm_one_add_mul_inv n hz) help <|
          fun t ht â†¦ mul_le_mul_of_nonneg_left (norm_one_add_mul_inv_le ht hz)
                       (pow_nonneg ((Set.mem_Icc.mp ht).1) _)
    _ = (1 - â€–zâ€–)â»Â¹ / (n + 1) := by
        rw [intervalIntegral.integral_mul_const, mul_comm, integral_pow]
        field_simp"
Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean,WeierstrassCurve.Jacobian.equiv_of_X_eq_of_Y_eq,equiv_of_X_eq_of_Y_eq,5f623dbbfb1d9c0f7f7df0c222909ea19906d81f,":= by
  use Units.mk0 _ hPz / Units.mk0 _ hQz
  simp only [smul_fin3, Units.val_div_eq_div_val, Units.val_mk0, div_pow, mul_comm, mul_div, â† hx,
    â† hy, mul_div_cancel_rightâ‚€ _ <| pow_ne_zero _ hQz, mul_div_cancel_rightâ‚€ _ hQz, fin3_def]","error:  unsolved goals
case h
R : Type u
instâœÂ¹ : CommRing R
W' : Jacobian R
F : Type v
instâœ : Field F
W : Jacobian F
P Q : Fin 3 â†’ F
hPz : P z â‰  0
hQz : Q z â‰  0
hx : P x * Q z ^ 2 = Q x * P z ^ 2
hy : P y * Q z ^ 3 = Q y * P z ^ 3
âŠ¢ (Units.mk0 (P z) hPz / Units.mk0 (Q z) hQz) â€¢ Q = P","lemma equiv_of_X_eq_of_Y_eq {P Q : Fin 3 â†’ F} (hPz : P z â‰  0) (hQz : Q z â‰  0)
    (hx : P x * Q z ^ 2 = Q x * P z ^ 2) (hy : P y * Q z ^ 3 = Q y * P z ^ 3) : P â‰ˆ Q ",":= by
  use Units.mk0 _ hPz / Units.mk0 _ hQz
  simp only [Units.smul_def, smul_fin3, Units.val_div_eq_div_val, Units.val_mk0, div_pow, mul_comm,
    mul_div, â† hx, â† hy, mul_div_cancel_rightâ‚€ _ <| pow_ne_zero _ hQz, mul_div_cancel_rightâ‚€ _ hQz,
    fin3_def]"
Mathlib/Algebra/Homology/ExactSequence.lean,CategoryTheory.ComposableArrows.isComplexâ‚‚_mk,isComplexâ‚‚_mk,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  S.isComplexâ‚‚_iff.2 w","error:  unsolved goals
C : Type u_1
instâœÂ¹ : Category.{u_2, u_1} C
instâœ : HasZeroMorphisms C
n : â„•
Sâœ : ComposableArrows C n
S : ShortComplex C
âŠ¢ S.f â‰« Precomp.map (mkâ‚ S.g) S.f 1 2 â‹¯ = 0","lemma isComplexâ‚‚_mk (S : ComposableArrows C 2) (w : S.map' 0 1 â‰« S.map' 1 2 = 0) :
    S.IsComplex ",":=
  S.isComplexâ‚‚_iff.2 w"
Mathlib/Analysis/Calculus/LHopital.lean,HasDerivAt.lhopital_zero_right_on_Ioo,lhopital_zero_right_on_Ioo,4da4e0ebfbf51ecc2e064d04970434177efdead3,":= by
  have sub : âˆ€ x âˆˆ Ioo a b, Ioo a x âŠ† Ioo a b := fun x hx =>
    Ioo_subset_Ioo (le_refl a) (le_of_lt hx.2)
  have hg : âˆ€ x âˆˆ Ioo a b, g x â‰  0 := by
    intro x hx h
    have : Tendsto g (ğ“[<] x) (ğ“ 0) := by
      rw [â† h, â† nhdsWithin_Ioo_eq_nhdsWithin_Iio hx.1]
      exact ((hgg' x hx).continuousAt.continuousWithinAt.mono <| sub x hx).tendsto
    obtain âŸ¨y, hyx, hyâŸ© : âˆƒ c âˆˆ Ioo a x, g' c = 0 :=
      exists_hasDerivAt_eq_zero' hx.1 hga this fun y hy => hgg' y <| sub x hx hy
    exact hg' y (sub x hx hyx) hy
  have : âˆ€ x âˆˆ Ioo a b, âˆƒ c âˆˆ Ioo a x, f x * g' c = g x * f' c := by
    intro x hx
    rw [â† sub_zero (f x), â† sub_zero (g x)]
    exact exists_ratio_hasDerivAt_eq_ratio_slope' g g' hx.1 f f' (fun y hy => hgg' y <| sub x hx hy)
      (fun y hy => hff' y <| sub x hx hy) hga hfa
      (tendsto_nhdsWithin_of_tendsto_nhds (hgg' x hx).continuousAt.tendsto)
      (tendsto_nhdsWithin_of_tendsto_nhds (hff' x hx).continuousAt.tendsto)
  choose! c hc using this
  have : âˆ€ x âˆˆ Ioo a b, ((fun x' => f' x' / g' x') âˆ˜ c) x = f x / g x := by
    intro x hx
    rcases hc x hx with âŸ¨hâ‚, hâ‚‚âŸ©
    field_simp [hg x hx, hg' (c x) ((sub x hx) hâ‚)]
    simp only [hâ‚‚]
    rw [mul_comm]
  have cmp : âˆ€ x âˆˆ Ioo a b, a < c x âˆ§ c x < x := fun x hx => (hc x hx).1
  rw [â† nhdsWithin_Ioo_eq_nhdsWithin_Ioi hab]
  apply tendsto_nhdsWithin_congr this
  apply hdiv.comp
  refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _
    (tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds
      (tendsto_nhdsWithin_of_tendsto_nhds tendsto_id) ?_ ?_?) _
  all_goals
    apply eventually_nhdsWithin_of_forall
    intro x hx
    have := cmp x hx
    try simp
    linarith [this]","error:  don't know how to synthesize placeholder for argument 'h2'
context:
a b : â„
hab : a < b
l : Filter â„
f f' g g' : â„ â†’ â„
hff' : âˆ€ x âˆˆ Ioo a b, HasDerivAt f (f' x) x
hgg' : âˆ€ x âˆˆ Ioo a b, HasDerivAt g (g' x) x
hg' : âˆ€ x âˆˆ Ioo a b, g' x â‰  0
hfa : Tendsto f (ğ“[>] a) (ğ“ 0)
hga : Tendsto g (ğ“[>] a) (ğ“ 0)
hdiv : Tendsto (fun x â†¦ f' x / g' x) (ğ“[>] a) l
sub : âˆ€ x âˆˆ Ioo a b, Ioo a x âŠ† Ioo a b
hg : âˆ€ x âˆˆ Ioo a b, g x â‰  0
c : â„ â†’ â„
hc : âˆ€ x âˆˆ Ioo a b, c x âˆˆ Ioo a x âˆ§ f x * g' (c x) = g x * f' (c x)
this : âˆ€ x âˆˆ Ioo a b, ((fun x' â†¦ f' x' / g' x') âˆ˜ c) x = f x / g x
cmp : âˆ€ x âˆˆ Ioo a b, a < c x âˆ§ c x < x
âŠ¢ âˆ€á¶  (x : â„) in ğ“[Ioo a b] a, c x âˆˆ Ioi a
error:  unsolved goals
a b : â„
hab : a < b
l : Filter â„
f f' g g' : â„ â†’ â„
hff' : âˆ€ x âˆˆ Ioo a b, HasDerivAt f (f' x) x
hgg' : âˆ€ x âˆˆ Ioo a b, HasDerivAt g (g' x) x
hg' : âˆ€ x âˆˆ Ioo a b, g' x â‰  0
hfa : Tendsto f (ğ“[>] a) (ğ“ 0)
hga : Tendsto g (ğ“[>] a) (ğ“ 0)
hdiv : Tendsto (fun x â†¦ f' x / g' x) (ğ“[>] a) l
sub : âˆ€ x âˆˆ Ioo a b, Ioo a x âŠ† Ioo a b
hg : âˆ€ x âˆˆ Ioo a b, g x â‰  0
c : â„ â†’ â„
hc : âˆ€ x âˆˆ Ioo a b, c x âˆˆ Ioo a x âˆ§ f x * g' (c x) = g x * f' (c x)
this : âˆ€ x âˆˆ Ioo a b, ((fun x' â†¦ f' x' / g' x') âˆ˜ c) x = f x / g x
cmp : âˆ€ x âˆˆ Ioo a b, a < c x âˆ§ c x < x
âŠ¢ Tendsto c (ğ“[Ioo a b] a) (ğ“[>] a)","theorem lhopital_zero_right_on_Ioo (hff' : âˆ€ x âˆˆ Ioo a b, HasDerivAt f (f' x) x)
    (hgg' : âˆ€ x âˆˆ Ioo a b, HasDerivAt g (g' x) x) (hg' : âˆ€ x âˆˆ Ioo a b, g' x â‰  0)
    (hfa : Tendsto f (ğ“[>] a) (ğ“ 0)) (hga : Tendsto g (ğ“[>] a) (ğ“ 0))
    (hdiv : Tendsto (fun x => f' x / g' x) (ğ“[>] a) l) :
    Tendsto (fun x => f x / g x) (ğ“[>] a) l ",":= by
  have sub : âˆ€ x âˆˆ Ioo a b, Ioo a x âŠ† Ioo a b := fun x hx =>
    Ioo_subset_Ioo (le_refl a) (le_of_lt hx.2)
  have hg : âˆ€ x âˆˆ Ioo a b, g x â‰  0 := by
    intro x hx h
    have : Tendsto g (ğ“[<] x) (ğ“ 0) := by
      rw [â† h, â† nhdsWithin_Ioo_eq_nhdsWithin_Iio hx.1]
      exact ((hgg' x hx).continuousAt.continuousWithinAt.mono <| sub x hx).tendsto
    obtain âŸ¨y, hyx, hyâŸ© : âˆƒ c âˆˆ Ioo a x, g' c = 0 :=
      exists_hasDerivAt_eq_zero' hx.1 hga this fun y hy => hgg' y <| sub x hx hy
    exact hg' y (sub x hx hyx) hy
  have : âˆ€ x âˆˆ Ioo a b, âˆƒ c âˆˆ Ioo a x, f x * g' c = g x * f' c := by
    intro x hx
    rw [â† sub_zero (f x), â† sub_zero (g x)]
    exact exists_ratio_hasDerivAt_eq_ratio_slope' g g' hx.1 f f' (fun y hy => hgg' y <| sub x hx hy)
      (fun y hy => hff' y <| sub x hx hy) hga hfa
      (tendsto_nhdsWithin_of_tendsto_nhds (hgg' x hx).continuousAt.tendsto)
      (tendsto_nhdsWithin_of_tendsto_nhds (hff' x hx).continuousAt.tendsto)
  choose! c hc using this
  have : âˆ€ x âˆˆ Ioo a b, ((fun x' => f' x' / g' x') âˆ˜ c) x = f x / g x := by
    intro x hx
    rcases hc x hx with âŸ¨hâ‚, hâ‚‚âŸ©
    field_simp [hg x hx, hg' (c x) ((sub x hx) hâ‚)]
    simp only [hâ‚‚]
    rw [mul_comm]
  have cmp : âˆ€ x âˆˆ Ioo a b, a < c x âˆ§ c x < x := fun x hx => (hc x hx).1
  rw [â† nhdsWithin_Ioo_eq_nhdsWithin_Ioi hab]
  apply tendsto_nhdsWithin_congr this
  apply hdiv.comp
  refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _
    (tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds
      (tendsto_nhdsWithin_of_tendsto_nhds tendsto_id) ?_ ?_) ?_
  all_goals
    apply eventually_nhdsWithin_of_forall
    intro x hx
    have := cmp x hx
    try simp
    linarith [this]"
Mathlib/Order/CompactlyGenerated/Basic.lean,exists_setIndependent_isCompl_sSup_atoms,exists_setIndependent_isCompl_sSup_atoms,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have := zorn_subset
    {s : Set Î± | CompleteLattice.SetIndependent s âˆ§ Disjoint b (sSup s) âˆ§ âˆ€ a âˆˆ s, IsAtom a}
    fun c hc1 hc2 =>
      âŸ¨â‹ƒâ‚€ c,
        âŸ¨CompleteLattice.independent_sUnion_of_directed hc2.directedOn fun s hs => (hc1 hs).1, ?_,
          fun a âŸ¨s, sc, asâŸ© => (hc1 sc).2.2 a asâŸ©,
        fun _ => Set.subset_sUnion_of_memâŸ©
  swap
  Â· rw [sSup_sUnion, â† sSup_image, DirectedOn.disjoint_sSup_right]
    Â· rintro _ âŸ¨s, hs, rflâŸ©
      exact (hc1 hs).2.1
    Â· rw [directedOn_image]
      exact hc2.directedOn.mono @fun s t => sSup_le_sSup
  obtain âŸ¨s, âŸ¨s_ind, b_inf_Sup_s, s_atomsâŸ©, s_maxâŸ© := this
  refine âŸ¨s, s_ind, âŸ¨b_inf_Sup_s, ?_âŸ©, s_atomsâŸ©
  rw [codisjoint_iff_le_sup, â† h, sSup_le_iff]
  intro a ha
  rw [â† inf_eq_left]
  refine (ha.le_iff.mp inf_le_left).resolve_left fun con => ha.1 ?_
  rw [â† con, eq_comm, inf_eq_left]
  refine (le_sSup ?_).trans le_sup_right
  rw [â† disjoint_iff] at con
  have a_dis_Sup_s : Disjoint a (sSup s) := con.mono_right le_sup_right
  rw [â† s_max (s âˆª {a}) âŸ¨fun x hx => _, _, fun x hx => _âŸ© (Set.subset_union_left _ _)]
  Â· exact Set.mem_union_right _ (Set.mem_singleton _)
  Â· intro x hx
    rw [Set.mem_union, Set.mem_singleton_iff] at hx
    obtain rfl | xa := eq_or_ne x a
    Â· simp only [Set.mem_singleton, Set.insert_diff_of_mem, Set.union_singleton]
      exact con.mono_right ((sSup_le_sSup <| Set.diff_subset _ _).trans le_sup_right)
    Â· have h : (s âˆª {a}) \ {x} = s \ {x} âˆª {a} := by
        simp only [Set.union_singleton]
        rw [Set.insert_diff_of_not_mem]
        rw [Set.mem_singleton_iff]
        exact Ne.symm xa
      rw [h, sSup_union, sSup_singleton]
      apply
        (s_ind (hx.resolve_right xa)).disjoint_sup_right_of_disjoint_sup_left
          (a_dis_Sup_s.mono_right _).symm
      rw [â† sSup_insert, Set.insert_diff_singleton, Set.insert_eq_of_mem (hx.resolve_right xa)]
  Â· rw [sSup_union, sSup_singleton]
    exact b_inf_Sup_s.disjoint_sup_right_of_disjoint_sup_left con.symm
  Â· intro x hx
    rw [Set.mem_union, Set.mem_singleton_iff] at hx
    obtain hx | rfl := hx
    Â· exact s_atoms x hx
    Â· exact ha","error:  function expected at
  subset_union_left ?m.88236
term has type
  ?m.88235 âˆˆ ?m.88233 âˆª ?m.88234
error:  function expected at
  diff_subset ?m.88747
term has type
  ?m.88746 âˆˆ ?m.88744","theorem exists_setIndependent_isCompl_sSup_atoms (h : sSup { a : Î± | IsAtom a } = âŠ¤) (b : Î±) :
    âˆƒ s : Set Î±, CompleteLattice.SetIndependent s âˆ§
    IsCompl b (sSup s) âˆ§ âˆ€ â¦ƒaâ¦„, a âˆˆ s â†’ IsAtom a ",":= by
  have := zorn_subset
    {s : Set Î± | CompleteLattice.SetIndependent s âˆ§ Disjoint b (sSup s) âˆ§ âˆ€ a âˆˆ s, IsAtom a}
    fun c hc1 hc2 =>
      âŸ¨â‹ƒâ‚€ c,
        âŸ¨CompleteLattice.independent_sUnion_of_directed hc2.directedOn fun s hs => (hc1 hs).1, ?_,
          fun a âŸ¨s, sc, asâŸ© => (hc1 sc).2.2 a asâŸ©,
        fun _ => Set.subset_sUnion_of_memâŸ©
  swap
  Â· rw [sSup_sUnion, â† sSup_image, DirectedOn.disjoint_sSup_right]
    Â· rintro _ âŸ¨s, hs, rflâŸ©
      exact (hc1 hs).2.1
    Â· rw [directedOn_image]
      exact hc2.directedOn.mono @fun s t => sSup_le_sSup
  obtain âŸ¨s, âŸ¨s_ind, b_inf_Sup_s, s_atomsâŸ©, s_maxâŸ© := this
  refine âŸ¨s, s_ind, âŸ¨b_inf_Sup_s, ?_âŸ©, s_atomsâŸ©
  rw [codisjoint_iff_le_sup, â† h, sSup_le_iff]
  intro a ha
  rw [â† inf_eq_left]
  refine (ha.le_iff.mp inf_le_left).resolve_left fun con => ha.1 ?_
  rw [â† con, eq_comm, inf_eq_left]
  refine (le_sSup ?_).trans le_sup_right
  rw [â† disjoint_iff] at con
  have a_dis_Sup_s : Disjoint a (sSup s) := con.mono_right le_sup_right
  rw [â† s_max (s âˆª {a}) âŸ¨fun x hx => _, _, fun x hx => _âŸ© Set.subset_union_left]
  Â· exact Set.mem_union_right _ (Set.mem_singleton _)
  Â· intro x hx
    rw [Set.mem_union, Set.mem_singleton_iff] at hx
    obtain rfl | xa := eq_or_ne x a
    Â· simp only [Set.mem_singleton, Set.insert_diff_of_mem, Set.union_singleton]
      exact con.mono_right ((sSup_le_sSup Set.diff_subset).trans le_sup_right)
    Â· have h : (s âˆª {a}) \ {x} = s \ {x} âˆª {a} := by
        simp only [Set.union_singleton]
        rw [Set.insert_diff_of_not_mem]
        rw [Set.mem_singleton_iff]
        exact Ne.symm xa
      rw [h, sSup_union, sSup_singleton]
      apply
        (s_ind (hx.resolve_right xa)).disjoint_sup_right_of_disjoint_sup_left
          (a_dis_Sup_s.mono_right _).symm
      rw [â† sSup_insert, Set.insert_diff_singleton, Set.insert_eq_of_mem (hx.resolve_right xa)]
  Â· rw [sSup_union, sSup_singleton]
    exact b_inf_Sup_s.disjoint_sup_right_of_disjoint_sup_left con.symm
  Â· intro x hx
    rw [Set.mem_union, Set.mem_singleton_iff] at hx
    obtain hx | rfl := hx
    Â· exact s_atoms x hx
    Â· exact ha"
Mathlib/RingTheory/FiniteType.lean,MonoidAlgebra.freeAlgebra_lift_of_surjective_of_closure,freeAlgebra_lift_of_surjective_of_closure,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  intro f
  induction' f using induction_on with m f g ihf ihg r f ih
  Â· have : m âˆˆ closure S := hS.symm â–¸ mem_top _
    refine AddSubmonoid.closure_induction this (fun m hm => ?_) ??_ _
    Â· exact âŸ¨FreeAlgebra.Î¹ R âŸ¨m, hmâŸ©, FreeAlgebra.lift_Î¹_apply _ _âŸ©
    Â· exact âŸ¨1, AlgHom.map_one _âŸ©
    Â· rintro mâ‚ mâ‚‚ âŸ¨Pâ‚, hPâ‚âŸ© âŸ¨Pâ‚‚, hPâ‚‚âŸ©
      exact
        âŸ¨Pâ‚ * Pâ‚‚, by
          rw [AlgHom.map_mul, hPâ‚, hPâ‚‚, of_apply, of_apply, of_apply, single_mul_single,
            one_mul]; rflâŸ©
  Â· rcases ihf with âŸ¨P, rflâŸ©
    rcases ihg with âŸ¨Q, rflâŸ©
    exact âŸ¨P + Q, AlgHom.map_add _ _ _âŸ©
  Â· rcases ih with âŸ¨P, rflâŸ©
    exact âŸ¨r â€¢ P, AlgHom.map_smul _ _ _âŸ©","error:  unexpected token '?'; expected '_' or identifier
error:  unsolved goals
case hadd
R : Type u_1
M : Type u_2
instâœÂ¹ : AddMonoid M
instâœ : CommSemiring R
S : Set M
hS : closure S = âŠ¤
f g : R[M]
ihf : âˆƒ a, ((FreeAlgebra.lift R) fun s â†¦ of' R M â†‘s) a = f
ihg : âˆƒ a, ((FreeAlgebra.lift R) fun s â†¦ of' R M â†‘s) a = g
âŠ¢ âˆƒ a, ((FreeAlgebra.lift R) fun s â†¦ of' R M â†‘s) a = f + g

case hsmul
R : Type u_1
M : Type u_2
instâœÂ¹ : AddMonoid M
instâœ : CommSemiring R
S : Set M
hS : closure S = âŠ¤
r : R
f : R[M]
ih : âˆƒ a, ((FreeAlgebra.lift R) fun s â†¦ of' R M â†‘s) a = f
âŠ¢ âˆƒ a, ((FreeAlgebra.lift R) fun s â†¦ of' R M â†‘s) a = r â€¢ f","theorem freeAlgebra_lift_of_surjective_of_closure [CommSemiring R] {S : Set M}
    (hS : closure S = âŠ¤) :
    Function.Surjective
      (FreeAlgebra.lift R fun s : S => of' R M â†‘s : FreeAlgebra R S â†’ R[M]) ",":= by
  intro f
  induction' f using induction_on with m f g ihf ihg r f ih
  Â· have : m âˆˆ closure S := hS.symm â–¸ mem_top _
    refine AddSubmonoid.closure_induction this (fun m hm => ?_) ?_ ?_
    Â· exact âŸ¨FreeAlgebra.Î¹ R âŸ¨m, hmâŸ©, FreeAlgebra.lift_Î¹_apply _ _âŸ©
    Â· exact âŸ¨1, AlgHom.map_one _âŸ©
    Â· rintro mâ‚ mâ‚‚ âŸ¨Pâ‚, hPâ‚âŸ© âŸ¨Pâ‚‚, hPâ‚‚âŸ©
      exact
        âŸ¨Pâ‚ * Pâ‚‚, by
          rw [AlgHom.map_mul, hPâ‚, hPâ‚‚, of_apply, of_apply, of_apply, single_mul_single,
            one_mul]; rflâŸ©
  Â· rcases ihf with âŸ¨P, rflâŸ©
    rcases ihg with âŸ¨Q, rflâŸ©
    exact âŸ¨P + Q, AlgHom.map_add _ _ _âŸ©
  Â· rcases ih with âŸ¨P, rflâŸ©
    exact âŸ¨r â€¢ P, AlgHom.map_smul _ _ _âŸ©"
Mathlib/GroupTheory/CoprodI.lean,FreeGroup.injective_lift_of_ping_pong,_root_.FreeGroup.injective_lift_of_ping_pong,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  have : FreeGroup.lift a =
      (CoprodI.lift fun i => FreeGroup.lift fun _ => a i).comp
        (@freeGroupEquivCoprodI Î¹).toMonoidHom := by
    ext i
    simp
  rw [this, MonoidHom.coe_comp]
  clear this
  refine' Function.Injective.comp _ (MulEquiv.injective freeGroupEquivCoprodI)
  show Function.Injective (lift fun i : Î¹ => FreeGroup.lift fun _ => a i)
  let H : Î¹ â†’ Type _ := fun _i => FreeGroup Unit
  let f : âˆ€ i, H i â†’* G := fun i => FreeGroup.lift fun _ => a i
  let X' : Î¹ â†’ Set Î± := fun i => X i âˆª Y i
  apply lift_injective_of_ping_pong f _ X'
  show âˆ€ i, (X' i).Nonempty
  Â· exact fun i => Set.Nonempty.inl (hXnonempty i)
  show Pairwise fun i j => Disjoint (X' i) (X' j)
  Â· intro i j hij
    simp only
    apply Disjoint.union_left <;> apply Disjoint.union_right
    Â· exact hXdisj hij
    Â· exact hXYdisj i j
    Â· exact (hXYdisj j i).symm
    Â· exact hYdisj hij
  show Pairwise fun i j => âˆ€ h : H i, h â‰  1 â†’ f i h â€¢ X' j âŠ† X' i
  Â· rintro i j hij
    refine' FreeGroup.freeGroupUnitEquivInt.forall_congr_left'.mpr _
    intro n hne1
    change FreeGroup.lift (fun _ => a i) (FreeGroup.of () ^ n) â€¢ X' j âŠ† X' i
    simp only [map_zpow, FreeGroup.lift.of]
    change a i ^ n â€¢ X' j âŠ† X' i
    have hnne0 : n â‰  0 := by
      rintro rfl
      apply hne1
      simp; rfl
    clear hne1
    simp only
    cases' (lt_or_gt_of_ne hnne0).symm with hlt hgt
    Â· have h1n : 1 â‰¤ n := hlt
      calc
        a i ^ n â€¢ X' j âŠ† a i ^ n â€¢ (Y i)á¶œ :=
          smul_set_mono ((hXYdisj j i).union_left <| hYdisj hij.symm).subset_compl_right
        _ âŠ† X i := by
          clear hnne0 hlt
          refine Int.le_induction (P := fun n => a i ^ n â€¢ (Y i)á¶œ âŠ† X i) ?_ ?_ n h1n
          Â· dsimp
            rw [zpow_one]
            exact hX i
          Â· dsimp
            intro n _hle hi
            calc
              a i ^ (n + 1) â€¢ (Y i)á¶œ = (a i ^ n * a i) â€¢ (Y i)á¶œ := by rw [zpow_add, zpow_one]
              _ = a i ^ n â€¢ a i â€¢ (Y i)á¶œ := (MulAction.mul_smul _ _ _)
              _ âŠ† a i ^ n â€¢ X i := (smul_set_mono <| hX i)
              _ âŠ† a i ^ n â€¢ (Y i)á¶œ := (smul_set_mono (hXYdisj i i).subset_compl_right)
              _ âŠ† X i := hi
        _ âŠ† X' i := Set.subset_union_left _ _
    Â· have h1n : n â‰¤ -1 := by
        apply Int.le_of_lt_add_one
        simpa using hgt
      calc
        a i ^ n â€¢ X' j âŠ† a i ^ n â€¢ (X i)á¶œ :=
          smul_set_mono ((hXdisj hij.symm).union_left (hXYdisj i j).symm).subset_compl_right
        _ âŠ† Y i := by
          refine' Int.le_induction_down (P := fun n => a i ^ n â€¢ (X i)á¶œ âŠ† Y i) _ _ _ h1n
          Â· dsimp
            rw [zpow_neg, zpow_one]
            exact hY i
          Â· dsimp
            intro n _ hi
            calc
              a i ^ (n - 1) â€¢ (X i)á¶œ = (a i ^ n * (a i)â»Â¹) â€¢ (X i)á¶œ := by rw [zpow_sub, zpow_one]
              _ = a i ^ n â€¢ (a i)â»Â¹ â€¢ (X i)á¶œ := (MulAction.mul_smul _ _ _)
              _ âŠ† a i ^ n â€¢ Y i := (smul_set_mono <| hY i)
              _ âŠ† a i ^ n â€¢ (X i)á¶œ := (smul_set_mono (hXYdisj i i).symm.subset_compl_right)
              _ âŠ† Y i := hi
        _ âŠ† X' i := Set.subset_union_right _ _
  show _ âˆ¨ âˆƒ i, 3 â‰¤ #(H i)
  Â· inhabit Î¹
    right
    use Inhabited.default
    simp only
    rw [FreeGroup.freeGroupUnitEquivInt.cardinal_eq, Cardinal.mk_denumerable]
    apply le_of_lt
    exact nat_lt_aleph0 3","error:  simp made no progress
warning:  `Equiv.forall_congr_left'` has been deprecated, use `Equiv.forall_congr_left` instead
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress",theorem _root_.FreeGroup.injective_lift_of_ping_pong : Function.Injective (FreeGroup.lift a) ,":= by
  have : FreeGroup.lift a =
      (CoprodI.lift fun i => FreeGroup.lift fun _ => a i).comp
        (@freeGroupEquivCoprodI Î¹).toMonoidHom := by
    ext i
    simp
  rw [this, MonoidHom.coe_comp]
  clear this
  refine Function.Injective.comp ?_ (MulEquiv.injective freeGroupEquivCoprodI)
  show Function.Injective (lift fun i : Î¹ => FreeGroup.lift fun _ => a i)
  let H : Î¹ â†’ Type _ := fun _i => FreeGroup Unit
  let f : âˆ€ i, H i â†’* G := fun i => FreeGroup.lift fun _ => a i
  let X' : Î¹ â†’ Set Î± := fun i => X i âˆª Y i
  apply lift_injective_of_ping_pong f _ X'
  Â· show âˆ€ i, (X' i).Nonempty
    exact fun i => Set.Nonempty.inl (hXnonempty i)
  Â· show Pairwise fun i j => Disjoint (X' i) (X' j)
    intro i j hij
    simp only [X']
    apply Disjoint.union_left <;> apply Disjoint.union_right
    Â· exact hXdisj hij
    Â· exact hXYdisj i j
    Â· exact (hXYdisj j i).symm
    Â· exact hYdisj hij
  Â· show Pairwise fun i j => âˆ€ h : H i, h â‰  1 â†’ f i h â€¢ X' j âŠ† X' i
    rintro i j hij
    refine FreeGroup.freeGroupUnitEquivInt.forall_congr_left.mpr ?_
    intro n hne1
    change FreeGroup.lift (fun _ => a i) (FreeGroup.of () ^ n) â€¢ X' j âŠ† X' i
    simp only [map_zpow, FreeGroup.lift.of]
    change a i ^ n â€¢ X' j âŠ† X' i
    have hnne0 : n â‰  0 := by
      rintro rfl
      apply hne1
      simp [H]; rfl
    clear hne1
    simp only [X']
    cases' (lt_or_gt_of_ne hnne0).symm with hlt hgt
    Â· have h1n : 1 â‰¤ n := hlt
      calc
        a i ^ n â€¢ X' j âŠ† a i ^ n â€¢ (Y i)á¶œ :=
          smul_set_mono ((hXYdisj j i).union_left <| hYdisj hij.symm).subset_compl_right
        _ âŠ† X i := by
          clear hnne0 hlt
          refine Int.le_induction (P := fun n => a i ^ n â€¢ (Y i)á¶œ âŠ† X i) ?_ ?_ n h1n
          Â· dsimp
            rw [zpow_one]
            exact hX i
          Â· dsimp
            intro n _hle hi
            calc
              a i ^ (n + 1) â€¢ (Y i)á¶œ = (a i ^ n * a i) â€¢ (Y i)á¶œ := by rw [zpow_add, zpow_one]
              _ = a i ^ n â€¢ a i â€¢ (Y i)á¶œ := MulAction.mul_smul _ _ _
              _ âŠ† a i ^ n â€¢ X i := smul_set_mono <| hX i
              _ âŠ† a i ^ n â€¢ (Y i)á¶œ := smul_set_mono (hXYdisj i i).subset_compl_right
              _ âŠ† X i := hi
        _ âŠ† X' i := Set.subset_union_left
    Â· have h1n : n â‰¤ -1 := by
        apply Int.le_of_lt_add_one
        simpa using hgt
      calc
        a i ^ n â€¢ X' j âŠ† a i ^ n â€¢ (X i)á¶œ :=
          smul_set_mono ((hXdisj hij.symm).union_left (hXYdisj i j).symm).subset_compl_right
        _ âŠ† Y i := by
          refine Int.le_induction_down (P := fun n => a i ^ n â€¢ (X i)á¶œ âŠ† Y i) ?_ ?_ _ h1n
          Â· dsimp
            rw [zpow_neg, zpow_one]
            exact hY i
          Â· dsimp
            intro n _ hi
            calc
              a i ^ (n - 1) â€¢ (X i)á¶œ = (a i ^ n * (a i)â»Â¹) â€¢ (X i)á¶œ := by rw [zpow_sub, zpow_one]
              _ = a i ^ n â€¢ (a i)â»Â¹ â€¢ (X i)á¶œ := MulAction.mul_smul _ _ _
              _ âŠ† a i ^ n â€¢ Y i := smul_set_mono <| hY i
              _ âŠ† a i ^ n â€¢ (X i)á¶œ := smul_set_mono (hXYdisj i i).symm.subset_compl_right
              _ âŠ† Y i := hi
        _ âŠ† X' i := Set.subset_union_right
  show _ âˆ¨ âˆƒ i, 3 â‰¤ #(H i)
  inhabit Î¹
  right
  use Inhabited.default
  simp only [H]
  rw [FreeGroup.freeGroupUnitEquivInt.cardinal_eq, Cardinal.mk_denumerable]
  apply le_of_lt
  exact nat_lt_aleph0 3"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,LipschitzWith.hausdorffMeasure_image_le,hausdorffMeasure_image_le,3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine' ENNReal.tsum_le_tsum fun n => _
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left s) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set X : Type u_2
but is expected to have type
  ?m.169595 âˆˆ t n âˆ© ?m.169594 : Prop
error:  simp made no progress","theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s ",":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd"
Mathlib/RingTheory/ChainOfDivisors.lean,DivisorChain.exists_chain_of_prime_pow,exists_chain_of_prime_pow,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine âŸ¨fun i => p ^ (i : â„•), ?_, fun n m h => ?_, @fun y => âŸ¨fun h => ?_?, _âŸ©âŸ©
  Â· dsimp only
    rw [Fin.val_one', Nat.mod_eq_of_lt, pow_one]
    exact Nat.lt_succ_of_le (Nat.one_le_iff_ne_zero.mpr hn)
  Â· exact Associates.dvdNotUnit_iff_lt.mp
        âŸ¨pow_ne_zero n hp.ne_zero, p ^ (m - n : â„•),
          not_isUnit_of_not_isUnit_dvd hp.not_unit (dvd_pow dvd_rfl (Nat.sub_pos_of_lt h).ne'),
          (pow_mul_pow_sub p h.le).symmâŸ©
  Â· obtain âŸ¨i, i_le, hiâŸ© := (dvd_prime_pow hp n).1 h
    rw [associated_iff_eq] at hi
    exact âŸ¨âŸ¨i, Nat.lt_succ_of_le i_leâŸ©, hiâŸ©
  Â· rintro âŸ¨i, rflâŸ©
    exact âŸ¨p ^ (n - i : â„•), (pow_mul_pow_sub p (Nat.succ_le_succ_iff.mp i.2)).symmâŸ©","error:  don't know how to synthesize placeholder for argument 'mpr'
context:
M : Type u_1
instâœ : CancelCommMonoidWithZero M
p : Associates M
n : â„•
hn : n â‰  0
hp : Prime p
y : Associates M
âŠ¢ (âˆƒ i, y = (fun i â†¦ p ^ â†‘i) i) â†’ y â‰¤ p ^ n
error:  unsolved goals
M : Type u_1
instâœ : CancelCommMonoidWithZero M
p : Associates M
n : â„•
hn : n â‰  0
hp : Prime p
âŠ¢ âˆƒ c, c 1 = p âˆ§ StrictMono c âˆ§ âˆ€ {r : Associates M}, r â‰¤ p ^ n â†” âˆƒ i, r = c i","theorem exists_chain_of_prime_pow {p : Associates M} {n : â„•} (hn : n â‰  0) (hp : Prime p) :
    âˆƒ c : Fin (n + 1) â†’ Associates M,
      c 1 = p âˆ§ StrictMono c âˆ§ âˆ€ {r : Associates M}, r â‰¤ p ^ n â†” âˆƒ i, r = c i ",":= by
  refine âŸ¨fun i => p ^ (i : â„•), ?_, fun n m h => ?_, @fun y => âŸ¨fun h => ?_, ?_âŸ©âŸ©
  Â· dsimp only
    rw [Fin.val_one', Nat.mod_eq_of_lt, pow_one]
    exact Nat.lt_succ_of_le (Nat.one_le_iff_ne_zero.mpr hn)
  Â· exact Associates.dvdNotUnit_iff_lt.mp
        âŸ¨pow_ne_zero n hp.ne_zero, p ^ (m - n : â„•),
          not_isUnit_of_not_isUnit_dvd hp.not_unit (dvd_pow dvd_rfl (Nat.sub_pos_of_lt h).ne'),
          (pow_mul_pow_sub p h.le).symmâŸ©
  Â· obtain âŸ¨i, i_le, hiâŸ© := (dvd_prime_pow hp n).1 h
    rw [associated_iff_eq] at hi
    exact âŸ¨âŸ¨i, Nat.lt_succ_of_le i_leâŸ©, hiâŸ©
  Â· rintro âŸ¨i, rflâŸ©
    exact âŸ¨p ^ (n - i : â„•), (pow_mul_pow_sub p (Nat.succ_le_succ_iff.mp i.2)).symmâŸ©"
Mathlib/Combinatorics/SimpleGraph/Clique.lean,SimpleGraph.CliqueFreeOn.of_succ,CliqueFreeOn.of_succ,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  classical
  refine fun t hts ht => hs ?_ (ht.insert fun b hb => (hts hb).2)
  push_cast
  exact Set.insert_subset_iff.2 âŸ¨ha, hts.trans <| Set.inter_subset_left _ _âŸ©","error:  function expected at
  Set.inter_subset_left ?m.155309
term has type
  ?m.155308 âˆˆ ?m.155306","theorem CliqueFreeOn.of_succ (hs : G.CliqueFreeOn s (n + 1)) (ha : a âˆˆ s) :
    G.CliqueFreeOn (s âˆ© G.neighborSet a) n ",":= by
  classical
  refine fun t hts ht => hs ?_ (ht.insert fun b hb => (hts hb).2)
  push_cast
  exact Set.insert_subset_iff.2 âŸ¨ha, hts.trans Set.inter_subset_leftâŸ©"
Mathlib/FieldTheory/NormalClosure.lean,normalClosure.restrictScalars_eq,restrictScalars_eq,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  classical
  have hi : âˆ€ x : K, IsIntegral F x :=
    fun x â†¦ (isIntegral_algebraMap_iff (algebraMap K L).injective).mp (h.isIntegral _)
  refine' le_antisymm (iSup_le _) (iSup_le fun x => adjoin_le_iff.mpr fun y hy => _)
  Â· rintro f _ âŸ¨x, rflâŸ©
    refine' le_iSup (fun x => adjoin F ((minpoly F x).rootSet L)) x
        (subset_adjoin F ((minpoly F x).rootSet L) _)
    rw [mem_rootSet_of_ne (minpoly.ne_zero (hi x)), AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom,
      Polynomial.aeval_algHom_apply, minpoly.aeval, map_zero]
  Â· rw [Polynomial.rootSet, Finset.mem_coe, Multiset.mem_toFinset] at hy
    let g := (algHomAdjoinIntegralEquiv F (hi x)).symm âŸ¨y, hyâŸ©
    refine' le_iSup (fun f : K â†’â‚[F] L => f.fieldRange) ((g.liftNormal L).comp (toAlgHom F K L))
        âŸ¨x, (g.liftNormal_commutes L (AdjoinSimple.gen F x)).trans _âŸ©
    rw [Algebra.id.map_eq_id, RingHom.id_apply]
    apply PowerBasis.lift_gen
    change aeval y (minpoly F (AdjoinSimple.gen F x)) = 0
    exact minpoly_gen F x â–¸ aeval_eq_zero_of_mem_rootSet (Multiset.mem_toFinset.mpr hy)","error:  unknown identifier 'h.isIntegral'
error:  application type mismatch
  le_antisymm (iSup_le ?m.142611)
argument
  iSup_le ?m.142611
has type
  iSup ?m.142609 â‰¤ ?m.142610 : Prop
but is expected to have type
  restrictScalars F (toAlgHom K (â†¥(normalClosure F K L)) L).fieldRange â‰¤ normalClosure F K L : Prop
error:  type mismatch
  adjoin_le_iff.mpr fun y hy â†¦ ?m.143874 y hy
has type
  adjoin ?m.143664 ?m.143812 â‰¤ ?m.143813 : Prop
but is expected to have type
  x.fieldRange â‰¤ restrictScalars F (toAlgHom K (â†¥(normalClosure F K L)) L).fieldRange : Prop","lemma restrictScalars_eq :
    (toAlgHom K (normalClosure F K L) L).fieldRange.restrictScalars F = normalClosure F K L ",":=
  SetLike.ext' Subtype.range_val"
Mathlib/Data/DFinsupp/WellFounded.lean,DFinsupp.lex_fibration,lex_fibration,e30889873ffb096aa1cebe161186c5e6a5f83f5f,":= by
  rintro âŸ¨p, xâ‚, xâ‚‚âŸ© x âŸ¨i, hr, hsâŸ©
  simp_rw [piecewise_apply] at hs hr
  split_ifs at hs with hp
  Â· refine âŸ¨âŸ¨{ j | r j i â†’ j âˆˆ p }, piecewise xâ‚ x { j | r j i }, xâ‚‚âŸ©,
      .fst âŸ¨i, fun j hj â†¦ ?_, ?_âŸ©, ?_âŸ© <;> simp only [piecewise_apply, Set.mem_setOf_eq]
    Â· simp only [if_pos hj]
    Â· split_ifs with hi
      Â· rwa [hr i hi, if_pos hp] at hs
      Â· assumption
    Â· ext1 j
      simp only [piecewise_apply, Set.mem_setOf_eq]
      split_ifs with hâ‚ hâ‚‚ <;> try rfl
      Â· rw [hr j hâ‚‚, if_pos (hâ‚ hâ‚‚)]
      Â· rw [not_imp] at hâ‚
        rw [hr j hâ‚.1, if_neg hâ‚.2]
  Â· refine âŸ¨âŸ¨{ j | r j i âˆ§ j âˆˆ p }, xâ‚, piecewise xâ‚‚ x { j | r j i }âŸ©,
      .snd âŸ¨i, fun j hj â†¦ ?_, ?_âŸ©, ?_âŸ© <;> simp only [piecewise_apply]
    Â· exact if_pos hj
    Â· split_ifs with hi
      Â· rwa [hr i hi, if_neg hp] at hs
      Â· assumption
    Â· ext1 j
      simp only [piecewise_apply, Set.mem_setOf_eq]
      split_ifs with hâ‚ hâ‚‚ <;> try rfl
      Â· rw [hr j hâ‚.1, if_pos hâ‚.2]
      Â· rw [hr j hâ‚‚, if_neg]
        simpa [hâ‚‚] using hâ‚","error:  ambiguous, possible interpretations 
  _root_.not_imp : Â¬(?m.5300 â†’ ?m.5301) â†” ?m.5300 âˆ§ Â¬?m.5301
  
  Classical.not_imp : Â¬(?m.5302 â†’ ?m.5303) â†” ?m.5302 âˆ§ Â¬?m.5303
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.5305
case neg
Î¹ : Type u_1
Î± : Î¹ â†’ Type u_2
instâœÂ¹ : (i : Î¹) â†’ Zero (Î± i)
r : Î¹ â†’ Î¹ â†’ Prop
s : (i : Î¹) â†’ Î± i â†’ Î± i â†’ Prop
instâœ : (i : Î¹) â†’ (s : Set Î¹) â†’ Decidable (i âˆˆ s)
p : Set Î¹
xâ‚ xâ‚‚ x : Î â‚€ (i : Î¹), Î± i
i : Î¹
hr : âˆ€ (j : Î¹), r j i â†’ x j = if j âˆˆ p then xâ‚ j else xâ‚‚ j
hp : i âˆˆ p
hs : s i (x i) (xâ‚ i)
j : Î¹
hâ‚ : Â¬(r j i â†’ j âˆˆ p)
âŠ¢ xâ‚‚ j = x j","theorem lex_fibration [âˆ€ (i) (s : Set Î¹), Decidable (i âˆˆ s)] :
    Fibration (InvImage (GameAdd (DFinsupp.Lex r s) (DFinsupp.Lex r s)) snd) (DFinsupp.Lex r s)
      fun x => piecewise x.2.1 x.2.2 x.1 ",":= by
  rintro âŸ¨p, xâ‚, xâ‚‚âŸ© x âŸ¨i, hr, hsâŸ©
  simp_rw [piecewise_apply] at hs hr
  split_ifs at hs with hp
  Â· refine âŸ¨âŸ¨{ j | r j i â†’ j âˆˆ p }, piecewise xâ‚ x { j | r j i }, xâ‚‚âŸ©,
      .fst âŸ¨i, fun j hj â†¦ ?_, ?_âŸ©, ?_âŸ© <;> simp only [piecewise_apply, Set.mem_setOf_eq]
    Â· simp only [if_pos hj]
    Â· split_ifs with hi
      Â· rwa [hr i hi, if_pos hp] at hs
      Â· assumption
    Â· ext1 j
      simp only [piecewise_apply, Set.mem_setOf_eq]
      split_ifs with hâ‚ hâ‚‚ <;> try rfl
      Â· rw [hr j hâ‚‚, if_pos (hâ‚ hâ‚‚)]
      Â· rw [Classical.not_imp] at hâ‚
        rw [hr j hâ‚.1, if_neg hâ‚.2]
  Â· refine âŸ¨âŸ¨{ j | r j i âˆ§ j âˆˆ p }, xâ‚, piecewise xâ‚‚ x { j | r j i }âŸ©,
      .snd âŸ¨i, fun j hj â†¦ ?_, ?_âŸ©, ?_âŸ© <;> simp only [piecewise_apply, Set.mem_setOf_eq]
    Â· exact if_pos hj
    Â· split_ifs with hi
      Â· rwa [hr i hi, if_neg hp] at hs
      Â· assumption
    Â· ext1 j
      simp only [piecewise_apply, Set.mem_setOf_eq]
      split_ifs with hâ‚ hâ‚‚ <;> try rfl
      Â· rw [hr j hâ‚.1, if_pos hâ‚.2]
      Â· rw [hr j hâ‚‚, if_neg]
        simpa [hâ‚‚] using hâ‚"
Mathlib/Probability/Moments.lean,ProbabilityTheory.iIndepFun.mgf_sum,iIndepFun.mgf_sum,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
  induction' s with i s hi_notin_s h_rec h_int
  Â· simp only [sum_empty, mgf_zero_fun, measure_univ, ENNReal.one_toReal, prod_empty]
  Â· have h_int' : âˆ€ i : Î¹, AEStronglyMeasurable (fun Ï‰ : Î© => exp (t * X i Ï‰)) Î¼ := fun i =>
      ((h_meas i).const_mul t).exp.aestronglyMeasurable
    rw [sum_insert hi_notin_s,
      IndepFun.mgf_add (h_indep.indepFun_finset_sum_of_not_mem h_meas hi_notin_s).symm (h_int' i)
        (aestronglyMeasurable_exp_mul_sum fun i _ => h_int' i),
      h_rec, prod_insert hi_notin_s]","error:  simp made no progress
error:  no goals to be solved","theorem iIndepFun.mgf_sum [IsProbabilityMeasure Î¼] {X : Î¹ â†’ Î© â†’ â„}
    (h_indep : iIndepFun (fun i => inferInstance) X Î¼) (h_meas : âˆ€ i, Measurable (X i))
    (s : Finset Î¹) : mgf (âˆ‘ i âˆˆ s, X i) Î¼ t = âˆ i âˆˆ s, mgf (X i) Î¼ t ",":= by
  classical
  induction' s using Finset.induction_on with i s hi_notin_s h_rec h_int
  Â· simp only [sum_empty, mgf_zero_fun, measure_univ, ENNReal.one_toReal, prod_empty]
  Â· have h_int' : âˆ€ i : Î¹, AEStronglyMeasurable (fun Ï‰ : Î© => exp (t * X i Ï‰)) Î¼ := fun i =>
      ((h_meas i).const_mul t).exp.aestronglyMeasurable
    rw [sum_insert hi_notin_s,
      IndepFun.mgf_add (h_indep.indepFun_finset_sum_of_not_mem h_meas hi_notin_s).symm (h_int' i)
        (aestronglyMeasurable_exp_mul_sum fun i _ => h_int' i),
      h_rec, prod_insert hi_notin_s]"
Mathlib/Dynamics/OmegaLimit.lean,nonempty_omegaLimit_of_isCompact_absorbing,nonempty_omegaLimit_of_isCompact_absorbing,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚]
  apply IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed
  Â· rintro âŸ¨uâ‚, huâ‚âŸ© âŸ¨uâ‚‚, huâ‚‚âŸ©
    use âŸ¨uâ‚ âˆ© uâ‚‚, inter_mem huâ‚ huâ‚‚âŸ©
    constructor
    all_goals exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) Subset.rfl)
  Â· intro u
    have hn : (image2 Ï• (u âˆ© v) s).Nonempty :=
      Nonempty.image2 (Filter.nonempty_of_mem (inter_mem u.prop hvâ‚)) hs
    exact hn.mono subset_closure
  Â· intro
    apply hcâ‚.of_isClosed_subset isClosed_closure
    calc
      _ âŠ† closure (image2 Ï• v s) := closure_mono (image2_subset (inter_subset_right _ _) Subset.rfl)
      _ âŠ† c := hvâ‚‚
  Â· exact fun _ â†¦ isClosed_closure","warning:  @omegaLimit does not have a doc string
error:  function expected at
  inter_subset_right ?m.55673
term has type
  ?m.55672 âˆˆ ?m.55671","theorem nonempty_omegaLimit_of_isCompact_absorbing [NeBot f] {c : Set Î²} (hcâ‚ : IsCompact c)
    (hcâ‚‚ : âˆƒ v âˆˆ f, closure (image2 Ï• v s) âŠ† c) (hs : s.Nonempty) : (Ï‰ f Ï• s).Nonempty ",":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚]
  apply IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed
  Â· rintro âŸ¨uâ‚, huâ‚âŸ© âŸ¨uâ‚‚, huâ‚‚âŸ©
    use âŸ¨uâ‚ âˆ© uâ‚‚, inter_mem huâ‚ huâ‚‚âŸ©
    constructor
    all_goals exact closure_mono (image2_subset (inter_subset_inter_left _ (by simp)) Subset.rfl)
  Â· intro u
    have hn : (image2 Ï• (u âˆ© v) s).Nonempty :=
      Nonempty.image2 (Filter.nonempty_of_mem (inter_mem u.prop hvâ‚)) hs
    exact hn.mono subset_closure
  Â· intro
    apply hcâ‚.of_isClosed_subset isClosed_closure
    calc
      _ âŠ† closure (image2 Ï• v s) := closure_mono (image2_subset inter_subset_right Subset.rfl)
      _ âŠ† c := hvâ‚‚
  Â· exact fun _ â†¦ isClosed_closure"
Mathlib/RingTheory/Polynomial/Bernstein.lean,bernsteinPolynomial.linearIndependent,linearIndependent,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' k with k ih
  Â· simp [Nat.zero_eq]
    apply linearIndependent_empty_type
  Â· apply linearIndependent_fin_succ'.mpr
    fconstructor
    Â· exact ih (le_of_lt h)
    Â· 
      clear ih
      simp only [Nat.succ_eq_add_one, add_le_add_iff_right] at h
      simp only [Fin.val_last, Fin.init_def]
      dsimp
      apply not_mem_span_of_apply_not_mem_span_image (@Polynomial.derivative â„š _ ^ (n - k))
      simp only [not_exists, not_and, Submodule.mem_map, Submodule.span_image _]
      intro p m
      apply_fun Polynomial.eval (1 : â„š)
      simp only [LinearMap.pow_apply]
      suffices (Polynomial.derivative^[n - k] p).eval 1 = 0 by
        rw [this]
        exact (iterate_derivative_at_1_ne_zero â„š n k h).symm
      refine span_induction m ?_ ?_ ?_ ?_
      Â· simp
        rintro âŸ¨a, wâŸ©; simp only [Fin.val_mk]
        rw [iterate_derivative_at_1_eq_zero_of_lt â„š n ((tsub_lt_tsub_iff_left_of_le h).mpr w)]
      Â· simp
      Â· intro x y hx hy; simp [hx, hy]
      Â· intro a x h; simp [h]",error:  simp made no progress,"theorem linearIndependent_aux (n k : â„•) (h : k â‰¤ n + 1) :
    LinearIndependent â„š fun Î½ : Fin k => bernsteinPolynomial â„š n Î½ ",":= by
  induction' k with k ih
  Â· apply linearIndependent_empty_type
  Â· apply linearIndependent_fin_succ'.mpr
    fconstructor
    Â· exact ih (le_of_lt h)
    Â· 
      clear ih
      simp only [Nat.succ_eq_add_one, add_le_add_iff_right] at h
      simp only [Fin.val_last, Fin.init_def]
      dsimp
      apply not_mem_span_of_apply_not_mem_span_image (@Polynomial.derivative â„š _ ^ (n - k))
      simp only [not_exists, not_and, Submodule.mem_map, Submodule.span_image _]
      intro p m
      apply_fun Polynomial.eval (1 : â„š)
      simp only [LinearMap.pow_apply]
      suffices (Polynomial.derivative^[n - k] p).eval 1 = 0 by
        rw [this]
        exact (iterate_derivative_at_1_ne_zero â„š n k h).symm
      refine span_induction m ?_ ?_ ?_ ?_
      Â· simp
        rintro âŸ¨a, wâŸ©; simp only [Fin.val_mk]
        rw [iterate_derivative_at_1_eq_zero_of_lt â„š n ((tsub_lt_tsub_iff_left_of_le h).mpr w)]
      Â· simp
      Â· intro x y hx hy; simp [hx, hy]
      Â· intro a x h; simp [h]"
Mathlib/MeasureTheory/Constructions/BorelSpace/Metrizable.lean,measurable_of_tendsto_metrizable,measurable_of_tendsto_metrizable,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  letI : PseudoMetricSpace Î² := pseudoMetrizableSpacePseudoMetric Î²
  apply measurable_of_is_closed'
  intro s h1s h2s h3s
  have : Measurable fun x => infNndist (g x) s := by
    suffices : Tendsto (fun i x => infNndist (f i x) s) u (ğ“ fun x => infNndist (g x) s)
    exact measurable_of_tendsto_nnreal' u (fun i => (hf i).infNndist) this
    rw [tendsto_pi_nhds] at lim âŠ¢
    intro x
    exact ((continuous_infNndist_pt s).tendsto (g x)).comp (lim x)
  have h4s : g â»Â¹' s = (fun x => infNndist (g x) s) â»Â¹' {0} := by
    ext x
    simp [h1s, â† h1s.mem_iff_infDist_zero h2s, â† NNReal.coe_eq_zero]
  rw [h4s]
  exact this (measurableSet_singleton 0)",error:  unexpected token ':'; expected term,"theorem measurable_of_tendsto_metrizable' {Î¹} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : Filter Î¹) [NeBot u]
    [IsCountablyGenerated u] (hf : âˆ€ i, Measurable (f i)) (lim : Tendsto f u (ğ“ g)) :
    Measurable g ",":= by
  letI : PseudoMetricSpace Î² := pseudoMetrizableSpacePseudoMetric Î²
  apply measurable_of_isClosed'
  intro s h1s h2s h3s
  have : Measurable fun x => infNndist (g x) s := by
    suffices Tendsto (fun i x => infNndist (f i x) s) u (ğ“ fun x => infNndist (g x) s) from
      NNReal.measurable_of_tendsto' u (fun i => (hf i).infNndist) this
    rw [tendsto_pi_nhds] at lim âŠ¢
    intro x
    exact ((continuous_infNndist_pt s).tendsto (g x)).comp (lim x)
  have h4s : g â»Â¹' s = (fun x => infNndist (g x) s) â»Â¹' {0} := by
    ext x
    simp [h1s, â† h1s.mem_iff_infDist_zero h2s, â† NNReal.coe_eq_zero]
  rw [h4s]
  exact this (measurableSet_singleton 0)"
Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Instances.lean,nonneg_iff_isSelfAdjoint_and_spectrumRestricts,nonneg_iff_isSelfAdjoint_and_spectrumRestricts,7f78c7252df23836519e580c929d645cda36b5ab,":= by
  rw [SpectrumRestricts.nnreal_iff]
  refine âŸ¨fun ha â†¦ ?_, ?_âŸ©
  Â· rw [StarOrderedRing.nonneg_iff] at ha
    induction ha using AddSubmonoid.closure_induction' with
    | mem x hx =>
      obtain âŸ¨b, rflâŸ© := hx
      exact âŸ¨IsSelfAdjoint.star_mul_self b, spectrum_star_mul_self_nonnegâŸ©
    | one =>
      nontriviality A
      simp
    | mul x _ y _ hx hy =>
      rw [â† SpectrumRestricts.nnreal_iff] at hx hy âŠ¢
      exact âŸ¨hx.1.add hy.1, hx.2.nnreal_add hx.1 hy.1 hy.2âŸ©
  Â· rintro âŸ¨haâ‚, haâ‚‚âŸ©
    let s := cfc Real.sqrt a
    have : a = star s * s := by
      rw [â† cfc_id a (R := â„), â† cfc_star (R := â„) _ a, â† cfc_mul ..]
      apply cfc_congr
      peel haâ‚‚ with x hx _
      simp [Real.mul_self_sqrt this]
    exact this â–¸ star_mul_self_nonneg s","error:  unknown identifier 'spectrum_star_mul_self_nonneg'
error:  invalid field 'nnreal_add', the environment does not contain 'SpectrumRestricts.nnreal_add'
  hx.right
has type
  SpectrumRestricts x â‡‘ContinuousMap.realToNNReal
error:  invalid field 'nnreal_add', the environment does not contain 'QuasispectrumRestricts.nnreal_add'
  hx.right
has type
  QuasispectrumRestricts x â‡‘ContinuousMap.realToNNReal","lemma nonneg_iff_isSelfAdjoint_and_spectrumRestricts {a : A} :
    0 â‰¤ a â†” IsSelfAdjoint a âˆ§ SpectrumRestricts a ContinuousMap.realToNNReal ",":= by
  refine âŸ¨fun ha â†¦ âŸ¨.of_nonneg ha, .nnreal_of_nonneg haâŸ©, ?_âŸ©
  rintro âŸ¨haâ‚, haâ‚‚âŸ©
  obtain âŸ¨x, hx, -, rflâŸ© := CFC.exists_sqrt_of_isSelfAdjoint_of_spectrumRestricts haâ‚ haâ‚‚
  simpa [sq, hx.star_eq] using star_mul_self_nonneg x"
Mathlib/Analysis/Complex/PhragmenLindelof.lean,PhragmenLindelof.eq_zero_on_right_half_plane_of_superexponential_decay,eq_zero_on_right_half_plane_of_superexponential_decay,b2daba4a3cb8c63681fd2ed000dbe9c9f749ebe7,":= by
  rcases him with âŸ¨C, hCâŸ©
  suffices âˆ€ z : â„‚, 0 < z.re â†’ f z = 0 by
    simpa only [closure_setOf_lt_re] using
      EqOn.of_subset_closure this hd.continuousOn continuousOn_const subset_closure Subset.rfl
  set g : â„• â†’ â„‚ â†’ E := fun (n : â„•) (z : â„‚) => exp z ^ n â€¢ f z
  have hg : âˆ€ n z, â€–g n zâ€– = expR z.re ^ n * â€–f zâ€– := fun n z â†¦ by
    simp only [norm_smul, norm_eq_abs, Complex.abs_pow, abs_exp]
  intro z hz
  suffices H : âˆ€ n : â„•, â€–g n zâ€– â‰¤ C
  Â· contrapose! H
    simp only [hg]
    exact (((tendsto_pow_atTop_atTop_of_one_lt (Real.one_lt_exp_iff.2 hz)).atTop_mul
      (norm_pos_iff.2 H) tendsto_const_nhds).eventually (eventually_gt_atTop C)).exists
  intro n
  refine' right_half_plane_of_tendsto_zero_on_real ((differentiable_exp.pow n).diffContOnCl.smul hd)
    _ _ (fun y => _) hz.le
  Â· rcases hexp with âŸ¨c, hc, B, hOâŸ©
    refine' âŸ¨max c 1, max_lt hc one_lt_two, n + max B 0, .of_norm_left _âŸ©
    simp only [hg]
    refine' ((isBigO_refl (fun z : â„‚ => expR z.re ^ n) _).mul hO.norm_left).trans (.of_bound 1 _)
    filter_upwards [(eventually_cobounded_le_norm 1).filter_mono inf_le_left] with z hz
    simp only [â† Real.exp_nat_mul, â† Real.exp_add, Real.norm_eq_abs, Real.abs_exp, add_mul, one_mul]
    gcongr
    Â· calc
        z.re â‰¤ abs z := re_le_abs _
        _ = abs z ^ (1 : â„) := (Real.rpow_one _).symm
        _ â‰¤ abs z ^ max c 1 := Real.rpow_le_rpow_of_exponent_le hz (le_max_right _ _)
    exacts [le_max_left _ _, hz, le_max_left _ _]
  Â· rw [tendsto_zero_iff_norm_tendsto_zero]; simp only [hg]
    exact hre n
  Â· rw [hg, ofReal_mul_re, I_re, mul_zero, Real.exp_zero, one_pow, one_mul]
    exact hC y",error:  unexpected token 'Â·'; expected 'by' or 'from',"theorem eq_zero_on_right_half_plane_of_superexponential_decay (hd : DiffContOnCl â„‚ f {z | 0 < z.re})
    (hexp : âˆƒ c < (2 : â„), âˆƒ B,
      f =O[cobounded â„‚ âŠ“ ğ“Ÿ {z | 0 < z.re}] fun z => expR (B * abs z ^ c))
    (hre : SuperpolynomialDecay atTop expR fun x => â€–f xâ€–) (him : âˆƒ C, âˆ€ x : â„, â€–f (x * I)â€– â‰¤ C) :
    EqOn f 0 {z : â„‚ | 0 â‰¤ z.re} ",":= by
  rcases him with âŸ¨C, hCâŸ©
  suffices âˆ€ z : â„‚, 0 < z.re â†’ f z = 0 by
    simpa only [closure_setOf_lt_re] using
      EqOn.of_subset_closure this hd.continuousOn continuousOn_const subset_closure Subset.rfl
  set g : â„• â†’ â„‚ â†’ E := fun (n : â„•) (z : â„‚) => exp z ^ n â€¢ f z
  have hg : âˆ€ n z, â€–g n zâ€– = expR z.re ^ n * â€–f zâ€– := fun n z â†¦ by
    simp only [g, norm_smul, norm_eq_abs, Complex.abs_pow, abs_exp]
  intro z hz
  suffices H : âˆ€ n : â„•, â€–g n zâ€– â‰¤ C by
    contrapose! H
    simp only [hg]
    exact (((tendsto_pow_atTop_atTop_of_one_lt (Real.one_lt_exp_iff.2 hz)).atTop_mul
      (norm_pos_iff.2 H) tendsto_const_nhds).eventually (eventually_gt_atTop C)).exists
  intro n
  refine right_half_plane_of_tendsto_zero_on_real ((differentiable_exp.pow n).diffContOnCl.smul hd)
    ?_ ?_ (fun y => ?_) hz.le
  Â· rcases hexp with âŸ¨c, hc, B, hOâŸ©
    refine âŸ¨max c 1, max_lt hc one_lt_two, n + max B 0, .of_norm_left ?_âŸ©
    simp only [hg]
    refine ((isBigO_refl (fun z : â„‚ => expR z.re ^ n) _).mul hO.norm_left).trans (.of_bound 1 ?_)
    filter_upwards [(eventually_cobounded_le_norm 1).filter_mono inf_le_left] with z hz
    simp only [â† Real.exp_nat_mul, â† Real.exp_add, Real.norm_eq_abs, Real.abs_exp, add_mul, one_mul]
    gcongr
    Â· calc
        z.re â‰¤ abs z := re_le_abs _
        _ = abs z ^ (1 : â„) := (Real.rpow_one _).symm
        _ â‰¤ abs z ^ max c 1 := Real.rpow_le_rpow_of_exponent_le hz (le_max_right _ _)
    exacts [le_max_left _ _, hz, le_max_left _ _]
  Â· rw [tendsto_zero_iff_norm_tendsto_zero]; simp only [hg]
    exact hre n
  Â· rw [hg, re_ofReal_mul, I_re, mul_zero, Real.exp_zero, one_pow, one_mul]
    exact hC y"
Mathlib/CategoryTheory/Abelian/ProjectiveResolution.lean,CategoryTheory.ProjectiveResolution.ofComplex_exactAt_succ,ofComplex_exactAt_succ,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  rw [HomologicalComplex.exactAt_iff' _ (n + 1 + 1) (n + 1) n (by simp) (by simp)]
  cases n
  all_goals
    dsimp [ofComplex, HomologicalComplex.sc', HomologicalComplex.shortComplexFunctor',
      ChainComplex.mk, ChainComplex.mk']
    simp
    apply exact_d_f","error:  simp made no progress
error:  unsolved goals
case zero
C : Type u
instâœÂ³ : Category.{v, u} C
instâœÂ² : Abelian C
instâœÂ¹ : HasProjectiveResolutions C
instâœ : EnoughProjectives C
Z : C
âŠ¢ (HomologicalComplex.sc' (ofComplex Z) (0 + 1 + 1) (0 + 1) 0).Exact","lemma ofComplex_exactAt_succ (n : â„•) :
    (ofComplex Z).ExactAt (n + 1) ",":= by
  rw [HomologicalComplex.exactAt_iff' _ (n + 1 + 1) (n + 1) n (by simp) (by simp)]
  dsimp [ofComplex, HomologicalComplex.sc', HomologicalComplex.shortComplexFunctor',
      ChainComplex.mk', ChainComplex.mk]
  simp only [ChainComplex.of_d]
  match n with
  | 0 =>
    apply exact_d_f ((ChainComplex.mkAux _ _ _ (d (Projective.Ï€ Z)) (d (d (Projective.Ï€ Z))) _ _
      0).g)
  | n+1 =>
    apply exact_d_f ((ChainComplex.mkAux _ _ _ (d (Projective.Ï€ Z)) (d (d (Projective.Ï€ Z))) _ _
      (n+1)).g)"
Mathlib/Algebra/Homology/ShortComplex/RightHomology.lean,CategoryTheory.ShortComplex.isIso_opcyclesMap'_of_isIso_of_epi,isIso_opcyclesMap'_of_isIso_of_epi,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine âŸ¨hâ‚‚.descQ (inv Ï†.Ï„â‚‚ â‰« hâ‚.p) ?_, ?_?, _âŸ©
  Â· simp only [â† cancel_epi Ï†.Ï„â‚, comp_zero, Ï†.commâ‚â‚‚_assoc, IsIso.hom_inv_id_assoc, hâ‚.wp]
  Â· simp only [â† cancel_epi hâ‚.p, p_opcyclesMap'_assoc, hâ‚‚.p_descQ,
      IsIso.hom_inv_id_assoc, comp_id]
  Â· simp only [â† cancel_epi hâ‚‚.p, hâ‚‚.p_descQ_assoc, assoc, p_opcyclesMap',
      IsIso.inv_hom_id_assoc, comp_id]","error:  don't know how to synthesize placeholder for argument 'right'
context:
C : Type u_1
instâœÂ¹ : Category.{u_2, u_1} C
instâœ : HasZeroMorphisms C
S Sâ‚ Sâ‚‚ Sâ‚ƒ : ShortComplex C
Ï† : Sâ‚ âŸ¶ Sâ‚‚
hâ‚‚âœ : IsIso Ï†.Ï„â‚‚
hâ‚âœ : Epi Ï†.Ï„â‚
hâ‚ : Sâ‚.RightHomologyData
hâ‚‚ : Sâ‚‚.RightHomologyData
âŠ¢ hâ‚‚.descQ (inv Ï†.Ï„â‚‚ â‰« hâ‚.p) ?m.237483 â‰« opcyclesMap' Ï† hâ‚ hâ‚‚ = ğŸ™ hâ‚‚.Q
error:  unsolved goals
C : Type u_1
instâœÂ¹ : Category.{u_2, u_1} C
instâœ : HasZeroMorphisms C
S Sâ‚ Sâ‚‚ Sâ‚ƒ : ShortComplex C
Ï† : Sâ‚ âŸ¶ Sâ‚‚
hâ‚‚âœ : IsIso Ï†.Ï„â‚‚
hâ‚âœ : Epi Ï†.Ï„â‚
hâ‚ : Sâ‚.RightHomologyData
hâ‚‚ : Sâ‚‚.RightHomologyData
âŠ¢ IsIso (opcyclesMap' Ï† hâ‚ hâ‚‚)","lemma isIso_opcyclesMap'_of_isIso_of_epi (Ï† : Sâ‚ âŸ¶ Sâ‚‚) (hâ‚‚ : IsIso Ï†.Ï„â‚‚) (hâ‚ : Epi Ï†.Ï„â‚)
    (hâ‚ : Sâ‚.RightHomologyData) (hâ‚‚ : Sâ‚‚.RightHomologyData) :
    IsIso (opcyclesMap' Ï† hâ‚ hâ‚‚) ",":= by
  refine âŸ¨hâ‚‚.descQ (inv Ï†.Ï„â‚‚ â‰« hâ‚.p) ?_, ?_, ?_âŸ©
  Â· simp only [â† cancel_epi Ï†.Ï„â‚, comp_zero, Ï†.commâ‚â‚‚_assoc, IsIso.hom_inv_id_assoc, hâ‚.wp]
  Â· simp only [â† cancel_epi hâ‚.p, p_opcyclesMap'_assoc, hâ‚‚.p_descQ,
      IsIso.hom_inv_id_assoc, comp_id]
  Â· simp only [â† cancel_epi hâ‚‚.p, hâ‚‚.p_descQ_assoc, assoc, p_opcyclesMap',
      IsIso.inv_hom_id_assoc, comp_id]"
Mathlib/ModelTheory/Satisfiability.lean,FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_le,exists_elementaryEmbedding_card_eq_of_le,047f73c34cd3e6bae28166f72847965b1a989c70,":= by
  obtain âŸ¨S, _, hSâŸ© := exists_elementarySubstructure_card_eq L âˆ… Îº h1 (by simp) h2 h3
  have : Small.{w} S := by
    rw [â† lift_inj.{_, w + 1}, lift_lift, lift_lift] at hS
    exact small_iff_lift_mk_lt_univ.2 (lt_of_eq_of_lt hS Îº.lift_lt_univ')
  refine'
    âŸ¨(equivShrink S).bundledInduced L,
      âŸ¨S.subtype.comp (Equiv.bundledInducedEquiv L _).symm.toElementaryEmbeddingâŸ©,
      lift_inj.1 (trans _ hS)âŸ©
  simp only [Equiv.bundledInduced_Î±, lift_mk_shrink']","error:  ambiguous, possible interpretations 
  _root_.trans ?m.22387 hS : lift.{w', w} #â†‘(Equiv.bundledInduced L (equivShrink â†¥S)) = lift.{w', w} Îº
  
  Trans.trans ?m.22583 hS : lift.{w', w} #â†‘(Equiv.bundledInduced L (equivShrink â†¥S)) = lift.{w', w} Îº
error:  no goals to be solved
error:  invalid occurrence of universe level 'u_1' at 'FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_ge', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  exists_elementaryEmbedding_card_eq_of_le.{max w' u, v, w, max (max (max u v) w) w', u_1}
    (withConstants.{u, v, w'} L M) (â†‘N0) Îº
    (Iff.mp aleph0_le_lift.{w, max (max u v) w'}
      (LE.le.trans.{max (w' + 1) ((max (max u v) w) + 1)}
        (Iff.mpr aleph0_le_lift.{w', max (max u v) w} (aleph0_le_mk.{w'} M))
        (Eq.mp.{0}
          (congrArg.{(max (max w' w) u v) + 2, 1}
            (fun _a â†¦ LE.le.{max ((max u v) + 1) ((max w w') + 1)} (lift.{max w u v, w'} (Cardinal.mk.{w'} M)) _a)
            (lift_lift.{w', max u v, w} Îº))
          (Eq.mp.{0}
            (congrArg.{(max (max w w') u v) + 2, 1}
              (fun _a â†¦ LE.le.{max ((max u v) + 1) ((max w w') + 1)} _a (lift.{max u v, max w w'} (lift.{w', w} Îº)))
              (lift_lift.{w, max u v, w'} (Cardinal.mk.{w'} M)))
            (Eq.mp.{0} (congrArg.{1, 1} (fun _a â†¦ _a) (Eq.symm.{1} (propext lift_le.{max u v, max w w'}))) h2)))))
    (Eq.mpr.{0}
      (id.{0}
        (congrArg.{(max (max (max w' u) v) w) + 2, 1}
          (fun x â†¦ LE.le.{max (max ((max w' u) + 1) (v + 1)) (w + 1)} x (lift.{max (max w' u) v, w} Îº))
          (Eq.trans.{(max (max (max w' u) v) w) + 2}
            (Eq.trans.{(max (max (max w' u) v) w) + 2}
              (congrArg.{(max (max w' u) v) + 2, (max (max (max w' u) v) w) + 2} lift.{w, max (max w' u) v}
                (card_withConstants.{u, v, w'} L M))
              (lift_add.{max (max u v) w', w} (lift.{w', max u v} (card.{u, v} L))
                (lift.{max u v, w'} (Cardinal.mk.{w'} M))))
            (congr.{(max (max (max u v) w') w) + 2, (max (max (max u v) w') w) + 2}
              (congrArg.{(max (max (max u v) w') w) + 2, max (max (max (u + 2) (v + 2)) (w + 2)) (w' + 2)}
                HAdd.hAdd.{max ((max (max u v) w') + 1) (w + 1), max ((max (max u v) w') + 1) (w + 1),
                  max ((max (max u v) w') + 1) (w + 1)}
                (lift_lift.{w', w, max u v} (card.{u, v} L)))
              (lift_lift.{max u v, w, w'} (Cardinal.mk.{w'} M))))))
      (Eq.mpr.{0}
        (id.{0}
          (congrArg.{(max (max (max (u + 1) (v + 1)) (w + 1)) (w' + 1)) + 1, 1}
            (fun _a â†¦ LE.le.{max (max ((max w' u) + 1) (v + 1)) (w + 1)} _a (lift.{max (max w' u) v, w} Îº))
            (add_comm.{max (max (max (u + 1) (v + 1)) (w + 1)) (w' + 1)} (lift.{max w' w, max u v} (card.{u, v} L))
              (lift.{max (max u v) w, w'} (Cardinal.mk.{w'} M)))))
        (Eq.mpr.{0}
          (id.{0}
            (congrArg.{(max (max (max u v) w) w') + 2, 1}
              (fun _a â†¦ LE.le.{max (max ((max w' u) + 1) (v + 1)) (w + 1)} _a (lift.{max (max w' u) v, w} Îº))
              (add_eq_max.{max (max (max u v) w) w'}
                (Iff.mpr aleph0_le_lift.{w', max (max u v) w} (Iff.mp infinite_iff.{w'} iM)))))
          (Eq.mpr.{0}
            (id.{0}
              (congrArg.{1, 1} (fun _a â†¦ _a) (propext max_le_iff.{max (max (max (u + 1) (v + 1)) (w + 1)) (w' + 1)})))
            (And.intro
              (Eq.mp.{0}
                (congrArg.{(max (max w' w) u v) + 2, 1}
                  (fun _a â†¦ LE.le.{max ((max u v) + 1) ((max w w') + 1)} (lift.{max w u v, w'} (Cardinal.mk.{w'} M)) _a)
                  (lift_lift.{w', max u v, w} Îº))
                (Eq.mp.{0}
                  (congrArg.{(max (max w w') u v) + 2, 1}
                    (fun _a â†¦
                      LE.le.{max ((max u v) + 1) ((max w w') + 1)} _a (lift.{max u v, max w w'} (lift.{w', w} Îº)))
                    (lift_lift.{w, max u v, w'} (Cardinal.mk.{w'} M)))
                  (Eq.mp.{0} (congrArg.{1, 1} (fun _a â†¦ _a) (Eq.symm.{1} (propext lift_le.{max u v, max w w'}))) h2)))
              (Eq.mp.{0}
                (congrArg.{(max (max (max u v) w) w') + 2, 1}
                  (fun _a â†¦ LE.le.{max (w' + 1) ((max (max u v) w) + 1)} (lift.{max w w', max u v} (card.{u, v} L)) _a)
                  (lift_lift.{max u v, w', w} Îº))
                (Eq.mp.{0}
                  (congrArg.{(max (max w u v) w') + 2, 1}
                    (fun _a â†¦
                      LE.le.{max (w' + 1) ((max (max u v) w) + 1)} _a
                        (lift.{w', max (max u v) w} (lift.{max u v, w} Îº)))
                    (lift_lift.{w, w', max u v} (card.{u, v} L)))
                  (Eq.mp.{0} (congrArg.{1, 1} (fun _a â†¦ _a) (Eq.symm.{1} (propext lift_le.{w', max (max u v) w})))
                    h1))))))))
    (LE.le.trans.{max (max (max (u + 1) (v + 1)) (w + 1)) (w' + 1)} hN0
      (Eq.mpr.{0}
        (id.{0}
          (congrArg.{max (w + 2) ((max (max (max u v) w) w') + 2), 1}
            (fun _a â†¦
              LE.le.{max (max (max (u + 1) (v + 1)) (w + 1)) (w' + 1)} (Cardinal.mk.{max (max (max u w') v) w} â†‘N0)
                (_a (Cardinal.mk.{max (max (max u v) w) w'} â†‘N0)))
            (Eq.symm.{max (w + 2) ((max (max (max u v) w) w') + 2)} lift_umax'.{max (max (max u v) w) w', w})))
        (Eq.mpr.{0}
          (id.{0}
            (congrArg.{(max (max (max u v) w) w') + 2, 1}
              (fun _a â†¦
                LE.le.{max (max (max (u + 1) (v + 1)) (w + 1)) (w' + 1)} (Cardinal.mk.{max (max (max u w') v) w} â†‘N0)
                  _a)
              (lift_id.{max (max (max u v) w) w'} (Cardinal.mk.{max (max (max u v) w) w'} â†‘N0))))
          (le_refl.{max (max (max (u + 1) (v + 1)) (w + 1)) (w' + 1)} (Cardinal.mk.{max (max (max u w') v) w} â†‘N0)))))
at declaration body
  fun (L : Language) (M : Type w') [L.Structure M] [iM : Infinite M] (Îº : Cardinal.{w})
      (h1 : lift.{w, max u v} L.card â‰¤ lift.{max u v, w} Îº) (h2 : lift.{w, w'} #M â‰¤ lift.{w', w} Îº) â†¦
    Exists.casesOn (Theory.exists_large_model_of_infinite_model (L.elementaryDiagram M) Îº M)
      fun (N0 : (L.elementaryDiagram M).ModelType) (hN0 : lift.{max (max u w') v w, w} Îº â‰¤ #â†‘N0) â†¦
      Exists.casesOn
        (exists_elementaryEmbedding_card_eq_of_le (L[[M]]) (â†‘N0) Îº
          (aleph0_le_lift.mp
            (LE.le.trans (aleph0_le_lift.mpr (aleph0_le_mk M))
              (Eq.mp (congrArg (fun (_a : Cardinal.{max (max w' w) u v}) â†¦ lift.{max w u v, w'} #M â‰¤ _a) (lift_lift Îº))
                (Eq.mp
                  (congrArg (fun (_a : Cardinal.{max (max w w') u v}) â†¦ _a â‰¤ lift.{max u v, max w w'} (lift.{w', w} Îº))
                    (lift_lift #M))
                  (Eq.mp (congrArg (fun (_a : Prop) â†¦ _a) (Eq.symm (propext lift_le))) h2)))))
          (Eq.mpr
            (id
              (congrArg (fun (x : Cardinal.{max (max (max w' u) v) w}) â†¦ x â‰¤ lift.{max (max w' u) v, w} Îº)
                (Eq.trans
                  (Eq.trans (congrArg lift.{w, max (max w' u) v} (card_withConstants L M))
                    (lift_add (lift.{w', max u v} L.card) (lift.{max u v, w'} #M)))
                  (congr (congrArg HAdd.hAdd (lift_lift L.card)) (lift_lift #M)))))
            (Eq.mpr
              (id
                (congrArg (fun (_a : Cardinal.{max (max (max u v) w') w}) â†¦ _a â‰¤ lift.{max (max w' u) v, w} Îº)
                  (add_comm (lift.{max w' w, max u v} L.card) (lift.{max (max u v) w, w'} #M))))
              (Eq.mpr
                (id
                  (congrArg (fun (_a : Cardinal.{max (max (max u v) w) w'}) â†¦ _a â‰¤ lift.{max (max w' u) v, w} Îº)
                    (add_eq_max (aleph0_le_lift.mpr (infinite_iff.mp iM)))))
                (Eq.mpr (id (congrArg (fun (_a : Prop) â†¦ _a) (propext max_le_iff)))
                  âŸ¨Eq.mp
                      (congrArg (fun (_a : Cardinal.{max (max w' w) u v}) â†¦ lift.{max w u v, w'} #M â‰¤ _a) (lift_lift Îº))
                      (Eq.mp
                        (congrArg
                          (fun (_a : Cardinal.{max (max w w') u v}) â†¦ _a â‰¤ lift.{max u v, max w w'} (lift.{w', w} Îº))
                          (lift_lift #M))
                        (Eq.mp (congrArg (fun (_a : Prop) â†¦ _a) (Eq.symm (propext lift_le))) h2)),
                    Eq.mp
                      (congrArg (fun (_a : Cardinal.{max (max (max u v) w) w'}) â†¦ lift.{max w w', max u v} L.card â‰¤ _a)
                        (lift_lift Îº))
                      (Eq.mp
                        (congrArg
                          (fun (_a : Cardinal.{max (max w u v) w'}) â†¦
                            _a â‰¤ lift.{w', max (max u v) w} (lift.{max u v, w} Îº))
                          (lift_lift L.card))
                        (Eq.mp (congrArg (fun (_a : Prop) â†¦ _a) (Eq.symm (propext lift_le))) h1))âŸ©))))
          (LE.le.trans hN0
            (Eq.mpr
              (id
                (congrArg
                  (fun (_a : Cardinal.{max (max (max u v) w) w'} â†’ Cardinal.{max w (max (max u v) w) w'}) â†¦
                    #â†‘N0 â‰¤ _a #â†‘N0)
                  (Eq.symm lift_umax')))
              (Eq.mpr (id (congrArg (fun (_a : Cardinal.{max (max (max u v) w) w'}) â†¦ #â†‘N0 â‰¤ _a) (lift_id #â†‘N0)))
                (le_refl #â†‘N0)))))
        fun (N : Bundled L[[M]].Structure) (h : Nonempty (â†‘N â†ªâ‚‘[L[[M]]] â†‘N0) âˆ§ #â†‘N = Îº) â†¦
        And.casesOn h fun (left : Nonempty (â†‘N â†ªâ‚‘[L[[M]]] â†‘N0)) (hN : #â†‘N = Îº) â†¦
          Nonempty.casesOn left fun (NN0 : â†‘N â†ªâ‚‘[L[[M]]] â†‘N0) â†¦
            Exists.intro (Bundled.of â†‘N) âŸ¨Nonempty.intro (ElementaryEmbedding.ofModelsElementaryDiagram L M â†‘N), hNâŸ©
error:  unknown identifier 'exists_elementaryEmbedding_card_eq_of_ge'
error:  rcases tactic failed: xâœ : ?m.28217 is not an inductive datatype
error:  invalid occurrence of universe level 'u_1' at 'FirstOrder.Language.exists_elementarilyEquivalent_card_eq', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  exists_elementaryEmbedding_card_eq.{u, v, w, w', u_1} L M Îº h1 h2
at declaration body
  fun (L : Language) (M : Type w') [L.Structure M] [Infinite M] (Îº : Cardinal.{w}) (h1 : â„µâ‚€ â‰¤ Îº)
      (h2 : lift.{w, max u v} L.card â‰¤ lift.{max u v, w} Îº) â†¦
    Exists.casesOn (exists_elementaryEmbedding_card_eq L M Îº h1 h2)
      fun (N : Bundled L.Structure) (h : (Nonempty (â†‘N â†ªâ‚‘[L] M) âˆ¨ Nonempty (M â†ªâ‚‘[L] â†‘N)) âˆ§ #â†‘N = Îº) â†¦
      And.casesOn h fun (left : Nonempty (â†‘N â†ªâ‚‘[L] M) âˆ¨ Nonempty (M â†ªâ‚‘[L] â†‘N)) (hNÎº : #â†‘N = Îº) â†¦
        Or.casesOn left
          (fun (NM : Nonempty (â†‘N â†ªâ‚‘[L] M)) â†¦
            Exists.intro N âŸ¨ElementarilyEquivalent.symm (ElementaryEmbedding.elementarilyEquivalent NM.some), hNÎºâŸ©)
          fun (MN : Nonempty (M â†ªâ‚‘[L] â†‘N)) â†¦ Exists.intro N âŸ¨ElementaryEmbedding.elementarilyEquivalent MN.some, hNÎºâŸ©
error:  unknown identifier 'exists_elementarilyEquivalent_card_eq'
error:  rcases tactic failed: xâœ : ?m.29319 is not an inductive datatype
warning:  @ModelsBoundedFormula does not have a doc string
error:  unknown identifier 'exists_elementarilyEquivalent_card_eq'
error:  rcases tactic failed: xâœ : ?m.66698 is not an inductive datatype","theorem exists_elementaryEmbedding_card_eq_of_le (M : Type w') [L.Structure M] [Nonempty M]
    (Îº : Cardinal.{w}) (h1 : â„µâ‚€ â‰¤ Îº) (h2 : lift.{w} L.card â‰¤ Cardinal.lift.{max u v} Îº)
    (h3 : lift.{w'} Îº â‰¤ Cardinal.lift.{w} #M) :
    âˆƒ N : Bundled L.Structure, Nonempty (N â†ªâ‚‘[L] M) âˆ§ #N = Îº ",":= by
  obtain âŸ¨S, _, hSâŸ© := exists_elementarySubstructure_card_eq L âˆ… Îº h1 (by simp) h2 h3
  have : Small.{w} S := by
    rw [â† lift_inj.{_, w + 1}, lift_lift, lift_lift] at hS
    exact small_iff_lift_mk_lt_univ.2 (lt_of_eq_of_lt hS Îº.lift_lt_univ')
  refine
    âŸ¨(equivShrink S).bundledInduced L,
      âŸ¨S.subtype.comp (Equiv.bundledInducedEquiv L _).symm.toElementaryEmbeddingâŸ©,
      lift_inj.1 (_root_.trans ?_ hS)âŸ©
  simp only [Equiv.bundledInduced_Î±, lift_mk_shrink']"
Mathlib/MeasureTheory/Constructions/Polish.lean,MeasureTheory.measurableSet_exists_tendsto,measurableSet_exists_tendsto,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  rcases l.eq_or_neBot with rfl | hl
  Â· simp
  letI := upgradePolishSpace Î³
  rcases l.exists_antitone_basis with âŸ¨u, huâŸ©
  simp_rw [â† cauchy_map_iff_exists_tendsto]
  change MeasurableSet { x | _ âˆ§ _ }
  have :
    âˆ€ x,
      (map (fun i => f i x) l Ã—Ë¢ map (fun i => f i x) l).HasAntitoneBasis fun n =>
        ((fun i => f i x) '' u n) Ã—Ë¢ ((fun i => f i x) '' u n) :=
    fun x => hu.map.prod hu.map
  simp_rw [and_iff_right (hl.map _),
    Filter.HasBasis.le_basis_iff (this _).toHasBasis Metric.uniformity_basis_dist_inv_nat_succ,
    Set.setOf_forall]
  refine' MeasurableSet.biInter Set.countable_univ fun K _ => _
  simp_rw [Set.setOf_exists, true_and]
  refine' MeasurableSet.iUnion fun N => _
  simp_rw [prod_image_image_eq, image_subset_iff, prod_subset_iff, Set.setOf_forall]
  exact
    MeasurableSet.biInter (to_countable (u N)) fun i _ =>
      MeasurableSet.biInter (to_countable (u N)) fun j _ =>
        measurableSet_lt (Measurable.dist (hf i) (hf j)) measurable_const","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  HasAntitoneBasis.map hu
has type
  âˆ€ (m : Î¹ â†’ ?m.80684), (map m l).HasAntitoneBasis fun x â†¦ m '' u x","theorem measurableSet_exists_tendsto [TopologicalSpace Î³] [PolishSpace Î³] [MeasurableSpace Î³]
    [hÎ³ : OpensMeasurableSpace Î³] [Countable Î¹] {l : Filter Î¹}
    [l.IsCountablyGenerated] {f : Î¹ â†’ Î² â†’ Î³} (hf : âˆ€ i, Measurable (f i)) :
    MeasurableSet { x | âˆƒ c, Tendsto (fun n => f n x) l (ğ“ c) } ",":= by
  rcases l.eq_or_neBot with rfl | hl
  Â· simp
  letI := upgradePolishSpace Î³
  rcases l.exists_antitone_basis with âŸ¨u, huâŸ©
  simp_rw [â† cauchy_map_iff_exists_tendsto]
  change MeasurableSet { x | _ âˆ§ _ }
  have : âˆ€ x, (map (f Â· x) l Ã—Ë¢ map (f Â· x) l).HasAntitoneBasis fun n =>
      ((f Â· x) '' u n) Ã—Ë¢ ((f Â· x) '' u n) := fun x => (hu.map _).prod (hu.map _)
  simp_rw [and_iff_right (hl.map _),
    Filter.HasBasis.le_basis_iff (this _).toHasBasis Metric.uniformity_basis_dist_inv_nat_succ,
    Set.setOf_forall]
  refine MeasurableSet.biInter Set.countable_univ fun K _ => ?_
  simp_rw [Set.setOf_exists, true_and]
  refine MeasurableSet.iUnion fun N => ?_
  simp_rw [prod_image_image_eq, image_subset_iff, prod_subset_iff, Set.setOf_forall]
  exact
    MeasurableSet.biInter (to_countable (u N)) fun i _ =>
      MeasurableSet.biInter (to_countable (u N)) fun j _ =>
        measurableSet_lt (Measurable.dist (hf i) (hf j)) measurable_const"
Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean,Real.Angle.sin_neg,sin_neg,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction Î¸
  exact Real.sin_neg _","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Î¸ : Angle
âŠ¢ (-Î¸).sin = -Î¸.sin",theorem sin_neg (Î¸ : Angle) : sin (-Î¸) = -sin Î¸ ,":= by
  induction Î¸ using Real.Angle.induction_on
  exact Real.sin_neg _"
Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean,AlgebraicTopology.AlternatingFaceMapComplex.d_squared,d_squared,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff, Fin.val_succ,
      Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij âŸ¨i', j'âŸ© hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine' âŸ¨(j'.pred <| _, Fin.castSucc i'), _, _âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'
    Â· simp only [Fin.castLT_castSucc, Fin.succ_pred]
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa using hij","error:  simp made no progress
error:  simp made no progress
error:  application type mismatch
  Nat.le_sub_one_of_lt hij'
argument
  hij'
has type
  (i', j') âˆˆ Sá¶œ : Prop
but is expected to have type
  ?m.10060 < ?m.10061 : Prop
error:  simp made no progress
error:  type mismatch
  hâœ
has type
  (i, j) âˆˆ S : Prop
but is expected to have type
  j â‰¤ i.castSucc : Prop",theorem d_squared (n : â„•) : objD X (n + 1) â‰« objD X n = 0 ,":= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,
      Fin.val_succ, Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij âŸ¨i', j'âŸ© hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine âŸ¨(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'
    Â· simp only [Ï†, Fin.castLT_castSucc, Fin.succ_pred]
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa [S] using hij"
Mathlib/Data/Multiset/Antidiagonal.lean,Multiset.mem_antidiagonal,mem_antidiagonal,6fe10b887203687c25b54ffc0676792b35bec434,":=
  Quotient.inductionOn s <| fun l â†¦ by
    dsimp only [quot_mk_to_coe, antidiagonal_coe]
    refine' âŸ¨fun h => revzip_powersetAux h, fun h â†¦ _âŸ©
    haveI := Classical.decEq Î±
    simp only [revzip_powersetAux_lemma l revzip_powersetAux, h.symm, ge_iff_le, mem_coe, mem_map',
      mem_powersetAux]
    cases' x with xâ‚ xâ‚‚
    exact âŸ¨xâ‚, le_add_right _ _, by rw [add_tsub_cancel_left xâ‚ xâ‚‚]âŸ©","error:  unknown identifier 'mem_map''
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type with only one constructor 
  List.Mem (xâ‚, xâ‚‚) (List.map (fun x â†¦ (x, (xâ‚, xâ‚‚).1 + (xâ‚, xâ‚‚).2 - x)) (powersetAux l))","theorem mem_antidiagonal {s : Multiset Î±} {x : Multiset Î± Ã— Multiset Î±} :
    x âˆˆ antidiagonal s â†” x.1 + x.2 = s ",":=
  Quotient.inductionOn s fun l â†¦ by
    dsimp only [quot_mk_to_coe, antidiagonal_coe]
    refine âŸ¨fun h => revzip_powersetAux h, fun h â†¦ ?_âŸ©
    haveI := Classical.decEq Î±
    simp only [revzip_powersetAux_lemma l revzip_powersetAux, h.symm, ge_iff_le, mem_coe,
      List.mem_map, mem_powersetAux]
    cases' x with xâ‚ xâ‚‚
    exact âŸ¨xâ‚, le_add_right _ _, by rw [add_tsub_cancel_left xâ‚ xâ‚‚]âŸ©"
Mathlib/Data/PFun.lean,PFun.bind_defined,bind_defined,ef3c9bcd07782b044027916a64e925f3e4951707,":= fun a ha =>
  (âŸ¨H1 ha, H2 _ haâŸ© : (f >>= g).Dom.toPred a)","error:  invalid field 'toPred', the environment does not contain 'Set.toPred'
  (f >>= g).Dom
has type
  Set Î±
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  (f >>= g).Dom
has type
  Î± â†’ Prop","theorem bind_defined {Î± Î² Î³} (p : Set Î±) {f : Î± â†’. Î²} {g : Î² â†’ Î± â†’. Î³} (H1 : p âŠ† f.Dom)
    (H2 : âˆ€ x, p âŠ† (g x).Dom) : p âŠ† (f >>= g).Dom ",":= fun a ha =>
  (âŸ¨H1 ha, H2 _ haâŸ© : (f >>= g).Dom a)"
Mathlib/Analysis/Calculus/FDeriv/Measurable.lean,RightDerivMeasurableAux.D_subset_differentiable_set,D_subset_differentiable_set,eaa83c6685ef1ea5f937bbcf33f93c81fbc9bdb7,":= by
  have P : âˆ€ {n : â„•}, (0 : â„) < (1 / 2) ^ n := fun {n} => pow_pos (by norm_num) n
  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©
  have cpos : 0 < â€–câ€– := lt_trans zero_lt_one hc
  intro x hx
  have :
    âˆ€ e : â„•, âˆƒ n : â„•, âˆ€ p q, n â‰¤ p â†’ n â‰¤ q â†’
      âˆƒ L âˆˆ K, x âˆˆ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) âˆ© A f L ((1 / 2) ^ q) ((1 / 2) ^ e) := by
    intro e
    have := mem_iInter.1 hx e
    rcases mem_iUnion.1 this with âŸ¨n, hnâŸ©
    refine' âŸ¨n, fun p q hp hq => _âŸ©
    simp only [mem_iInter, ge_iff_le] at hn
    rcases mem_iUnion.1 (hn p hp q hq) with âŸ¨L, hLâŸ©
    exact âŸ¨L, exists_prop.mp <| mem_iUnion.1 hLâŸ©
  choose! n L hn using this
  have M :
    âˆ€ e p q e' p' q',
      n e â‰¤ p â†’
        n e â‰¤ q â†’
          n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’ â€–L e p q - L e' p' q'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p q e' p' q' hp hq hp' hq' he'
    let r := max (n e) (n e')
    have I : ((1 : â„) / 2) ^ e' â‰¤ (1 / 2) ^ e :=
      pow_le_pow_of_le_one (by norm_num) (by norm_num) he'
    have J1 : â€–L e p q - L e p râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1
      have I2 : x âˆˆ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1
      exact norm_sub_le_of_mem_A hc P P I1 I2
    have J2 : â€–L e p r - L e' p' râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2
      have I2 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.2
      exact norm_sub_le_of_mem_A hc P P I1 (A_mono _ _ I I2)
    have J3 : â€–L e' p' r - L e' p' q'â€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.1
      have I2 : x âˆˆ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1
      exact norm_sub_le_of_mem_A hc P P (A_mono _ _ I I1) (A_mono _ _ I I2)
    calc
      â€–L e p q - L e' p' q'â€– =
          â€–L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')â€– :=
        by congr 1; abel
      _ â‰¤ â€–L e p q - L e p râ€– + â€–L e p r - L e' p' râ€– + â€–L e' p' r - L e' p' q'â€– :=
        norm_addâ‚ƒ_le _ _ _
      _ â‰¤ 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e := by gcongr
      _ = 12 * â€–câ€– * (1 / 2) ^ e := by ring
  let L0 : â„• â†’ E â†’L[ğ•œ] F := fun e => L e (n e) (n e)
  have : CauchySeq L0 := by
    rw [Metric.cauchySeq_iff']
    intro Îµ Îµpos
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (div_pos Îµpos (mul_pos (by norm_num) cpos)) (by norm_num)
    refine' âŸ¨e, fun e' he' => _âŸ©
    rw [dist_comm, dist_eq_norm]
    calc
      â€–L0 e - L0 e'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'
      _ < 12 * â€–câ€– * (Îµ / (12 * â€–câ€–)) := by gcongr
      _ = Îµ := by field_simp [(by norm_num : (12 : â„) â‰  0), ne_of_gt cpos]; ring
  obtain âŸ¨f', f'K, hf'âŸ© : âˆƒ f' âˆˆ K, Tendsto L0 atTop (ğ“ f') :=
    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this
  have Lf' : âˆ€ e p, n e â‰¤ p â†’ â€–L e (n e) p - f'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p hp
    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm
    rw [eventually_atTop]
    exact âŸ¨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'âŸ©
  have : HasFDerivAt f f' x := by
    simp only [hasFDerivAt_iff_isLittleO_nhds_zero, isLittleO_iff]
    intro Îµ Îµpos
    have pos : 0 < 4 + 12 * â€–câ€– := by positivity
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (4 + 12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (div_pos Îµpos pos) (by norm_num)
    rw [eventually_nhds_iff_ball]
    refine' âŸ¨(1 / 2) ^ (n e + 1), P, fun y hy => _âŸ©
    by_cases y_pos : y = 0;
    Â· simp [y_pos]
    have yzero : 0 < â€–yâ€– := norm_pos_iff.mpr y_pos
    have y_lt : â€–yâ€– < (1 / 2) ^ (n e + 1) := by simpa using mem_ball_iff_norm.1 hy
    have yone : â€–yâ€– â‰¤ 1 := le_trans y_lt.le (pow_le_one _ (by norm_num) (by norm_num))
    obtain âŸ¨k, hk, h'kâŸ© : âˆƒ k : â„•, (1 / 2) ^ (k + 1) < â€–yâ€– âˆ§ â€–yâ€– â‰¤ (1 / 2) ^ k :=
      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : â„) < 1 / 2)
        (by norm_num : (1 : â„) / 2 < 1)
    have k_gt : n e < k := by
      have : ((1 : â„) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_trans hk y_lt
      rw [pow_lt_pow_iff_of_lt_one (by norm_num : (0 : â„) < 1 / 2) (by norm_num)] at this
      linarith
    set m := k - 1
    have m_ge : n e â‰¤ m := Nat.le_sub_one_of_lt k_gt
    have km : k = m + 1 := (Nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm
    rw [km] at hk h'k
    have J1 : â€–f (x + y) - f x - L e (n e) m (x + y - x)â€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
      apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2
      Â· simp only [mem_closedBall, dist_self]
        exact div_nonneg (le_of_lt P) zero_le_two
      Â· simpa only [dist_eq_norm, add_sub_cancel', mem_closedBall, pow_succ', mul_one_div] using
          h'k
    have J2 : â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– :=
      calc
        â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
          simpa only [add_sub_cancel'] using J1
        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by field_simp; ring
        _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– := by gcongr
    calc
      â€–f (x + y) - f x - f' yâ€– = â€–f (x + y) - f x - L e (n e) m y + (L e (n e) m - f') yâ€– :=
        congr_arg _ (by simp)
      _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– + 12 * â€–câ€– * (1 / 2) ^ e * â€–yâ€– :=
        norm_add_le_of_le J2 <| by grw [le_op_norm, Lf' _ _ m_ge]
      _ = (4 + 12 * â€–câ€–) * â€–yâ€– * (1 / 2) ^ e := by ring
      _ â‰¤ (4 + 12 * â€–câ€–) * â€–yâ€– * (Îµ / (4 + 12 * â€–câ€–)) := by gcongr
      _ = Îµ * â€–yâ€– := by field_simp [ne_of_gt pos]; ring
  rw [â† this.fderiv] at f'K
  exact âŸ¨this.differentiableAt, f'KâŸ©","error:  unknown tactic
error:  unsolved goals
ğ•œ : Type u_1
instâœâ´ : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace ğ•œ E
F : Type u_3
instâœÂ¹ : NormedAddCommGroup F
instâœ : NormedSpace ğ•œ F
f : E â†’ F
Kâœ K : Set (E â†’L[ğ•œ] F)
hK : IsComplete K
P : âˆ€ {n : â„•}, 0 < (1 / 2) ^ n
c : ğ•œ
hc : 1 < â€–câ€–
cpos : 0 < â€–câ€–
x : E
hx : x âˆˆ D f K
n : â„• â†’ â„•
L : â„• â†’ â„• â†’ â„• â†’ E â†’L[ğ•œ] F
hn :
  âˆ€ (e p q : â„•),
    n e â‰¤ p â†’
      n e â‰¤ q â†’ L e p q âˆˆ K âˆ§ x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) âˆ© A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)
M :
  âˆ€ (e p q e' p' q' : â„•),
    n e â‰¤ p â†’ n e â‰¤ q â†’ n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’ â€–L e p q - L e' p' q'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e
L0 : â„• â†’ E â†’L[ğ•œ] F := fun e â†¦ L e (n e) (n e)
this : CauchySeq L0
f' : E â†’L[ğ•œ] F
f'K : f' âˆˆ K
hf' : Tendsto L0 atTop (ğ“ f')
Lf' : âˆ€ (e p : â„•), n e â‰¤ p â†’ â€–L e (n e) p - f'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e
Îµ : â„
Îµpos : 0 < Îµ
pos : 0 < 4 + 12 * â€–câ€–
e : â„•
he : (1 / 2) ^ e < Îµ / (4 + 12 * â€–câ€–)
y : E
hy : y âˆˆ ball 0 ((1 / 2) ^ (n e + 1))
y_pos : Â¬y = 0
yzero : 0 < â€–yâ€–
y_lt : â€–yâ€– < (1 / 2) ^ (n e + 1)
yone : â€–yâ€– â‰¤ 1
k : â„•
k_gt : n e < k
m : â„• := k - 1
h'k : â€–yâ€– â‰¤ (1 / 2) ^ (m + 1)
hk : (1 / 2) ^ (m + 1 + 1) < â€–yâ€–
m_ge : n e â‰¤ m
km : k = m + 1
J1 : â€–f (x + y) - f x - (L e (n e) m) (x + y - x)â€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m
J2 : â€–f (x + y) - f x - (L e (n e) m) yâ€– â‰¤ 4 * (1 / 2) ^ e * â€–yâ€–
âŠ¢ â€–(L e (n e) m - f') yâ€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e * â€–yâ€–
error:  unsolved goals
case neg.intro.intro.calc.step
ğ•œ : Type u_1
instâœâ´ : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace ğ•œ E
F : Type u_3
instâœÂ¹ : NormedAddCommGroup F
instâœ : NormedSpace ğ•œ F
f : E â†’ F
Kâœ K : Set (E â†’L[ğ•œ] F)
hK : IsComplete K
P : âˆ€ {n : â„•}, 0 < (1 / 2) ^ n
c : ğ•œ
hc : 1 < â€–câ€–
cpos : 0 < â€–câ€–
x : E
hx : x âˆˆ D f K
n : â„• â†’ â„•
L : â„• â†’ â„• â†’ â„• â†’ E â†’L[ğ•œ] F
hn :
  âˆ€ (e p q : â„•),
    n e â‰¤ p â†’
      n e â‰¤ q â†’ L e p q âˆˆ K âˆ§ x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) âˆ© A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)
M :
  âˆ€ (e p q e' p' q' : â„•),
    n e â‰¤ p â†’ n e â‰¤ q â†’ n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’ â€–L e p q - L e' p' q'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e
L0 : â„• â†’ E â†’L[ğ•œ] F := fun e â†¦ L e (n e) (n e)
this : CauchySeq L0
f' : E â†’L[ğ•œ] F
f'K : f' âˆˆ K
hf' : Tendsto L0 atTop (ğ“ f')
Lf' : âˆ€ (e p : â„•), n e â‰¤ p â†’ â€–L e (n e) p - f'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e
Îµ : â„
Îµpos : 0 < Îµ
pos : 0 < 4 + 12 * â€–câ€–
e : â„•
he : (1 / 2) ^ e < Îµ / (4 + 12 * â€–câ€–)
y : E
hy : y âˆˆ ball 0 ((1 / 2) ^ (n e + 1))
y_pos : Â¬y = 0
yzero : 0 < â€–yâ€–
y_lt : â€–yâ€– < (1 / 2) ^ (n e + 1)
yone : â€–yâ€– â‰¤ 1
k : â„•
k_gt : n e < k
m : â„• := k - 1
h'k : â€–yâ€– â‰¤ (1 / 2) ^ (m + 1)
hk : (1 / 2) ^ (m + 1 + 1) < â€–yâ€–
m_ge : n e â‰¤ m
km : k = m + 1
J1 : â€–f (x + y) - f x - (L e (n e) m) (x + y - x)â€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m
J2 : â€–f (x + y) - f x - (L e (n e) m) yâ€– â‰¤ 4 * (1 / 2) ^ e * â€–yâ€–
âŠ¢ 4 * (1 / 2) ^ e * â€–yâ€– + 12 * â€–câ€– * (1 / 2) ^ e * â€–yâ€– â‰¤ Îµ * â€–yâ€–
error:  unsolved goals
case intro.intro.intro
ğ•œ : Type u_1
instâœâ´ : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace ğ•œ E
F : Type u_3
instâœÂ¹ : NormedAddCommGroup F
instâœ : NormedSpace ğ•œ F
f : E â†’ F
Kâœ K : Set (E â†’L[ğ•œ] F)
hK : IsComplete K
P : âˆ€ {n : â„•}, 0 < (1 / 2) ^ n
c : ğ•œ
hc : 1 < â€–câ€–
cpos : 0 < â€–câ€–
x : E
hx : x âˆˆ D f K
n : â„• â†’ â„•
L : â„• â†’ â„• â†’ â„• â†’ E â†’L[ğ•œ] F
hn :
  âˆ€ (e p q : â„•),
    n e â‰¤ p â†’
      n e â‰¤ q â†’ L e p q âˆˆ K âˆ§ x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) âˆ© A f (L e p q) ((1 / 2) ^ q) ((1 / 2) ^ e)
M :
  âˆ€ (e p q e' p' q' : â„•),
    n e â‰¤ p â†’ n e â‰¤ q â†’ n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’ â€–L e p q - L e' p' q'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e
L0 : â„• â†’ E â†’L[ğ•œ] F := fun e â†¦ L e (n e) (n e)
thisâœ : CauchySeq L0
f' : E â†’L[ğ•œ] F
f'K : f' âˆˆ K
hf' : Tendsto L0 atTop (ğ“ f')
Lf' : âˆ€ (e p : â„•), n e â‰¤ p â†’ â€–L e (n e) p - f'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e
this : HasFDerivAt f f' x
âŠ¢ x âˆˆ {x | DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K}","theorem D_subset_differentiable_set {K : Set (E â†’L[ğ•œ] F)} (hK : IsComplete K) :
    D f K âŠ† { x | DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K } ",":= by
  have P : âˆ€ {n : â„•}, (0 : â„) < (1 / 2) ^ n := fun {n} => pow_pos (by norm_num) n
  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©
  intro x hx
  have :
    âˆ€ e : â„•, âˆƒ n : â„•, âˆ€ p q, n â‰¤ p â†’ n â‰¤ q â†’
      âˆƒ L âˆˆ K, x âˆˆ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) âˆ© A f L ((1 / 2) ^ q) ((1 / 2) ^ e) := by
    intro e
    have := mem_iInter.1 hx e
    rcases mem_iUnion.1 this with âŸ¨n, hnâŸ©
    refine âŸ¨n, fun p q hp hq => ?_âŸ©
    simp only [mem_iInter, ge_iff_le] at hn
    rcases mem_iUnion.1 (hn p hp q hq) with âŸ¨L, hLâŸ©
    exact âŸ¨L, exists_prop.mp <| mem_iUnion.1 hLâŸ©
  choose! n L hn using this
  have M :
    âˆ€ e p q e' p' q',
      n e â‰¤ p â†’
        n e â‰¤ q â†’
          n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’ â€–L e p q - L e' p' q'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p q e' p' q' hp hq hp' hq' he'
    let r := max (n e) (n e')
    have I : ((1 : â„) / 2) ^ e' â‰¤ (1 / 2) ^ e :=
      pow_le_pow_of_le_one (by norm_num) (by norm_num) he'
    have J1 : â€–L e p q - L e p râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1
      have I2 : x âˆˆ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1
      exact norm_sub_le_of_mem_A hc P P I1 I2
    have J2 : â€–L e p r - L e' p' râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2
      have I2 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.2
      exact norm_sub_le_of_mem_A hc P P I1 (A_mono _ _ I I2)
    have J3 : â€–L e' p' r - L e' p' q'â€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.1
      have I2 : x âˆˆ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1
      exact norm_sub_le_of_mem_A hc P P (A_mono _ _ I I1) (A_mono _ _ I I2)
    calc
      â€–L e p q - L e' p' q'â€– =
          â€–L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')â€– := by
        congr 1; abel
      _ â‰¤ â€–L e p q - L e p râ€– + â€–L e p r - L e' p' râ€– + â€–L e' p' r - L e' p' q'â€– :=
        norm_addâ‚ƒ_le _ _ _
      _ â‰¤ 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e := by gcongr
      _ = 12 * â€–câ€– * (1 / 2) ^ e := by ring
  let L0 : â„• â†’ E â†’L[ğ•œ] F := fun e => L e (n e) (n e)
  have : CauchySeq L0 := by
    rw [Metric.cauchySeq_iff']
    intro Îµ Îµpos
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (by positivity) (by norm_num)
    refine âŸ¨e, fun e' he' => ?_âŸ©
    rw [dist_comm, dist_eq_norm]
    calc
      â€–L0 e - L0 e'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'
      _ < 12 * â€–câ€– * (Îµ / (12 * â€–câ€–)) := by gcongr
      _ = Îµ := by field_simp
  obtain âŸ¨f', f'K, hf'âŸ© : âˆƒ f' âˆˆ K, Tendsto L0 atTop (ğ“ f') :=
    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this
  have Lf' : âˆ€ e p, n e â‰¤ p â†’ â€–L e (n e) p - f'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p hp
    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm
    rw [eventually_atTop]
    exact âŸ¨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'âŸ©
  have : HasFDerivAt f f' x := by
    simp only [hasFDerivAt_iff_isLittleO_nhds_zero, isLittleO_iff]
    intro Îµ Îµpos
    have pos : 0 < 4 + 12 * â€–câ€– := by positivity
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (4 + 12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (div_pos Îµpos pos) (by norm_num)
    rw [eventually_nhds_iff_ball]
    refine âŸ¨(1 / 2) ^ (n e + 1), P, fun y hy => ?_âŸ©
    by_cases y_pos : y = 0;
    Â· simp [y_pos]
    have yzero : 0 < â€–yâ€– := norm_pos_iff.mpr y_pos
    have y_lt : â€–yâ€– < (1 / 2) ^ (n e + 1) := by simpa using mem_ball_iff_norm.1 hy
    have yone : â€–yâ€– â‰¤ 1 := le_trans y_lt.le (pow_le_one _ (by norm_num) (by norm_num))
    obtain âŸ¨k, hk, h'kâŸ© : âˆƒ k : â„•, (1 / 2) ^ (k + 1) < â€–yâ€– âˆ§ â€–yâ€– â‰¤ (1 / 2) ^ k :=
      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : â„) < 1 / 2)
        (by norm_num : (1 : â„) / 2 < 1)
    have k_gt : n e < k := by
      have : ((1 : â„) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_trans hk y_lt
      rw [pow_lt_pow_iff_right_of_lt_one (by norm_num : (0 : â„) < 1 / 2) (by norm_num)] at this
      omega
    set m := k - 1
    have m_ge : n e â‰¤ m := Nat.le_sub_one_of_lt k_gt
    have km : k = m + 1 := (Nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm
    rw [km] at hk h'k
    have J1 : â€–f (x + y) - f x - L e (n e) m (x + y - x)â€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
      apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2
      Â· simp only [mem_closedBall, dist_self]
        positivity
      Â· simpa only [dist_eq_norm, add_sub_cancel_left, mem_closedBall, pow_succ, mul_one_div] using
          h'k
    have J2 : â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– :=
      calc
        â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
          simpa only [add_sub_cancel_left] using J1
        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by field_simp; ring
        _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– := by gcongr
    calc
      â€–f (x + y) - f x - f' yâ€– = â€–f (x + y) - f x - L e (n e) m y + (L e (n e) m - f') yâ€– :=
        congr_arg _ (by simp)
      _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– + 12 * â€–câ€– * (1 / 2) ^ e * â€–yâ€– :=
        norm_add_le_of_le J2 <| (le_opNorm _ _).trans <| by gcongr; exact Lf' _ _ m_ge
      _ = (4 + 12 * â€–câ€–) * â€–yâ€– * (1 / 2) ^ e := by ring
      _ â‰¤ (4 + 12 * â€–câ€–) * â€–yâ€– * (Îµ / (4 + 12 * â€–câ€–)) := by gcongr
      _ = Îµ * â€–yâ€– := by field_simp [ne_of_gt pos]; ring
  rw [â† this.fderiv] at f'K
  exact âŸ¨this.differentiableAt, f'KâŸ©"
Mathlib/RingTheory/Discriminant.lean,Algebra.discr_zero_of_not_linearIndependent,discr_zero_of_not_linearIndependent,d0e3dadb7f268f5d0b13ff76950fa593c6c44a2e,":= by
  classical
  obtain âŸ¨g, hg, i, hiâŸ© := Fintype.not_linearIndependent_iff.1 hli
  have : (traceMatrix A b).mulVec g = 0 := by
    ext i
    have : âˆ€ j, (trace A B) (b i * b j) * g j = (trace A B) (g j â€¢ b j * b i) := by
      intro j;
      simp [mul_comm]
    simp only [mulVec, dotProduct, traceMatrix_apply, Pi.zero_apply, traceForm_apply, fun j =>
      this j, â† LinearMap.map_sum, â† sum_mul, hg, zero_mul, LinearMap.map_zero]
  by_contra h
  rw [discr_def] at h
  simp [Matrix.eq_zero_of_mulVec_eq_zero h this] at hi","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.22531 â†’+* ?m.22532) â†’
    (M : Type ?u.22528) â†’
      (Mâ‚‚ : Type ?u.22527) â†’
        [inst : AddCommMonoid M] â†’
          [inst_1 : AddCommMonoid Mâ‚‚] â†’
            [inst : Module ?m.22531 M] â†’ [inst : Module ?m.22532 Mâ‚‚] â†’ Type (max ?u.22528 ?u.22527)
error:  unsolved goals
case h
A : Type u
B : Type v
C : Type z
Î¹ : Type w
instâœâ¹ : DecidableEq Î¹
instâœâ¸ : CommRing A
instâœâ· : CommRing B
instâœâ¶ : Algebra A B
instâœâµ : CommRing C
instâœâ´ : Algebra A C
Î¹' : Type u_1
instâœÂ³ : Fintype Î¹'
instâœÂ² : Fintype Î¹
instâœÂ¹ : DecidableEq Î¹'
instâœ : IsDomain A
b : Î¹ â†’ B
hli : Â¬LinearIndependent A b
g : Î¹ â†’ A
hg : âˆ‘ i : Î¹, g i â€¢ b i = 0
iâœ : Î¹
hi : g iâœ â‰  0
i : Î¹
this : âˆ€ (j : Î¹), (trace A B) (b i * b j) * g j = (trace A B) (g j â€¢ b j * b i)
âŠ¢ âˆ‘ x : Î¹, (trace A B) (g x â€¢ b x * b i) = 0","theorem discr_zero_of_not_linearIndependent [IsDomain A] {b : Î¹ â†’ B}
    (hli : Â¬LinearIndependent A b) : discr A b = 0 ",":= by
  classical
  obtain âŸ¨g, hg, i, hiâŸ© := Fintype.not_linearIndependent_iff.1 hli
  have : (traceMatrix A b) *áµ¥ g = 0 := by
    ext i
    have : âˆ€ j, (trace A B) (b i * b j) * g j = (trace A B) (g j â€¢ b j * b i) := by
      intro j;
      simp [mul_comm]
    simp only [mulVec, dotProduct, traceMatrix_apply, Pi.zero_apply, traceForm_apply, fun j =>
      this j, â† map_sum, â† sum_mul, hg, zero_mul, LinearMap.map_zero]
  by_contra h
  rw [discr_def] at h
  simp [Matrix.eq_zero_of_mulVec_eq_zero h this] at hi"
Mathlib/Algebra/Lie/Weights/Basic.lean,LieModule.independent_weightSpace,independent_weightSpace,28269e9608b6effc07d6a7ace3ec8db2f26eaad9,":= by
  classical
  suffices âˆ€ Ï‡ (s : Finset (L â†’ R)) (_ : Ï‡ âˆ‰ s),
      Disjoint (weightSpace M Ï‡) (s.sup fun (Ï‡ : L â†’ R) â†¦ weightSpace M Ï‡) by
    simpa only [CompleteLattice.independent_iff_supIndep_of_injOn (injOn_weightSpace R L M),
      Finset.supIndep_iff_disjoint_erase] using fun s Ï‡ _ â†¦ this _ _ (s.not_mem_erase Ï‡)
  intro Ï‡â‚ s
  induction' s using Finset.induction_on with Ï‡â‚‚ s _ ih; simp
  intro hÏ‡â‚â‚‚
  obtain âŸ¨hÏ‡â‚â‚‚ : Ï‡â‚ â‰  Ï‡â‚‚, hÏ‡â‚ : Ï‡â‚ âˆ‰ sâŸ© := by rwa [Finset.mem_insert, not_or] at hÏ‡â‚â‚‚
  specialize ih hÏ‡â‚
  rw [Finset.sup_insert, disjoint_iff, LieSubmodule.eq_bot_iff]
  rintro x âŸ¨hx, hx'âŸ©
  simp only [SetLike.mem_coe, LieSubmodule.mem_coeSubmodule] at hx hx'
  suffices x âˆˆ weightSpace M Ï‡â‚‚ by
    rw [â† LieSubmodule.mem_bot (R := R) (L := L), â† (disjoint_weightSpace R L M hÏ‡â‚â‚‚).eq_bot]
    exact âŸ¨hx, thisâŸ©
  obtain âŸ¨y, hy, z, hz, rflâŸ© := (LieSubmodule.mem_sup _ _ _).mp hx'; clear hx'
  suffices âˆ€ l, âˆƒ (k : â„•),
      ((toEndomorphism R L M l - algebraMap R (Module.End R M) (Ï‡â‚‚ l)) ^ k) (y + z) âˆˆ
      weightSpace M Ï‡â‚ âŠ“ Finset.sup s fun Ï‡ â†¦ weightSpace M Ï‡ by
    simpa only [ih.eq_bot, LieSubmodule.mem_bot, mem_weightSpace] using this
  intro l
  let g : Module.End R M := toEndomorphism R L M l - algebraMap R (Module.End R M) (Ï‡â‚‚ l)
  obtain âŸ¨k, hk : (g ^ k) y = 0âŸ© := (mem_weightSpace _ _ _).mp hy l
  refine âŸ¨k, (LieSubmodule.mem_inf _ _ _).mp âŸ¨?_, ?_âŸ©âŸ©
  Â· exact LieSubmodule.mapsTo_pow_toEndomorphism_sub_algebraMap _ hx
  Â· rw [map_add, hk, zero_add]
    suffices (s.sup fun Ï‡ â†¦ weightSpace M Ï‡ : Submodule R M).map (g ^ k) â‰¤
        s.sup fun Ï‡ â†¦ weightSpace M Ï‡ by
      refine this (Submodule.mem_map_of_mem ?_)
      simp_rw [â† LieSubmodule.mem_coeSubmodule, Finset.sup_eq_iSup,
        LieSubmodule.iSup_coe_toSubmodule, â† Finset.sup_eq_iSup] at hz
      exact hz
    simp_rw [Finset.sup_eq_iSup, Submodule.map_iSup (Î¹ := L â†’ R), Submodule.map_iSup (Î¹ := _ âˆˆ s),
      LieSubmodule.iSup_coe_toSubmodule]
    refine iSupâ‚‚_mono fun Ï‡ _ â†¦ ?_
    rintro - âŸ¨u, hu, rflâŸ©
    exact LieSubmodule.mapsTo_pow_toEndomorphism_sub_algebraMap _ hu","error:  unknown identifier 'toEndomorphism'
error:  unknown identifier 'toEndomorphism'
error:  rcases: scrutinee has type
  (((toEnd R L M) l - Ï‡â‚‚ l â€¢ 1) ^ k) y = 0 : Prop
but is expected to have type
  (g ^ k) y = 0 : Prop","lemma independent_weightSpace [NoZeroSMulDivisors R M] :
    CompleteLattice.Independent fun (Ï‡ : L â†’ R) â†¦ weightSpace M Ï‡ ",":= by
  classical
  suffices âˆ€ Ï‡ (s : Finset (L â†’ R)) (_ : Ï‡ âˆ‰ s),
      Disjoint (weightSpace M Ï‡) (s.sup fun (Ï‡ : L â†’ R) â†¦ weightSpace M Ï‡) by
    simpa only [CompleteLattice.independent_iff_supIndep_of_injOn (injOn_weightSpace R L M),
      Finset.supIndep_iff_disjoint_erase] using fun s Ï‡ _ â†¦ this _ _ (s.not_mem_erase Ï‡)
  intro Ï‡â‚ s
  induction' s using Finset.induction_on with Ï‡â‚‚ s _ ih
  Â· simp
  intro hÏ‡â‚â‚‚
  obtain âŸ¨hÏ‡â‚â‚‚ : Ï‡â‚ â‰  Ï‡â‚‚, hÏ‡â‚ : Ï‡â‚ âˆ‰ sâŸ© := by rwa [Finset.mem_insert, not_or] at hÏ‡â‚â‚‚
  specialize ih hÏ‡â‚
  rw [Finset.sup_insert, disjoint_iff, LieSubmodule.eq_bot_iff]
  rintro x âŸ¨hx, hx'âŸ©
  simp only [SetLike.mem_coe, LieSubmodule.mem_coeSubmodule] at hx hx'
  suffices x âˆˆ weightSpace M Ï‡â‚‚ by
    rw [â† LieSubmodule.mem_bot (R := R) (L := L), â† (disjoint_weightSpace R L M hÏ‡â‚â‚‚).eq_bot]
    exact âŸ¨hx, thisâŸ©
  obtain âŸ¨y, hy, z, hz, rflâŸ© := (LieSubmodule.mem_sup _ _ _).mp hx'; clear hx'
  suffices âˆ€ l, âˆƒ (k : â„•),
      ((toEnd R L M l - algebraMap R (Module.End R M) (Ï‡â‚‚ l)) ^ k) (y + z) âˆˆ
      weightSpace M Ï‡â‚ âŠ“ Finset.sup s fun Ï‡ â†¦ weightSpace M Ï‡ by
    simpa only [ih.eq_bot, LieSubmodule.mem_bot, mem_weightSpace] using this
  intro l
  let g : Module.End R M := toEnd R L M l - algebraMap R (Module.End R M) (Ï‡â‚‚ l)
  obtain âŸ¨k, hk : (g ^ k) y = 0âŸ© := (mem_weightSpace _ _ _).mp hy l
  refine âŸ¨k, (LieSubmodule.mem_inf _ _ _).mp âŸ¨?_, ?_âŸ©âŸ©
  Â· exact LieSubmodule.mapsTo_pow_toEnd_sub_algebraMap _ hx
  Â· rw [map_add, hk, zero_add]
    suffices (s.sup fun Ï‡ â†¦ weightSpace M Ï‡ : Submodule R M).map (g ^ k) â‰¤
        s.sup fun Ï‡ â†¦ weightSpace M Ï‡ by
      refine this (Submodule.mem_map_of_mem ?_)
      simp_rw [â† LieSubmodule.mem_coeSubmodule, Finset.sup_eq_iSup,
        LieSubmodule.iSup_coe_toSubmodule, â† Finset.sup_eq_iSup] at hz
      exact hz
    simp_rw [Finset.sup_eq_iSup, Submodule.map_iSup (Î¹ := L â†’ R), Submodule.map_iSup (Î¹ := _ âˆˆ s),
      LieSubmodule.iSup_coe_toSubmodule]
    refine iSupâ‚‚_mono fun Ï‡ _ â†¦ ?_
    rintro - âŸ¨u, hu, rflâŸ©
    exact LieSubmodule.mapsTo_pow_toEnd_sub_algebraMap _ hu"
Mathlib/MeasureTheory/Measure/WithDensityFinite.lean,MeasureTheory.toFiniteAux_absolutelyContinuous_toFinite,toFiniteAux_absolutelyContinuous_toFinite,4bc787e4cd27d5ae2ed300af7ae9e9f1c8480840,:= Measure.absolutelyContinuous_smul (by simp [measure_ne_top]),"error:  unsolved goals
Î± : Type u_1
mÎ± : MeasurableSpace Î±
Î¼âœ Î¼ : Measure Î±
instâœ : SFinite Î¼
âŠ¢ Â¬?m.39286 = 0","lemma toFiniteAux_absolutelyContinuous_toFinite (Î¼ : Measure Î±) [SFinite Î¼] :
    Î¼.toFiniteAux â‰ª Î¼.toFinite ",:= ProbabilityTheory.absolutelyContinuous_cond_univ
Mathlib/Analysis/Calculus/Taylor.lean,taylor_mean_remainder_bound,taylor_mean_remainder_bound,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  rcases eq_or_lt_of_le hab with (rfl | h)
  Â· rw [Icc_self, mem_singleton_iff] at hx
    simp [hx]
  have hf' : DifferentiableOn â„ (iteratedDerivWithin n f (Icc a b)) (Icc a b) :=
    hf.differentiableOn_iteratedDerivWithin (WithTop.coe_lt_coe.mpr n.lt_succ_self)
      (uniqueDiffOn_Icc h)
  have h' : âˆ€ y âˆˆ Ico a x,
      â€–((n ! : â„)â»Â¹ * (x - y) ^ n) â€¢ iteratedDerivWithin (n + 1) f (Icc a b) yâ€– â‰¤
        (n ! : â„)â»Â¹ * |x - a| ^ n * C := by
    rintro y âŸ¨hay, hyxâŸ©
    rw [norm_smul, Real.norm_eq_abs]
    gcongr
    Â· rw [abs_mul, abs_pow, abs_inv, Nat.abs_cast]
      gcongr
      rw [abs_of_nonneg, abs_of_nonneg] <;> linarith
    Â· exact hC y âŸ¨hay, hyx.le.trans hx.2âŸ©
  have A : âˆ€ t âˆˆ Icc a x, HasDerivWithinAt (fun y => taylorWithinEval f n (Icc a b) y x)
      (((â†‘n !)â»Â¹ * (x - t) ^ n) â€¢ iteratedDerivWithin (n + 1) f (Icc a b) t) (Icc a x) t := by
    intro t ht
    have I : Icc a x âŠ† Icc a b := Icc_subset_Icc_right hx.2
    exact (has_deriv_within_taylorWithinEval_at_Icc x h (I ht) hf.of_succ hf').mono I
  have := norm_image_sub_le_of_norm_deriv_le_segment' A h' x (right_mem_Icc.2 hx.1)
  simp only [taylorWithinEval_self] at this
  refine' this.trans_eq _
  rw [abs_of_nonneg (sub_nonneg.mpr hx.1)]
  ring","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  |?m.236441|
case intro.hâ‚.h.hab.ha
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace â„ E
f : â„ â†’ E
a b C x : â„
n : â„•
hab : a â‰¤ b
hf : ContDiffOn â„ (â†‘n + 1) f (Icc a b)
hx : x âˆˆ Icc a b
hC : âˆ€ y âˆˆ Icc a b, â€–iteratedDerivWithin (n + 1) f (Icc a b) yâ€– â‰¤ C
h : a < b
hf' : DifferentiableOn â„ (iteratedDerivWithin n f (Icc a b)) (Icc a b)
y : â„
hay : a â‰¤ y
hyx : y < x
âŠ¢ 0 â‰¤ x - y
error:  unknown identifier 'has_deriv_within_taylorWithinEval_at_Icc'","theorem taylor_mean_remainder_bound {f : â„ â†’ E} {a b C x : â„} {n : â„•} (hab : a â‰¤ b)
    (hf : ContDiffOn â„ (n + 1) f (Icc a b)) (hx : x âˆˆ Icc a b)
    (hC : âˆ€ y âˆˆ Icc a b, â€–iteratedDerivWithin (n + 1) f (Icc a b) yâ€– â‰¤ C) :
    â€–f x - taylorWithinEval f n (Icc a b) a xâ€– â‰¤ C * (x - a) ^ (n + 1) / n ! ",":= by
  rcases eq_or_lt_of_le hab with (rfl | h)
  Â· rw [Icc_self, mem_singleton_iff] at hx
    simp [hx]
  have hf' : DifferentiableOn â„ (iteratedDerivWithin n f (Icc a b)) (Icc a b) :=
    hf.differentiableOn_iteratedDerivWithin (WithTop.coe_lt_coe.mpr n.lt_succ_self)
      (uniqueDiffOn_Icc h)
  have h' : âˆ€ y âˆˆ Ico a x,
      â€–((n ! : â„)â»Â¹ * (x - y) ^ n) â€¢ iteratedDerivWithin (n + 1) f (Icc a b) yâ€– â‰¤
        (n ! : â„)â»Â¹ * |x - a| ^ n * C := by
    rintro y âŸ¨hay, hyxâŸ©
    rw [norm_smul, Real.norm_eq_abs]
    gcongr
    Â· rw [abs_mul, abs_pow, abs_inv, Nat.abs_cast]
      gcongr
      exact sub_nonneg.2 hyx.le
    Â· exact hC y âŸ¨hay, hyx.le.trans hx.2âŸ©
  have A : âˆ€ t âˆˆ Icc a x, HasDerivWithinAt (fun y => taylorWithinEval f n (Icc a b) y x)
      (((â†‘n !)â»Â¹ * (x - t) ^ n) â€¢ iteratedDerivWithin (n + 1) f (Icc a b) t) (Icc a x) t := by
    intro t ht
    have I : Icc a x âŠ† Icc a b := Icc_subset_Icc_right hx.2
    exact (hasDerivWithinAt_taylorWithinEval_at_Icc x h (I ht) hf.of_succ hf').mono I
  have := norm_image_sub_le_of_norm_deriv_le_segment' A h' x (right_mem_Icc.2 hx.1)
  simp only [taylorWithinEval_self] at this
  refine this.trans_eq ?_
  rw [abs_of_nonneg (sub_nonneg.mpr hx.1)]
  ring"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.lintegral_abs_det_fderiv_le_addHaar_image_aux1,lintegral_abs_det_fderiv_le_addHaar_image_aux1,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have :
    âˆ€ A : E â†’L[â„] E,
      âˆƒ Î´ : â„â‰¥0,
        0 < Î´ âˆ§
          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§
            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’
              ENNReal.ofReal |A.det| * Î¼ t â‰¤ Î¼ (g '' t) + Îµ * Î¼ t := by
    intro A
    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt Îµ Îµpos
    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©
    have I'' : âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ â†‘Î´'' â†’ |B.det - A.det| â‰¤ â†‘Îµ := by
      intro B hB
      rw [â† Real.dist_eq]
      apply (hÎ´' B _).le
      rw [dist_eq_norm]
      exact hB.trans_lt (half_lt_self Î´'pos)
    rcases eq_or_ne A.det 0 with (hA | hA)
    Â· refine âŸ¨Î´'', half_pos Î´'pos, I'', ?_âŸ©
      simp only [hA, forall_const, zero_mul, ENNReal.ofReal_zero, imp_true_iff,
        zero_le, abs_zero]
    let m : â„â‰¥0 := Real.toNNReal |A.det| - Îµ
    have I : (m : â„â‰¥0âˆ) < ENNReal.ofReal |A.det| := by
      simp only [m, ENNReal.ofReal, ENNReal.coe_sub]
      apply ENNReal.sub_lt_self ENNReal.coe_ne_top
      Â· simpa only [abs_nonpos_iff, Real.toNNReal_eq_zero, ENNReal.coe_eq_zero, Ne] using hA
      Â· simp only [Îµpos.ne', ENNReal.coe_eq_zero, Ne, not_false_iff]
    rcases ((mul_le_addHaar_image_of_lt_det Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©
    refine âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), ?_, ?_âŸ©
    Â· intro B hB
      apply I'' _ (hB.trans _)
      simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
    Â· intro t g htg
      rcases eq_or_ne (Î¼ t) âˆ with (ht | ht)
      Â· simp only [ht, Îµpos.ne', ENNReal.mul_top, ENNReal.coe_eq_zero, le_top, Ne,
          not_false_iff, _root_.add_top]
      have := h t g (htg.mono_num (min_le_left _ _))
      rwa [ENNReal.coe_sub, ENNReal.sub_mul, tsub_le_iff_right] at this
      simp only [ht, imp_true_iff, Ne, not_false_iff]
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  have s_eq : s = â‹ƒ n, s âˆ© t n := by
    rw [â† inter_iUnion]
    exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left _ _)
  calc
    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) =
        âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| âˆ‚Î¼ := by
      conv_lhs => rw [s_eq]
      rw [lintegral_iUnion]
      Â· exact fun n => hs.inter (t_meas n)
      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right _ _
    _ â‰¤ âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono (inter_subset_left _ _)]
      intro x hx
      have I : |(f' x).det| â‰¤ |(A n).det| + Îµ :=
        calc
          |(f' x).det| = |(A n).det + ((f' x).det - (A n).det)| := by congr 1; abel
          _ â‰¤ |(A n).det| + |(f' x).det - (A n).det| := abs_add _ _
          _ â‰¤ |(A n).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(f' x).det| â‰¤ ENNReal.ofReal (|(A n).det| + Îµ) :=
          ENNReal.ofReal_le_ofReal I
        _ = ENNReal.ofReal |(A n).det| + Îµ := by
          simp only [ENNReal.ofReal_add, abs_nonneg, NNReal.zero_le_coe, ENNReal.ofReal_coe_nnreal]
    _ = âˆ‘' n, (ENNReal.ofReal |(A n).det| * Î¼ (s âˆ© t n) + Îµ * Î¼ (s âˆ© t n)) := by
      simp only [set_lintegral_const, lintegral_add_right _ measurable_const]
    _ â‰¤ âˆ‘' n, (Î¼ (f '' (s âˆ© t n)) + Îµ * Î¼ (s âˆ© t n) + Îµ * Î¼ (s âˆ© t n)) := by
      gcongr
      exact (hÎ´ (A _)).2.2 _ _ (ht _)
    _ = Î¼ (f '' s) + 2 * Îµ * Î¼ s := by
      conv_rhs => rw [s_eq]
      rw [image_iUnion, measure_iUnion]; rotate_left
      Â· intro i j hij
        apply Disjoint.image _ hf (inter_subset_left _ _) (inter_subset_left _ _)
        exact Disjoint.mono (inter_subset_right _ _) (inter_subset_right _ _) (t_disj hij)
      Â· intro i
        exact
          measurable_image_of_fderivWithin (hs.inter (t_meas i))
            (fun x hx => (hf' x hx.1).mono (inter_subset_left _ _))
            (hf.mono (inter_subset_left _ _))
      rw [measure_iUnion]; rotate_left
      Â· exact pairwise_disjoint_mono t_disj fun i => inter_subset_right _ _
      Â· exact fun i => hs.inter (t_meas i)
      rw [â† ENNReal.tsum_mul_left, â† ENNReal.tsum_add]
      congr 1
      ext1 i
      rw [mul_assoc, two_mul, add_assoc]","error:  function expected at
  inter_subset_left ?m.487300
term has type
  ?m.487299 âˆˆ ?m.487297
error:  function expected at
  inter_subset_right ?m.491737
term has type
  ?m.491736 âˆˆ ?m.491735
error:  function expected at
  inter_subset_left ?m.492037
term has type
  ?m.492036 âˆˆ ?m.492034
warning:  `MeasureTheory.set_lintegral_const` has been deprecated, use `MeasureTheory.setLIntegral_const` instead
error:  function expected at
  inter_subset_left ?m.505648
term has type
  ?m.505647 âˆˆ ?m.505645
error:  function expected at
  inter_subset_left ?m.506119
term has type
  ?m.506118 âˆˆ ?m.506116
error:  function expected at
  inter_subset_left ?m.506190
term has type
  ?m.506189 âˆˆ ?m.506187
error:  function expected at
  inter_subset_right ?m.506602
term has type
  ?m.506601 âˆˆ ?m.506600","theorem lintegral_abs_det_fderiv_le_addHaar_image_aux1 (hs : MeasurableSet s)
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) {Îµ : â„â‰¥0} (Îµpos : 0 < Îµ) :
    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) â‰¤ Î¼ (f '' s) + 2 * Îµ * Î¼ s ",":= by
  have :
    âˆ€ A : E â†’L[â„] E,
      âˆƒ Î´ : â„â‰¥0,
        0 < Î´ âˆ§
          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§
            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’
              ENNReal.ofReal |A.det| * Î¼ t â‰¤ Î¼ (g '' t) + Îµ * Î¼ t := by
    intro A
    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt Îµ Îµpos
    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©
    have I'' : âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ â†‘Î´'' â†’ |B.det - A.det| â‰¤ â†‘Îµ := by
      intro B hB
      rw [â† Real.dist_eq]
      apply (hÎ´' B _).le
      rw [dist_eq_norm]
      exact hB.trans_lt (half_lt_self Î´'pos)
    rcases eq_or_ne A.det 0 with (hA | hA)
    Â· refine âŸ¨Î´'', half_pos Î´'pos, I'', ?_âŸ©
      simp only [hA, forall_const, zero_mul, ENNReal.ofReal_zero, imp_true_iff,
        zero_le, abs_zero]
    let m : â„â‰¥0 := Real.toNNReal |A.det| - Îµ
    have I : (m : â„â‰¥0âˆ) < ENNReal.ofReal |A.det| := by
      simp only [m, ENNReal.ofReal, ENNReal.coe_sub]
      apply ENNReal.sub_lt_self ENNReal.coe_ne_top
      Â· simpa only [abs_nonpos_iff, Real.toNNReal_eq_zero, ENNReal.coe_eq_zero, Ne] using hA
      Â· simp only [Îµpos.ne', ENNReal.coe_eq_zero, Ne, not_false_iff]
    rcases ((mul_le_addHaar_image_of_lt_det Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©
    refine âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), ?_, ?_âŸ©
    Â· intro B hB
      apply I'' _ (hB.trans _)
      simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
    Â· intro t g htg
      rcases eq_or_ne (Î¼ t) âˆ with (ht | ht)
      Â· simp only [ht, Îµpos.ne', ENNReal.mul_top, ENNReal.coe_eq_zero, le_top, Ne,
          not_false_iff, _root_.add_top]
      have := h t g (htg.mono_num (min_le_left _ _))
      rwa [ENNReal.coe_sub, ENNReal.sub_mul, tsub_le_iff_right] at this
      simp only [ht, imp_true_iff, Ne, not_false_iff]
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  have s_eq : s = â‹ƒ n, s âˆ© t n := by
    rw [â† inter_iUnion]
    exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left
  calc
    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) =
        âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| âˆ‚Î¼ := by
      conv_lhs => rw [s_eq]
      rw [lintegral_iUnion]
      Â· exact fun n => hs.inter (t_meas n)
      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
    _ â‰¤ âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono inter_subset_left]
      intro x hx
      have I : |(f' x).det| â‰¤ |(A n).det| + Îµ :=
        calc
          |(f' x).det| = |(A n).det + ((f' x).det - (A n).det)| := by congr 1; abel
          _ â‰¤ |(A n).det| + |(f' x).det - (A n).det| := abs_add _ _
          _ â‰¤ |(A n).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(f' x).det| â‰¤ ENNReal.ofReal (|(A n).det| + Îµ) :=
          ENNReal.ofReal_le_ofReal I
        _ = ENNReal.ofReal |(A n).det| + Îµ := by
          simp only [ENNReal.ofReal_add, abs_nonneg, NNReal.zero_le_coe, ENNReal.ofReal_coe_nnreal]
    _ = âˆ‘' n, (ENNReal.ofReal |(A n).det| * Î¼ (s âˆ© t n) + Îµ * Î¼ (s âˆ© t n)) := by
      simp only [setLIntegral_const, lintegral_add_right _ measurable_const]
    _ â‰¤ âˆ‘' n, (Î¼ (f '' (s âˆ© t n)) + Îµ * Î¼ (s âˆ© t n) + Îµ * Î¼ (s âˆ© t n)) := by
      gcongr
      exact (hÎ´ (A _)).2.2 _ _ (ht _)
    _ = Î¼ (f '' s) + 2 * Îµ * Î¼ s := by
      conv_rhs => rw [s_eq]
      rw [image_iUnion, measure_iUnion]; rotate_left
      Â· intro i j hij
        apply Disjoint.image _ hf inter_subset_left inter_subset_left
        exact Disjoint.mono inter_subset_right inter_subset_right (t_disj hij)
      Â· intro i
        exact
          measurable_image_of_fderivWithin (hs.inter (t_meas i))
            (fun x hx => (hf' x hx.1).mono inter_subset_left)
            (hf.mono inter_subset_left)
      rw [measure_iUnion]; rotate_left
      Â· exact pairwise_disjoint_mono t_disj fun i => inter_subset_right
      Â· exact fun i => hs.inter (t_meas i)
      rw [â† ENNReal.tsum_mul_left, â† ENNReal.tsum_add]
      congr 1
      ext1 i
      rw [mul_assoc, two_mul, add_assoc]"
Mathlib/MeasureTheory/Function/Egorov.lean,MeasureTheory.Egorov.measure_notConvergentSeq_tendsto_zero,measure_notConvergentSeq_tendsto_zero,b0906f1a9f950f5731cad2defb88e9843a7e3fc9,":= by
  cases' isEmpty_or_nonempty Î¹ with h h
  Â· have : (fun j => Î¼ (s âˆ© notConvergentSeq f g n j)) = fun j => 0 := by
      simp only [eq_iff_true_of_subsingleton]
    rw [this]
    exact tendsto_const_nhds
  rw [â† measure_inter_notConvergentSeq_eq_zero hfg n, Set.inter_iInter]
  refine' tendsto_measure_iInter (fun n => hsm.inter <| notConvergentSeq_measurableSet hf hg)
    (fun k l hkl => Set.inter_subset_inter_right _ <| notConvergentSeq_antitone hkl)
    âŸ¨h.some,
      (lt_of_le_of_lt (measure_mono <| Set.inter_subset_left _ _) (lt_top_iff_ne_top.2 hs)).neâŸ©","error:  function expected at
  inter_subset_left ?m.12268
term has type
  ?m.12267 âˆˆ ?m.12265","theorem measure_notConvergentSeq_tendsto_zero [SemilatticeSup Î¹] [Countable Î¹]
    (hf : âˆ€ n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g) (hsm : MeasurableSet s)
    (hs : Î¼ s â‰  âˆ) (hfg : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ Tendsto (fun n => f n x) atTop (ğ“ (g x))) (n : â„•) :
    Tendsto (fun j => Î¼ (s âˆ© notConvergentSeq f g n j)) atTop (ğ“ 0) ",":= by
  cases' isEmpty_or_nonempty Î¹ with h h
  Â· have : (fun j => Î¼ (s âˆ© notConvergentSeq f g n j)) = fun j => 0 := by
      simp only [eq_iff_true_of_subsingleton]
    rw [this]
    exact tendsto_const_nhds
  rw [â† measure_inter_notConvergentSeq_eq_zero hfg n, Set.inter_iInter]
  refine tendsto_measure_iInter (fun n => hsm.inter <| notConvergentSeq_measurableSet hf hg)
    (fun k l hkl => Set.inter_subset_inter_right _ <| notConvergentSeq_antitone hkl)
    âŸ¨h.some, ne_top_of_le_ne_top hs (measure_mono Set.inter_subset_left)âŸ©"
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,smul_vsub_rev_mem_vectorSpan_pair,smul_vsub_rev_mem_vectorSpan_pair,f27ef6dc0fb66aa1c033b41bb16e840c0a1527a5,":= by
  set_like","error:  unknown tactic
error:  unsolved goals
k : Type u_1
V : Type u_2
P : Type u_3
instâœÂ³ : Ring k
instâœÂ² : AddCommGroup V
instâœÂ¹ : Module k V
instâœ : AffineSpace V P
Î¹ : Type u_4
r : k
pâ‚ pâ‚‚ : P
âŠ¢ r â€¢ (pâ‚‚ -áµ¥ pâ‚) âˆˆ vectorSpan k {pâ‚, pâ‚‚}
warning:  @AffineSubspace.Parallel does not have a doc string","theorem smul_vsub_rev_mem_vectorSpan_pair (r : k) (pâ‚ pâ‚‚ : P) :
    r â€¢ (pâ‚‚ -áµ¥ pâ‚) âˆˆ vectorSpan k ({pâ‚, pâ‚‚} : Set P) ",":=
  Submodule.smul_mem _ _ (vsub_rev_mem_vectorSpan_pair k pâ‚ pâ‚‚)"
Mathlib/RingTheory/Localization/Basic.lean,Localization.add_mk,add_mk,e8b31359b48045c7bc8570e6e21659333f48f568,":= by
  rw [add_comm (b * c) (d * a), mul_comm b d]
  exact OreLocalization.oreDiv_add_oreDiv","warning:  @map_units' does not have a doc string
warning:  @surj' does not have a doc string
warning:  @exists_of_eq does not have a doc string
error:  typeclass instance problem is stuck, it is often due to metavariables
  DistribMulAction ?m.386818 ?m.386822","theorem add_mk (a b c d) : (mk a b : Localization M) + mk c d =
    mk ((b : R) * c + (d : R) * a) (b * d) ",":= by
  show Localization.add (mk a b) (mk c d) = mk _ _
  simp [Localization.add_def]"
Mathlib/Analysis/BoundedVariation.lean,eVariationOn.lowerSemicontinuous_uniformOn,lowerSemicontinuous_uniformOn,96cf974eb3910f8af599dab3fd734ea72d5614ad,":= fun f â†¦ by
  rw [lowerSemicontinuousAt_iff_eventually_lt]
  apply @lowerSemicontinuous_aux _ _ _ _ (UniformOnFun Î± E {s}) id (ğ“ f) f s _
  have := @tendsto_id _ (ğ“ f)
  rw [UniformOnFun.tendsto_iff_tendstoUniformlyOn] at this
  simp_rw [â† tendstoUniformlyOn_singleton_iff_tendsto]
  exact fun x xs => (this s rfl).mono (singleton_subset_iff.mpr xs)","error:  unknown identifier 'lowerSemicontinuousAt_iff_eventually_lt'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.31448
Î± : Type u_1
instâœÂ¹ : LinearOrder Î±
E : Type u_2
instâœ : PseudoEMetricSpace E
s : Set Î±
f : Î± â†’áµ¤[{s}] E
âŠ¢ LowerSemicontinuousAt (fun f â†¦ eVariationOn f s) f","theorem lowerSemicontinuous_uniformOn (s : Set Î±) :
    LowerSemicontinuous fun f : Î± â†’áµ¤[{s}] E => eVariationOn f s ",":= fun f â†¦ by
  apply @lowerSemicontinuous_aux _ _ _ _ (UniformOnFun Î± E {s}) id (ğ“ f) f s _
  have := @tendsto_id _ (ğ“ f)
  rw [UniformOnFun.tendsto_iff_tendstoUniformlyOn] at this
  simp_rw [â† tendstoUniformlyOn_singleton_iff_tendsto]
  exact fun x xs => (this s rfl).mono (singleton_subset_iff.mpr xs)"
Mathlib/Analysis/Calculus/FDeriv/Measurable.lean,RightDerivMeasurableAux.D_subset_differentiable_set,D_subset_differentiable_set,aa420cc4213ec00e046ed37661f7396b162d3e67,":= by
  have P : âˆ€ {n : â„•}, (0 : â„) < (1 / 2) ^ n := fun {n} => pow_pos (by norm_num) n
  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©
  intro x hx
  have :
    âˆ€ e : â„•, âˆƒ n : â„•, âˆ€ p q, n â‰¤ p â†’ n â‰¤ q â†’
      âˆƒ L âˆˆ K, x âˆˆ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) âˆ© A f L ((1 / 2) ^ q) ((1 / 2) ^ e) := by
    intro e
    have := mem_iInter.1 hx e
    rcases mem_iUnion.1 this with âŸ¨n, hnâŸ©
    refine' âŸ¨n, fun p q hp hq => _âŸ©
    simp only [mem_iInter, ge_iff_le] at hn
    rcases mem_iUnion.1 (hn p hp q hq) with âŸ¨L, hLâŸ©
    exact âŸ¨L, exists_prop.mp <| mem_iUnion.1 hLâŸ©
  choose! n L hn using this
  have M :
    âˆ€ e p q e' p' q',
      n e â‰¤ p â†’
        n e â‰¤ q â†’
          n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’ â€–L e p q - L e' p' q'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p q e' p' q' hp hq hp' hq' he'
    let r := max (n e) (n e')
    have I : ((1 : â„) / 2) ^ e' â‰¤ (1 / 2) ^ e :=
      pow_le_pow_of_le_one (by norm_num) (by norm_num) he'
    have J1 : â€–L e p q - L e p râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1
      have I2 : x âˆˆ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1
      exact norm_sub_le_of_mem_A hc P P I1 I2
    have J2 : â€–L e p r - L e' p' râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2
      have I2 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.2
      exact norm_sub_le_of_mem_A hc P P I1 (A_mono _ _ I I2)
    have J3 : â€–L e' p' r - L e' p' q'â€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.1
      have I2 : x âˆˆ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1
      exact norm_sub_le_of_mem_A hc P P (A_mono _ _ I I1) (A_mono _ _ I I2)
    calc
      â€–L e p q - L e' p' q'â€– =
          â€–L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')â€– :=
        by congr 1; abel
      _ â‰¤ â€–L e p q - L e p râ€– + â€–L e p r - L e' p' râ€– + â€–L e' p' r - L e' p' q'â€– :=
        norm_addâ‚ƒ_le _ _ _
      _ â‰¤ 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e := by gcongr
      _ = 12 * â€–câ€– * (1 / 2) ^ e := by ring
  let L0 : â„• â†’ E â†’L[ğ•œ] F := fun e => L e (n e) (n e)
  have : CauchySeq L0 := by
    rw [Metric.cauchySeq_iff']
    intro Îµ Îµpos
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (by positivity) (by norm_num)
    refine' âŸ¨e, fun e' he' => _âŸ©
    rw [dist_comm, dist_eq_norm]
    calc
      â€–L0 e - L0 e'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'
      _ < 12 * â€–câ€– * (Îµ / (12 * â€–câ€–)) := by gcongr
      _ = Îµ := by field_simp; ring
  obtain âŸ¨f', f'K, hf'âŸ© : âˆƒ f' âˆˆ K, Tendsto L0 atTop (ğ“ f') :=
    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this
  have Lf' : âˆ€ e p, n e â‰¤ p â†’ â€–L e (n e) p - f'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p hp
    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm
    rw [eventually_atTop]
    exact âŸ¨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'âŸ©
  have : HasFDerivAt f f' x := by
    simp only [hasFDerivAt_iff_isLittleO_nhds_zero, isLittleO_iff]
    intro Îµ Îµpos
    have pos : 0 < 4 + 12 * â€–câ€– := by positivity
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (4 + 12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (div_pos Îµpos pos) (by norm_num)
    rw [eventually_nhds_iff_ball]
    refine' âŸ¨(1 / 2) ^ (n e + 1), P, fun y hy => _âŸ©
    by_cases y_pos : y = 0;
    Â· simp [y_pos]
    have yzero : 0 < â€–yâ€– := norm_pos_iff.mpr y_pos
    have y_lt : â€–yâ€– < (1 / 2) ^ (n e + 1) := by simpa using mem_ball_iff_norm.1 hy
    have yone : â€–yâ€– â‰¤ 1 := le_trans y_lt.le (pow_le_one _ (by norm_num) (by norm_num))
    obtain âŸ¨k, hk, h'kâŸ© : âˆƒ k : â„•, (1 / 2) ^ (k + 1) < â€–yâ€– âˆ§ â€–yâ€– â‰¤ (1 / 2) ^ k :=
      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : â„) < 1 / 2)
        (by norm_num : (1 : â„) / 2 < 1)
    have k_gt : n e < k := by
      have : ((1 : â„) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_trans hk y_lt
      rw [pow_lt_pow_iff_right_of_lt_one (by norm_num : (0 : â„) < 1 / 2) (by norm_num)] at this
      linarith
    set m := k - 1
    have m_ge : n e â‰¤ m := Nat.le_sub_one_of_lt k_gt
    have km : k = m + 1 := (Nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm
    rw [km] at hk h'k
    have J1 : â€–f (x + y) - f x - L e (n e) m (x + y - x)â€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
      apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2
      Â· simp only [mem_closedBall, dist_self]
        positivity
      Â· simpa only [dist_eq_norm, add_sub_cancel', mem_closedBall, pow_succ', mul_one_div] using
          h'k
    have J2 : â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– :=
      calc
        â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
          simpa only [add_sub_cancel'] using J1
        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by field_simp; ring
        _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– := by gcongr
    calc
      â€–f (x + y) - f x - f' yâ€– = â€–f (x + y) - f x - L e (n e) m y + (L e (n e) m - f') yâ€– :=
        congr_arg _ (by simp)
      _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– + 12 * â€–câ€– * (1 / 2) ^ e * â€–yâ€– :=
        norm_add_le_of_le J2 <| (le_op_norm _ _).trans <| by gcongr; exact Lf' _ _ m_ge
      _ = (4 + 12 * â€–câ€–) * â€–yâ€– * (1 / 2) ^ e := by ring
      _ â‰¤ (4 + 12 * â€–câ€–) * â€–yâ€– * (Îµ / (4 + 12 * â€–câ€–)) := by gcongr
      _ = Îµ * â€–yâ€– := by field_simp [ne_of_gt pos]; ring
  rw [â† this.fderiv] at f'K
  exact âŸ¨this.differentiableAt, f'KâŸ©","error:  no goals to be solved
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  type mismatch
  hâœ
has type
  â€–yâ€– â‰¤ 1 / 2 * (1 / 2) ^ m : Prop
but is expected to have type
  â€–yâ€– â‰¤ (1 / 2) ^ m / 2 : Prop
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
warning:  `ContinuousLinearMap.le_op_norm` has been deprecated, use `ContinuousLinearMap.le_opNorm` instead","theorem D_subset_differentiable_set {K : Set (E â†’L[ğ•œ] F)} (hK : IsComplete K) :
    D f K âŠ† { x | DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K } ",":= by
  have P : âˆ€ {n : â„•}, (0 : â„) < (1 / 2) ^ n := fun {n} => pow_pos (by norm_num) n
  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©
  intro x hx
  have :
    âˆ€ e : â„•, âˆƒ n : â„•, âˆ€ p q, n â‰¤ p â†’ n â‰¤ q â†’
      âˆƒ L âˆˆ K, x âˆˆ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) âˆ© A f L ((1 / 2) ^ q) ((1 / 2) ^ e) := by
    intro e
    have := mem_iInter.1 hx e
    rcases mem_iUnion.1 this with âŸ¨n, hnâŸ©
    refine âŸ¨n, fun p q hp hq => ?_âŸ©
    simp only [mem_iInter, ge_iff_le] at hn
    rcases mem_iUnion.1 (hn p hp q hq) with âŸ¨L, hLâŸ©
    exact âŸ¨L, exists_prop.mp <| mem_iUnion.1 hLâŸ©
  choose! n L hn using this
  have M :
    âˆ€ e p q e' p' q',
      n e â‰¤ p â†’
        n e â‰¤ q â†’
          n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’ â€–L e p q - L e' p' q'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p q e' p' q' hp hq hp' hq' he'
    let r := max (n e) (n e')
    have I : ((1 : â„) / 2) ^ e' â‰¤ (1 / 2) ^ e :=
      pow_le_pow_of_le_one (by norm_num) (by norm_num) he'
    have J1 : â€–L e p q - L e p râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1
      have I2 : x âˆˆ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1
      exact norm_sub_le_of_mem_A hc P P I1 I2
    have J2 : â€–L e p r - L e' p' râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2
      have I2 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.2
      exact norm_sub_le_of_mem_A hc P P I1 (A_mono _ _ I I2)
    have J3 : â€–L e' p' r - L e' p' q'â€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.1
      have I2 : x âˆˆ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1
      exact norm_sub_le_of_mem_A hc P P (A_mono _ _ I I1) (A_mono _ _ I I2)
    calc
      â€–L e p q - L e' p' q'â€– =
          â€–L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')â€– := by
        congr 1; abel
      _ â‰¤ â€–L e p q - L e p râ€– + â€–L e p r - L e' p' râ€– + â€–L e' p' r - L e' p' q'â€– :=
        norm_addâ‚ƒ_le _ _ _
      _ â‰¤ 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e := by gcongr
      _ = 12 * â€–câ€– * (1 / 2) ^ e := by ring
  let L0 : â„• â†’ E â†’L[ğ•œ] F := fun e => L e (n e) (n e)
  have : CauchySeq L0 := by
    rw [Metric.cauchySeq_iff']
    intro Îµ Îµpos
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (by positivity) (by norm_num)
    refine âŸ¨e, fun e' he' => ?_âŸ©
    rw [dist_comm, dist_eq_norm]
    calc
      â€–L0 e - L0 e'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'
      _ < 12 * â€–câ€– * (Îµ / (12 * â€–câ€–)) := by gcongr
      _ = Îµ := by field_simp
  obtain âŸ¨f', f'K, hf'âŸ© : âˆƒ f' âˆˆ K, Tendsto L0 atTop (ğ“ f') :=
    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this
  have Lf' : âˆ€ e p, n e â‰¤ p â†’ â€–L e (n e) p - f'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p hp
    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm
    rw [eventually_atTop]
    exact âŸ¨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'âŸ©
  have : HasFDerivAt f f' x := by
    simp only [hasFDerivAt_iff_isLittleO_nhds_zero, isLittleO_iff]
    intro Îµ Îµpos
    have pos : 0 < 4 + 12 * â€–câ€– := by positivity
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (4 + 12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (div_pos Îµpos pos) (by norm_num)
    rw [eventually_nhds_iff_ball]
    refine âŸ¨(1 / 2) ^ (n e + 1), P, fun y hy => ?_âŸ©
    by_cases y_pos : y = 0;
    Â· simp [y_pos]
    have yzero : 0 < â€–yâ€– := norm_pos_iff.mpr y_pos
    have y_lt : â€–yâ€– < (1 / 2) ^ (n e + 1) := by simpa using mem_ball_iff_norm.1 hy
    have yone : â€–yâ€– â‰¤ 1 := le_trans y_lt.le (pow_le_one _ (by norm_num) (by norm_num))
    obtain âŸ¨k, hk, h'kâŸ© : âˆƒ k : â„•, (1 / 2) ^ (k + 1) < â€–yâ€– âˆ§ â€–yâ€– â‰¤ (1 / 2) ^ k :=
      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : â„) < 1 / 2)
        (by norm_num : (1 : â„) / 2 < 1)
    have k_gt : n e < k := by
      have : ((1 : â„) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_trans hk y_lt
      rw [pow_lt_pow_iff_right_of_lt_one (by norm_num : (0 : â„) < 1 / 2) (by norm_num)] at this
      omega
    set m := k - 1
    have m_ge : n e â‰¤ m := Nat.le_sub_one_of_lt k_gt
    have km : k = m + 1 := (Nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm
    rw [km] at hk h'k
    have J1 : â€–f (x + y) - f x - L e (n e) m (x + y - x)â€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
      apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2
      Â· simp only [mem_closedBall, dist_self]
        positivity
      Â· simpa only [dist_eq_norm, add_sub_cancel_left, mem_closedBall, pow_succ, mul_one_div] using
          h'k
    have J2 : â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– :=
      calc
        â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
          simpa only [add_sub_cancel_left] using J1
        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by field_simp; ring
        _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– := by gcongr
    calc
      â€–f (x + y) - f x - f' yâ€– = â€–f (x + y) - f x - L e (n e) m y + (L e (n e) m - f') yâ€– :=
        congr_arg _ (by simp)
      _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– + 12 * â€–câ€– * (1 / 2) ^ e * â€–yâ€– :=
        norm_add_le_of_le J2 <| (le_opNorm _ _).trans <| by gcongr; exact Lf' _ _ m_ge
      _ = (4 + 12 * â€–câ€–) * â€–yâ€– * (1 / 2) ^ e := by ring
      _ â‰¤ (4 + 12 * â€–câ€–) * â€–yâ€– * (Îµ / (4 + 12 * â€–câ€–)) := by gcongr
      _ = Îµ * â€–yâ€– := by field_simp [ne_of_gt pos]; ring
  rw [â† this.fderiv] at f'K
  exact âŸ¨this.differentiableAt, f'KâŸ©"
Mathlib/RingTheory/Finiteness.lean,Submodule.fg_iff_compact,fg_iff_compact,5bb9a8dd3d2ae6c23dc106b7e870c55d5ed93af8,":= by
  classical
    let sp : M â†’ Submodule R M := fun a => span R {a}
    have supr_rw : âˆ€ t : Finset M, (â¨† x âˆˆ t, sp x) = â¨† x âˆˆ (â†‘t : Set M), sp x := fun t => by rfl
    constructor
    Â· rintro âŸ¨t, rflâŸ©
      rw [span_eq_iSup_of_singleton_spans, â† supr_rw, â† Finset.sup_eq_iSup t sp]
      apply CompleteLattice.finset_sup_compact_of_compact
      exact fun n _ => singleton_span_isCompactElement n
    Â· intro h
      have sSup' : s = sSup (sp '' â†‘s) := by
        rw [sSup_eq_iSup, iSup_image, â† span_eq_iSup_of_singleton_spans, eq_comm, span_eq]
      obtain âŸ¨u, âŸ¨huspan, husupâŸ©âŸ© := h (sp '' â†‘s) (le_of_eq sSup')
      have ssup : s = u.sup id := by
        suffices : u.sup id â‰¤ s
        exact le_antisymm husup this
        rw [sSup', Finset.sup_id_eq_sSup]
        exact sSup_le_sSup huspan
      have := Finset.subset_image_iff.mp huspan
      obtain âŸ¨t, âŸ¨-, rflâŸ©âŸ© := this
      rw [Finset.sup_image, Function.comp.left_id, Finset.sup_eq_iSup, supr_rw, â†
        span_eq_iSup_of_singleton_spans, eq_comm] at ssup
      exact âŸ¨t, ssupâŸ©","error:  unexpected token ':'; expected term
error:  unsolved goals
case mpr.intro.intro
R : Type u_1
M : Type u_2
instâœâ´ : Semiring R
instâœÂ³ : AddCommMonoid M
instâœÂ² : Module R M
P : Type u_3
instâœÂ¹ : AddCommMonoid P
instâœ : Module R P
f : M â†’â‚—[R] P
s : Submodule R M
sp : M â†’ Submodule R M := fun a â†¦ span R {a}
supr_rw : âˆ€ (t : Finset M), â¨† x âˆˆ t, sp x = â¨† x âˆˆ â†‘t, sp x
h : CompleteLattice.IsCompactElement s
sSup' : s = sSup (sp '' â†‘s)
u : Finset (Submodule R M)
huspan : â†‘u âŠ† sp '' â†‘s
husup : s â‰¤ u.sup id
ssup : s = u.sup id
âŠ¢ s.FG
warning:  Module.Finite does not have a doc string",theorem fg_iff_compact (s : Submodule R M) : s.FG â†” CompleteLattice.IsCompactElement s ,":= by
  classical
    let sp : M â†’ Submodule R M := fun a => span R {a}
    have supr_rw : âˆ€ t : Finset M, â¨† x âˆˆ t, sp x = â¨† x âˆˆ (â†‘t : Set M), sp x := fun t => by rfl
    constructor
    Â· rintro âŸ¨t, rflâŸ©
      rw [span_eq_iSup_of_singleton_spans, â† supr_rw, â† Finset.sup_eq_iSup t sp]
      apply CompleteLattice.isCompactElement_finsetSup
      exact fun n _ => singleton_span_isCompactElement n
    Â· intro h
      have sSup' : s = sSup (sp '' â†‘s) := by
        rw [sSup_eq_iSup, iSup_image, â† span_eq_iSup_of_singleton_spans, eq_comm, span_eq]
      obtain âŸ¨u, âŸ¨huspan, husupâŸ©âŸ© := h (sp '' â†‘s) (le_of_eq sSup')
      have ssup : s = u.sup id := by
        suffices u.sup id â‰¤ s from le_antisymm husup this
        rw [sSup', Finset.sup_id_eq_sSup]
        exact sSup_le_sSup huspan
      have := Finset.subset_image_iff.mp huspan
      obtain âŸ¨t, âŸ¨-, rflâŸ©âŸ© := this
      rw [Finset.sup_image, Function.id_comp, Finset.sup_eq_iSup, supr_rw, â†
        span_eq_iSup_of_singleton_spans, eq_comm] at ssup
      exact âŸ¨t, ssupâŸ©"
Mathlib/FieldTheory/Finite/Basic.lean,FiniteField.roots_X_pow_card_sub_X,roots_X_pow_card_sub_X,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  classical
    have aux : (X ^ q - X : K[X]) â‰  0 := X_pow_card_sub_X_ne_zero K Fintype.one_lt_card
    have : (roots (X ^ q - X : K[X])).toFinset = Finset.univ := by
      rw [eq_univ_iff_forall]
      intro x
      rw [Multiset.mem_toFinset, mem_roots aux, IsRoot.def, eval_sub, eval_pow, eval_X,
        sub_eq_zero, pow_card]
    rw [â† this, Multiset.toFinset_val, eq_comm, Multiset.dedup_eq_self]
    apply nodup_roots
    rw [separable_def]
    convert isCoprime_one_right.neg_right (R := K[X]) using 1
    rw [derivative_sub, derivative_X, derivative_X_pow, CharP.cast_card_eq_zero K, C_0,
      zero_mul, zero_sub]","error:  unknown constant 'CharP.cast_card_eq_zero'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.127015
case h.e'_4
K : Type u_1
R : Type u_2
instâœÂ³ : Field K
instâœÂ² : Fintype K
p : â„•
instâœÂ¹ : Fact (Nat.Prime p)
instâœ : Algebra (ZMod p) K
aux : X ^ q - X â‰  0
this : (X ^ q - X).roots.toFinset = univ
âŠ¢ C â†‘q * X ^ (q - 1) - 1 = -1",theorem roots_X_pow_card_sub_X : roots (X ^ q - X : K[X]) = Finset.univ.val ,":= by
  classical
    have aux : (X ^ q - X : K[X]) â‰  0 := X_pow_card_sub_X_ne_zero K Fintype.one_lt_card
    have : (roots (X ^ q - X : K[X])).toFinset = Finset.univ := by
      rw [eq_univ_iff_forall]
      intro x
      rw [Multiset.mem_toFinset, mem_roots aux, IsRoot.def, eval_sub, eval_pow, eval_X,
        sub_eq_zero, pow_card]
    rw [â† this, Multiset.toFinset_val, eq_comm, Multiset.dedup_eq_self]
    apply nodup_roots
    rw [separable_def]
    convert isCoprime_one_right.neg_right (R := K[X]) using 1
    rw [derivative_sub, derivative_X, derivative_X_pow, Nat.cast_card_eq_zero K, C_0,
      zero_mul, zero_sub]"
Mathlib/Computability/PartrecCode.lean,Nat.Partrec.Code.const_inj,const_inj,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,"  | 0, 0, _ => by simp
  | nâ‚ + 1, nâ‚‚ + 1, h => by
    dsimp [Nat.add_one, Nat.Partrec.Code.const] at h
    injection h with hâ‚ hâ‚‚
    simp only [const_inj hâ‚‚]","error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information","theorem const_inj : âˆ€ {nâ‚ nâ‚‚}, Nat.Partrec.Code.const nâ‚ = Nat.Partrec.Code.const nâ‚‚ â†’ nâ‚ = nâ‚‚
","  | 0, 0, _ => by simp
  | nâ‚ + 1, nâ‚‚ + 1, h => by
    dsimp [Nat.Partrec.Code.const] at h
    injection h with hâ‚ hâ‚‚
    simp only [const_inj hâ‚‚]"
Mathlib/Topology/UrysohnsLemma.lean,Urysohns.CU.continuous_lim,continuous_lim,76620f7bc93be67fe98a87948024801e42a6f815,":= by
  obtain âŸ¨h0, h1234, h1âŸ© : 0 < (2â»Â¹ : â„) âˆ§ (2â»Â¹ : â„) < 3 / 4 âˆ§ (3 / 4 : â„) < 1 := by norm_num
  refine'
    continuous_iff_continuousAt.2 fun x =>
      (Metric.nhds_basis_closedBall_pow (h0.trans h1234) h1).tendsto_right_iff.2 fun n _ => _
  simp only [Metric.mem_closedBall]
  induction' n with n ihn generalizing c
  Â· refine' eventually_of_forall fun y => _
    rw [pow_zero]
    exact Real.dist_le_of_mem_Icc_01 (c.lim_mem_Icc _) (c.lim_mem_Icc _)
  Â· by_cases hxl : x âˆˆ c.left.U
    Â· filter_upwards [IsOpen.mem_nhds c.left.open_U hxl, ihn c.left] with _ hyl hyd
      rw [pow_succ, c.lim_eq_midpoint, c.lim_eq_midpoint,
        c.right.lim_of_mem_C _ (c.left_U_subset_right_C hyl),
        c.right.lim_of_mem_C _ (c.left_U_subset_right_C hxl)]
      refine' (dist_midpoint_midpoint_le _ _ _ _).trans _
      rw [dist_self, add_zero, div_eq_inv_mul]
      gcongr
    Â· replace hxl : x âˆˆ c.left.right.Cá¶œ :=
        compl_subset_compl.2 c.left.right.subset hxl
      filter_upwards [IsOpen.mem_nhds (isOpen_compl_iff.2 c.left.right.closed_C) hxl,
        ihn c.left.right, ihn c.right] with y hyl hydl hydr
      replace hxl : x âˆ‰ c.left.left.U :=
        compl_subset_compl.2 c.left.left_U_subset_right_C hxl
      replace hyl : y âˆ‰ c.left.left.U :=
        compl_subset_compl.2 c.left.left_U_subset_right_C hyl
      simp only [pow_succ, c.lim_eq_midpoint, c.left.lim_eq_midpoint,
        c.left.left.lim_of_nmem_U _ hxl, c.left.left.lim_of_nmem_U _ hyl]
      refine' (dist_midpoint_midpoint_le _ _ _ _).trans _
      refine' (div_le_div_of_le zero_le_two
        (add_le_add_right (dist_midpoint_midpoint_le _ _ _ _) _)).trans _
      rw [dist_self, zero_add]
      set r := (3 / 4 : â„) ^ n
      calc _ â‰¤ (r / 2 + r) / 2 := by gcongr
        _ = _ := by field_simp; ring","error:  unsolved goals
case h.hâ‚
X : Type u_1
instâœ : TopologicalSpace X
P : Set X â†’ Prop
h0 : 0 < 2â»Â¹
h1234 : 2â»Â¹ < 3 / 4
h1 : 3 / 4 < 1
x : X
xâœ : True
n : â„•
ihn : âˆ€ (c : CU P), âˆ€á¶  (x_1 : X) in ğ“ x, dist (c.lim x_1) (c.lim x) â‰¤ (3 / 4) ^ n
c : CU P
hxl : x âˆˆ c.left.U
aâœ : X
hyl : aâœ âˆˆ c.left.U
hyd : dist (c.left.lim aâœ) (c.left.lim x) â‰¤ (3 / 4) ^ n
âŠ¢ 2â»Â¹ â‰¤ (3 / 4) ^ n

case h.hâ‚‚
X : Type u_1
instâœ : TopologicalSpace X
P : Set X â†’ Prop
h0 : 0 < 2â»Â¹
h1234 : 2â»Â¹ < 3 / 4
h1 : 3 / 4 < 1
x : X
xâœ : True
n : â„•
ihn : âˆ€ (c : CU P), âˆ€á¶  (x_1 : X) in ğ“ x, dist (c.lim x_1) (c.lim x) â‰¤ (3 / 4) ^ n
c : CU P
hxl : x âˆˆ c.left.U
aâœ : X
hyl : aâœ âˆˆ c.left.U
hyd : dist (c.left.lim aâœ) (c.left.lim x) â‰¤ (3 / 4) ^ n
âŠ¢ dist (c.left.lim aâœ) (c.left.lim x) â‰¤ 3 / 4
warning:  `div_le_div_of_le` has been deprecated, use `div_le_div_of_nonneg_right` instead",theorem continuous_lim (c : CU P) : Continuous c.lim ,":= by
  obtain âŸ¨h0, h1234, h1âŸ© : 0 < (2â»Â¹ : â„) âˆ§ (2â»Â¹ : â„) < 3 / 4 âˆ§ (3 / 4 : â„) < 1 := by norm_num
  refine
    continuous_iff_continuousAt.2 fun x =>
      (Metric.nhds_basis_closedBall_pow (h0.trans h1234) h1).tendsto_right_iff.2 fun n _ => ?_
  simp only [Metric.mem_closedBall]
  induction' n with n ihn generalizing c
  Â· filter_upwards with y
    rw [pow_zero]
    exact Real.dist_le_of_mem_Icc_01 (c.lim_mem_Icc _) (c.lim_mem_Icc _)
  Â· by_cases hxl : x âˆˆ c.left.U
    Â· filter_upwards [IsOpen.mem_nhds c.left.open_U hxl, ihn c.left] with _ hyl hyd
      rw [pow_succ', c.lim_eq_midpoint, c.lim_eq_midpoint,
        c.right.lim_of_mem_C _ (c.left_U_subset_right_C hyl),
        c.right.lim_of_mem_C _ (c.left_U_subset_right_C hxl)]
      refine (dist_midpoint_midpoint_le _ _ _ _).trans ?_
      rw [dist_self, add_zero, div_eq_inv_mul]
      gcongr
    Â· replace hxl : x âˆˆ c.left.right.Cá¶œ :=
        compl_subset_compl.2 c.left.right.subset hxl
      filter_upwards [IsOpen.mem_nhds (isOpen_compl_iff.2 c.left.right.closed_C) hxl,
        ihn c.left.right, ihn c.right] with y hyl hydl hydr
      replace hxl : x âˆ‰ c.left.left.U :=
        compl_subset_compl.2 c.left.left_U_subset_right_C hxl
      replace hyl : y âˆ‰ c.left.left.U :=
        compl_subset_compl.2 c.left.left_U_subset_right_C hyl
      simp only [pow_succ, c.lim_eq_midpoint, c.left.lim_eq_midpoint,
        c.left.left.lim_of_nmem_U _ hxl, c.left.left.lim_of_nmem_U _ hyl]
      refine (dist_midpoint_midpoint_le _ _ _ _).trans ?_
      refine (div_le_div_of_nonneg_right (add_le_add_right (dist_midpoint_midpoint_le _ _ _ _) _)
        zero_le_two).trans ?_
      rw [dist_self, zero_add]
      set r := (3 / 4 : â„) ^ n
      calc _ â‰¤ (r / 2 + r) / 2 := by gcongr
        _ = _ := by field_simp; ring"
Mathlib/SetTheory/Ordinal/NaturalOps.lean,Ordinal.add_le_nadd,add_le_nadd,25e538f3a737a71314ac143929711e67d0b14d73,":= by
  induction b with
  | Hâ‚ => simp
  | Hâ‚‚ c h =>
    rwa [add_succ, nadd_succ, succ_le_succ_iff]
  | Hâ‚ƒ c hc H =>
    simp_rw [â† IsNormal.blsub_eq.{u, u} (add_isNormal a) hc, blsub_le_iff]
    exact fun i hi => (H i hi).trans_lt (nadd_lt_nadd_left hi a)","warning:  Ordinal.nadd does not have a doc string
warning:  Ordinal.nmul does not have a doc string
error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
a b c : Ordinal.{u}
âŠ¢ a + b â‰¤ a â™¯ b",theorem add_le_nadd : a + b â‰¤ a â™¯ b ,":= by
  induction b using limitRecOn with
  | Hâ‚ => simp
  | Hâ‚‚ c h =>
    rwa [add_succ, nadd_succ, succ_le_succ_iff]
  | Hâ‚ƒ c hc H =>
    simp_rw [â† IsNormal.blsub_eq.{u, u} (add_isNormal a) hc, blsub_le_iff]
    exact fun i hi => (H i hi).trans_lt (nadd_lt_nadd_left hi a)"
Mathlib/RingTheory/WittVector/MulCoeff.lean,WittVector.peval_polyOfInterest',peval_polyOfInterest',e194c75699f5107c3020dd83bb1dc00cf62f62aa,":= by
  rw [peval_polyOfInterest]
  have : (p : k) = 0 := CharP.cast_eq_zero k p
  simp only [this, Nat.cast_pow, ne_eq, add_eq_zero, and_false, zero_pow', zero_mul, add_zero]
  have sum_zero_pow_mul_pow_p : âˆ€ y : ğ• k, âˆ‘ x : â„• in range (n + 1 + 1),
      (0 : k) ^ x * y.coeff x ^ p ^ (n + 1 - x) = y.coeff 0 ^ p ^ (n + 1) := by
    intro y
    rw [Finset.sum_eq_single_of_mem 0]
    Â· simp
    Â· simp
    Â· intro j _ hj
      simp [zero_pow (zero_lt_iff.mpr hj)]
  congr <;> apply sum_zero_pow_mul_pow_p","error:  unknown identifier 'zero_pow''
error:  application type mismatch
  zero_pow (zero_lt_iff.mpr hj)
argument
  zero_lt_iff.mpr hj
has type
  0 < j : Prop
but is expected to have type
  ?m.190538 â‰  0 : Prop
error:  simp made no progress
error:  tactic 'apply' failed, failed to unify
  âˆ‘ x âˆˆ range (n + 1 + 1), 0 ^ x * ?y.coeff x ^ p ^ (n + 1 - x) = ?y.coeff 0 ^ p ^ (n + 1)
with
  (x * y).coeff (n + 1) + 0 ^ (n + 1) * x.coeff (n + 1) * y.coeff (n + 1) = (x * y).coeff (n + 1)
case e_a.e_a
p : â„•
hp : Fact (Nat.Prime p)
k : Type u_1
instâœÂ¹ : CommRing k
instâœ : CharP k p
n : â„•
x y : ğ• k
this : â†‘p = 0
sum_zero_pow_mul_pow_p :
  âˆ€ (y : ğ• k), âˆ‘ x âˆˆ range (n + 1 + 1), 0 ^ x * y.coeff x ^ p ^ (n + 1 - x) = y.coeff 0 ^ p ^ (n + 1)
âŠ¢ (x * y).coeff (n + 1) + 0 ^ (n + 1) * x.coeff (n + 1) * y.coeff (n + 1) = (x * y).coeff (n + 1)
error:  unsolved goals
case e_a.e_a
p : â„•
hp : Fact (Nat.Prime p)
k : Type u_1
instâœÂ¹ : CommRing k
instâœ : CharP k p
n : â„•
x y : ğ• k
this : â†‘p = 0
sum_zero_pow_mul_pow_p :
  âˆ€ (y : ğ• k), âˆ‘ x âˆˆ range (n + 1 + 1), 0 ^ x * y.coeff x ^ p ^ (n + 1 - x) = y.coeff 0 ^ p ^ (n + 1)
âŠ¢ (x * y).coeff (n + 1) + 0 ^ (n + 1) * x.coeff (n + 1) * y.coeff (n + 1) = (x * y).coeff (n + 1)","theorem peval_polyOfInterest' (n : â„•) (x y : ğ• k) :
    peval (polyOfInterest p n) ![fun i => x.coeff i, fun i => y.coeff i] =
      (x * y).coeff (n + 1) - y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) -
        x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1) ",":= by
  rw [peval_polyOfInterest]
  have : (p : k) = 0 := CharP.cast_eq_zero k p
  simp only [this, Nat.cast_pow, ne_eq, add_eq_zero, and_false, zero_pow, zero_mul, add_zero,
    not_false_eq_true]
  have sum_zero_pow_mul_pow_p (y : ğ• k) : âˆ‘ x âˆˆ range (n + 1 + 1),
      (0 : k) ^ x * y.coeff x ^ p ^ (n + 1 - x) = y.coeff 0 ^ p ^ (n + 1) := by
    rw [Finset.sum_eq_single_of_mem 0] <;> simp (config := { contextual := true })
  congr <;> apply sum_zero_pow_mul_pow_p"
Mathlib/AlgebraicGeometry/Spec.lean,AlgebraicGeometry.Spec.sheafedSpaceMap_id,Spec.sheafedSpaceMap_id,9fe8df0e363b05d86962c4bfbd8514bd00253a97,":=
  AlgebraicGeometry.PresheafedSpace.Hom.ext _ _ (Spec.topMap_id R) <| by
    ext
    dsimp
    erw [comap_id (by simp)]
    simp
    rfl",error:  no goals to be solved,"theorem Spec.sheafedSpaceMap_id {R : CommRingCat.{u}} :
    Spec.sheafedSpaceMap (ğŸ™ R) = ğŸ™ (Spec.sheafedSpaceObj R) ",":=
  AlgebraicGeometry.PresheafedSpace.Hom.ext _ _ (Spec.topMap_id R) <| by
    ext
    dsimp
    erw [comap_id (by simp)]
    simp"
Mathlib/NumberTheory/LegendreSymbol/AddCharacter.lean,AddChar.IsPrimitive.compMulHom_of_isPrimitive,IsPrimitive.compMulHom_of_isPrimitive,cfb67dc2b69e7e3c8df320d6d887e00dd240c448,":= by
  intro a a_ne_zero
  obtain âŸ¨r, ne_oneâŸ© := hÏ† a a_ne_zero
  rw [mulShift_apply] at ne_one
  simp only [IsNontrivial, mulShift_apply, f.coe_compAddChar, Function.comp_apply]
  exact âŸ¨r, fun H â†¦ ne_one <| hf <| f.map_one â–¸ HâŸ©","error:  application type mismatch
  hÏ† a
argument
  a
has type
  R : Type u
but is expected to have type
  ?m.5756 â‰  0 : Prop
error:  no goals to be solved","lemma IsPrimitive.compMulHom_of_isPrimitive {R'' : Type*} [CommMonoid R''] {Ï† : AddChar R R'}
    {f : R' â†’* R''} (hÏ† : Ï†.IsPrimitive) (hf : Function.Injective f) :
    (f.compAddChar Ï†).IsPrimitive ",":= fun a ha â†¦ by
  simpa [DFunLike.ext_iff] using (MonoidHom.compAddChar_injective_right f hf).ne (hÏ† ha)"
Mathlib/MeasureTheory/Constructions/Prod/Basic.lean,MeasureTheory.Measure.prod_eq_generateFrom,prod_eq_generateFrom,bf51f258386f8087f1e18f6afd6b10d7fcd704ae,":= by
  refine'
    (h3C.prod h3D).ext
      (generateFrom_eq_prod hC hD h3C.isCountablySpanning h3D.isCountablySpanning).symm
      (h2C.prod h2D) _
  Â· rintro _ âŸ¨s, t, hs, ht, rflâŸ©
    haveI := h3D.sigmaFinite
    rw [hâ‚ s hs t ht, prod_prod]","error:  application type mismatch
  hâ‚ s hs
argument
  hs
has type
  Set Î² : Type u_3
but is expected to have type
  s âˆˆ C : Prop","theorem prod_eq_generateFrom {Î¼ : Measure Î±} {Î½ : Measure Î²} {C : Set (Set Î±)} {D : Set (Set Î²)}
    (hC : generateFrom C = â€¹_â€º) (hD : generateFrom D = â€¹_â€º) (h2C : IsPiSystem C)
    (h2D : IsPiSystem D) (h3C : Î¼.FiniteSpanningSetsIn C) (h3D : Î½.FiniteSpanningSetsIn D)
    {Î¼Î½ : Measure (Î± Ã— Î²)} (hâ‚ : âˆ€ s âˆˆ C, âˆ€ t âˆˆ D, Î¼Î½ (s Ã—Ë¢ t) = Î¼ s * Î½ t) : Î¼.prod Î½ = Î¼Î½ ",":= by
  refine
    (h3C.prod h3D).ext
      (generateFrom_eq_prod hC hD h3C.isCountablySpanning h3D.isCountablySpanning).symm
      (h2C.prod h2D) ?_
  rintro _ âŸ¨s, hs, t, ht, rflâŸ©
  haveI := h3D.sigmaFinite
  rw [hâ‚ s hs t ht, prod_prod]"
Mathlib/Analysis/Analytic/Meromorphic.lean,MeromorphicOn.add,add,1df5e9f2d5d2defceda7b95892bf4c4bb80859af,":= by
  rcases hf with âŸ¨m, hfâŸ©
  rcases hg with âŸ¨n, hgâŸ©
  refine âŸ¨max m n, ?_âŸ©
  have : (fun z â†¦ (z - x) ^ max m n â€¢ (f + g) z) = fun z â†¦ (z - x) ^ (max m n - m) â€¢
    ((z - x) ^ m â€¢ f z) + (z - x) ^ (max m n - n) â€¢ ((z - x) ^ n â€¢ g z)
  Â· simp_rw [â† mul_smul, â† pow_add, Nat.sub_add_cancel (Nat.le_max_left _ _),
      Nat.sub_add_cancel (Nat.le_max_right _ _), Pi.add_apply, smul_add]
  rw [this]
  exact ((((analyticAt_id ğ•œ x).sub analyticAt_const).pow _).smul hf).add
   ((((analyticAt_id ğ•œ x).sub analyticAt_const).pow _).smul hg)","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case intro.intro
ğ•œ : Type u_1
instâœÂ² : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace ğ•œ E
f g : ğ•œ â†’ E
x : ğ•œ
m : â„•
hf : AnalyticAt ğ•œ (fun z â†¦ (z - x) ^ m â€¢ f z) x
n : â„•
hg : AnalyticAt ğ•œ (fun z â†¦ (z - x) ^ n â€¢ g z) x
this :
  (fun z â†¦ (z - x) ^ max m n â€¢ (f + g) z) = fun z â†¦
    (z - x) ^ (max m n - m) â€¢ (z - x) ^ m â€¢ f z + (z - x) ^ (max m n - n) â€¢ (z - x) ^ n â€¢ g z
âŠ¢ AnalyticAt ğ•œ (fun z â†¦ (z - x) ^ max m n â€¢ (f + g) z) x","lemma add {f g : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :
    MeromorphicAt (f + g) x ",":= by
  rcases hf with âŸ¨m, hfâŸ©
  rcases hg with âŸ¨n, hgâŸ©
  refine âŸ¨max m n, ?_âŸ©
  have : (fun z â†¦ (z - x) ^ max m n â€¢ (f + g) z) = fun z â†¦ (z - x) ^ (max m n - m) â€¢
      ((z - x) ^ m â€¢ f z) + (z - x) ^ (max m n - n) â€¢ ((z - x) ^ n â€¢ g z) := by
    simp_rw [â† mul_smul, â† pow_add, Nat.sub_add_cancel (Nat.le_max_left _ _),
      Nat.sub_add_cancel (Nat.le_max_right _ _), Pi.add_apply, smul_add]
  rw [this]
  exact ((((analyticAt_id ğ•œ x).sub analyticAt_const).pow _).smul hf).add
   ((((analyticAt_id ğ•œ x).sub analyticAt_const).pow _).smul hg)"
Mathlib/Analysis/Convex/SpecificFunctions/Pow.lean,Real.strictConcaveOn_rpow,strictConcaveOn_rpow,693fd79515903b10b1d31f10dccfc49e633cf7ee,":= by
  have hpâ‚€' : 0 < 1 / p := by positivity
  have hpâ‚' : 1 < 1 / p := by rw [one_lt_div hpâ‚€]; exact hpâ‚
  let f := NNReal.orderIsoRpow (1 / p) hpâ‚€'
  have hâ‚ : StrictConvexOn â„â‰¥0 univ f := by
    refine âŸ¨convex_univ, fun x _ y _ hxy a b ha hb hab => ?_âŸ©
    exact (strictConvexOn_rpow hpâ‚').2 (by positivity : 0 â‰¤ x) (by positivity : 0 â‰¤ y)
      (by simp [hxy]) ha hb (by simp; norm_cast)
  have hâ‚‚ : âˆ€ x, f.symm x = x ^ p := by simp [NNReal.orderIsoRpow_symm_eq]
  refine âŸ¨convex_univ, fun x _ y _ hxy a b ha hb hab => ?_âŸ©
  simp only [â†hâ‚‚]
  exact (f.strictConcaveOn_symm hâ‚).2 (Set.mem_univ x) (Set.mem_univ y) hxy ha hb hab",error:  simp made no progress,"lemma strictConcaveOn_rpow {p : â„} (hpâ‚€ : 0 < p) (hpâ‚ : p < 1) :
    StrictConcaveOn â„â‰¥0 univ fun x : â„â‰¥0 â†¦ x ^ p ",":= by
  have hpâ‚€' : 0 < 1 / p := div_pos zero_lt_one hpâ‚€
  have hpâ‚' : 1 < 1 / p := by rw [one_lt_div hpâ‚€]; exact hpâ‚
  let f := NNReal.orderIsoRpow (1 / p) hpâ‚€'
  have hâ‚ : StrictConvexOn â„â‰¥0 univ f := by
    refine âŸ¨convex_univ, fun x _ y _ hxy a b ha hb hab => ?_âŸ©
    exact (strictConvexOn_rpow hpâ‚').2 x.2 y.2 (by simp [hxy]) ha hb (by simp; norm_cast)
  have hâ‚‚ : âˆ€ x, f.symm x = x ^ p := by simp [f, NNReal.orderIsoRpow_symm_eq]
  refine âŸ¨convex_univ, fun x mx y my hxy a b ha hb hab => ?_âŸ©
  simp only [â† hâ‚‚]
  exact (f.strictConcaveOn_symm hâ‚).2 mx my hxy ha hb hab"
Mathlib/LinearAlgebra/Matrix/Charpoly/Coeff.lean,Matrix.isNilpotent_trace_of_isNilpotent,isNilpotent_trace_of_isNilpotent,bf6e4bb13f659a85fd8161ecb4867b3785573600,":= by
  cases isEmpty_or_nonempty n; simp
  suffices IsNilpotent (coeff (charpolyRev M) 1) by simpa using this
  exact (isUnit_iff_coeff_isUnit_isNilpotent.mp (isUnit_charpolyRev_of_IsNilpotent hM)).2
    _ one_ne_zero",error:  unknown identifier 'isUnit_charpolyRev_of_IsNilpotent',"lemma isNilpotent_trace_of_isNilpotent (hM : IsNilpotent M) :
    IsNilpotent (trace M) ",":= by
  cases isEmpty_or_nonempty n
  Â· simp
  suffices IsNilpotent (coeff (charpolyRev M) 1) by simpa using this
  exact (isUnit_iff_coeff_isUnit_isNilpotent.mp (isUnit_charpolyRev_of_isNilpotent hM)).2
    _ one_ne_zero"
Mathlib/Analysis/Complex/PhragmenLindelof.lean,PhragmenLindelof.horizontal_strip,horizontal_strip,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; Â· exact hle_a _ hza.symm
  cases' hzb with hzb hzb; Â· exact hle_b _ hzb
  wlog hCâ‚€ : 0 < C generalizing C
  Â· refine' le_of_forall_le_of_dense fun C' hC' => this (fun w hw => _) (fun w hw => _) _
    Â· exact (hle_a _ hw).trans hC'.le
    Â· exact (hle_b _ hw).trans hC'.le
    Â· refine' ((norm_nonneg (f (a * I))).trans (hle_a _ _)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain âŸ¨a, b, rfl, rflâŸ© : âˆƒ a' b', a = a' - b' âˆ§ b = a' + b' :=
    âŸ¨(a + b) / 2, (b - a) / 2, by ring, by ringâŸ©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, â† two_mul, div_mul_eq_div_div] at hB
  have hÏ€b : 0 < Ï€ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with âŸ¨c, hc, B, hOâŸ©
  obtain âŸ¨d, âŸ¨hcd, hdâ‚€âŸ©, hdâŸ© : âˆƒ d, (c < d âˆ§ 0 < d) âˆ§ d < Ï€ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hÏ€b)
  have hb' : d * b < Ï€ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : â„‚ â†’ â„‚)
  set g := fun (Îµ : â„) (w : â„‚) => exp (Îµ * (exp (aff w) + exp (-aff w)))
  suffices âˆ€á¶  Îµ : â„ in ğ“[<] (0 : â„), â€–g Îµ z â€¢ f zâ€– â‰¤ C by
    refine' le_of_tendsto (Tendsto.mono_left _ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Îµ Îµâ‚€; change Îµ < 0 at Îµâ‚€
  obtain âŸ¨Î´, Î´â‚€, hÎ´âŸ© :
    âˆƒ Î´ : â„,
      Î´ < 0 âˆ§ âˆ€ â¦ƒwâ¦„, im w âˆˆ Icc (a - b) (a + b) â†’ abs (g Îµ w) â‰¤ expR (Î´ * expR (d * |re w|)) := by
    refine'
      âŸ¨Îµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Îµâ‚€
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hdâ‚€ hb)).symm â–¸ hb'),
        fun w hw => _âŸ©
    replace hw : |im (aff w)| â‰¤ d * b := by
      rw [â† Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hdâ‚€,
        mul_le_mul_left hdâ‚€]
    simpa only [re_ofReal_mul, _root_.abs_mul, abs_of_pos hdâ‚€, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Îµâ‚€.le hw hb'.le
  have hgâ‚ : âˆ€ w, im w = a - b âˆ¨ im w = a + b â†’ abs (g Îµ w) â‰¤ 1 := by
    refine' fun w hw => (hÎ´ <| hw.by_cases _ _).trans (Real.exp_le_one_iff.2 _)
    exacts [fun h => h.symm â–¸ left_mem_Icc.2 hab.le, fun h => h.symm â–¸ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Î´â‚€.le (Real.exp_pos _).le]
  obtain âŸ¨R, hzR, hRâŸ© :
    âˆƒ R : â„, |z.re| < R âˆ§ âˆ€ w, |re w| = R â†’ im w âˆˆ Ioo (a - b) (a + b) â†’ â€–g Îµ w â€¢ f wâ€– â‰¤ C := by
    refine' ((eventually_gt_atTop _).and _).exists
    rcases hO.exists_pos with âŸ¨A, hAâ‚€, hAâŸ©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, â† abs_lt,
      mem_preimage, (Â· âˆ˜ Â·), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Î´ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ğ“ 0) by
      filter_upwards [this.eventually (ge_mem_nhds hCâ‚€), hA] with R hR Hle w hre him
      calc
        â€–g Îµ w â€¢ f wâ€– â‰¤ expR (Î´ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ â‰¤ C := hR
      rw [norm_smul, Real.exp_add, â† hre, Real.exp_add, Real.exp_log hAâ‚€, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hÎ´ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine' Real.tendsto_exp_atBot.comp _
    suffices H : Tendsto (fun R => Î´ + B * (expR ((d - c) * R))â»Â¹) atTop (ğ“ (Î´ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine' Tendsto.atBot_add _ tendsto_const_nhds
      simpa only [id, (Â· âˆ˜ Â·), add_mul, mul_assoc, â† div_eq_inv_mul, â† Real.exp_sub, â† sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Î´â‚€ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hdâ‚€ tendsto_id
    refine' tendsto_const_nhds.add (tendsto_const_nhds.mul _)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hRâ‚€ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable â„‚ (g Îµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl â„‚ (fun w => g Îµ w â€¢ f w) (Ioo (-R) R Ã—â„‚ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono (inter_subset_right _ _)
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  Â· rw [frontier_reProdIm, closure_Ioo (neg_lt_self hRâ‚€).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hRâ‚€)] at hw
    by_cases him : w.im = a - b âˆ¨ w.im = a + b
    Â· rw [norm_smul, â† one_mul C]
      exact mul_le_mul (hgâ‚ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    Â· replace hw : w âˆˆ {-R, R} Ã—â„‚ Icc (a - b) (a + b) := hw.resolve_left fun h â†¦ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [â† or_assoc] at hw'
      exact hR _ ((abs_eq hRâ‚€.le).2 hw.1.symm) (hw'.resolve_left him)
  Â· rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hRâ‚€).ne]
    exact âŸ¨abs_le.1 hzR.le, âŸ¨hza.le, hzb.leâŸ©âŸ©","error:  type mismatch
  hâœ
has type
  Complex.abs (cexp (â†‘Îµ * (cexp (aff w) + cexp (-aff w)))) â‰¤ expR (Îµ * Real.cos (d * b) * expR |(aff w).re|) : Prop
but is expected to have type
  Complex.abs (g Îµ w) â‰¤ expR (Îµ * Real.cos (d * b) * expR (d * |w.re|)) : Prop
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'horizontal_strip'
error:  unknown identifier 'horizontal_strip'
error:  no goals to be solved
error:  unknown identifier 'horizontal_strip'
error:  no goals to be solved","theorem horizontal_strip (hfd : DiffContOnCl â„‚ f (im â»Â¹' Ioo a b))
    (hB : âˆƒ c < Ï€ / (b - a), âˆƒ B, f =O[comap (_root_.abs âˆ˜ re) atTop âŠ“ ğ“Ÿ (im â»Â¹' Ioo a b)]
      fun z â†¦ expR (B * expR (c * |z.re|)))
    (hle_a : âˆ€ z : â„‚, im z = a â†’ â€–f zâ€– â‰¤ C) (hle_b : âˆ€ z, im z = b â†’ â€–f zâ€– â‰¤ C) (hza : a â‰¤ im z)
    (hzb : im z â‰¤ b) : â€–f zâ€– â‰¤ C ",":= by
  rw [le_iff_eq_or_lt] at hza hzb
  cases' hza with hza hza; Â· exact hle_a _ hza.symm
  cases' hzb with hzb hzb; Â· exact hle_b _ hzb
  wlog hCâ‚€ : 0 < C generalizing C
  Â· refine le_of_forall_le_of_dense fun C' hC' => this (fun w hw => ?_) (fun w hw => ?_) ?_
    Â· exact (hle_a _ hw).trans hC'.le
    Â· exact (hle_b _ hw).trans hC'.le
    Â· refine ((norm_nonneg (f (a * I))).trans (hle_a _ ?_)).trans_lt hC'
      rw [mul_I_im, ofReal_re]
  obtain âŸ¨a, b, rfl, rflâŸ© : âˆƒ a' b', a = a' - b' âˆ§ b = a' + b' :=
    âŸ¨(a + b) / 2, (b - a) / 2, by ring, by ringâŸ©
  have hab : a - b < a + b := hza.trans hzb
  have hb : 0 < b := by simpa only [sub_eq_add_neg, add_lt_add_iff_left, neg_lt_self_iff] using hab
  rw [add_sub_sub_cancel, â† two_mul, div_mul_eq_div_div] at hB
  have hÏ€b : 0 < Ï€ / 2 / b := div_pos Real.pi_div_two_pos hb
  rcases hB with âŸ¨c, hc, B, hOâŸ©
  obtain âŸ¨d, âŸ¨hcd, hdâ‚€âŸ©, hdâŸ© : âˆƒ d, (c < d âˆ§ 0 < d) âˆ§ d < Ï€ / 2 / b := by
    simpa only [max_lt_iff] using exists_between (max_lt hc hÏ€b)
  have hb' : d * b < Ï€ / 2 := (lt_div_iff hb).1 hd
  set aff := (fun w => d * (w - a * I) : â„‚ â†’ â„‚)
  set g := fun (Îµ : â„) (w : â„‚) => exp (Îµ * (exp (aff w) + exp (-aff w)))
  suffices âˆ€á¶  Îµ : â„ in ğ“[<] (0 : â„), â€–g Îµ z â€¢ f zâ€– â‰¤ C by
    refine le_of_tendsto (Tendsto.mono_left ?_ nhdsWithin_le_nhds) this
    apply ((continuous_ofReal.mul continuous_const).cexp.smul continuous_const).norm.tendsto'
    simp
  filter_upwards [self_mem_nhdsWithin] with Îµ Îµâ‚€; change Îµ < 0 at Îµâ‚€
  obtain âŸ¨Î´, Î´â‚€, hÎ´âŸ© :
    âˆƒ Î´ : â„,
      Î´ < 0 âˆ§ âˆ€ â¦ƒwâ¦„, im w âˆˆ Icc (a - b) (a + b) â†’ abs (g Îµ w) â‰¤ expR (Î´ * expR (d * |re w|)) := by
    refine
      âŸ¨Îµ * Real.cos (d * b),
        mul_neg_of_neg_of_pos Îµâ‚€
          (Real.cos_pos_of_mem_Ioo <| abs_lt.1 <| (abs_of_pos (mul_pos hdâ‚€ hb)).symm â–¸ hb'),
        fun w hw => ?_âŸ©
    replace hw : |im (aff w)| â‰¤ d * b := by
      rw [â† Real.closedBall_eq_Icc] at hw
      rwa [im_ofReal_mul, sub_im, mul_I_im, ofReal_re, _root_.abs_mul, abs_of_pos hdâ‚€,
        mul_le_mul_left hdâ‚€]
    simpa only [aff, re_ofReal_mul, _root_.abs_mul, abs_of_pos hdâ‚€, sub_re, mul_I_re, ofReal_im,
      zero_mul, neg_zero, sub_zero] using
      abs_exp_mul_exp_add_exp_neg_le_of_abs_im_le Îµâ‚€.le hw hb'.le
  have hgâ‚ : âˆ€ w, im w = a - b âˆ¨ im w = a + b â†’ abs (g Îµ w) â‰¤ 1 := by
    refine fun w hw => (hÎ´ <| hw.by_cases ?_ ?_).trans (Real.exp_le_one_iff.2 ?_)
    exacts [fun h => h.symm â–¸ left_mem_Icc.2 hab.le, fun h => h.symm â–¸ right_mem_Icc.2 hab.le,
      mul_nonpos_of_nonpos_of_nonneg Î´â‚€.le (Real.exp_pos _).le]
  obtain âŸ¨R, hzR, hRâŸ© :
    âˆƒ R : â„, |z.re| < R âˆ§ âˆ€ w, |re w| = R â†’ im w âˆˆ Ioo (a - b) (a + b) â†’ â€–g Îµ w â€¢ f wâ€– â‰¤ C := by
    refine ((eventually_gt_atTop _).and ?_).exists
    rcases hO.exists_pos with âŸ¨A, hAâ‚€, hAâŸ©
    simp only [isBigOWith_iff, eventually_inf_principal, eventually_comap, mem_Ioo, â† abs_lt,
      mem_preimage, (Â· âˆ˜ Â·), Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)] at hA
    suffices
        Tendsto (fun R => expR (Î´ * expR (d * R) + B * expR (c * R) + Real.log A)) atTop (ğ“ 0) by
      filter_upwards [this.eventually (ge_mem_nhds hCâ‚€), hA] with R hR Hle w hre him
      calc
        â€–g Îµ w â€¢ f wâ€– â‰¤ expR (Î´ * expR (d * R) + B * expR (c * R) + Real.log A) := ?_
        _ â‰¤ C := hR
      rw [norm_smul, Real.exp_add, â† hre, Real.exp_add, Real.exp_log hAâ‚€, mul_assoc, mul_comm _ A]
      gcongr
      exacts [hÎ´ <| Ioo_subset_Icc_self him, Hle _ hre him]
    refine Real.tendsto_exp_atBot.comp ?_
    suffices H : Tendsto (fun R => Î´ + B * (expR ((d - c) * R))â»Â¹) atTop (ğ“ (Î´ + B * 0)) by
      rw [mul_zero, add_zero] at H
      refine Tendsto.atBot_add ?_ tendsto_const_nhds
      simpa only [id, (Â· âˆ˜ Â·), add_mul, mul_assoc, â† div_eq_inv_mul, â† Real.exp_sub, â† sub_mul,
        sub_sub_cancel]
        using H.neg_mul_atTop Î´â‚€ <| Real.tendsto_exp_atTop.comp <|
          tendsto_const_nhds.mul_atTop hdâ‚€ tendsto_id
    refine tendsto_const_nhds.add (tendsto_const_nhds.mul ?_)
    exact tendsto_inv_atTop_zero.comp <| Real.tendsto_exp_atTop.comp <|
      tendsto_const_nhds.mul_atTop (sub_pos.2 hcd) tendsto_id
  have hRâ‚€ : 0 < R := (_root_.abs_nonneg _).trans_lt hzR
  have hgd : Differentiable â„‚ (g Îµ) :=
    ((((differentiable_id.sub_const _).const_mul _).cexp.add
            ((differentiable_id.sub_const _).const_mul _).neg.cexp).const_mul _).cexp
  replace hd : DiffContOnCl â„‚ (fun w => g Îµ w â€¢ f w) (Ioo (-R) R Ã—â„‚ Ioo (a - b) (a + b)) :=
    (hgd.diffContOnCl.smul hfd).mono inter_subset_right
  convert norm_le_of_forall_mem_frontier_norm_le ((isBounded_Ioo _ _).reProdIm (isBounded_Ioo _ _))
    hd (fun w hw => _) _
  Â· rw [frontier_reProdIm, closure_Ioo (neg_lt_self hRâ‚€).ne, frontier_Ioo hab, closure_Ioo hab.ne,
      frontier_Ioo (neg_lt_self hRâ‚€)] at hw
    by_cases him : w.im = a - b âˆ¨ w.im = a + b
    Â· rw [norm_smul, â† one_mul C]
      exact mul_le_mul (hgâ‚ _ him) (him.by_cases (hle_a _) (hle_b _)) (norm_nonneg _) zero_le_one
    Â· replace hw : w âˆˆ {-R, R} Ã—â„‚ Icc (a - b) (a + b) := hw.resolve_left fun h â†¦ him h.2
      have hw' := eq_endpoints_or_mem_Ioo_of_mem_Icc hw.2; rw [â† or_assoc] at hw'
      exact hR _ ((abs_eq hRâ‚€.le).2 hw.1.symm) (hw'.resolve_left him)
  Â· rw [closure_reProdIm, closure_Ioo hab.ne, closure_Ioo (neg_lt_self hRâ‚€).ne]
    exact âŸ¨abs_le.1 hzR.le, âŸ¨hza.le, hzb.leâŸ©âŸ©"
Mathlib/Data/Matroid/Restrict.lean,Matroid.Indep.augment,Indep.augment,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  by_contra! he
  have hb : M.Basis I (I âˆª J) := by
    simp_rw [hI.basis_iff_forall_insert_dep (subset_union_left _ _), union_diff_left, mem_diff,
      and_imp, dep_iff, insert_subset_iff, and_iff_left hI.subset_ground]
    exact fun e heJ heI â†¦ âŸ¨he e âŸ¨heJ, heIâŸ©, hJ.subset_ground heJâŸ©
  obtain âŸ¨J', hJ', hJJ'âŸ© := hJ.subset_basis_of_subset (subset_union_right I J)
  rw [â† hJ'.encard_eq_encard hb] at hIJ
  exact hIJ.not_le (encard_mono hJJ')","error:  function expected at
  subset_union_left ?m.85538
term has type
  ?m.85537 âˆˆ ?m.85535 âˆª ?m.85536
error:  simp made no progress
error:  application type mismatch
  subset_union_right I
argument
  I
has type
  Set Î± : Type u_1
but is expected to have type
  ?m.85597 âˆˆ ?m.85596 : Prop
error:  application type mismatch
  Basis.encard_eq_encard hJ' hb
argument
  hb
has type
  M.Basis I (I âˆª J) : Prop
but is expected to have type
  M.Basis I âˆ… : Prop","theorem Indep.augment (hI : M.Indep I) (hJ : M.Indep J) (hIJ : I.encard < J.encard) :
    âˆƒ e âˆˆ J \ I, M.Indep (insert e I) ",":= by
  by_contra! he
  have hb : M.Basis I (I âˆª J) := by
    simp_rw [hI.basis_iff_forall_insert_dep subset_union_left, union_diff_left, mem_diff,
      and_imp, dep_iff, insert_subset_iff, and_iff_left hI.subset_ground]
    exact fun e heJ heI â†¦ âŸ¨he e âŸ¨heJ, heIâŸ©, hJ.subset_ground heJâŸ©
  obtain âŸ¨J', hJ', hJJ'âŸ© := hJ.subset_basis_of_subset I.subset_union_right
  rw [â† hJ'.encard_eq_encard hb] at hIJ
  exact hIJ.not_le (encard_mono hJJ')"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.flatten_think,flatten_think,88f252d9ef6777980e9cb4396094e178f3ed4acb,":=
  WSeq.ext _ _ <| Seq'.dest_eq_cons <| by simp [flatten, think]",error:  unknown constant 'Stream'.WSeq.ext',theorem flatten_think (c : Computation (WSeq Î±)) : flatten c.think = think (flatten c) ,":=
  Seq.destruct_eq_cons <| by simp [flatten, think]"
Mathlib/Data/Set/Image.lean,Set.subset_image_iff,subset_image_iff,ea1b2576466eb49ae109b64acf312f52285dafce,":= by
  refine âŸ¨fun h â†¦ âŸ¨f â»Â¹' t âˆ© s, inter_subset_right _ _, ?_âŸ©,
    fun âŸ¨u, hu, hu'âŸ© â†¦ hu'.symm â–¸ image_mono huâŸ©
  rwa [image_preimage_inter, inter_eq_left]","error:  function expected at
  inter_subset_right ?m.41145
term has type
  ?m.41144 âˆˆ ?m.41143","theorem subset_image_iff {t : Set Î²} :
    t âŠ† f '' s â†” âˆƒ u, u âŠ† s âˆ§ f '' u = t ",":= by
  refine âŸ¨fun h â†¦ âŸ¨f â»Â¹' t âˆ© s, inter_subset_right, ?_âŸ©,
    fun âŸ¨u, hu, hu'âŸ© â†¦ hu'.symm â–¸ image_mono huâŸ©
  rwa [image_preimage_inter, inter_eq_left]"
Mathlib/Order/Filter/EventuallyConst.lean,Filter.EventuallyConst.comp_tendsto,comp_tendsto,421acd0506b28a0c309081c10818feebfc9f4e0b,":=
  let âŸ¨c, hcâŸ© := hg; âŸ¨c, hf hcâŸ©","error:  application type mismatch
  hf hc
argument
  hc
has type
  c âˆˆ map g lb âˆ§ c.Subsingleton : Prop
but is expected to have type
  ?m.3799 âˆˆ lb : Prop","lemma comp_tendsto {lb : Filter Î²} {g : Î² â†’ Î³} (hg : EventuallyConst g lb)
    (hf : Tendsto f l lb) : EventuallyConst (g âˆ˜ f) l ",":=
  hg.anti hf"
Mathlib/Algebra/Module/LinearMap/Polynomial.lean,LinearMap.polyCharpolyAux_baseChange,polyCharpolyAux_baseChange,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  simp only [polyCharpolyAux]
  rw [â† charpoly.univ_map_map _ (algebraMap R A)]
  simp only [Polynomial.map_map]
  congr 1
  apply ringHom_ext
  Â· intro r
    simp only [RingHom.coe_comp, RingHom.coe_coe, Function.comp_apply, map_C, bindâ‚_C_right]
  Â· rintro ij
    simp only [RingHom.coe_comp, RingHom.coe_coe, Function.comp_apply, map_X, bindâ‚_X_right]
    classical
    rw [toMvPolynomial_comp _ (basis A (Basis.end bâ‚˜)), â† toMvPolynomial_baseChange]
    suffices toMvPolynomial (basis A bâ‚˜.end) (basis A bâ‚˜).end (tensorProduct R A M M) ij = X ij by
      rw [this, bindâ‚_X_right]
    simp only [toMvPolynomial, Matrix.toMvPolynomial]
    suffices âˆ€ kl,
        (toMatrix (basis A bâ‚˜.end) (basis A bâ‚˜).end) (tensorProduct R A M M) ij kl =
        if kl = ij then 1 else 0 by
      rw [Finset.sum_eq_single ij]
      Â· rw [this, if_pos rfl, X]
      Â· rintro kl - H
        rw [this, if_neg H, map_zero]
      Â· intro h
        exact (h (Finset.mem_univ _)).elim
    intro kl
    rw [toMatrix_apply, tensorProduct, TensorProduct.AlgebraTensorModule.lift_apply,
      basis_apply, TensorProduct.lift.tmul, coe_restrictScalars]
    dsimp only [coe_mk, AddHom.coe_mk, smul_apply, baseChangeHom_apply]
    rw [one_smul, Basis.baseChange_end, Basis.repr_self_apply]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  toMvPolynomial (basis A bâ‚˜.end) ?m.295515 ?m.297589 ij
R : Type u_1
L : Type u_2
M : Type u_3
n : Type u_4
Î¹ : Type u_5
Î¹' : Type u_6
Î¹M : Type u_7
instâœÂ¹Â² : CommRing R
instâœÂ¹Â¹ : AddCommGroup L
instâœÂ¹â° : Module R L
instâœâ¹ : AddCommGroup M
instâœâ¸ : Module R M
Ï† : L â†’â‚—[R] Module.End R M
instâœâ· : Fintype Î¹
instâœâ¶ : Fintype Î¹'
instâœâµ : Fintype Î¹M
instâœâ´ : DecidableEq Î¹
instâœÂ³ : DecidableEq Î¹'
instâœÂ² : DecidableEq Î¹M
b : Basis Î¹ R L
bâ‚˜ : Basis Î¹M R M
A : Type u_8
instâœÂ¹ : CommRing A
instâœ : Algebra R A
ij : Î¹M Ã— Î¹M
this : toMvPolynomial (basis A bâ‚˜.end) ?m.295515 ?m.297589 ij = X ij
âŠ¢ (bindâ‚ (toMvPolynomial (basis A b) (basis A bâ‚˜.end) (baseChange A Ï†)))
      (toMvPolynomial (basis A bâ‚˜.end) (basis A bâ‚˜).end (tensorProduct R A M M) ij) =
    toMvPolynomial (basis A b) (basis A bâ‚˜.end) (baseChange A Ï†) ij
error:  application type mismatch
  toMvPolynomial (basis A bâ‚˜.end) ?m.295515 (tensorProduct R A M M)
argument
  tensorProduct R A M M
has type
  @LinearMap A A CommSemiring.toSemiring CommSemiring.toSemiring (RingHom.id A) (TensorProduct R A (M â†’â‚—[R] M))
    (TensorProduct R A M â†’â‚—[A] TensorProduct R A M) TensorProduct.addCommMonoid addCommMonoid TensorProduct.leftModule
    module : Type (max u_3 u_8)
but is expected to have type
  @LinearMap A A CommSemiring.toSemiring CommSemiring.toSemiring (RingHom.id A) (TensorProduct R A (Module.End R M))
    (TensorProduct R A M â†’â‚—[A] TensorProduct R A M) AddCommGroup.toAddCommMonoid AddCommGroup.toAddCommMonoid
    TensorProduct.leftModule ?m.287858 : Type (max u_3 u_8)","lemma polyCharpolyAux_baseChange (A : Type*) [CommRing A] [Algebra R A] :
    polyCharpolyAux (tensorProduct _ _ _ _ âˆ˜â‚— Ï†.baseChange A) (basis A b) (basis A bâ‚˜) =
      (polyCharpolyAux Ï† b bâ‚˜).map (MvPolynomial.map (algebraMap R A)) ",":= by
  simp only [polyCharpolyAux]
  rw [â† charpoly.univ_map_map _ (algebraMap R A)]
  simp only [Polynomial.map_map]
  congr 1
  apply ringHom_ext
  Â· intro r
    simp only [RingHom.coe_comp, RingHom.coe_coe, Function.comp_apply, map_C, bindâ‚_C_right]
  Â· rintro ij
    simp only [RingHom.coe_comp, RingHom.coe_coe, Function.comp_apply, map_X, bindâ‚_X_right]
    classical
    rw [toMvPolynomial_comp _ (basis A (Basis.end bâ‚˜)), â† toMvPolynomial_baseChange]
    suffices toMvPolynomial (Mâ‚‚ := (Module.End A (TensorProduct R A M)))
        (basis A bâ‚˜.end) (basis A bâ‚˜).end (tensorProduct R A M M) ij = X ij by
      rw [this, bindâ‚_X_right]
    simp only [toMvPolynomial, Matrix.toMvPolynomial]
    suffices âˆ€ kl,
        (toMatrix (basis A bâ‚˜.end) (basis A bâ‚˜).end) (tensorProduct R A M M) ij kl =
        if kl = ij then 1 else 0 by
      rw [Finset.sum_eq_single ij]
      Â· rw [this, if_pos rfl, X]
      Â· rintro kl - H
        rw [this, if_neg H, map_zero]
      Â· intro h
        exact (h (Finset.mem_univ _)).elim
    intro kl
    rw [toMatrix_apply, tensorProduct, TensorProduct.AlgebraTensorModule.lift_apply,
      basis_apply, TensorProduct.lift.tmul, coe_restrictScalars]
    dsimp only [coe_mk, AddHom.coe_mk, smul_apply, baseChangeHom_apply]
    rw [one_smul, Basis.baseChange_end, Basis.repr_self_apply]"
Mathlib/GroupTheory/Sylow.lean,Sylow.exists_subgroup_card_pow_succ,exists_subgroup_card_pow_succ,ee3bd06d13312ae542594529a7568a6b0940def4,":=
  let âŸ¨s, hsâŸ© := exists_eq_mul_left_of_dvd hdvd
  have hcard : card (G â§¸ H) = s * p :=
    (mul_left_inj' (show card H â‰  0 from Fintype.card_ne_zero)).1
      (by
        rw [â† card_eq_card_quotient_mul_card_subgroup H, hH, hs, pow_succ', mul_assoc, mul_comm p])
  have hm : s * p % p = card (normalizer H â§¸ H.subgroupOf H.normalizer) % p :=
    Fintype.card_congr (fixedPointsMulLeftCosetsEquivQuotient H) â–¸
      hcard â–¸ (IsPGroup.of_card hH).card_modEq_card_fixedPoints _
  have hm' : p âˆ£ card (normalizer H â§¸ H.subgroupOf H.normalizer) :=
    Nat.dvd_of_mod_eq_zero (by rwa [Nat.mod_eq_zero_of_dvd (dvd_mul_left _ _), eq_comm] at hm)
  let âŸ¨x, hxâŸ© := @exists_prime_orderOf_dvd_card _ (QuotientGroup.Quotient.group _) _ _ hp hm'
  have hequiv : H â‰ƒ H.subgroupOf H.normalizer := (subgroupOfEquivOfLe le_normalizer).symm.toEquiv
  âŸ¨Subgroup.map (normalizer H).subtype
      (Subgroup.comap (mk' (H.subgroupOf H.normalizer)) (zpowers x)), by
    show Fintype.card (Subgroup.map H.normalizer.subtype
              (comap (mk' (H.subgroupOf H.normalizer)) (Subgroup.zpowers x))) = p ^ (n + 1)
    suffices Fintype.card (Subtype.val ''
              (Subgroup.comap (mk' (H.subgroupOf H.normalizer)) (zpowers x) : Set H.normalizer)) =
        p ^ (n + 1)
      by convert this using 2
    rw [Set.card_image_of_injective
        (Subgroup.comap (mk' (H.subgroupOf H.normalizer)) (zpowers x) : Set H.normalizer)
        Subtype.val_injective,
      pow_succ', â† hH, Fintype.card_congr hequiv, â† hx, â†Fintype.card_zpowers, â†
      Fintype.card_prod]
    exact @Fintype.card_congr _ _ (_) (_)
      (preimageMkEquivSubgroupProdSet (H.subgroupOf H.normalizer) (zpowers x)), by
    intro y hy
    simp only [exists_prop, Subgroup.coeSubtype, mk'_apply, Subgroup.mem_map, Subgroup.mem_comap]
    refine' âŸ¨âŸ¨y, le_normalizer hyâŸ©, âŸ¨0, _âŸ©, rflâŸ©
    dsimp only
    rw [zpow_zero, eq_comm, QuotientGroup.eq_one_iff]
    simpa using hyâŸ©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.card (G â§¸ H) * Nat.card â†¥H
G : Type u
Î± : Type v
Î² : Type w
instâœÂ¹ : Group G
instâœ : Fintype G
p n : â„•
hp : Fact (Nat.Prime p)
hdvd : p ^ (n + 1) âˆ£ Fintype.card G
H : Subgroup G
hH : Fintype.card â†¥H = p ^ n
s : â„•
hs : Fintype.card G = s * p ^ (n + 1)
âŠ¢ Fintype.card (G â§¸ H) * Fintype.card â†¥H = s * p * Fintype.card â†¥H
error:  application type mismatch
  Fintype.card_congr (preimageMkEquivSubgroupProdSet (H.subgroupOf H.normalizer) â†‘(zpowers x))
argument
  preimageMkEquivSubgroupProdSet (H.subgroupOf H.normalizer) â†‘(zpowers x)
has type
  â†‘(QuotientGroup.mk â»Â¹' â†‘(zpowers x)) â‰ƒ â†¥(H.subgroupOf H.normalizer) Ã— â†‘â†‘(zpowers x) : Type u
but is expected to have type
  â†‘â†‘(comap (mk' (H.subgroupOf H.normalizer)) (zpowers x)) â‰ƒ â†¥(zpowers x) Ã— â†¥(H.subgroupOf H.normalizer) : Type u","theorem exists_subgroup_card_pow_succ [Fintype G] {p : â„•} {n : â„•} [hp : Fact p.Prime]
    (hdvd : p ^ (n + 1) âˆ£ card G) {H : Subgroup G} (hH : Fintype.card H = p ^ n) :
    âˆƒ K : Subgroup G, Fintype.card K = p ^ (n + 1) âˆ§ H â‰¤ K ",":=
  let âŸ¨s, hsâŸ© := exists_eq_mul_left_of_dvd hdvd
  have hcard : card (G â§¸ H) = s * p :=
    (mul_left_inj' (show card H â‰  0 from Fintype.card_ne_zero)).1
      (by
        simp only [â† Nat.card_eq_fintype_card] at hs hH âŠ¢
        rw [â† card_eq_card_quotient_mul_card_subgroup H, hH, hs, pow_succ', mul_assoc, mul_comm p])
  have hm : s * p % p = card (normalizer H â§¸ H.subgroupOf H.normalizer) % p :=
    Fintype.card_congr (fixedPointsMulLeftCosetsEquivQuotient H) â–¸
      hcard â–¸ (IsPGroup.of_card hH).card_modEq_card_fixedPoints _
  have hm' : p âˆ£ card (normalizer H â§¸ H.subgroupOf H.normalizer) :=
    Nat.dvd_of_mod_eq_zero (by rwa [Nat.mod_eq_zero_of_dvd (dvd_mul_left _ _), eq_comm] at hm)
  let âŸ¨x, hxâŸ© := @exists_prime_orderOf_dvd_card _ (QuotientGroup.Quotient.group _) _ _ hp hm'
  have hequiv : H â‰ƒ H.subgroupOf H.normalizer := (subgroupOfEquivOfLe le_normalizer).symm.toEquiv
  âŸ¨Subgroup.map (normalizer H).subtype
      (Subgroup.comap (mk' (H.subgroupOf H.normalizer)) (zpowers x)), by
    show Fintype.card (Subgroup.map H.normalizer.subtype
              (comap (mk' (H.subgroupOf H.normalizer)) (Subgroup.zpowers x))) = p ^ (n + 1)
    suffices Fintype.card (Subtype.val ''
              (Subgroup.comap (mk' (H.subgroupOf H.normalizer)) (zpowers x) : Set H.normalizer)) =
        p ^ (n + 1)
      by convert this using 2
    rw [Set.card_image_of_injective
        (Subgroup.comap (mk' (H.subgroupOf H.normalizer)) (zpowers x) : Set H.normalizer)
        Subtype.val_injective,
      pow_succ, â† hH, Fintype.card_congr hequiv, â† hx, â† Fintype.card_zpowers, â†
      Fintype.card_prod]
    exact @Fintype.card_congr _ _ (_) (_)
      (preimageMkEquivSubgroupProdSet (H.subgroupOf H.normalizer) (zpowers x)), by
    intro y hy
    simp only [exists_prop, Subgroup.coeSubtype, mk'_apply, Subgroup.mem_map, Subgroup.mem_comap]
    refine âŸ¨âŸ¨y, le_normalizer hyâŸ©, âŸ¨0, ?_âŸ©, rflâŸ©
    dsimp only
    rw [zpow_zero, eq_comm, QuotientGroup.eq_one_iff]
    simpa using hyâŸ©"
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,AffineSubspace.coe_direction_eq_vsub_set_right,coe_direction_eq_vsub_set_right,a37e82f3616d798c1103557af7187357fc3e9e42,":= by
  rw [coe_direction_eq_vsub_set âŸ¨p, hpâŸ©]
  refine' le_antisymm _ _
  Â· rintro v âŸ¨p1, p2, hp1, hp2, rflâŸ©
    exact âŸ¨p1 -áµ¥ p2 +áµ¥ p, by aesop, vadd_vsub _ _âŸ©
  Â· rintro v âŸ¨p2, hp2, rflâŸ©
    exact âŸ¨p2, p, hp2, hp, rflâŸ©","error:  application type mismatch
  p1 -áµ¥ p2
argument
  p2
has type
  p1 âˆˆ â†‘s : Prop
but is expected to have type
  P : Type u_3
warning:  aesop: failed to prove the goal after exhaustive search.
error:  unsolved goals
k : Type u_1
V : Type u_2
P : Type u_3
inst : Ring k
inst_1 : AddCommGroup V
inst_2 : Module k V
inst_3 : AffineSpace V P
s : AffineSubspace k P
p : P
hp : p âˆˆ s
p1 hp1 : P
p2 : p1 âˆˆ s
hp2 : hp1 âˆˆ s
âŠ¢ p1 -áµ¥ sorryAx P true +áµ¥ p âˆˆ s
error:  application type mismatch
  And.intro p
argument
  p
has type
  P : Type u_3
but is expected to have type
  p2 âˆˆ â†‘s : Prop
error:  application type mismatch
  Exists.intro hp2
argument
  hp2
has type
  p2 âˆˆ â†‘s : Prop
but is expected to have type
  P : Type u_3
warning:  @AffineSubspace.Parallel does not have a doc string","theorem coe_direction_eq_vsub_set_right {s : AffineSubspace k P} {p : P} (hp : p âˆˆ s) :
    (s.direction : Set V) = (Â· -áµ¥ p) '' s ",":= by
  rw [coe_direction_eq_vsub_set âŸ¨p, hpâŸ©]
  refine le_antisymm ?_ ?_
  Â· rintro v âŸ¨p1, hp1, p2, hp2, rflâŸ©
    exact âŸ¨p1 -áµ¥ p2 +áµ¥ p, vadd_mem_of_mem_direction (vsub_mem_direction hp1 hp2) hp, vadd_vsub _ _âŸ©
  Â· rintro v âŸ¨p2, hp2, rflâŸ©
    exact âŸ¨p2, hp2, p, hp, rflâŸ©"
Mathlib/Data/Complex/Exponential.lean,Real.cosh_eq,cosh_eq,e0e36cd8862f71a903d4e784b508e9675f486059,":=
  eq_div_of_mul_eq two_ne_zero <| by
    rw [cosh, exp, exp, Complex.ofReal_neg, Complex.cosh, mul_two, â† Complex.add_re, â† mul_two,
      div_mul_cancel _ (two_ne_zero' â„‚), Complex.add_re]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.185075 / ?m.185154 * ?m.185154
xâœ y x : â„
âŠ¢ ((cexp â†‘x + cexp (-â†‘x)) / 2 * 2).re = (cexp â†‘x).re + (cexp (-â†‘x)).re",theorem cosh_eq (x : â„) : cosh x = (exp x + exp (-x)) / 2 ,":=
  eq_div_of_mul_eq two_ne_zero <| by
    rw [cosh, exp, exp, Complex.ofReal_neg, Complex.cosh, mul_two, â† Complex.add_re, â† mul_two,
      div_mul_cancelâ‚€ _ (two_ne_zero' â„‚), Complex.add_re]"
Mathlib/Data/Setoid/Partition.lean,Finpartition.isPartition_parts,Finpartition.isPartition_parts,0bb63b2bff135338722ab98f6da549f3e6350f0a,":=
  âŸ¨f.not_bot_mem,
    Setoid.eqv_classes_of_disjoint_union (f.parts.sup_id_set_eq_sUnion.symm.trans f.supParts)
      f.supIndep.pairwiseDisjointâŸ©","error:  invalid field 'supParts', the environment does not contain 'Finpartition.supParts'
  f
has type
  Finpartition Set.univ","theorem Finpartition.isPartition_parts {Î±} (f : Finpartition (Set.univ : Set Î±)) :
    Setoid.IsPartition (f.parts : Set (Set Î±)) ",":=
  âŸ¨f.not_bot_mem,
    Setoid.eqv_classes_of_disjoint_union (f.parts.sup_id_set_eq_sUnion.symm.trans f.sup_parts)
      f.supIndep.pairwiseDisjointâŸ©"
Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean,AlgebraicTopology.AlternatingCofaceMapComplex.d_squared,d_squared,6d1b77e97159c51b0084f053ab93299f39b3a009,":= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff, Fin.val_succ,
      Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa using hij
  Â· 
    rintro âŸ¨i, jâŸ© âŸ¨i', j'âŸ© hij hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine' âŸ¨(j'.pred _, Fin.castSucc i'), _, _âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_pred_of_lt hij'
    Â· simp only [Fin.castLT_castSucc, Fin.succ_pred]","error:  simp made no progress
error:  simp made no progress
error:  rcases tactic failed: aâœ : Quot.lift (fun l â†¦ (i, j) âˆˆ l) â‹¯ Sá¶œ.val is not an inductive datatype
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #3 provided
error:  no goals to be solved",theorem d_squared (n : â„•) : objD X (n + 1) â‰« objD X n = 0 ,":= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,
      Fin.val_succ, Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij âŸ¨i', j'âŸ© hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine âŸ¨(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'
    Â· simp only [Ï†, Fin.castLT_castSucc, Fin.succ_pred]
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa [S] using hij"
Mathlib/NumberTheory/Multiplicity.lean,Int.two_pow_sub_pow',Int.two_pow_sub_pow',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have hx_odd : Odd x := by rwa [Int.odd_iff_not_even, even_iff_two_dvd]
  have hxy_even : Even (x - y) := even_iff_two_dvd.mpr (dvd_trans (by decide) hxy)
  have hy_odd : Odd y := by simpa using hx_odd.sub_even hxy_even
  cases' n with n
  Â· simp only [pow_zero, sub_self, multiplicity.zero, Int.ofNat_zero, Nat.zero_eq, add_top]
  have h : (multiplicity 2 n.succ).Dom := multiplicity.finite_nat_iff.mpr âŸ¨by norm_num, n.succ_posâŸ©
  rcases multiplicity.eq_coe_iff.mp (PartENat.natCast_get h).symm with âŸ¨âŸ¨k, hkâŸ©, hpnâŸ©
  rw [hk, pow_mul, pow_mul, multiplicity.pow_sub_pow_of_prime,
    Int.two_pow_two_pow_sub_pow_two_pow _ hxy hx, â† hk, PartENat.natCast_get]
  Â· norm_cast
  Â· exact Int.prime_two
  Â· simpa only [even_iff_two_dvd] using hx_odd.pow.sub_odd hy_odd.pow
  Â· simpa only [even_iff_two_dvd, Int.odd_iff_not_even] using hx_odd.pow
  erw [Int.natCast_dvd_natCast]
  contrapose! hpn
  rw [pow_succ]
  conv_rhs => rw [hk]
  exact mul_dvd_mul_left _ hpn","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  n.succ
case succ.intro.intro
R : Type u_1
nâœ : â„•
x y : â„¤
hxy : 4 âˆ£ x - y
hx : Â¬2 âˆ£ x
hx_odd : Odd x
hxy_even : Even (x - y)
hy_odd : Odd y
n : â„•
h : (multiplicity 2 n.succ).Dom
hpn : Â¬2 ^ ((multiplicity 2 n.succ).get h + 1) âˆ£ n.succ
k : â„•
hk : n.succ = 2 ^ (multiplicity 2 n.succ).get h * k
âŠ¢ multiplicity 2 (x ^ (n + 1) - y ^ (n + 1)) = multiplicity 2 (x - y) + multiplicity 2 â†‘(n + 1)","theorem Int.two_pow_sub_pow' {x y : â„¤} (n : â„•) (hxy : 4 âˆ£ x - y) (hx : Â¬2 âˆ£ x) :
    multiplicity 2 (x ^ n - y ^ n) = multiplicity 2 (x - y) + multiplicity (2 : â„¤) n ",":= by
  have hx_odd : Odd x := by rwa [Int.odd_iff_not_even, even_iff_two_dvd]
  have hxy_even : Even (x - y) := even_iff_two_dvd.mpr (dvd_trans (by decide) hxy)
  have hy_odd : Odd y := by simpa using hx_odd.sub_even hxy_even
  cases' n with n
  Â· simp only [pow_zero, sub_self, multiplicity.zero, Int.ofNat_zero, Nat.zero_eq, add_top]
  have h : (multiplicity 2 n.succ).Dom := multiplicity.finite_nat_iff.mpr âŸ¨by norm_num, n.succ_posâŸ©
  simp only [Nat.succ_eq_add_one] at h
  rcases multiplicity.eq_coe_iff.mp (PartENat.natCast_get h).symm with âŸ¨âŸ¨k, hkâŸ©, hpnâŸ©
  rw [hk, pow_mul, pow_mul, multiplicity.pow_sub_pow_of_prime,
    Int.two_pow_two_pow_sub_pow_two_pow _ hxy hx, â† hk, PartENat.natCast_get]
  Â· norm_cast
  Â· exact Int.prime_two
  Â· simpa only [even_iff_two_dvd] using hx_odd.pow.sub_odd hy_odd.pow
  Â· simpa only [even_iff_two_dvd, Int.odd_iff_not_even] using hx_odd.pow
  erw [Int.natCast_dvd_natCast]
  contrapose! hpn
  rw [pow_succ]
  conv_rhs => rw [hk]
  exact mul_dvd_mul_left _ hpn"
Mathlib/NumberTheory/Modular.lean,ModularGroup.smul_eq_lcRow0_add,smul_eq_lcRow0_add,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  have nonZ1 : (p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2 â‰  0 := by exact_mod_cast hp.sq_add_sq_ne_zero
  have : ((â†‘) : â„¤ â†’ â„) âˆ˜ p â‰  0 := fun h => hp.ne_zero (by ext i; simpa using congr_fun h i)
  have nonZ2 : (p 0 : â„‚) * z + p 1 â‰  0 := by simpa using linear_ne_zero _ z this
  field_simp [nonZ1, nonZ2, denom_ne_zero, num]
  rw [(by simp :
    (p 1 : â„‚) * z - p 0 = (p 1 * z - p 0) * â†‘(Matrix.det (â†‘g : Matrix (Fin 2) (Fin 2) â„¤)))]
  rw [â† hg, det_fin_two]
  simp only [Int.coe_castRingHom, coe_matrix_coe, Int.cast_mul, ofReal_int_cast, map_apply, denom,
    Int.cast_sub, coe_GLPos_coe_GL_coe_matrix, coe'_apply_complex]
  ring","error:  unknown identifier 'ofReal_int_cast'
warning:  fd does not have a doc string
warning:  fdo does not have a doc string","theorem smul_eq_lcRow0_add {p : Fin 2 â†’ â„¤} (hp : IsCoprime (p 0) (p 1)) (hg : (â†‘â‚˜g) 1 = p) :
    â†‘(g â€¢ z) =
      (lcRow0 p â†‘(g : SL(2, â„)) : â„‚) / ((p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2) +
        ((p 1 : â„‚) * z - p 0) / (((p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2) * (p 0 * z + p 1)) ",":= by
  have nonZ1 : (p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2 â‰  0 := mod_cast hp.sq_add_sq_ne_zero
  have : ((â†‘) : â„¤ â†’ â„) âˆ˜ p â‰  0 := fun h => hp.ne_zero (by ext i; simpa using congr_fun h i)
  have nonZ2 : (p 0 : â„‚) * z + p 1 â‰  0 := by simpa using linear_ne_zero _ z this
  field_simp [nonZ1, nonZ2, denom_ne_zero, num]
  rw [(by simp :
    (p 1 : â„‚) * z - p 0 = (p 1 * z - p 0) * â†‘(Matrix.det (â†‘g : Matrix (Fin 2) (Fin 2) â„¤)))]
  rw [â† hg, det_fin_two]
  simp only [Int.coe_castRingHom, coe_matrix_coe, Int.cast_mul, ofReal_intCast, map_apply, denom,
    Int.cast_sub, coe_GLPos_coe_GL_coe_matrix, coe'_apply_complex]
  ring"
Mathlib/Analysis/SpecialFunctions/Trigonometric/Arctan.lean,Real.arccos_eq_arctan,arccos_eq_arctan,ded82be28af61da8cf3266077ac67ad9bf41c841,":= by
  rw [arccos, eq_comm]
  refine arctan_eq_of_tan_eq ?_ ?âŸ¨_, ?_âŸ©
  Â· rw_mod_cast [tan_pi_div_two_sub, tan_arcsin, inv_div]
  Â· linarith only [arcsin_le_pi_div_two x, pi_pos]
  Â· linarith only [arcsin_pos.2 h]","error:  unexpected token 'âŸ¨'; expected '_' or identifier
error:  unsolved goals
case refine_1
x : â„
h : 0 < x
âŠ¢ tan (Ï€ / 2 - arcsin x) = âˆš(1 - x ^ 2) / x

case refine_2
x : â„
h : 0 < x
âŠ¢ Ï€ / 2 - arcsin x âˆˆ Ioo (-(Ï€ / 2)) (Ï€ / 2)",theorem arccos_eq_arctan {x : â„} (h : 0 < x) : arccos x = arctan (âˆš(1 - x ^ 2) / x) ,":= by
  rw [arccos, eq_comm]
  refine arctan_eq_of_tan_eq ?_ âŸ¨?_, ?_âŸ©
  Â· rw_mod_cast [tan_pi_div_two_sub, tan_arcsin, inv_div]
  Â· linarith only [arcsin_le_pi_div_two x, pi_pos]
  Â· linarith only [arcsin_pos.2 h]"
Mathlib/CategoryTheory/Filtered/Basic.lean,CategoryTheory.IsFiltered.cocone_nonempty,cocone_nonempty,ba9ffb63c3a392ae937d6d012c9e01340814d771,":= by
  classical
  let O := Finset.univ.image F.obj
  let H : Finset (Î£' (X Y : C) (_ : X âˆˆ O) (_ : Y âˆˆ O), X âŸ¶ Y) :=
    Finset.univ.biUnion   fun X : J =>
      Finset.univ.biUnion fun Y : J =>
        Finset.univ.image fun f : X âŸ¶ Y => âŸ¨F.obj X, F.obj Y, by simp, by simp, F.map fâŸ©
  obtain âŸ¨Z, f, wâŸ© := sup_exists O H
  refine' âŸ¨âŸ¨Z, âŸ¨fun X => f (by simp), _âŸ©âŸ©âŸ©
  intro j j' g
  dsimp
  simp only [Category.comp_id]
  apply w
  simp only [Finset.mem_biUnion, Finset.mem_univ, Finset.mem_image, PSigma.mk.injEq,
    true_and, exists_and_left]
  exact âŸ¨j, rfl, j', g, by simpâŸ©","error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress",theorem cocone_nonempty (F : J â¥¤ C) : Nonempty (Cocone F) ,":= by
  classical
  let O := Finset.univ.image F.obj
  let H : Finset (Î£' (X Y : C) (_ : X âˆˆ O) (_ : Y âˆˆ O), X âŸ¶ Y) :=
    Finset.univ.biUnion   fun X : J =>
      Finset.univ.biUnion fun Y : J =>
        Finset.univ.image fun f : X âŸ¶ Y => âŸ¨F.obj X, F.obj Y, by simp [O], by simp [O], F.map fâŸ©
  obtain âŸ¨Z, f, wâŸ© := sup_exists O H
  refine âŸ¨âŸ¨Z, âŸ¨fun X => f (by simp [O]), ?_âŸ©âŸ©âŸ©
  intro j j' g
  dsimp
  simp only [Category.comp_id]
  apply w
  simp only [O, H, Finset.mem_biUnion, Finset.mem_univ, Finset.mem_image, PSigma.mk.injEq,
    true_and, exists_and_left]
  exact âŸ¨j, rfl, j', g, by simpâŸ©"
Mathlib/Analysis/Fourier/AddCircle.lean,fourierCoeff_eq_intervalIntegral,fourierCoeff_eq_intervalIntegral,50dac17e96f8a0ddcbd8740f9929f7cf0a85740d,":= by
  have : âˆ€ x : â„, @fourier T (-n) x â€¢ f x = (fun z : AddCircle T => @fourier T (-n) z â€¢ f z) x := by
    intro x; rfl
  simp_rw [this]
  rw [fourierCoeff, AddCircle.intervalIntegral_preimage T a (fun z => _ â€¢ _),
    volume_eq_smul_haarAddCircle, integral_smul_measure, ENNReal.toReal_ofReal hT.out.le,
    â† smul_assoc, smul_eq_mul, one_div_mul_cancel hT.out.ne', one_smul]","error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information","theorem fourierCoeff_eq_intervalIntegral (f : AddCircle T â†’ E) (n : â„¤) (a : â„) :
    fourierCoeff f n = (1 / T) â€¢ âˆ« x in a..a + T, @fourier T (-n) x â€¢ f x ",":= by
  have : âˆ€ x : â„, @fourier T (-n) x â€¢ f x = (fun z : AddCircle T => @fourier T (-n) z â€¢ f z) x := by
    intro x; rfl
  simp_rw (config := {singlePass := true}) [this]
  rw [fourierCoeff, AddCircle.intervalIntegral_preimage T a (fun z => _ â€¢ _),
    volume_eq_smul_haarAddCircle, integral_smul_measure, ENNReal.toReal_ofReal hT.out.le,
    â† smul_assoc, smul_eq_mul, one_div_mul_cancel hT.out.ne', one_smul]"
Mathlib/RingTheory/NonUnitalSubring/Basic.lean,NonUnitalSubring.mem_iSup_of_directed,mem_iSup_of_directed,a37e82f3616d798c1103557af7187357fc3e9e42,":= by
  refine' âŸ¨_, fun âŸ¨i, hiâŸ© => (SetLike.le_def.1 <| le_iSup S i) hiâŸ©
  let U : NonUnitalSubring R :=
    NonUnitalSubring.mk' (â‹ƒ i, (S i : Set R)) (â¨† i, (S i).toSubsemigroup) (â¨† i, (S i).toAddSubgroup)
      (Subsemigroup.coe_iSup_of_directed <| hS.mono_comp _ fun _ _ => id)
      (AddSubgroup.coe_iSup_of_directed <| hS.mono_comp _ fun _ _ => id)
  suffices (â¨† i, S i) â‰¤ U by simpa using @this x
  exact iSup_le fun i x hx => Set.mem_iUnion.2 âŸ¨i, hxâŸ©","error:  type mismatch
  hâœ
has type
  x âˆˆ â¨† i, S i â†’ x âˆˆ U : Prop
but is expected to have type
  x âˆˆ â¨† i, S i â†’ âˆƒ i, x âˆˆ S i : Prop","theorem mem_iSup_of_directed {Î¹} [hÎ¹ : Nonempty Î¹] {S : Î¹ â†’ NonUnitalSubring R}
    (hS : Directed (Â· â‰¤ Â·) S) {x : R} : (x âˆˆ â¨† i, S i) â†” âˆƒ i, x âˆˆ S i ",":= by
  refine âŸ¨?_, fun âŸ¨i, hiâŸ© â†¦ le_iSup S i hiâŸ©
  let U : NonUnitalSubring R :=
    NonUnitalSubring.mk' (â‹ƒ i, (S i : Set R)) (â¨† i, (S i).toSubsemigroup) (â¨† i, (S i).toAddSubgroup)
      (Subsemigroup.coe_iSup_of_directed hS) (AddSubgroup.coe_iSup_of_directed hS)
  suffices â¨† i, S i â‰¤ U by simpa [U] using @this x
  exact iSup_le fun i x hx â†¦ Set.mem_iUnion.2 âŸ¨i, hxâŸ©"
Mathlib/Order/SupClosed.lean,SupClosed.directedOn,SupClosed.directedOn,a380f5a603bf5030bc30e58b1aed19567f67b98d,:=,error:  unexpected token 'lemma'; expected term,lemma SupClosed.directedOn (hs : SupClosed s) : DirectedOn (Â· â‰¤ Â·) s ,":=
  fun _a ha _b hb â†¦ âŸ¨_, hs ha hb, le_sup_left, le_sup_rightâŸ©"
Mathlib/LinearAlgebra/Reflection.lean,Module.Dual.eq_of_preReflection_mapsTo,Dual.eq_of_preReflection_mapsTo,669cc3a01fcbdb94ecdc47e504b36ef369648f7c,":= by
  let u := reflection hgâ‚ * reflection hfâ‚
  have hu : u = LinearMap.id (R := R) (M := M) + (f - g).smulRight x := by
    ext y
    simp only [reflection_apply, hgâ‚, two_smul, LinearEquiv.coe_toLinearMap_mul, LinearMap.id_coe,
      LinearEquiv.coe_coe, LinearMap.mul_apply, LinearMap.add_apply, id_eq, LinearMap.coe_smulRight,
      LinearMap.sub_apply, map_sub, map_smul, sub_add_cancel', smul_neg, sub_neg_eq_add, sub_smul]
    abel
  replace hu : âˆ€ (n : â„•),
      â†‘(u ^ n) = LinearMap.id (R := R) (M := M) + (n : R) â€¢ (f - g).smulRight x := by
    intros n
    induction' n with n ih; simp
    have : ((f - g).smulRight x).comp ((n : R) â€¢ (f - g).smulRight x) = 0 := by ext; simp [hfâ‚, hgâ‚]
    rw [pow_succ, LinearEquiv.coe_toLinearMap_mul, ih, hu, add_mul, mul_add, mul_add]
    simp_rw [LinearMap.mul_eq_comp, LinearMap.comp_id, LinearMap.id_comp, this, add_zero, add_assoc,
      Nat.cast_succ, add_smul, one_smul]
  suffices IsOfFinOrder u by
    obtain âŸ¨n, hnâ‚€, hnâ‚âŸ© := isOfFinOrder_iff_pow_eq_one.mp this
    replace hnâ‚ : (â†‘(u ^ n) : M â†’â‚—[R] M) = LinearMap.id := LinearEquiv.toLinearMap_inj.mpr hnâ‚
    simpa [hnâ‚, hnâ‚€.ne', hx, sub_eq_zero] using hu n
  exact u.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo hÎ¦â‚ hÎ¦â‚‚ (hgâ‚‚.comp hfâ‚‚)","warning:  `sub_add_cancel'` has been deprecated, use `sub_add_cancel_left` instead
info:  Try this: abel_nf
error:  unsolved goals
case h
R : Type u_1
M : Type u_2
instâœâ´ : CommRing R
instâœÂ³ : AddCommGroup M
instâœÂ² : Module R M
xâœ : M
fâœ : Dual R M
yâœ : M
instâœÂ¹ : CharZero R
instâœ : NoZeroSMulDivisors R M
x : M
hx : x â‰  0
Î¦ : Set M
hÎ¦â‚ : Î¦.Finite
hÎ¦â‚‚ : span R Î¦ = âŠ¤
f g : Dual R M
hfâ‚ : f x = 2
hfâ‚‚ : MapsTo (â‡‘(preReflection x f)) Î¦ Î¦
hgâ‚ : g x = 2
hgâ‚‚ : MapsTo (â‡‘(preReflection x g)) Î¦ Î¦
u : M â‰ƒâ‚—[R] M := reflection hgâ‚ * reflection hfâ‚
y : M
âŠ¢ u y = y + (f y â€¢ x + -1 â€¢ g y â€¢ x)
error:  simp made no progress","lemma Dual.eq_of_preReflection_mapsTo [CharZero R] [NoZeroSMulDivisors R M]
    {x : M} (hx : x â‰  0) {Î¦ : Set M} (hÎ¦â‚ : Î¦.Finite) (hÎ¦â‚‚ : span R Î¦ = âŠ¤) {f g : Dual R M}
    (hfâ‚ : f x = 2) (hfâ‚‚ : MapsTo (preReflection x f) Î¦ Î¦)
    (hgâ‚ : g x = 2) (hgâ‚‚ : MapsTo (preReflection x g) Î¦ Î¦) :
    f = g ",":= by
  let u := reflection hgâ‚ * reflection hfâ‚
  have hu : u = LinearMap.id (R := R) (M := M) + (f - g).smulRight x := by
    ext y
    simp only [u, reflection_apply, hgâ‚, two_smul, LinearEquiv.coe_toLinearMap_mul,
      LinearMap.id_coe, LinearEquiv.coe_coe, LinearMap.mul_apply, LinearMap.add_apply, id_eq,
      LinearMap.coe_smulRight, LinearMap.sub_apply, map_sub, map_smul, sub_add_cancel_left,
      smul_neg, sub_neg_eq_add, sub_smul]
    abel
  replace hu : âˆ€ (n : â„•),
      â†‘(u ^ n) = LinearMap.id (R := R) (M := M) + (n : R) â€¢ (f - g).smulRight x := by
    intros n
    induction n with
    | zero => simp
    | succ n ih =>
      have : ((f - g).smulRight x).comp ((n : R) â€¢ (f - g).smulRight x) = 0 := by
        ext; simp [hfâ‚, hgâ‚]
      rw [pow_succ', LinearEquiv.coe_toLinearMap_mul, ih, hu, add_mul, mul_add, mul_add]
      simp_rw [LinearMap.mul_eq_comp, LinearMap.comp_id, LinearMap.id_comp, this, add_zero,
        add_assoc, Nat.cast_succ, add_smul, one_smul]
  suffices IsOfFinOrder u by
    obtain âŸ¨n, hnâ‚€, hnâ‚âŸ© := isOfFinOrder_iff_pow_eq_one.mp this
    replace hnâ‚ : (â†‘(u ^ n) : M â†’â‚—[R] M) = LinearMap.id := LinearEquiv.toLinearMap_inj.mpr hnâ‚
    simpa [hnâ‚, hnâ‚€.ne', hx, sub_eq_zero] using hu n
  exact u.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo hÎ¦â‚ hÎ¦â‚‚ (hgâ‚‚.comp hfâ‚‚)"
Mathlib/NumberTheory/NumberField/Embeddings.lean,NumberField.InfinitePlace.mem_orbit_iff,mem_orbit_iff,4fda6f75a24576d1bee6410cfcd8c2d587eaab96,":= by
  refine âŸ¨?_, exists_smul_eq_of_comap_eq w w'âŸ©
  rintro âŸ¨Ïƒ, rfl : Ïƒ â€¢ w = w'âŸ©
  rw [â† mk_embedding w, comap_mk, smul_mk, comap_mk]
  congr 1; ext1; simp","error:  application type mismatch
  exists_smul_eq_of_comap_eq w
argument
  w
has type
  InfinitePlace K : Type u_2
but is expected to have type
  ?m.299442.comap (algebraMap ?m.299436 ?m.299438) = ?m.299443.comap (algebraMap ?m.299436 ?m.299438) : Prop","lemma mem_orbit_iff [IsGalois k K] {w w' : InfinitePlace K} :
    w' âˆˆ MulAction.orbit (K â‰ƒâ‚[k] K) w â†” w.comap (algebraMap k K) = w'.comap (algebraMap k K) ",":= by
  refine âŸ¨?_, exists_smul_eq_of_comap_eqâŸ©
  rintro âŸ¨Ïƒ, rfl : Ïƒ â€¢ w = w'âŸ©
  rw [â† mk_embedding w, comap_mk, smul_mk, comap_mk]
  congr 1; ext1; simp"
Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean,CategoryTheory.Pretriangulated.exists_iso_binaryBiproduct_of_distTriang,exists_iso_binaryBiproduct_of_distTriang,eb4e7cb40c973c5fbf11d3373bd0829447b7de8a,":= by
  have := T.epiâ‚‚ hT zero
  have := isSplitEpi_of_epi T.morâ‚‚
  obtain âŸ¨fst, hfstâŸ© := T.coyoneda_exactâ‚‚ hT (ğŸ™ T.objâ‚‚ - T.morâ‚‚ â‰« section_ T.morâ‚‚) (by simp)
  let d := binaryBiproductData _ hT zero (section_ T.morâ‚‚) (by simp) fst
    (by simp only [â† hfst, sub_add_cancel])
  refine' âŸ¨biprod.uniqueUpToIso _ _ d.isBilimit, âŸ¨_, by simpâŸ©âŸ©
  ext
  Â· simpa using d.bicone.inl_fst
  Â· simpa using d.bicone.inl_snd","error:  unsolved goals
C : Type u
instâœâ´ : Category.{v, u} C
instâœÂ³ : HasZeroObject C
instâœÂ² : HasShift C â„¤
instâœÂ¹ : Preadditive C
instâœ : âˆ€ (n : â„¤), (shiftFunctor C n).Additive
hC : Pretriangulated C
T : Triangle C
hT : T âˆˆ distinguishedTriangles
zero : T.morâ‚ƒ = 0
thisâœ : Epi T.morâ‚‚
this : IsSplitEpi T.morâ‚‚
fst : T.objâ‚‚ âŸ¶ T.objâ‚
hfst : ğŸ™ T.objâ‚‚ - T.morâ‚‚ â‰« section_ T.morâ‚‚ = fst â‰« T.morâ‚
d : BinaryBiproductData T.objâ‚ T.objâ‚ƒ := binaryBiproductData T hT zero (section_ T.morâ‚‚) â‹¯ fst â‹¯
âŠ¢ T.morâ‚‚ = d.bicone.snd
error:  type mismatch
  hâœ
has type
  True : Prop
but is expected to have type
  T.morâ‚ â‰« d.bicone.fst = ğŸ™ T.objâ‚ : Prop
error:  type mismatch
  hâœ
has type
  True : Prop
but is expected to have type
  T.morâ‚ â‰« d.bicone.snd = 0 : Prop","lemma exists_iso_binaryBiproduct_of_distTriang (T : Triangle C) (hT : T âˆˆ distTriang C)
    (zero : T.morâ‚ƒ = 0) :
    âˆƒ (e : T.objâ‚‚ â‰… T.objâ‚ âŠ T.objâ‚ƒ), T.morâ‚ â‰« e.hom = biprod.inl âˆ§
      T.morâ‚‚ = e.hom â‰« biprod.snd ",":= by
  have := T.epiâ‚‚ hT zero
  have := isSplitEpi_of_epi T.morâ‚‚
  obtain âŸ¨fst, hfstâŸ© := T.coyoneda_exactâ‚‚ hT (ğŸ™ T.objâ‚‚ - T.morâ‚‚ â‰« section_ T.morâ‚‚) (by simp)
  let d := binaryBiproductData _ hT zero (section_ T.morâ‚‚) (by simp) fst
    (by simp only [â† hfst, sub_add_cancel])
  refine âŸ¨biprod.uniqueUpToIso _ _ d.isBilimit, âŸ¨?_, by simp [d]âŸ©âŸ©
  ext
  Â· simpa [d] using d.bicone.inl_fst
  Â· simpa [d] using d.bicone.inl_snd"
Mathlib/Data/Nat/Bits.lean,Nat.testBit_bit_zero,testBit_bit_zero,2ea14b79e1f7e6978b1265a8d41f7a305925875c,":= by
  rw [testBit, bit]
  cases b
  Â· simp [bit0, â† Nat.mul_two]
  Â· simp only [cond_true, bit1, bit0, shiftRight_zero, and_one_is_mod, bne_iff_ne]
    simp only [â† Nat.mul_two]
    rw [Nat.add_mod]
    simp","warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?a + ?b) % ?n
case true
m nâœ n : â„•
âŠ¢ 1 &&& n * 2 + 1 â‰  0
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated",lemma testBit_bit_zero (b n) : testBit (bit b n) 0 = b ,":= by
  rw [testBit, bit]
  cases b
  Â· simp [bit0, â† Nat.mul_two]
  Â· simp [bit0, bit1, â† Nat.mul_two]"
Mathlib/Data/Finset/Lattice.lean,Finset.sup_induction,sup_induction,dee5d9343d596781e8ec7749927ce52e2d12df27,":= by
  induction s using Finset.cons_induction with
  | empty => exact hb
  | cons _ ih =>
    simp only [sup_cons, forall_mem_cons] at hs âŠ¢
    exact hp _ hs.1 _ (ih hs.2)","error:  function expected at
  ih
term has type
  Finset Î²","theorem sup_induction {p : Î± â†’ Prop} (hb : p âŠ¥) (hp : âˆ€ aâ‚, p aâ‚ â†’ âˆ€ aâ‚‚, p aâ‚‚ â†’ p (aâ‚ âŠ” aâ‚‚))
    (hs : âˆ€ b âˆˆ s, p (f b)) : p (s.sup f) ",":= by
  induction s using Finset.cons_induction with
  | empty => exact hb
  | cons _ _ _ ih =>
    simp only [sup_cons, forall_mem_cons] at hs âŠ¢
    exact hp _ hs.1 _ (ih hs.2)"
Mathlib/Algebra/MonoidAlgebra/Ideal.lean,MonoidAlgebra.mem_ideal_span_of_image,MonoidAlgebra.mem_ideal_span_of_image,dbf5a47b8c4182b629cafbc5ac0943103cfdca17,":= by
  let RHS : Ideal (MonoidAlgebra k G) :=
    { carrier := { p | âˆ€ m : G, m âˆˆ p.support â†’ âˆƒ m' âˆˆ s, âˆƒ d, m = d * m' }
      add_mem' := fun {x y} hx hy m hm => by
        classical exact (Finset.mem_union.1 <| Finsupp.support_add hm).elim (hx m) (hy m)
      zero_mem' := fun m hm => by cases hm
      smul_mem' := fun x y hy m hm => by
        classical
        replace hm := Finset.mem_biUnion.mp (Finsupp.support_sum hm)
        obtain âŸ¨xm, -, hmâŸ© := hm
        replace hm := Finset.mem_biUnion.mp (Finsupp.support_sum hm)
        obtain âŸ¨ym, hym, hmâŸ© := hm
        replace hm := Finset.mem_singleton.mp (Finsupp.support_single_subset hm)
        obtain rfl := hm
        refine' (hy _ hym).imp fun sm p => And.imp_right _ p
        rintro âŸ¨d, rflâŸ©
        exact âŸ¨xm * d, (mul_assoc _ _ _).symmâŸ© }
  change _ â†” x âˆˆ RHS
  constructor
  Â· revert x
    rw [â† SetLike.le_def] 
    refine Ideal.span_le.2 ?_
    rintro _ âŸ¨i, hi, rflâŸ© m hm
    refine' âŸ¨_, hi, 1, _âŸ©
    obtain rfl := Finset.mem_singleton.mp (Finsupp.support_single_subset hm)
    exact (one_mul _).symm
  Â· intro hx
    rw [â† Finsupp.sum_single x]
    refine Ideal.sum_mem _ fun i hi => ?_  
    obtain âŸ¨d, hd, d2, rflâŸ© := hx _ hi
    convert Ideal.mul_mem_left _ (id <| Finsupp.single d2 <| x (d2 * d) : MonoidAlgebra k G) _
    pick_goal 3
    refine' Ideal.subset_span âŸ¨_, hd, rflâŸ©
    rw [id, MonoidAlgebra.of_apply, MonoidAlgebra.single_mul_single, mul_one]","error:  application type mismatch
  Finsupp.support_sum hm
argument
  hm
has type
  m âˆˆ (x â€¢ y).support : Prop
but is expected to have type
  m âˆˆ (?m.4588.sum ?m.4589).support : Prop
error:  unsolved goals
k : Type u_1
A : Type u_2
G : Type u_3
instâœÂ¹ : Monoid G
instâœ : Semiring k
s : Set G
xâœ x y : MonoidAlgebra k G
hy : y âˆˆ { carrier := {p | âˆ€ m âˆˆ p.support, âˆƒ m' âˆˆ s, âˆƒ d, m = d * m'}, add_mem' := â‹¯, zero_mem' := â‹¯ }.carrier
m : G
hm : m âˆˆ (x â€¢ y).support
âŠ¢ âˆƒ m' âˆˆ s, âˆƒ d, m = d * m'","theorem MonoidAlgebra.mem_ideal_span_of_image [Monoid G] [Semiring k] {s : Set G}
    {x : MonoidAlgebra k G} :
    x âˆˆ Ideal.span (MonoidAlgebra.of k G '' s) â†” âˆ€ m âˆˆ x.support, âˆƒ m' âˆˆ s, âˆƒ d, m = d * m' ",":= by
  let RHS : Ideal (MonoidAlgebra k G) :=
    { carrier := { p | âˆ€ m : G, m âˆˆ p.support â†’ âˆƒ m' âˆˆ s, âˆƒ d, m = d * m' }
      add_mem' := fun {x y} hx hy m hm => by
        classical exact (Finset.mem_union.1 <| Finsupp.support_add hm).elim (hx m) (hy m)
      zero_mem' := fun m hm => by cases hm
      smul_mem' := fun x y hy m hm => by
        classical
        rw [smul_eq_mul, mul_def] at hm
        replace hm := Finset.mem_biUnion.mp (Finsupp.support_sum hm)
        obtain âŸ¨xm, -, hmâŸ© := hm
        replace hm := Finset.mem_biUnion.mp (Finsupp.support_sum hm)
        obtain âŸ¨ym, hym, hmâŸ© := hm
        obtain rfl := Finset.mem_singleton.mp (Finsupp.support_single_subset hm)
        refine (hy _ hym).imp fun sm p => And.imp_right ?_ p
        rintro âŸ¨d, rflâŸ©
        exact âŸ¨xm * d, (mul_assoc _ _ _).symmâŸ© }
  change _ â†” x âˆˆ RHS
  constructor
  Â· revert x
    rw [â† SetLike.le_def] 
    refine Ideal.span_le.2 ?_
    rintro _ âŸ¨i, hi, rflâŸ© m hm
    refine âŸ¨_, hi, 1, ?_âŸ©
    obtain rfl := Finset.mem_singleton.mp (Finsupp.support_single_subset hm)
    exact (one_mul _).symm
  Â· intro hx
    rw [â† Finsupp.sum_single x]
    refine Ideal.sum_mem _ fun i hi => ?_  
    obtain âŸ¨d, hd, d2, rflâŸ© := hx _ hi
    convert Ideal.mul_mem_left _ (id <| Finsupp.single d2 <| x (d2 * d) : MonoidAlgebra k G) _
    pick_goal 3
    Â· exact Ideal.subset_span âŸ¨_, hd, rflâŸ©
    rw [id, MonoidAlgebra.of_apply, MonoidAlgebra.single_mul_single, mul_one]"
Mathlib/CategoryTheory/IsConnected.lean,CategoryTheory.induct_on_objects,induct_on_objects,22076520903c461af1cd692a5be16bb5748b9a06,":= by
  let aux (jâ‚ jâ‚‚ : J) (f : jâ‚ âŸ¶  jâ‚‚) := congrArg ULift.up <| (h1 f).to_eq 
  injection constant_of_preserves_morphisms (fun k => ULift.up (k âˆˆ p)) aux j jâ‚€ with i
  rwa [i]","warning:  IsPreconnected does not have a doc string
error:  invalid field 'to_eq', the environment does not contain 'Iff.to_eq'
  h1 f
has type
  jâ‚ âˆˆ p â†” jâ‚‚ âˆˆ p
error:  unsolved goals
J : Type uâ‚
instâœÂ² : Category.{vâ‚, uâ‚} J
K : Type uâ‚‚
instâœÂ¹ : Category.{vâ‚‚, uâ‚‚} K
instâœ : IsPreconnected J
p : Set J
jâ‚€ : J
h0 : jâ‚€ âˆˆ p
h1 : âˆ€ {jâ‚ jâ‚‚ : J}, (jâ‚ âŸ¶ jâ‚‚) â†’ (jâ‚ âˆˆ p â†” jâ‚‚ âˆˆ p)
j : J
âŠ¢ j âˆˆ p","theorem induct_on_objects [IsPreconnected J] (p : Set J) {jâ‚€ : J} (h0 : jâ‚€ âˆˆ p)
    (h1 : âˆ€ {jâ‚ jâ‚‚ : J} (_ : jâ‚ âŸ¶ jâ‚‚), jâ‚ âˆˆ p â†” jâ‚‚ âˆˆ p) (j : J) : j âˆˆ p ",":= by
  let aux (jâ‚ jâ‚‚ : J) (f : jâ‚ âŸ¶ jâ‚‚) := congrArg ULift.up <| (h1 f).eq
  injection constant_of_preserves_morphisms (fun k => ULift.up.{uâ‚} (k âˆˆ p)) aux j jâ‚€ with i
  rwa [i]"
Mathlib/Analysis/Convex/Between.lean,sbtw_of_sbtw_of_sbtw_of_mem_affineSpan_pair,sbtw_of_sbtw_of_sbtw_of_mem_affineSpan_pair,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  letI : DecidableRel ((Â· < Â·) : R â†’ R â†’ Prop) := LinearOrderedRing.decidableLT
  have hâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ := by
    rintro rfl
    simp at hâ‚‚
  have hâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ := by
    rintro rfl
    simp at hâ‚
  have h3 : âˆ€ i : Fin 3, i = iâ‚ âˆ¨ i = iâ‚‚ âˆ¨ i = iâ‚ƒ := by
    clear hâ‚ hâ‚‚ hâ‚' hâ‚‚'
    intro i
    fin_cases i <;> fin_cases iâ‚ <;> fin_cases iâ‚‚ <;> fin_cases iâ‚ƒ <;> simp at hâ‚â‚‚ hâ‚â‚ƒ hâ‚‚â‚ƒ âŠ¢
  have hu : (Finset.univ : Finset (Fin 3)) = {iâ‚, iâ‚‚, iâ‚ƒ} := by
    clear hâ‚ hâ‚‚ hâ‚' hâ‚‚'
    fin_cases iâ‚ <;> fin_cases iâ‚‚ <;> fin_cases iâ‚ƒ
      <;> simp (config := {decide := true}) at hâ‚â‚‚ hâ‚â‚ƒ hâ‚‚â‚ƒ âŠ¢
  have hp : p âˆˆ affineSpan R (Set.range t.points) := by
    have hle : line[R, t.points iâ‚, pâ‚] â‰¤ affineSpan R (Set.range t.points) := by
      refine' affineSpan_pair_le_of_mem_of_mem (mem_affineSpan R (Set.mem_range_self _)) _
      have hle : line[R, t.points iâ‚‚, t.points iâ‚ƒ] â‰¤ affineSpan R (Set.range t.points) := by
        refine' affineSpan_mono R _
        simp [Set.insert_subset_iff]
      rw [AffineSubspace.le_def'] at hle
      exact hle _ hâ‚.wbtw.mem_affineSpan
    rw [AffineSubspace.le_def'] at hle
    exact hle _ hâ‚'
  have hâ‚i := hâ‚.mem_image_Ioo
  have hâ‚‚i := hâ‚‚.mem_image_Ioo
  rw [Set.mem_image] at hâ‚i hâ‚‚i
  rcases hâ‚i with âŸ¨râ‚, âŸ¨hrâ‚0, hrâ‚1âŸ©, rflâŸ©
  rcases hâ‚‚i with âŸ¨râ‚‚, âŸ¨hrâ‚‚0, hrâ‚‚1âŸ©, rflâŸ©
  rcases eq_affineCombination_of_mem_affineSpan_of_fintype hp with âŸ¨w, hw, rflâŸ©
  have hâ‚s :=
    sign_eq_of_affineCombination_mem_affineSpan_single_lineMap t.Independent hw (Finset.mem_univ _)
      (Finset.mem_univ _) (Finset.mem_univ _) hâ‚â‚‚ hâ‚â‚ƒ hâ‚‚â‚ƒ hrâ‚0 hrâ‚1 hâ‚'
  have hâ‚‚s :=
    sign_eq_of_affineCombination_mem_affineSpan_single_lineMap t.Independent hw (Finset.mem_univ _)
      (Finset.mem_univ _) (Finset.mem_univ _) hâ‚â‚‚.symm hâ‚‚â‚ƒ hâ‚â‚ƒ hrâ‚‚0 hrâ‚‚1 hâ‚‚'
  rw [â† Finset.univ.affineCombination_affineCombinationSingleWeights R t.points
      (Finset.mem_univ iâ‚),
    â† Finset.univ.affineCombination_affineCombinationLineMapWeights t.points (Finset.mem_univ _)
      (Finset.mem_univ _)] at hâ‚' âŠ¢
  refine'
    Sbtw.affineCombination_of_mem_affineSpan_pair t.Independent hw
      (Finset.univ.sum_affineCombinationSingleWeights R (Finset.mem_univ _))
      (Finset.univ.sum_affineCombinationLineMapWeights (Finset.mem_univ _) (Finset.mem_univ _) _)
      hâ‚' (Finset.mem_univ iâ‚) _
  rw [Finset.affineCombinationSingleWeights_apply_self,
    Finset.affineCombinationLineMapWeights_apply_of_ne hâ‚â‚‚ hâ‚â‚ƒ, sbtw_one_zero_iff]
  have hs : âˆ€ i : Fin 3, SignType.sign (w i) = SignType.sign (w iâ‚ƒ) := by
    intro i
    rcases h3 i with (rfl | rfl | rfl)
    Â· exact hâ‚‚s
    Â· exact hâ‚s
    Â· rfl
  have hss : SignType.sign (âˆ‘ i, w i) = 1 := by simp [hw]
  have hs' := sign_sum Finset.univ_nonempty (SignType.sign (w iâ‚ƒ)) fun i _ => hs i
  rw [hs'] at hss
  simp_rw [hss, sign_eq_one_iff] at hs
  refine' âŸ¨hs iâ‚, _âŸ©
  rw [hu] at hw
  rw [Finset.sum_insert, Finset.sum_insert, Finset.sum_singleton] at hw
  Â· by_contra hle
    rw [not_lt] at hle
    exact (hle.trans_lt (lt_add_of_pos_right _ (Left.add_pos (hs iâ‚‚) (hs iâ‚ƒ)))).ne' hw
  Â· simpa using hâ‚‚â‚ƒ
  Â· simpa [not_or] using âŸ¨hâ‚â‚‚, hâ‚â‚ƒâŸ©","error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Affine.Triangle R P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Affine.Simplex R P 2
error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Affine.Triangle R P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Affine.Simplex R P 2
error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Affine.Triangle R P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Affine.Simplex R P 2","theorem sbtw_of_sbtw_of_sbtw_of_mem_affineSpan_pair [NoZeroSMulDivisors R V]
    {t : Affine.Triangle R P} {iâ‚ iâ‚‚ iâ‚ƒ : Fin 3} (hâ‚â‚‚ : iâ‚ â‰  iâ‚‚) {pâ‚ pâ‚‚ p : P}
    (hâ‚ : Sbtw R (t.points iâ‚‚) pâ‚ (t.points iâ‚ƒ)) (hâ‚‚ : Sbtw R (t.points iâ‚) pâ‚‚ (t.points iâ‚ƒ))
    (hâ‚' : p âˆˆ line[R, t.points iâ‚, pâ‚]) (hâ‚‚' : p âˆˆ line[R, t.points iâ‚‚, pâ‚‚]) :
    Sbtw R (t.points iâ‚) p pâ‚ ",":= by
  letI : DecidableRel ((Â· < Â·) : R â†’ R â†’ Prop) := LinearOrderedRing.decidableLT
  have hâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ := by
    rintro rfl
    simp at hâ‚‚
  have hâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ := by
    rintro rfl
    simp at hâ‚
  have h3 : âˆ€ i : Fin 3, i = iâ‚ âˆ¨ i = iâ‚‚ âˆ¨ i = iâ‚ƒ := by
    clear hâ‚ hâ‚‚ hâ‚' hâ‚‚'
    intro i
    fin_cases i <;> fin_cases iâ‚ <;> fin_cases iâ‚‚ <;> fin_cases iâ‚ƒ <;> simp at hâ‚â‚‚ hâ‚â‚ƒ hâ‚‚â‚ƒ âŠ¢
  have hu : (Finset.univ : Finset (Fin 3)) = {iâ‚, iâ‚‚, iâ‚ƒ} := by
    clear hâ‚ hâ‚‚ hâ‚' hâ‚‚'
    fin_cases iâ‚ <;> fin_cases iâ‚‚ <;> fin_cases iâ‚ƒ
      <;> simp (config := {decide := true}) at hâ‚â‚‚ hâ‚â‚ƒ hâ‚‚â‚ƒ âŠ¢
  have hp : p âˆˆ affineSpan R (Set.range t.points) := by
    have hle : line[R, t.points iâ‚, pâ‚] â‰¤ affineSpan R (Set.range t.points) := by
      refine affineSpan_pair_le_of_mem_of_mem (mem_affineSpan R (Set.mem_range_self _)) ?_
      have hle : line[R, t.points iâ‚‚, t.points iâ‚ƒ] â‰¤ affineSpan R (Set.range t.points) := by
        refine affineSpan_mono R ?_
        simp [Set.insert_subset_iff]
      rw [AffineSubspace.le_def'] at hle
      exact hle _ hâ‚.wbtw.mem_affineSpan
    rw [AffineSubspace.le_def'] at hle
    exact hle _ hâ‚'
  have hâ‚i := hâ‚.mem_image_Ioo
  have hâ‚‚i := hâ‚‚.mem_image_Ioo
  rw [Set.mem_image] at hâ‚i hâ‚‚i
  rcases hâ‚i with âŸ¨râ‚, âŸ¨hrâ‚0, hrâ‚1âŸ©, rflâŸ©
  rcases hâ‚‚i with âŸ¨râ‚‚, âŸ¨hrâ‚‚0, hrâ‚‚1âŸ©, rflâŸ©
  rcases eq_affineCombination_of_mem_affineSpan_of_fintype hp with âŸ¨w, hw, rflâŸ©
  have hâ‚s :=
    sign_eq_of_affineCombination_mem_affineSpan_single_lineMap t.independent hw (Finset.mem_univ _)
      (Finset.mem_univ _) (Finset.mem_univ _) hâ‚â‚‚ hâ‚â‚ƒ hâ‚‚â‚ƒ hrâ‚0 hrâ‚1 hâ‚'
  have hâ‚‚s :=
    sign_eq_of_affineCombination_mem_affineSpan_single_lineMap t.independent hw (Finset.mem_univ _)
      (Finset.mem_univ _) (Finset.mem_univ _) hâ‚â‚‚.symm hâ‚‚â‚ƒ hâ‚â‚ƒ hrâ‚‚0 hrâ‚‚1 hâ‚‚'
  rw [â† Finset.univ.affineCombination_affineCombinationSingleWeights R t.points
      (Finset.mem_univ iâ‚),
    â† Finset.univ.affineCombination_affineCombinationLineMapWeights t.points (Finset.mem_univ _)
      (Finset.mem_univ _)] at hâ‚' âŠ¢
  refine
    Sbtw.affineCombination_of_mem_affineSpan_pair t.independent hw
      (Finset.univ.sum_affineCombinationSingleWeights R (Finset.mem_univ _))
      (Finset.univ.sum_affineCombinationLineMapWeights (Finset.mem_univ _) (Finset.mem_univ _) _)
      hâ‚' (Finset.mem_univ iâ‚) ?_
  rw [Finset.affineCombinationSingleWeights_apply_self,
    Finset.affineCombinationLineMapWeights_apply_of_ne hâ‚â‚‚ hâ‚â‚ƒ, sbtw_one_zero_iff]
  have hs : âˆ€ i : Fin 3, SignType.sign (w i) = SignType.sign (w iâ‚ƒ) := by
    intro i
    rcases h3 i with (rfl | rfl | rfl)
    Â· exact hâ‚‚s
    Â· exact hâ‚s
    Â· rfl
  have hss : SignType.sign (âˆ‘ i, w i) = 1 := by simp [hw]
  have hs' := sign_sum Finset.univ_nonempty (SignType.sign (w iâ‚ƒ)) fun i _ => hs i
  rw [hs'] at hss
  simp_rw [hss, sign_eq_one_iff] at hs
  refine âŸ¨hs iâ‚, ?_âŸ©
  rw [hu] at hw
  rw [Finset.sum_insert, Finset.sum_insert, Finset.sum_singleton] at hw
  Â· by_contra hle
    rw [not_lt] at hle
    exact (hle.trans_lt (lt_add_of_pos_right _ (Left.add_pos (hs iâ‚‚) (hs iâ‚ƒ)))).ne' hw
  Â· simpa using hâ‚‚â‚ƒ
  Â· simpa [not_or] using âŸ¨hâ‚â‚‚, hâ‚â‚ƒâŸ©"
Mathlib/Combinatorics/SimpleGraph/Operations.lean,SimpleGraph.card_edgeFinset_replaceVertex_of_not_adj,card_edgeFinset_replaceVertex_of_not_adj,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have inc : G.incidenceFinset t âŠ† G.edgeFinset := by simp [incidenceFinset, incidenceSet_subset]
  rw [G.edgeFinset_replaceVertex_of_not_adj hn,
    card_union_of_disjoint G.disjoint_sdiff_neighborFinset_image, card_sdiff inc,
    tsub_add_eq_add_tsub <| card_le_card inc, card_incidenceFinset_eq_degree]
  congr 2
  rw [card_image_of_injective, card_neighborFinset_eq_degree]
  unfold Function.Injective
  aesop","error:  failed to synthesize
  ExistsAddOfLE â„•
use `set_option diagnostics true` to get diagnostic information
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.78487
V : Type u_1
instâœÂ² : DecidableEq V
G : SimpleGraph V
s t : V
instâœÂ¹ : Fintype V
instâœ : DecidableRel G.Adj
hn : Â¬G.Adj s t
inc : G.incidenceFinset t âŠ† G.edgeFinset
âŠ¢ G.edgeFinset.card - (G.incidenceFinset t).card + (image (fun x â†¦ s(x, t)) (G.neighborFinset s)).card =
    G.edgeFinset.card + G.degree s - G.degree t","theorem card_edgeFinset_replaceVertex_of_not_adj (hn : Â¬G.Adj s t) :
    (G.replaceVertex s t).edgeFinset.card = G.edgeFinset.card + G.degree s - G.degree t ",":= by
  have inc : G.incidenceFinset t âŠ† G.edgeFinset := by simp [incidenceFinset, incidenceSet_subset]
  rw [G.edgeFinset_replaceVertex_of_not_adj hn,
    card_union_of_disjoint G.disjoint_sdiff_neighborFinset_image, card_sdiff inc,
    â† Nat.sub_add_comm <| card_le_card inc, card_incidenceFinset_eq_degree]
  congr 2
  rw [card_image_of_injective, card_neighborFinset_eq_degree]
  unfold Function.Injective
  aesop"
Mathlib/CategoryTheory/Sites/IsSheafFor.lean,CategoryTheory.Presieve.extension_iff_amalgamation,extension_iff_amalgamation,4ffd02f9c9941b47354d51806a4eab27e5c27b03,":= by
  change _ â†” âˆ€ â¦ƒY : Câ¦„ (f : Y âŸ¶ X) (h : S f), P.map f.op (yonedaEquiv g) = x.app (op Y) âŸ¨f, hâŸ©
  constructor
  Â· rintro rfl Y f hf
    rw [yonedaEquiv_naturality]
    dsimp
    simp
  Â· intro h
    ext Y âŸ¨f, hfâŸ©
    convert h f hf
    rw [yonedaEquiv_naturality]
    simp [yonedaEquiv]",error:  simp made no progress,"theorem extension_iff_amalgamation {P : Cáµ’áµ– â¥¤ Type vâ‚} (x : S.functor âŸ¶ P) (g : yoneda.obj X âŸ¶ P) :
    S.functorInclusion â‰« g = x â†”
      (natTransEquivCompatibleFamily x).1.IsAmalgamation (yonedaEquiv g) ",":= by
  change _ â†” âˆ€ â¦ƒY : Câ¦„ (f : Y âŸ¶ X) (h : S f), P.map f.op (yonedaEquiv g) = x.app (op Y) âŸ¨f, hâŸ©
  constructor
  Â· rintro rfl Y f hf
    rw [yonedaEquiv_naturality]
    dsimp
    simp [yonedaEquiv_apply]
  Â· intro h
    ext Y âŸ¨f, hfâŸ©
    convert h f hf
    rw [yonedaEquiv_naturality]
    dsimp [yonedaEquiv]
    simp"
Mathlib/Data/Nat/Bits.lean,Nat.div2_succ,div2_succ,e22ab90242ae5cde6c534b464851a092255da039,":= by
  apply Nat.eq_of_mul_eq_mul_left (by decide : 0 < 2)
  apply Nat.add_right_cancel (m := cond (bodd (succ n)) 1 0)
  rw (config := {occs := .pos [1]}) [div2_add_bodd, bodd_succ, â† div2_add_bodd n]
  cases bodd n <;> simp [succ_eq_add_one, Nat.add_comm 1, Nat.mul_add]","error:  unknown identifier 'div2_add_bodd'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.3992
m nâœ n : â„•
âŠ¢ (2 * n.succ.div2 + bif n.succ.bodd then 1 else 0) =
    (2 * bif n.bodd then n.div2.succ else n.div2) + bif n.succ.bodd then 1 else 0
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated",lemma div2_succ (n : â„•) : div2 (succ n) = cond (bodd n) (succ (div2 n)) (div2 n) ,":= by
  simp only [bodd, boddDiv2, div2]
  rcases boddDiv2 n with âŸ¨_|_, _âŸ© <;> simp"
Mathlib/Data/List/Perm.lean,List.nodup_permutations'Aux_iff,nodup_permutations'Aux_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine' âŸ¨fun h => _, nodup_permutations'Aux_of_not_mem _ _âŸ©
  intro H
  obtain âŸ¨k, hk, hk'âŸ© := nthLe_of_mem H
  rw [nodup_iff_nthLe_inj] at h
  refine k.succ_ne_self.symm $ h k (k + 1) ?_ ?_ ?_
  Â· simpa [Nat.lt_succ_iff] using hk.le
  Â· simpa using hk
  rw [nthLe_permutations'Aux, nthLe_permutations'Aux]
  have hl : length (insertNth k x s) = length (insertNth (k + 1) x s) := by
    rw [length_insertNth _ _ hk.le, length_insertNth _ _ (Nat.succ_le_of_lt hk)]
  refine' ext_nthLe hl fun n hn hn' => _
  rcases lt_trichotomy n k with (H | rfl | H)
  Â· rw [nthLe_insertNth_of_lt _ _ _ _ H (H.trans hk),
      nthLe_insertNth_of_lt _ _ _ _ (H.trans (Nat.lt_succ_self _))]
  Â· rw [nthLe_insertNth_self _ _ _ hk.le, nthLe_insertNth_of_lt _ _ _ _ (Nat.lt_succ_self _) hk,
      hk']
  Â· rcases (Nat.succ_le_of_lt H).eq_or_lt with (rfl | H')
    Â· rw [nthLe_insertNth_self _ _ _ (Nat.succ_le_of_lt hk)]
      convert hk' using 1
      exact nthLe_insertNth_add_succ _ _ _ 0 _
    Â· obtain âŸ¨m, rflâŸ© := Nat.exists_eq_add_of_lt H'
      erw [length_insertNth _ _ hk.le, Nat.succ_lt_succ_iff, Nat.succ_add] at hn
      rw [nthLe_insertNth_add_succ]
      Â· convert nthLe_insertNth_add_succ s x k m.succ (by simpa using hn) using 2
        Â· simp [Nat.add_succ, Nat.succ_add]
        Â· simp [Nat.add_left_comm, Nat.add_comm]
      Â· simpa [Nat.succ_add] using hn","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nthLe_permutations'Aux` has been deprecated, use `List.get_permutations'Aux` instead
warning:  `List.nthLe_permutations'Aux` has been deprecated, use `List.get_permutations'Aux` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_insertNth_of_lt` has been deprecated, use `List.get_insertNth_of_lt` instead
warning:  `List.nthLe_insertNth_of_lt` has been deprecated, use `List.get_insertNth_of_lt` instead
warning:  `List.nthLe_insertNth_self` has been deprecated, use `List.get_insertNth_self` instead
warning:  `List.nthLe_insertNth_of_lt` has been deprecated, use `List.get_insertNth_of_lt` instead
warning:  `List.nthLe_insertNth_self` has been deprecated, use `List.get_insertNth_self` instead
warning:  `List.nthLe_insertNth_add_succ` has been deprecated, use `List.get_insertNth_add_succ` instead
warning:  `List.nthLe_insertNth_add_succ` has been deprecated, use `List.get_insertNth_add_succ` instead
warning:  `List.nthLe_insertNth_add_succ` has been deprecated, use `List.get_insertNth_add_succ` instead
error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
warning:  `List.nthLe_permutations'Aux` has been deprecated, use `List.get_permutations'Aux` instead
warning:  `List.nthLe_permutations'Aux` has been deprecated, use `List.get_permutations'Aux` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_insertNth_of_lt` has been deprecated, use `List.get_insertNth_of_lt` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe_insertNth_of_lt` has been deprecated, use `List.get_insertNth_of_lt` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead",theorem nodup_permutations'Aux_iff {s : List Î±} {x : Î±} : Nodup (permutations'Aux x s) â†” x âˆ‰ s ,":= by
  refine âŸ¨fun h => ?_, nodup_permutations'Aux_of_not_mem _ _âŸ©
  intro H
  obtain âŸ¨k, hk, hk'âŸ© := nthLe_of_mem H
  rw [nodup_iff_nthLe_inj] at h
  refine k.succ_ne_self.symm $ h k (k + 1) ?_ ?_ ?_
  Â· simpa [Nat.lt_succ_iff] using hk.le
  Â· simpa using hk
  rw [nthLe_permutations'Aux, nthLe_permutations'Aux]
  have hl : length (insertNth k x s) = length (insertNth (k + 1) x s) := by
    rw [length_insertNth _ _ hk.le, length_insertNth _ _ (Nat.succ_le_of_lt hk)]
  refine ext_nthLe hl fun n hn hn' => ?_
  rcases lt_trichotomy n k with (H | rfl | H)
  Â· rw [nthLe_insertNth_of_lt _ _ _ _ H (H.trans hk),
      nthLe_insertNth_of_lt _ _ _ _ (H.trans (Nat.lt_succ_self _))]
  Â· rw [nthLe_insertNth_self _ _ _ hk.le, nthLe_insertNth_of_lt _ _ _ _ (Nat.lt_succ_self _) hk,
      hk']
  Â· rcases (Nat.succ_le_of_lt H).eq_or_lt with (rfl | H')
    Â· rw [nthLe_insertNth_self _ _ _ (Nat.succ_le_of_lt hk)]
      convert hk' using 1
      exact nthLe_insertNth_add_succ _ _ _ 0 _
    Â· obtain âŸ¨m, rflâŸ© := Nat.exists_eq_add_of_lt H'
      erw [length_insertNth _ _ hk.le, Nat.succ_lt_succ_iff, Nat.succ_add] at hn
      rw [nthLe_insertNth_add_succ]
      Â· convert nthLe_insertNth_add_succ s x k m.succ (by simpa using hn) using 2
        Â· simp [Nat.add_assoc, Nat.add_left_comm]
        Â· simp [Nat.add_left_comm, Nat.add_comm]
      Â· simpa [Nat.succ_add] using hn"
Mathlib/CategoryTheory/FiberedCategory/HomLift.lean,CategoryTheory.IsHomLift.eqToHom_codomain_lift_id,eqToHom_codomain_lift_id,95e75fcfd1c014add03de9b53a54ac3c1396bb20,  fac := by simp [eqToHom_map],"error:  function expected at
  p.IsHomLift (ğŸ™ S) (eqToHom hab)
term has type
  Prop
error:  simp made no progress","lemma eqToHom_codomain_lift_id {p : ğ’³ â¥¤ ğ’®} {a b : ğ’³} (hab : a = b) {S : ğ’®} (hS : p.obj b = S) :
    p.IsHomLift (ğŸ™ S) (eqToHom hab) ",":= by
  subst hS hab; simp"
Mathlib/RingTheory/IntegralClosure.lean,isField_of_isIntegral_of_isField,isField_of_isIntegral_of_isField,7f9dc9f143dee6aa91b24a87f65fcdd01b71fe57,"  exists_pair_ne := âŸ¨0, 1, zero_ne_oneâŸ©
  mul_comm := mul_comm
  mul_inv_cancel {x} hx := by
    letI := hR.toField
    obtain âŸ¨y, rflâŸ© := (H x).isUnit hx
    exact âŸ¨y.inv, y.val_invâŸ©","error:  function expected at
  IsField R
term has type
  Prop
error:  invalid constructor âŸ¨...âŸ©, expected type must be known
error:  unexpected token ':='; expected command
error:  unknown identifier 'isField_of_isIntegral_of_isField'","theorem isField_of_isIntegral_of_isField {R S : Type*} [CommRing R] [CommRing S]
    [Algebra R S] [Algebra.IsIntegral R S]
    (hRS : Function.Injective (algebraMap R S)) (hS : IsField S) : IsField R ",":= by
  have := hS.nontrivial; have := Module.nontrivial R S
  refine âŸ¨âŸ¨0, 1, zero_ne_oneâŸ©, mul_comm, fun {a} ha â†¦ ?_âŸ©
  obtain âŸ¨a_inv, ha_invâŸ© := hS.mul_inv_cancel fun h â†¦ ha (hRS (h.trans (RingHom.map_zero _).symm))
  letI : Invertible a_inv := (Units.mkOfMulEqOne a_inv _ <| mul_comm _ a_inv â–¸ ha_inv).invertible
  obtain âŸ¨p, p_monic, hpâŸ© := Algebra.IsIntegral.isIntegral (R := R) a_inv
  use -p.reverse.divX.eval a 
  nth_rewrite 1 [mul_neg, â† eval_X (x := a), â† eval_mul, â† p_monic, â† coeff_zero_reverse,
    â† add_eq_zero_iff_neg_eq, â† eval_C (a := p.reverse.coeff 0), â† eval_add, X_mul_divX_add,
    â† (injective_iff_map_eq_zero' _).mp hRS, â† aeval_algebraMap_apply_eq_algebraMap_eval]
  rwa [â† evalâ‚‚_reverse_eq_zero_iff] at hp"
Mathlib/Geometry/Manifold/ContMDiff/Basic.lean,ContMDiff.extend_one,ContMDiff.extend_one,b502dbb455f708f5af5e6017e88f53565165ab0a,":= fun x â†¦ by
  refine contMDiff_of_mulTSupport (fun x h â†¦ ?_) _
  lift x to U using Subtype.coe_image_subset _ _
    (supp.mulTSupport_extend_one_subset continuous_subtype_val h)
  rw [â† contMdiffAt_subtype_iff, â† comp_def, extend_comp Subtype.val_injective]
  exact diff.contMDiffAt","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  extend Subtype.val ?g ?e' âˆ˜ Subtype.val
case intro
ğ•œ : Type u_1
instâœÂ¹â¹ : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ¹â¸ : NormedAddCommGroup E
instâœÂ¹â· : NormedSpace ğ•œ E
H : Type u_3
instâœÂ¹â¶ : TopologicalSpace H
I : ModelWithCorners ğ•œ E H
M : Type u_4
instâœÂ¹âµ : TopologicalSpace M
instâœÂ¹â´ : ChartedSpace H M
instâœÂ¹Â³ : SmoothManifoldWithCorners I M
E' : Type u_5
instâœÂ¹Â² : NormedAddCommGroup E'
instâœÂ¹Â¹ : NormedSpace ğ•œ E'
H' : Type u_6
instâœÂ¹â° : TopologicalSpace H'
I' : ModelWithCorners ğ•œ E' H'
M' : Type u_7
instâœâ¹ : TopologicalSpace M'
instâœâ¸ : ChartedSpace H' M'
instâœâ· : SmoothManifoldWithCorners I' M'
E'' : Type u_8
instâœâ¶ : NormedAddCommGroup E''
instâœâµ : NormedSpace ğ•œ E''
H'' : Type u_9
instâœâ´ : TopologicalSpace H''
I'' : ModelWithCorners ğ•œ E'' H''
M'' : Type u_10
instâœÂ³ : TopologicalSpace M''
instâœÂ² : ChartedSpace H'' M''
e : PartialHomeomorph M H
e' : PartialHomeomorph M' H'
fâœ fâ‚ : M â†’ M'
s sâ‚ t : Set M
xâœÂ¹ : M
m nâœ : â„•âˆ
instâœÂ¹ : T2Space M
instâœ : One M'
n : â„•âˆ
U : Opens M
f : â†¥U â†’ M'
supp : HasCompactMulSupport f
diff : ContMDiff I I' n f
xâœ : M
x : â†¥U
h : â†‘x âˆˆ mulTSupport (extend Subtype.val f 1)
âŠ¢ ContMDiffAt I I' n (extend Subtype.val f 1 âˆ˜ Subtype.val) x","theorem ContMDiff.extend_one [T2Space M] [One M'] {n : â„•âˆ} {U : Opens M} {f : U â†’ M'}
    (supp : HasCompactMulSupport f) (diff : ContMDiff I I' n f) :
    ContMDiff I I' n (Subtype.val.extend f 1) ",":= fun x â†¦ by
  refine contMDiff_of_mulTSupport (fun x h â†¦ ?_) _
  lift x to U using Subtype.coe_image_subset _ _
    (supp.mulTSupport_extend_one_subset continuous_subtype_val h)
  rw [â† contMdiffAt_subtype_iff, â† comp_def]
  erw [ extend_comp Subtype.val_injective]
  exact diff.contMDiffAt"
Mathlib/Order/Filter/Lift.lean,Filter.HasBasis.mem_lift_iff,HasBasis.mem_lift_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine' (mem_biInf_of_directed _ âŸ¨univ, univ_sets _âŸ©).trans _
  Â· intro tâ‚ htâ‚ tâ‚‚ htâ‚‚
    exact âŸ¨tâ‚ âˆ© tâ‚‚, inter_mem htâ‚ htâ‚‚, gm <| inter_subset_left _ _, gm <| inter_subset_right _ _âŸ©
  Â· simp only [â† (hg _).mem_iff]
    exact hf.exists_iff fun tâ‚ tâ‚‚ ht H => gm ht H","error:  function expected at
  inter_subset_left ?m.2034
term has type
  ?m.2033 âˆˆ ?m.2031
error:  function expected at
  inter_subset_right ?m.2080
term has type
  ?m.2079 âˆˆ ?m.2078","theorem HasBasis.mem_lift_iff {Î¹} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {f : Filter Î±}
    (hf : f.HasBasis p s) {Î² : Î¹ â†’ Type*} {pg : âˆ€ i, Î² i â†’ Prop} {sg : âˆ€ i, Î² i â†’ Set Î³}
    {g : Set Î± â†’ Filter Î³} (hg : âˆ€ i, (g <| s i).HasBasis (pg i) (sg i)) (gm : Monotone g)
    {s : Set Î³} : s âˆˆ f.lift g â†” âˆƒ i, p i âˆ§ âˆƒ x, pg i x âˆ§ sg i x âŠ† s ",":= by
  refine (mem_biInf_of_directed ?_ âŸ¨univ, univ_sets _âŸ©).trans ?_
  Â· intro tâ‚ htâ‚ tâ‚‚ htâ‚‚
    exact âŸ¨tâ‚ âˆ© tâ‚‚, inter_mem htâ‚ htâ‚‚, gm inter_subset_left, gm inter_subset_rightâŸ©
  Â· simp only [â† (hg _).mem_iff]
    exact hf.exists_iff fun tâ‚ tâ‚‚ ht H => gm ht H"
Mathlib/Analysis/Convex/Measure.lean,Convex.addHaar_frontier,addHaar_frontier,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  cases' ne_or_eq (affineSpan â„ s) âŠ¤ with hspan hspan
  Â· refine' measure_mono_null _ (addHaar_affineSubspace _ _ hspan)
    exact frontier_subset_closure.trans
      (closure_minimal (subset_affineSpan _ _) (affineSpan â„ s).closed_of_finiteDimensional)
  rw [â† hs.interior_nonempty_iff_affineSpan_eq_top] at hspan
  rcases hspan with âŸ¨x, hxâŸ©
  suffices H : âˆ€ t : Set E, Convex â„ t â†’ x âˆˆ interior t â†’ IsBounded t â†’ Î¼ (frontier t) = 0 by
    let B : â„• â†’ Set E := fun n => ball x (n + 1)
    have : Î¼ (â‹ƒ n : â„•, frontier (s âˆ© B n)) = 0 := by
      refine' measure_iUnion_null fun n =>
        H _ (hs.inter (convex_ball _ _)) _ (isBounded_ball.subset (inter_subset_right _ _))
      rw [interior_inter, isOpen_ball.interior_eq]
      exact âŸ¨hx, mem_ball_self (add_pos_of_nonneg_of_pos n.cast_nonneg zero_lt_one)âŸ©
    refine measure_mono_null (fun y hy => ?_) this; clear this
    set N : â„• := âŒŠdist y xâŒ‹â‚Š
    refine' mem_iUnion.2 âŸ¨N, _âŸ©
    have hN : y âˆˆ B N := by simp [B, N, Nat.lt_floor_add_one]
    suffices y âˆˆ frontier (s âˆ© B N) âˆ© B N from this.1
    rw [frontier_inter_open_inter isOpen_ball]
    exact âŸ¨hy, hNâŸ©
  intro s hs hx hb
  replace hb : Î¼ (interior s) â‰  âˆ := (hb.subset interior_subset).measure_lt_top.ne
  suffices Î¼ (closure s) â‰¤ Î¼ (interior s) by
    rwa [frontier, measure_diff interior_subset_closure isOpen_interior.measurableSet hb,
      tsub_eq_zero_iff_le]
  set d : â„• := FiniteDimensional.finrank â„ E
  have : âˆ€ r : â„â‰¥0, 1 < r â†’ Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) := fun r hr â†¦ by
    refine (measure_mono <|
      hs.closure_subset_image_homothety_interior_of_one_lt hx r hr).trans_eq ?_
    rw [addHaar_image_homothety, â† NNReal.coe_pow, NNReal.abs_eq, ENNReal.ofReal_coe_nnreal]
  have : âˆ€á¶  (r : â„â‰¥0) in ğ“[>] 1, Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) :=
    mem_of_superset self_mem_nhdsWithin this
  refine ge_of_tendsto ?_ this
  refine' (((ENNReal.continuous_mul_const hb).comp
    (ENNReal.continuous_coe.comp (continuous_pow d))).tendsto' _ _ _).mono_left nhdsWithin_le_nhds
  simp","error:  function expected at
  inter_subset_right ?m.13269
term has type
  ?m.13268 âˆˆ ?m.13267
error:  unsolved goals
case refine'_2
E : Type u_1
instâœâµ : NormedAddCommGroup E
instâœâ´ : NormedSpace â„ E
instâœÂ³ : MeasurableSpace E
instâœÂ² : BorelSpace E
instâœÂ¹ : FiniteDimensional â„ E
Î¼ : Measure E
instâœ : Î¼.IsAddHaarMeasure
s : Set E
hs : Convex â„ s
x : E
hx : x âˆˆ interior s
H : âˆ€ (t : Set E), Convex â„ t â†’ x âˆˆ interior t â†’ Bornology.IsBounded t â†’ Î¼ (frontier t) = 0
B : â„• â†’ Set E := fun n â†¦ ball x (â†‘n + 1)
âŠ¢ â„• â†’ E

case refine'_3
E : Type u_1
instâœâµ : NormedAddCommGroup E
instâœâ´ : NormedSpace â„ E
instâœÂ³ : MeasurableSpace E
instâœÂ² : BorelSpace E
instâœÂ¹ : FiniteDimensional â„ E
Î¼ : Measure E
instâœ : Î¼.IsAddHaarMeasure
s : Set E
hs : Convex â„ s
x : E
hx : x âˆˆ interior s
H : âˆ€ (t : Set E), Convex â„ t â†’ x âˆˆ interior t â†’ Bornology.IsBounded t â†’ Î¼ (frontier t) = 0
B : â„• â†’ Set E := fun n â†¦ ball x (â†‘n + 1)
âŠ¢ â„• â†’ â„",theorem addHaar_frontier (hs : Convex â„ s) : Î¼ (frontier s) = 0 ,":= by
  cases' ne_or_eq (affineSpan â„ s) âŠ¤ with hspan hspan
  Â· refine measure_mono_null ?_ (addHaar_affineSubspace _ _ hspan)
    exact frontier_subset_closure.trans
      (closure_minimal (subset_affineSpan _ _) (affineSpan â„ s).closed_of_finiteDimensional)
  rw [â† hs.interior_nonempty_iff_affineSpan_eq_top] at hspan
  rcases hspan with âŸ¨x, hxâŸ©
  suffices H : âˆ€ t : Set E, Convex â„ t â†’ x âˆˆ interior t â†’ IsBounded t â†’ Î¼ (frontier t) = 0 by
    let B : â„• â†’ Set E := fun n => ball x (n + 1)
    have : Î¼ (â‹ƒ n : â„•, frontier (s âˆ© B n)) = 0 := by
      refine measure_iUnion_null fun n =>
        H _ (hs.inter (convex_ball _ _)) ?_ (isBounded_ball.subset inter_subset_right)
      rw [interior_inter, isOpen_ball.interior_eq]
      exact âŸ¨hx, mem_ball_self (add_pos_of_nonneg_of_pos n.cast_nonneg zero_lt_one)âŸ©
    refine measure_mono_null (fun y hy => ?_) this; clear this
    set N : â„• := âŒŠdist y xâŒ‹â‚Š
    refine mem_iUnion.2 âŸ¨N, ?_âŸ©
    have hN : y âˆˆ B N := by simp [B, N, Nat.lt_floor_add_one]
    suffices y âˆˆ frontier (s âˆ© B N) âˆ© B N from this.1
    rw [frontier_inter_open_inter isOpen_ball]
    exact âŸ¨hy, hNâŸ©
  intro s hs hx hb
  replace hb : Î¼ (interior s) â‰  âˆ := (hb.subset interior_subset).measure_lt_top.ne
  suffices Î¼ (closure s) â‰¤ Î¼ (interior s) by
    rwa [frontier, measure_diff interior_subset_closure isOpen_interior.measurableSet hb,
      tsub_eq_zero_iff_le]
  set d : â„• := FiniteDimensional.finrank â„ E
  have : âˆ€ r : â„â‰¥0, 1 < r â†’ Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) := fun r hr â†¦ by
    refine (measure_mono <|
      hs.closure_subset_image_homothety_interior_of_one_lt hx r hr).trans_eq ?_
    rw [addHaar_image_homothety, â† NNReal.coe_pow, NNReal.abs_eq, ENNReal.ofReal_coe_nnreal]
  have : âˆ€á¶  (r : â„â‰¥0) in ğ“[>] 1, Î¼ (closure s) â‰¤ â†‘(r ^ d) * Î¼ (interior s) :=
    mem_of_superset self_mem_nhdsWithin this
  refine ge_of_tendsto ?_ this
  refine (((ENNReal.continuous_mul_const hb).comp
    (ENNReal.continuous_coe.comp (continuous_pow d))).tendsto' _ _ ?_).mono_left nhdsWithin_le_nhds
  simp"
Mathlib/NumberTheory/Pell.lean,Pell.IsFundamental.eq_pow_of_nonneg,eq_pow_of_nonneg,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  lift a.x to â„• using hax.le with ax hax'
  clear hax
  induction' ax using Nat.strong_induction_on with x ih generalizing a
  rcases hay.eq_or_lt with hy | hy
  Â· 
    refine' âŸ¨0, _âŸ©
    simp only [pow_zero]
    ext <;> simp only [x_one, y_one]
    Â· have prop := a.prop
      rw [â† hy, sq (0 : â„¤), zero_mul, mul_zero, sub_zero,
        sq_eq_one_iff] at prop
      refine' prop.resolve_right fun hf => _
      have := (hax.trans_eq hax').le.trans_eq hf
      norm_num at this
    Â· exact hy.symm
  Â· 
    have hxâ‚ : 1 < a.x := by nlinarith [a.prop, h.d_pos]
    have hxxâ‚ := h.mul_inv_x_pos hxâ‚ hy
    have hxxâ‚‚ := h.mul_inv_x_lt_x hxâ‚ hy
    have hyy := h.mul_inv_y_nonneg hxâ‚ hy
    lift (a * aâ‚â»Â¹).x to â„• using hxxâ‚.le with x' hx'
    obtain âŸ¨n, hnâŸ© := ih x' (mod_cast hxxâ‚‚.trans_eq hax'.symm) hyy hx' hxxâ‚
    exact âŸ¨n + 1, by rw [pow_succ, â† hn, mul_comm a, â† mul_assoc, mul_inv_self, one_mul]âŸ©","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * (?b * ?c)
d : â„¤
aâ‚ : Solutionâ‚ d
h : IsFundamental aâ‚
x : â„•
ih : âˆ€ m < x, âˆ€ {a : Solutionâ‚ d}, 0 â‰¤ a.y â†’ â†‘m = a.x â†’ 0 < â†‘m â†’ âˆƒ n, a = aâ‚ ^ n
a : Solutionâ‚ d
hay : 0 â‰¤ a.y
hax' : â†‘x = a.x
hax : 0 < â†‘x
hy : 0 < a.y
hxâ‚ : 1 < a.x
hyy : 0 â‰¤ (a * aâ‚â»Â¹).y
x' : â„•
hx' : â†‘x' = (a * aâ‚â»Â¹).x
hxxâ‚âœ hxxâ‚ : 0 < â†‘x'
hxxâ‚‚âœ hxxâ‚‚ : â†‘x' < a.x
n : â„•
hn : a * aâ‚â»Â¹ = aâ‚ ^ n
âŠ¢ a = aâ‚â»Â¹ * a * aâ‚","theorem eq_pow_of_nonneg {aâ‚ : Solutionâ‚ d} (h : IsFundamental aâ‚) {a : Solutionâ‚ d} (hax : 0 < a.x)
    (hay : 0 â‰¤ a.y) : âˆƒ n : â„•, a = aâ‚ ^ n ",":= by
  lift a.x to â„• using hax.le with ax hax'
  clear hax
  induction' ax using Nat.strong_induction_on with x ih generalizing a
  rcases hay.eq_or_lt with hy | hy
  Â· 
    refine âŸ¨0, ?_âŸ©
    simp only [pow_zero]
    ext <;> simp only [x_one, y_one]
    Â· have prop := a.prop
      rw [â† hy, sq (0 : â„¤), zero_mul, mul_zero, sub_zero,
        sq_eq_one_iff] at prop
      refine prop.resolve_right fun hf => ?_
      have := (hax.trans_eq hax').le.trans_eq hf
      norm_num at this
    Â· exact hy.symm
  Â· 
    have hxâ‚ : 1 < a.x := by nlinarith [a.prop, h.d_pos]
    have hxxâ‚ := h.mul_inv_x_pos hxâ‚ hy
    have hxxâ‚‚ := h.mul_inv_x_lt_x hxâ‚ hy
    have hyy := h.mul_inv_y_nonneg hxâ‚ hy
    lift (a * aâ‚â»Â¹).x to â„• using hxxâ‚.le with x' hx'
    obtain âŸ¨n, hnâŸ© := ih x' (mod_cast hxxâ‚‚.trans_eq hax'.symm) hyy hx' hxxâ‚
    exact âŸ¨n + 1, by rw [pow_succ', â† hn, mul_comm a, â† mul_assoc, mul_inv_self, one_mul]âŸ©"
Mathlib/Data/Set/Finite.lean,Set.Finite.biUnion,Finite.biUnion,b764e03d48c53e3f744636472c9d205d33ffdb4c,":= by
  classical
    cases hs
    haveI := fintypeBiUnion s t fun i hi => (ht i hi).fintype
    apply toFinite","error:  application type mismatch
  s.fintypeBiUnion t
argument
  t
has type
  (i : Î¹) â†’ i âˆˆ s â†’ Set Î± : Type (max u u_1)
but is expected to have type
  Î¹ â†’ Set ?m.86087 : Type (max u_1 ?u.86086)
error:  failed to synthesize
  Fintype â†‘s
use `set_option diagnostics true` to get diagnostic information","theorem Finite.biUnion' {Î¹} {s : Set Î¹} (hs : s.Finite) {t : âˆ€ i âˆˆ s, Set Î±}
    (ht : âˆ€ i (hi : i âˆˆ s), (t i hi).Finite) : (â‹ƒ i âˆˆ s, t i â€¹_â€º).Finite ",":= by
  have := hs.to_subtype
  rw [biUnion_eq_iUnion]
  apply finite_iUnion fun i : s => ht i.1 i.2"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.OuterMeasure.IsMetric.borel_le_caratheodory,borel_le_caratheodory,2e39f97941029a908858d0472e3091e677aa35e4,":= by
  rw [borel_eq_generateFrom_isClosed]
  refine MeasurableSpace.generateFrom_le fun t ht => Î¼.isCaratheodory_iff_le.2 fun s => ?_
  set S : â„• â†’ Set X := fun n => {x âˆˆ s | (â†‘n)â»Â¹ â‰¤ infEdist x t}
  have Ssep (n) : IsMetricSeparated (S n) t :=
    âŸ¨nâ»Â¹, ENNReal.inv_ne_zero.2 (ENNReal.natCast_ne_top _),
      fun x hx y hy â†¦ hx.2.trans <| infEdist_le_edist_of_mem hyâŸ©
  have Ssep' : âˆ€ n, IsMetricSeparated (S n) (s âˆ© t) := fun n =>
    (Ssep n).mono Subset.rfl (inter_subset_right _ _)
  have S_sub : âˆ€ n, S n âŠ† s \ t := fun n =>
    subset_inter (inter_subset_left _ _) (Ssep n).subset_compl_right
  have hSs : âˆ€ n, Î¼ (s âˆ© t) + Î¼ (S n) â‰¤ Î¼ s := fun n =>
    calc
      Î¼ (s âˆ© t) + Î¼ (S n) = Î¼ (s âˆ© t âˆª S n) := Eq.symm <| hm _ _ <| (Ssep' n).symm
      _ â‰¤ Î¼ (s âˆ© t âˆª s \ t) := Î¼.mono <| union_subset_union_right _ <| S_sub n
      _ = Î¼ s := by rw [inter_union_diff]
  have iUnion_S : â‹ƒ n, S n = s \ t := by
    refine Subset.antisymm (iUnion_subset S_sub) ?_
    rintro x âŸ¨hxs, hxtâŸ©
    rw [mem_iff_infEdist_zero_of_closed ht] at hxt
    rcases ENNReal.exists_inv_nat_lt hxt with âŸ¨n, hnâŸ©
    exact mem_iUnion.2 âŸ¨n, hxs, hn.leâŸ©
  by_cases htop : Î¼ (s \ t) = âˆ
  Â· rw [htop, add_top, â† htop]
    exact Î¼.mono (diff_subset _ _)
  suffices Î¼ (â‹ƒ n, S n) â‰¤ â¨† n, Î¼ (S n) by calc
    Î¼ (s âˆ© t) + Î¼ (s \ t) = Î¼ (s âˆ© t) + Î¼ (â‹ƒ n, S n) := by rw [iUnion_S]
    _ â‰¤ Î¼ (s âˆ© t) + â¨† n, Î¼ (S n) := by gcongr
    _ = â¨† n, Î¼ (s âˆ© t) + Î¼ (S n) := ENNReal.add_iSup
    _ â‰¤ Î¼ s := iSup_le hSs
  have : âˆ€ n, S n âŠ† S (n + 1) := fun n x hx =>
    âŸ¨hx.1, le_trans (ENNReal.inv_le_inv.2 <| Nat.cast_le.2 n.le_succ) hx.2âŸ©
  classical 
  refine (Î¼.iUnion_nat_of_monotone_of_tsum_ne_top this ?_).le; clear this
  rw [â† tsum_even_add_odd ENNReal.summable ENNReal.summable, ENNReal.add_ne_top]
  suffices âˆ€ a, (âˆ‘' k : â„•, Î¼ (S (2 * k + 1 + a) \ S (2 * k + a))) â‰  âˆ from
    âŸ¨by simpa using this 0, by simpa using this 1âŸ©
  refine fun r => ne_top_of_le_ne_top htop ?_
  rw [â† iUnion_S, ENNReal.tsum_eq_iSup_nat, iSup_le_iff]
  intro n
  rw [â† hm.finset_iUnion_of_pairwise_separated]
  Â· exact Î¼.mono (iUnion_subset fun i => iUnion_subset fun _ x hx => mem_iUnion.2 âŸ¨_, hx.1âŸ©)
  suffices âˆ€ i j, i < j â†’ IsMetricSeparated (S (2 * i + 1 + r)) (s \ S (2 * j + r)) from
    fun i _ j _ hij => hij.lt_or_lt.elim
      (fun h => (this i j h).mono (inter_subset_left _ _) fun x hx => by exact âŸ¨hx.1.1, hx.2âŸ©)
      fun h => (this j i h).symm.mono (fun x hx => by exact âŸ¨hx.1.1, hx.2âŸ©) (inter_subset_left _ _)
  intro i j hj
  have A : ((â†‘(2 * j + r))â»Â¹ : â„â‰¥0âˆ) < (â†‘(2 * i + 1 + r))â»Â¹ := by
    rw [ENNReal.inv_lt_inv, Nat.cast_lt]; omega
  refine âŸ¨(â†‘(2 * i + 1 + r))â»Â¹ - (â†‘(2 * j + r))â»Â¹, by simpa [tsub_eq_zero_iff_le] using A,
    fun x hx y hy => ?_âŸ©
  have : infEdist y t < (â†‘(2 * j + r))â»Â¹ := not_le.1 fun hle => hy.2 âŸ¨hy.1, hleâŸ©
  rcases infEdist_lt_iff.mp this with âŸ¨z, hzt, hyzâŸ©
  have hxz : (â†‘(2 * i + 1 + r))â»Â¹ â‰¤ edist x z := le_infEdist.1 hx.2 _ hzt
  apply ENNReal.le_of_add_le_add_right hyz.ne_top
  refine le_trans ?_ (edist_triangle _ _ _)
  refine (add_le_add le_rfl hyz.le).trans (Eq.trans_le ?_ hxz)
  rw [tsub_add_cancel_of_le A.le]","error:  function expected at
  inter_subset_right ?m.7946
term has type
  ?m.7945 âˆˆ ?m.7944
error:  function expected at
  inter_subset_left ?m.8081
term has type
  ?m.8080 âˆˆ ?m.8078
error:  function expected at
  diff_subset ?m.10257
term has type
  ?m.10256 âˆˆ ?m.10254
error:  function expected at
  inter_subset_left ?m.24534
term has type
  ?m.24533 âˆˆ ?m.24531
error:  function expected at
  inter_subset_left ?m.24641
term has type
  ?m.24640 âˆˆ ?m.24638",theorem borel_le_caratheodory (hm : IsMetric Î¼) : borel X â‰¤ Î¼.caratheodory ,":= by
  rw [borel_eq_generateFrom_isClosed]
  refine MeasurableSpace.generateFrom_le fun t ht => Î¼.isCaratheodory_iff_le.2 fun s => ?_
  set S : â„• â†’ Set X := fun n => {x âˆˆ s | (â†‘n)â»Â¹ â‰¤ infEdist x t}
  have Ssep (n) : IsMetricSeparated (S n) t :=
    âŸ¨nâ»Â¹, ENNReal.inv_ne_zero.2 (ENNReal.natCast_ne_top _),
      fun x hx y hy â†¦ hx.2.trans <| infEdist_le_edist_of_mem hyâŸ©
  have Ssep' : âˆ€ n, IsMetricSeparated (S n) (s âˆ© t) := fun n =>
    (Ssep n).mono Subset.rfl inter_subset_right
  have S_sub : âˆ€ n, S n âŠ† s \ t := fun n =>
    subset_inter inter_subset_left (Ssep n).subset_compl_right
  have hSs : âˆ€ n, Î¼ (s âˆ© t) + Î¼ (S n) â‰¤ Î¼ s := fun n =>
    calc
      Î¼ (s âˆ© t) + Î¼ (S n) = Î¼ (s âˆ© t âˆª S n) := Eq.symm <| hm _ _ <| (Ssep' n).symm
      _ â‰¤ Î¼ (s âˆ© t âˆª s \ t) := Î¼.mono <| union_subset_union_right _ <| S_sub n
      _ = Î¼ s := by rw [inter_union_diff]
  have iUnion_S : â‹ƒ n, S n = s \ t := by
    refine Subset.antisymm (iUnion_subset S_sub) ?_
    rintro x âŸ¨hxs, hxtâŸ©
    rw [mem_iff_infEdist_zero_of_closed ht] at hxt
    rcases ENNReal.exists_inv_nat_lt hxt with âŸ¨n, hnâŸ©
    exact mem_iUnion.2 âŸ¨n, hxs, hn.leâŸ©
  by_cases htop : Î¼ (s \ t) = âˆ
  Â· rw [htop, add_top, â† htop]
    exact Î¼.mono diff_subset
  suffices Î¼ (â‹ƒ n, S n) â‰¤ â¨† n, Î¼ (S n) by calc
    Î¼ (s âˆ© t) + Î¼ (s \ t) = Î¼ (s âˆ© t) + Î¼ (â‹ƒ n, S n) := by rw [iUnion_S]
    _ â‰¤ Î¼ (s âˆ© t) + â¨† n, Î¼ (S n) := by gcongr
    _ = â¨† n, Î¼ (s âˆ© t) + Î¼ (S n) := ENNReal.add_iSup
    _ â‰¤ Î¼ s := iSup_le hSs
  have : âˆ€ n, S n âŠ† S (n + 1) := fun n x hx =>
    âŸ¨hx.1, le_trans (ENNReal.inv_le_inv.2 <| Nat.cast_le.2 n.le_succ) hx.2âŸ©
  classical 
  refine (Î¼.iUnion_nat_of_monotone_of_tsum_ne_top this ?_).le; clear this
  rw [â† tsum_even_add_odd ENNReal.summable ENNReal.summable, ENNReal.add_ne_top]
  suffices âˆ€ a, (âˆ‘' k : â„•, Î¼ (S (2 * k + 1 + a) \ S (2 * k + a))) â‰  âˆ from
    âŸ¨by simpa using this 0, by simpa using this 1âŸ©
  refine fun r => ne_top_of_le_ne_top htop ?_
  rw [â† iUnion_S, ENNReal.tsum_eq_iSup_nat, iSup_le_iff]
  intro n
  rw [â† hm.finset_iUnion_of_pairwise_separated]
  Â· exact Î¼.mono (iUnion_subset fun i => iUnion_subset fun _ x hx => mem_iUnion.2 âŸ¨_, hx.1âŸ©)
  suffices âˆ€ i j, i < j â†’ IsMetricSeparated (S (2 * i + 1 + r)) (s \ S (2 * j + r)) from
    fun i _ j _ hij => hij.lt_or_lt.elim
      (fun h => (this i j h).mono inter_subset_left fun x hx => by exact âŸ¨hx.1.1, hx.2âŸ©)
      fun h => (this j i h).symm.mono (fun x hx => by exact âŸ¨hx.1.1, hx.2âŸ©) inter_subset_left
  intro i j hj
  have A : ((â†‘(2 * j + r))â»Â¹ : â„â‰¥0âˆ) < (â†‘(2 * i + 1 + r))â»Â¹ := by
    rw [ENNReal.inv_lt_inv, Nat.cast_lt]; omega
  refine âŸ¨(â†‘(2 * i + 1 + r))â»Â¹ - (â†‘(2 * j + r))â»Â¹, by simpa [tsub_eq_zero_iff_le] using A,
    fun x hx y hy => ?_âŸ©
  have : infEdist y t < (â†‘(2 * j + r))â»Â¹ := not_le.1 fun hle => hy.2 âŸ¨hy.1, hleâŸ©
  rcases infEdist_lt_iff.mp this with âŸ¨z, hzt, hyzâŸ©
  have hxz : (â†‘(2 * i + 1 + r))â»Â¹ â‰¤ edist x z := le_infEdist.1 hx.2 _ hzt
  apply ENNReal.le_of_add_le_add_right hyz.ne_top
  refine le_trans ?_ (edist_triangle _ _ _)
  refine (add_le_add le_rfl hyz.le).trans (Eq.trans_le ?_ hxz)
  rw [tsub_add_cancel_of_le A.le]"
Mathlib/Topology/Bases.lean,TopologicalSpace.IsTopologicalBasis.diff_empty,IsTopologicalBasis.diff_empty,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine âŸ¨?_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq],? _âŸ©
  Â· rintro tâ‚ âŸ¨hâ‚, -âŸ© tâ‚‚ âŸ¨hâ‚‚, -âŸ© x hx
    obtain âŸ¨tâ‚ƒ, hâ‚ƒ, hsâŸ© := h.exists_subset_inter _ hâ‚ _ hâ‚‚ x hx
    exact âŸ¨tâ‚ƒ, âŸ¨hâ‚ƒ, Nonempty.ne_empty âŸ¨x, hs.1âŸ©âŸ©, hsâŸ©
  Â· rw [h.eq_generateFrom]
    refine le_antisymm (generateFrom_anti <| diff_subset s _) (le_generateFrom fun t ht => ?_)
    obtain rfl | he := eq_or_ne t âˆ…
    Â· exact @isOpen_empty _ (generateFrom _)
    Â· exact .basic t âŸ¨ht, heâŸ©","error:  application type mismatch
  diff_subset s
argument
  s
has type
  Set (Set Î±) : Type u
but is expected to have type
  ?m.1865 âˆˆ ?m.1863 \ ?m.1864 : Prop","theorem IsTopologicalBasis.diff_empty {s : Set (Set Î±)} (h : IsTopologicalBasis s) :
    IsTopologicalBasis (s \ {âˆ…}) ",":= by
  refine âŸ¨?_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], ?_âŸ©
  Â· rintro tâ‚ âŸ¨hâ‚, -âŸ© tâ‚‚ âŸ¨hâ‚‚, -âŸ© x hx
    obtain âŸ¨tâ‚ƒ, hâ‚ƒ, hsâŸ© := h.exists_subset_inter _ hâ‚ _ hâ‚‚ x hx
    exact âŸ¨tâ‚ƒ, âŸ¨hâ‚ƒ, Nonempty.ne_empty âŸ¨x, hs.1âŸ©âŸ©, hsâŸ©
  Â· rw [h.eq_generateFrom]
    refine le_antisymm (generateFrom_anti diff_subset) (le_generateFrom fun t ht => ?_)
    obtain rfl | he := eq_or_ne t âˆ…
    Â· exact @isOpen_empty _ (generateFrom _)
    Â· exact .basic t âŸ¨ht, heâŸ©"
Mathlib/Probability/Kernel/MeasurableIntegral.lean,Measurable.lintegral_kernel,_root_.Measurable.lintegral_kernel,e6f9a50e9b8db18b96255fd34e1d7e09072168a9,":= by
  let F : â„• â†’ SimpleFunc (Î± Ã— Î²) â„â‰¥0âˆ := SimpleFunc.eapprox (uncurry f)
  have h : âˆ€ a, (â¨† n, F n a) = uncurry f a := SimpleFunc.iSup_eapprox_apply (uncurry f) hf
  simp only [Prod.forall, uncurry_apply_pair] at h
  simp_rw [â† h]
  have : âˆ€ a, (âˆ«â» b, â¨† n, F n (a, b) âˆ‚Îº a) = â¨† n, âˆ«â» b, F n (a, b) âˆ‚Îº a := by
    intro a
    rw [lintegral_iSup]
    Â· exact fun n => (F n).measurable.comp measurable_prod_mk_left
    Â· exact fun i j hij b => SimpleFunc.monotone_eapprox (uncurry f) hij _
  simp_rw [this]
  refine' measurable_iSup fun n => _
  refine' SimpleFunc.induction
    (P := fun f => Measurable (fun (a : Î±) => âˆ«â» (b : Î²), f (a, b) âˆ‚Îº a)) _ _ (F n)
  Â· intro c t ht
    simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,
      SimpleFunc.coe_zero, Set.piecewise_eq_indicator]
    exact Kernel.measurable_lintegral_indicator_const (Îº := Îº) ht c
  Â· intro gâ‚ gâ‚‚ _ hmâ‚ hmâ‚‚
    simp only [SimpleFunc.coe_add, Pi.add_apply]
    have h_add :
      (fun a => âˆ«â» b, gâ‚ (a, b) + gâ‚‚ (a, b) âˆ‚Îº a) =
        (fun a => âˆ«â» b, gâ‚ (a, b) âˆ‚Îº a) + fun a => âˆ«â» b, gâ‚‚ (a, b) âˆ‚Îº a := by
      ext1 a
      rw [Pi.add_apply]
      erw [lintegral_add_left (gâ‚.measurable.comp measurable_prod_mk_left)]
      simp_rw [Function.comp_apply]
    rw [h_add]
    exact Measurable.add hmâ‚ hmâ‚‚",error:  unknown identifier 'Kernel.measurable_lintegral_indicator_const',"theorem _root_.Measurable.lintegral_kernel_prod_right {f : Î± â†’ Î² â†’ â„â‰¥0âˆ}
    (hf : Measurable (uncurry f)) : Measurable fun a => âˆ«â» b, f a b âˆ‚Îº a ",":= by
  let F : â„• â†’ SimpleFunc (Î± Ã— Î²) â„â‰¥0âˆ := SimpleFunc.eapprox (uncurry f)
  have h : âˆ€ a, â¨† n, F n a = uncurry f a := SimpleFunc.iSup_eapprox_apply (uncurry f) hf
  simp only [Prod.forall, uncurry_apply_pair] at h
  simp_rw [â† h]
  have : âˆ€ a, (âˆ«â» b, â¨† n, F n (a, b) âˆ‚Îº a) = â¨† n, âˆ«â» b, F n (a, b) âˆ‚Îº a := by
    intro a
    rw [lintegral_iSup]
    Â· exact fun n => (F n).measurable.comp measurable_prod_mk_left
    Â· exact fun i j hij b => SimpleFunc.monotone_eapprox (uncurry f) hij _
  simp_rw [this]
  refine measurable_iSup fun n => ?_
  refine SimpleFunc.induction
    (P := fun f => Measurable (fun (a : Î±) => âˆ«â» (b : Î²), f (a, b) âˆ‚Îº a)) ?_ ?_ (F n)
  Â· intro c t ht
    simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,
      SimpleFunc.coe_zero, Set.piecewise_eq_indicator]
    exact kernel.measurable_lintegral_indicator_const (Îº := Îº) ht c
  Â· intro gâ‚ gâ‚‚ _ hmâ‚ hmâ‚‚
    simp only [SimpleFunc.coe_add, Pi.add_apply]
    have h_add :
      (fun a => âˆ«â» b, gâ‚ (a, b) + gâ‚‚ (a, b) âˆ‚Îº a) =
        (fun a => âˆ«â» b, gâ‚ (a, b) âˆ‚Îº a) + fun a => âˆ«â» b, gâ‚‚ (a, b) âˆ‚Îº a := by
      ext1 a
      rw [Pi.add_apply]
      erw [lintegral_add_left (gâ‚.measurable.comp measurable_prod_mk_left)]
      simp_rw [Function.comp_apply]
    rw [h_add]
    exact Measurable.add hmâ‚ hmâ‚‚"
Mathlib/Analysis/SpecialFunctions/Gaussian/FourierTransform.lean,GaussianFourier.verticalIntegral_norm_le,verticalIntegral_norm_le,9b5d788d575748c82ffdfc08ef4aaf0a3c6023f0,":= by
  have vert_norm_bound :
    âˆ€ {T : â„},
      0 â‰¤ T â†’
        âˆ€ {c y : â„},
          |y| â‰¤ |c| â†’
            â€–cexp (-b * (T + y * I) ^ 2)â€– â‰¤
              exp (-(b.re * T ^ 2 - (2 : â„) * |b.im| * |c| * T - b.re * c ^ 2)) := by
    intro T hT c y hy
    rw [norm_cexp_neg_mul_sq_add_mul_I b]
    gcongr exp (- (_ - ?_ * _ - _ * ?_))
    Â· (conv_lhs => rw [mul_assoc]); (conv_rhs => rw [mul_assoc])
      gcongr _ * ?_
      refine (le_abs_self _).trans ?_
      rw [abs_mul]
      gcongr
    Â· rwa [sq_le_sq]
  refine (intervalIntegral.norm_integral_le_of_norm_le_const ?_).trans ?_
  pick_goal 3
  Â· rw [sub_zero]
    conv_lhs => simp only [mul_comm _ |c|]
    conv_rhs =>
      conv =>
        congr
        rw [mul_comm]
      rw [mul_assoc]
  Â· intro y hy
    have absy : |y| â‰¤ |c| := by
      rcases le_or_lt 0 c with (h | h)
      Â· rw [uIoc_of_le h] at hy
        rw [abs_of_nonneg h, abs_of_pos hy.1]
        exact hy.2
      Â· rw [uIoc_of_lt h] at hy
        rw [abs_of_neg h, abs_of_nonpos hy.2, neg_le_neg_iff]
        exact hy.1.le
    rw [norm_mul, Complex.norm_eq_abs, abs_I, one_mul, two_mul]
    refine (norm_sub_le _ _).trans (add_le_add (vert_norm_bound hT absy) ?_)
    rw [â† abs_neg y] at absy
    simpa only [neg_mul, ofReal_neg] using vert_norm_bound hT absy","error:  don't know how to synthesize implicit argument 'b'
  @LE.le.trans â„ instPreorder â€–âˆ« (x : â„) in 0 ..c, I * (cexp (-b * (â†‘T + â†‘x * I) ^ 2) - cexp (-b * (â†‘T - â†‘x * I) ^ 2))â€–
    (?m.32670 * |c - 0|) (2 * |c| * rexp (-(b.re * T ^ 2 - 2 * |b.im| * |c| * T - b.re * c ^ 2)))
    (intervalIntegral.norm_integral_le_of_norm_le_const ?m.32672) ?m.32812
context:
b : â„‚
hb : 0 < b.re
c T : â„
hT : 0 â‰¤ T
vert_norm_bound :
  âˆ€ {T : â„},
    0 â‰¤ T â†’
      âˆ€ {c y : â„},
        |y| â‰¤ |c| â†’ â€–cexp (-b * (â†‘T + â†‘y * I) ^ 2)â€– â‰¤ rexp (-(b.re * T ^ 2 - 2 * |b.im| * |c| * T - b.re * c ^ 2))
âŠ¢ â„
error:  don't know how to synthesize implicit argument 'C'
  @intervalIntegral.norm_integral_le_of_norm_le_const â„‚ instNormedAddCommGroup InnerProductSpace.toNormedSpace 0 c
    ?m.32670 (fun y â†¦ I * (cexp (-b * (â†‘T + â†‘y * I) ^ 2) - cexp (-b * (â†‘T - â†‘y * I) ^ 2))) ?m.32672
context:
b : â„‚
hb : 0 < b.re
c T : â„
hT : 0 â‰¤ T
vert_norm_bound :
  âˆ€ {T : â„},
    0 â‰¤ T â†’
      âˆ€ {c y : â„},
        |y| â‰¤ |c| â†’ â€–cexp (-b * (â†‘T + â†‘y * I) ^ 2)â€– â‰¤ rexp (-(b.re * T ^ 2 - 2 * |b.im| * |c| * T - b.re * c ^ 2))
âŠ¢ â„
error:  unsolved goals
b : â„‚
hb : 0 < b.re
c T : â„
hT : 0 â‰¤ T
vert_norm_bound :
  âˆ€ {T : â„},
    0 â‰¤ T â†’
      âˆ€ {c y : â„},
        |y| â‰¤ |c| â†’ â€–cexp (-b * (â†‘T + â†‘y * I) ^ 2)â€– â‰¤ rexp (-(b.re * T ^ 2 - 2 * |b.im| * |c| * T - b.re * c ^ 2))
âŠ¢ â€–verticalIntegral b c Tâ€– â‰¤ 2 * |c| * rexp (-(b.re * T ^ 2 - 2 * |b.im| * |c| * T - b.re * c ^ 2))","theorem verticalIntegral_norm_le (hb : 0 < b.re) (c : â„) {T : â„} (hT : 0 â‰¤ T) :
    â€–verticalIntegral b c Tâ€– â‰¤
      (2 : â„) * |c| * exp (-(b.re * T ^ 2 - (2 : â„) * |b.im| * |c| * T - b.re * c ^ 2)) ",":= by
  have vert_norm_bound :
    âˆ€ {T : â„},
      0 â‰¤ T â†’
        âˆ€ {c y : â„},
          |y| â‰¤ |c| â†’
            â€–cexp (-b * (T + y * I) ^ 2)â€– â‰¤
              exp (-(b.re * T ^ 2 - (2 : â„) * |b.im| * |c| * T - b.re * c ^ 2)) := by
    intro T hT c y hy
    rw [norm_cexp_neg_mul_sq_add_mul_I b]
    gcongr exp (- (_ - ?_ * _ - _ * ?_))
    Â· (conv_lhs => rw [mul_assoc]); (conv_rhs => rw [mul_assoc])
      gcongr _ * ?_
      refine (le_abs_self _).trans ?_
      rw [abs_mul]
      gcongr
    Â· rwa [sq_le_sq]
  apply (intervalIntegral.norm_integral_le_of_norm_le_const _).trans
  Â· rw [sub_zero]
    conv_lhs => simp only [mul_comm _ |c|]
    conv_rhs =>
      conv =>
        congr
        rw [mul_comm]
      rw [mul_assoc]
  Â· intro y hy
    have absy : |y| â‰¤ |c| := by
      rcases le_or_lt 0 c with (h | h)
      Â· rw [uIoc_of_le h] at hy
        rw [abs_of_nonneg h, abs_of_pos hy.1]
        exact hy.2
      Â· rw [uIoc_of_ge h.le] at hy
        rw [abs_of_neg h, abs_of_nonpos hy.2, neg_le_neg_iff]
        exact hy.1.le
    rw [norm_mul, Complex.norm_eq_abs, abs_I, one_mul, two_mul]
    refine (norm_sub_le _ _).trans (add_le_add (vert_norm_bound hT absy) ?_)
    rw [â† abs_neg y] at absy
    simpa only [neg_mul, ofReal_neg] using vert_norm_bound hT absy"
Mathlib/Algebra/Homology/TotalComplex.lean,HomologicalComplexâ‚‚.Dâ‚‚_Dâ‚,Dâ‚‚_Dâ‚,10f63baf7e1660a2ffa3e891eef40812f434a38f,":= by
  by_cases hâ‚ : câ‚â‚‚.Rel iâ‚â‚‚ iâ‚â‚‚'
  Â· by_cases hâ‚‚ : câ‚â‚‚.Rel iâ‚â‚‚' iâ‚â‚‚''
    Â· ext âŸ¨iâ‚, iâ‚‚âŸ© h
      simp only [Î¹_Dâ‚‚_assoc, comp_neg, Î¹_Dâ‚_assoc]
      by_cases hâ‚ƒ : câ‚.Rel iâ‚ (câ‚.next iâ‚)
      Â· rw [K.dâ‚_eq câ‚â‚‚ hâ‚ƒ iâ‚‚ iâ‚â‚‚']; swap
        Â· rw [â† ComplexShape.next_Ï€â‚ câ‚‚ câ‚â‚‚ hâ‚ƒ iâ‚‚, â† câ‚â‚‚.next_eq' hâ‚, h]
        simp only [Linear.units_smul_comp, assoc, Î¹_Dâ‚‚]
        by_cases hâ‚„ : câ‚‚.Rel iâ‚‚ (câ‚‚.next iâ‚‚)
        Â· have hâ‚… : ComplexShape.Ï€ câ‚ câ‚‚ câ‚â‚‚ (iâ‚, câ‚‚.next iâ‚‚) = iâ‚â‚‚' := by
            rw [â† câ‚â‚‚.next_eq' hâ‚, â† h, ComplexShape.next_Ï€â‚‚ câ‚ câ‚â‚‚ iâ‚ hâ‚„]
          have hâ‚† : ComplexShape.Ï€ câ‚ câ‚‚ câ‚â‚‚ (câ‚.next iâ‚, câ‚‚.next iâ‚‚) = iâ‚â‚‚'' := by
            rw [â† câ‚â‚‚.next_eq' hâ‚‚, â† ComplexShape.next_Ï€â‚ câ‚‚ câ‚â‚‚ hâ‚ƒ, hâ‚…]
          simp only [K.dâ‚‚_eq câ‚â‚‚ _ hâ‚„ _ hâ‚…, K.dâ‚‚_eq câ‚â‚‚ _ hâ‚„ _ hâ‚†,
            Linear.units_smul_comp, assoc, Î¹_Dâ‚, Linear.comp_units_smul,
            K.dâ‚_eq câ‚â‚‚ hâ‚ƒ _ _ hâ‚†, HomologicalComplex.Hom.comm_assoc, smul_smul,
            ComplexShape.Îµâ‚‚_Îµâ‚ câ‚â‚‚ hâ‚ƒ hâ‚„, neg_mul, Units.neg_smul]
        Â· simp only [K.dâ‚‚_eq_zero câ‚â‚‚ _ _ _ hâ‚„, zero_comp, comp_zero, smul_zero, neg_zero]
      Â· rw [K.dâ‚_eq_zero câ‚â‚‚ _ _ _ hâ‚ƒ, zero_comp, neg_zero]
        Â· by_cases hâ‚„ : câ‚‚.Rel iâ‚‚ (câ‚‚.next iâ‚‚)
          Â· rw [K.dâ‚‚_eq câ‚â‚‚ iâ‚ hâ‚„ iâ‚â‚‚']; swap
            Â· rw [â† ComplexShape.next_Ï€â‚‚ câ‚ câ‚â‚‚ iâ‚ hâ‚„, â† câ‚â‚‚.next_eq' hâ‚, h]
            simp only [Linear.units_smul_comp, assoc, Î¹_Dâ‚]
            rw [K.dâ‚_eq_zero câ‚â‚‚ _ _ _ hâ‚ƒ, comp_zero, smul_zero]
          Â· rw [K.dâ‚‚_eq_zero câ‚â‚‚ _ _ _ hâ‚„, zero_comp]
    Â· rw [K.Dâ‚_shape câ‚â‚‚ _ _ hâ‚‚, K.Dâ‚‚_shape câ‚â‚‚ _ _ hâ‚‚, comp_zero, comp_zero, neg_zero]
  Â· rw [K.Dâ‚_shape câ‚â‚‚ _ _ hâ‚, K.Dâ‚‚_shape câ‚â‚‚ _ _ hâ‚, zero_comp, zero_comp, neg_zero]","error:  unknown identifier 'Î¹_Dâ‚‚_assoc'
error:  unknown identifier 'Î¹_Dâ‚_assoc'
error:  invalid field 'dâ‚_eq', the environment does not contain 'HomologicalComplexâ‚‚.dâ‚_eq'
  K
has type
  HomologicalComplexâ‚‚ C câ‚ câ‚‚
error:  invalid field 'dâ‚_eq', the environment does not contain 'HomologicalComplex.dâ‚_eq'
  K
has type
  HomologicalComplex (HomologicalComplex C câ‚‚) câ‚
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.49946
case pos
C : Type u_1
instâœâ´ : Category.{u_5, u_1} C
instâœÂ³ : Preadditive C
Iâ‚ : Type u_2
Iâ‚‚ : Type u_3
Iâ‚â‚‚ : Type u_4
câ‚ : ComplexShape Iâ‚
câ‚‚ : ComplexShape Iâ‚‚
K L M : HomologicalComplexâ‚‚ C câ‚ câ‚‚
Ï† : K âŸ¶ L
e : K â‰… L
Ïˆ : L âŸ¶ M
câ‚â‚‚ : ComplexShape Iâ‚â‚‚
instâœÂ² : DecidableEq Iâ‚â‚‚
instâœÂ¹ : TotalComplexShape câ‚ câ‚‚ câ‚â‚‚
instâœ : K.HasTotal câ‚â‚‚
iâ‚â‚‚ iâ‚â‚‚' iâ‚â‚‚'' : Iâ‚â‚‚
hâ‚ : câ‚â‚‚.Rel iâ‚â‚‚ iâ‚â‚‚'
hâ‚‚ : câ‚â‚‚.Rel iâ‚â‚‚' iâ‚â‚‚''
iâ‚ : Iâ‚
iâ‚‚ : Iâ‚‚
h : câ‚.Ï€ câ‚‚ câ‚â‚‚ (iâ‚, iâ‚‚) = iâ‚â‚‚
hâ‚ƒ : câ‚.Rel iâ‚ (câ‚.next iâ‚)
âŠ¢ K.toGradedObject.Î¹MapObj (câ‚.Ï€ câ‚‚ câ‚â‚‚) (iâ‚, iâ‚‚) iâ‚â‚‚ h â‰« K.Dâ‚‚ câ‚â‚‚ iâ‚â‚‚ iâ‚â‚‚' â‰« K.Dâ‚ câ‚â‚‚ iâ‚â‚‚' iâ‚â‚‚'' =
    -K.toGradedObject.Î¹MapObj (câ‚.Ï€ câ‚‚ câ‚â‚‚) (iâ‚, iâ‚‚) iâ‚â‚‚ h â‰« K.Dâ‚ câ‚â‚‚ iâ‚â‚‚ iâ‚â‚‚' â‰« K.Dâ‚‚ câ‚â‚‚ iâ‚â‚‚' iâ‚â‚‚''
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  K.dâ‚ câ‚â‚‚ iâ‚ ?m.50001 ?m.50002
case neg
C : Type u_1
instâœâ´ : Category.{u_5, u_1} C
instâœÂ³ : Preadditive C
Iâ‚ : Type u_2
Iâ‚‚ : Type u_3
Iâ‚â‚‚ : Type u_4
câ‚ : ComplexShape Iâ‚
câ‚‚ : ComplexShape Iâ‚‚
K L M : HomologicalComplexâ‚‚ C câ‚ câ‚‚
Ï† : K âŸ¶ L
e : K â‰… L
Ïˆ : L âŸ¶ M
câ‚â‚‚ : ComplexShape Iâ‚â‚‚
instâœÂ² : DecidableEq Iâ‚â‚‚
instâœÂ¹ : TotalComplexShape câ‚ câ‚‚ câ‚â‚‚
instâœ : K.HasTotal câ‚â‚‚
iâ‚â‚‚ iâ‚â‚‚' iâ‚â‚‚'' : Iâ‚â‚‚
hâ‚ : câ‚â‚‚.Rel iâ‚â‚‚ iâ‚â‚‚'
hâ‚‚ : câ‚â‚‚.Rel iâ‚â‚‚' iâ‚â‚‚''
iâ‚ : Iâ‚
iâ‚‚ : Iâ‚‚
h : câ‚.Ï€ câ‚‚ câ‚â‚‚ (iâ‚, iâ‚‚) = iâ‚â‚‚
hâ‚ƒ : Â¬câ‚.Rel iâ‚ (câ‚.next iâ‚)
âŠ¢ K.toGradedObject.Î¹MapObj (câ‚.Ï€ câ‚‚ câ‚â‚‚) (iâ‚, iâ‚‚) iâ‚â‚‚ h â‰« K.Dâ‚‚ câ‚â‚‚ iâ‚â‚‚ iâ‚â‚‚' â‰« K.Dâ‚ câ‚â‚‚ iâ‚â‚‚' iâ‚â‚‚'' =
    -K.toGradedObject.Î¹MapObj (câ‚.Ï€ câ‚‚ câ‚â‚‚) (iâ‚, iâ‚‚) iâ‚â‚‚ h â‰« K.Dâ‚ câ‚â‚‚ iâ‚â‚‚ iâ‚â‚‚' â‰« K.Dâ‚‚ câ‚â‚‚ iâ‚â‚‚' iâ‚â‚‚''","lemma Dâ‚‚_Dâ‚ (iâ‚â‚‚ iâ‚â‚‚' iâ‚â‚‚'' : Iâ‚â‚‚) :
    K.Dâ‚‚ câ‚â‚‚ iâ‚â‚‚ iâ‚â‚‚' â‰« K.Dâ‚ câ‚â‚‚ iâ‚â‚‚' iâ‚â‚‚'' = - K.Dâ‚ câ‚â‚‚ iâ‚â‚‚ iâ‚â‚‚' â‰« K.Dâ‚‚ câ‚â‚‚ iâ‚â‚‚' iâ‚â‚‚'' ",":= by
  by_cases hâ‚ : câ‚â‚‚.Rel iâ‚â‚‚ iâ‚â‚‚'
  Â· by_cases hâ‚‚ : câ‚â‚‚.Rel iâ‚â‚‚' iâ‚â‚‚''
    Â· ext âŸ¨iâ‚, iâ‚‚âŸ© h
      simp only [totalAux.Î¹MapObj_Dâ‚‚_assoc, comp_neg, totalAux.Î¹MapObj_Dâ‚_assoc]
      by_cases hâ‚ƒ : câ‚.Rel iâ‚ (câ‚.next iâ‚)
      Â· rw [totalAux.dâ‚_eq K câ‚â‚‚ hâ‚ƒ iâ‚‚ iâ‚â‚‚']; swap
        Â· rw [â† ComplexShape.next_Ï€â‚ câ‚‚ câ‚â‚‚ hâ‚ƒ iâ‚‚, â† câ‚â‚‚.next_eq' hâ‚, h]
        simp only [Linear.units_smul_comp, assoc, totalAux.Î¹MapObj_Dâ‚‚]
        by_cases hâ‚„ : câ‚‚.Rel iâ‚‚ (câ‚‚.next iâ‚‚)
        Â· have hâ‚… : ComplexShape.Ï€ câ‚ câ‚‚ câ‚â‚‚ (iâ‚, câ‚‚.next iâ‚‚) = iâ‚â‚‚' := by
            rw [â† câ‚â‚‚.next_eq' hâ‚, â† h, ComplexShape.next_Ï€â‚‚ câ‚ câ‚â‚‚ iâ‚ hâ‚„]
          have hâ‚† : ComplexShape.Ï€ câ‚ câ‚‚ câ‚â‚‚ (câ‚.next iâ‚, câ‚‚.next iâ‚‚) = iâ‚â‚‚'' := by
            rw [â† câ‚â‚‚.next_eq' hâ‚‚, â† ComplexShape.next_Ï€â‚ câ‚‚ câ‚â‚‚ hâ‚ƒ, hâ‚…]
          simp only [totalAux.dâ‚‚_eq K câ‚â‚‚ _ hâ‚„ _ hâ‚…, totalAux.dâ‚‚_eq K câ‚â‚‚ _ hâ‚„ _ hâ‚†,
            Linear.units_smul_comp, assoc, totalAux.Î¹MapObj_Dâ‚, Linear.comp_units_smul,
            totalAux.dâ‚_eq K câ‚â‚‚ hâ‚ƒ _ _ hâ‚†, HomologicalComplex.Hom.comm_assoc, smul_smul,
            ComplexShape.Îµâ‚‚_Îµâ‚ câ‚â‚‚ hâ‚ƒ hâ‚„, neg_mul, Units.neg_smul]
        Â· simp only [K.dâ‚‚_eq_zero câ‚â‚‚ _ _ _ hâ‚„, zero_comp, comp_zero, smul_zero, neg_zero]
      Â· rw [K.dâ‚_eq_zero câ‚â‚‚ _ _ _ hâ‚ƒ, zero_comp, neg_zero]
        by_cases hâ‚„ : câ‚‚.Rel iâ‚‚ (câ‚‚.next iâ‚‚)
        Â· rw [totalAux.dâ‚‚_eq K câ‚â‚‚ iâ‚ hâ‚„ iâ‚â‚‚']; swap
          Â· rw [â† ComplexShape.next_Ï€â‚‚ câ‚ câ‚â‚‚ iâ‚ hâ‚„, â† câ‚â‚‚.next_eq' hâ‚, h]
          simp only [Linear.units_smul_comp, assoc, totalAux.Î¹MapObj_Dâ‚]
          rw [K.dâ‚_eq_zero câ‚â‚‚ _ _ _ hâ‚ƒ, comp_zero, smul_zero]
        Â· rw [K.dâ‚‚_eq_zero câ‚â‚‚ _ _ _ hâ‚„, zero_comp]
    Â· rw [K.Dâ‚_shape câ‚â‚‚ _ _ hâ‚‚, K.Dâ‚‚_shape câ‚â‚‚ _ _ hâ‚‚, comp_zero, comp_zero, neg_zero]
  Â· rw [K.Dâ‚_shape câ‚â‚‚ _ _ hâ‚, K.Dâ‚‚_shape câ‚â‚‚ _ _ hâ‚, zero_comp, zero_comp, neg_zero]"
Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean,MeasureTheory.exists_lt_lowerSemicontinuous_integral_lt,exists_lt_lowerSemicontinuous_integral_lt,7fa0a827960832ef960210f51c78c246882fbb79,":= by
  let Î´ : â„â‰¥0 := âŸ¨Îµ / 2, (half_pos Îµpos).leâŸ©
  have Î´pos : 0 < Î´ := half_pos Îµpos
  let fp : Î± â†’ â„â‰¥0 := fun x => Real.toNNReal (f x)
  have int_fp : Integrable (fun x => (fp x : â„)) Î¼ := hf.real_toNNReal
  rcases exists_lt_lowerSemicontinuous_integral_gt_nnreal fp int_fp Î´pos with
    âŸ¨gp, fp_lt_gp, gpcont, gp_lt_top, gp_integrable, gpintâŸ©
  let fm : Î± â†’ â„â‰¥0 := fun x => Real.toNNReal (-f x)
  have int_fm : Integrable (fun x => (fm x : â„)) Î¼ := hf.neg.real_toNNReal
  rcases exists_upperSemicontinuous_le_integral_le fm int_fm Î´pos with
    âŸ¨gm, gm_le_fm, gmcont, gm_integrable, gmintâŸ©
  let g : Î± â†’ EReal := fun x => (gp x : EReal) - gm x
  have ae_g : âˆ€áµ x âˆ‚Î¼, (g x).toReal = (gp x : EReal).toReal - (gm x : EReal).toReal := by
    filter_upwards [gp_lt_top] with _ hx
    rw [EReal.toReal_sub] <;> simp [hx.ne]
  refine' âŸ¨g, ?lt, ?lsc, ?int, ?aelt, ?intltâŸ©
  case int =>
    show Integrable (fun x => EReal.toReal (g x)) Î¼
    rw [integrable_congr ae_g]
    convert gp_integrable.sub gm_integrable
    simp
  case intlt =>
    show (âˆ« x : Î±, (g x).toReal âˆ‚Î¼) < (âˆ« x : Î±, f x âˆ‚Î¼) + Îµ;
    exact
      calc
        (âˆ« x : Î±, (g x).toReal âˆ‚Î¼) = âˆ« x : Î±, EReal.toReal (gp x) - EReal.toReal (gm x) âˆ‚Î¼ :=
          integral_congr_ae ae_g
        _ = (âˆ« x : Î±, EReal.toReal (gp x) âˆ‚Î¼) - âˆ« x : Î±, â†‘(gm x) âˆ‚Î¼ := by
          simp only [EReal.toReal_coe_ennreal, ENNReal.coe_toReal]
          exact integral_sub gp_integrable gm_integrable
        _ < (âˆ« x : Î±, â†‘(fp x) âˆ‚Î¼) + â†‘Î´ - âˆ« x : Î±, â†‘(gm x) âˆ‚Î¼ := by
          apply sub_lt_sub_right
          convert gpint
          simp only [EReal.toReal_coe_ennreal]
        _ â‰¤ (âˆ« x : Î±, â†‘(fp x) âˆ‚Î¼) + â†‘Î´ - ((âˆ« x : Î±, â†‘(fm x) âˆ‚Î¼) - Î´) := (sub_le_sub_left gmint _)
        _ = (âˆ« x : Î±, f x âˆ‚Î¼) + 2 * Î´ := by
          simp_rw [integral_eq_integral_pos_part_sub_integral_neg_part hf]; ring
        _ = (âˆ« x : Î±, f x âˆ‚Î¼) + Îµ := by congr 1; field_simp [Î´, mul_comm]
  case aelt =>
    show âˆ€áµ x : Î± âˆ‚Î¼, g x < âŠ¤
    filter_upwards [gp_lt_top] with ?_ hx
    simp only [g, sub_eq_add_neg, Ne.def, (EReal.add_lt_top _ _).ne, lt_top_iff_ne_top,
      lt_top_iff_ne_top.1 hx, EReal.coe_ennreal_eq_top_iff, not_false_iff, EReal.neg_eq_top_iff,
      EReal.coe_ennreal_ne_bot]
  case lt =>
    show âˆ€ x, (f x : EReal) < g x
    intro x
    rw [EReal.coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal (f x)]
    refine' EReal.sub_lt_sub_of_lt_of_le _ _ _ _
    Â· simp only [EReal.coe_ennreal_lt_coe_ennreal_iff]; exact fp_lt_gp x
    Â· simp only [ENNReal.coe_le_coe, EReal.coe_ennreal_le_coe_ennreal_iff]
      exact gm_le_fm x
    Â· simp only [EReal.coe_ennreal_ne_bot, Ne.def, not_false_iff]
    Â· simp only [EReal.coe_nnreal_ne_top, Ne.def, not_false_iff]
  case lsc =>
    show LowerSemicontinuous g
    apply LowerSemicontinuous.add'
    Â· exact continuous_coe_ennreal_ereal.comp_lowerSemicontinuous gpcont fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
    Â· apply continuous_neg.comp_upperSemicontinuous_antitone _ fun x y hxy =>
          EReal.neg_le_neg_iff.2 hxy
      dsimp
      apply continuous_coe_ennreal_ereal.comp_upperSemicontinuous _ fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
      exact ENNReal.continuous_coe.comp_upperSemicontinuous gmcont fun x y hxy =>
          ENNReal.coe_le_coe.2 hxy
    Â· intro x
      exact EReal.continuousAt_add (by simp) (by simp)","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.139261 â†’ ?m.139261 â†’ Prop
error:  unsolved goals
case h
Î± : Type u_1
instâœâ´ : TopologicalSpace Î±
instâœÂ³ : MeasurableSpace Î±
instâœÂ² : BorelSpace Î±
Î¼ : Measure Î±
instâœÂ¹ : Î¼.WeaklyRegular
instâœ : SigmaFinite Î¼
f : Î± â†’ â„
hf : Integrable f Î¼
Îµ : â„
Îµpos : 0 < Îµ
Î´ : â„â‰¥0 := âŸ¨Îµ / 2, â‹¯âŸ©
Î´pos : 0 < Î´
fp : Î± â†’ â„â‰¥0 := fun x â†¦ (f x).toNNReal
int_fp : Integrable (fun x â†¦ â†‘(fp x)) Î¼
gp : Î± â†’ â„â‰¥0âˆ
fp_lt_gp : âˆ€ (x : Î±), â†‘(fp x) < gp x
gpcont : LowerSemicontinuous gp
gp_lt_top : âˆ€áµ (x : Î±) âˆ‚Î¼, gp x < âŠ¤
gp_integrable : Integrable (fun x â†¦ (gp x).toReal) Î¼
gpint : âˆ« (x : Î±), (gp x).toReal âˆ‚Î¼ < âˆ« (x : Î±), â†‘(fp x) âˆ‚Î¼ + (fun a â†¦ â†‘a) Î´
fm : Î± â†’ â„â‰¥0 := fun x â†¦ (-f x).toNNReal
int_fm : Integrable (fun x â†¦ â†‘(fm x)) Î¼
gm : Î± â†’ â„â‰¥0
gm_le_fm : âˆ€ (x : Î±), gm x â‰¤ fm x
gmcont : UpperSemicontinuous gm
gm_integrable : Integrable (fun x â†¦ â†‘(gm x)) Î¼
gmint : âˆ« (x : Î±), â†‘(fm x) âˆ‚Î¼ - (fun a â†¦ â†‘a) Î´ â‰¤ âˆ« (x : Î±), â†‘(gm x) âˆ‚Î¼
g : Î± â†’ EReal := fun x â†¦ â†‘(gp x) - â†‘â†‘(gm x)
ae_g : âˆ€áµ (x : Î±) âˆ‚Î¼, (g x).toReal = (â†‘(gp x)).toReal - (â†‘â†‘(gm x)).toReal
xâœ : Î±
hx : gp xâœ < âŠ¤
âŠ¢ â†‘(gp xâœ) + -â†‘â†‘(gm xâœ) â‰  âŠ¤
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.140748 â†’ ?m.140748 â†’ Prop
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.140783 â†’ ?m.140783 â†’ Prop
error:  simp made no progress","theorem exists_lt_lowerSemicontinuous_integral_lt [SigmaFinite Î¼] (f : Î± â†’ â„) (hf : Integrable f Î¼)
    {Îµ : â„} (Îµpos : 0 < Îµ) :
    âˆƒ g : Î± â†’ EReal,
      (âˆ€ x, (f x : EReal) < g x) âˆ§
      LowerSemicontinuous g âˆ§
      Integrable (fun x => EReal.toReal (g x)) Î¼ âˆ§
      (âˆ€áµ x âˆ‚Î¼, g x < âŠ¤) âˆ§ (âˆ« x, EReal.toReal (g x) âˆ‚Î¼) < (âˆ« x, f x âˆ‚Î¼) + Îµ ",":= by
  let Î´ : â„â‰¥0 := âŸ¨Îµ / 2, (half_pos Îµpos).leâŸ©
  have Î´pos : 0 < Î´ := half_pos Îµpos
  let fp : Î± â†’ â„â‰¥0 := fun x => Real.toNNReal (f x)
  have int_fp : Integrable (fun x => (fp x : â„)) Î¼ := hf.real_toNNReal
  rcases exists_lt_lowerSemicontinuous_integral_gt_nnreal fp int_fp Î´pos with
    âŸ¨gp, fp_lt_gp, gpcont, gp_lt_top, gp_integrable, gpintâŸ©
  let fm : Î± â†’ â„â‰¥0 := fun x => Real.toNNReal (-f x)
  have int_fm : Integrable (fun x => (fm x : â„)) Î¼ := hf.neg.real_toNNReal
  rcases exists_upperSemicontinuous_le_integral_le fm int_fm Î´pos with
    âŸ¨gm, gm_le_fm, gmcont, gm_integrable, gmintâŸ©
  let g : Î± â†’ EReal := fun x => (gp x : EReal) - gm x
  have ae_g : âˆ€áµ x âˆ‚Î¼, (g x).toReal = (gp x : EReal).toReal - (gm x : EReal).toReal := by
    filter_upwards [gp_lt_top] with _ hx
    rw [EReal.toReal_sub] <;> simp [hx.ne]
  refine âŸ¨g, ?lt, ?lsc, ?int, ?aelt, ?intltâŸ©
  case int =>
    show Integrable (fun x => EReal.toReal (g x)) Î¼
    rw [integrable_congr ae_g]
    convert gp_integrable.sub gm_integrable
    simp
  case intlt =>
    show (âˆ« x : Î±, (g x).toReal âˆ‚Î¼) < (âˆ« x : Î±, f x âˆ‚Î¼) + Îµ;
    exact
      calc
        (âˆ« x : Î±, (g x).toReal âˆ‚Î¼) = âˆ« x : Î±, EReal.toReal (gp x) - EReal.toReal (gm x) âˆ‚Î¼ :=
          integral_congr_ae ae_g
        _ = (âˆ« x : Î±, EReal.toReal (gp x) âˆ‚Î¼) - âˆ« x : Î±, â†‘(gm x) âˆ‚Î¼ := by
          simp only [EReal.toReal_coe_ennreal, ENNReal.coe_toReal]
          exact integral_sub gp_integrable gm_integrable
        _ < (âˆ« x : Î±, â†‘(fp x) âˆ‚Î¼) + â†‘Î´ - âˆ« x : Î±, â†‘(gm x) âˆ‚Î¼ := by
          apply sub_lt_sub_right
          convert gpint
          simp only [EReal.toReal_coe_ennreal]
        _ â‰¤ (âˆ« x : Î±, â†‘(fp x) âˆ‚Î¼) + â†‘Î´ - ((âˆ« x : Î±, â†‘(fm x) âˆ‚Î¼) - Î´) := sub_le_sub_left gmint _
        _ = (âˆ« x : Î±, f x âˆ‚Î¼) + 2 * Î´ := by
          simp_rw [integral_eq_integral_pos_part_sub_integral_neg_part hf]; ring
        _ = (âˆ« x : Î±, f x âˆ‚Î¼) + Îµ := by congr 1; field_simp [Î´, mul_comm]
  case aelt =>
    show âˆ€áµ x : Î± âˆ‚Î¼, g x < âŠ¤
    filter_upwards [gp_lt_top] with ?_ hx
    simp only [g, sub_eq_add_neg, Ne, (EReal.add_lt_top _ _).ne, lt_top_iff_ne_top,
      lt_top_iff_ne_top.1 hx, EReal.coe_ennreal_eq_top_iff, not_false_iff, EReal.neg_eq_top_iff,
      EReal.coe_ennreal_ne_bot]
  case lt =>
    show âˆ€ x, (f x : EReal) < g x
    intro x
    rw [EReal.coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal (f x)]
    refine EReal.sub_lt_sub_of_lt_of_le ?_ ?_ ?_ ?_
    Â· simp only [EReal.coe_ennreal_lt_coe_ennreal_iff]; exact fp_lt_gp x
    Â· simp only [ENNReal.coe_le_coe, EReal.coe_ennreal_le_coe_ennreal_iff]
      exact gm_le_fm x
    Â· simp only [EReal.coe_ennreal_ne_bot, Ne, not_false_iff]
    Â· simp only [EReal.coe_nnreal_ne_top, Ne, not_false_iff]
  case lsc =>
    show LowerSemicontinuous g
    apply LowerSemicontinuous.add'
    Â· exact continuous_coe_ennreal_ereal.comp_lowerSemicontinuous gpcont fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
    Â· apply continuous_neg.comp_upperSemicontinuous_antitone _ fun x y hxy =>
          EReal.neg_le_neg_iff.2 hxy
      dsimp
      apply continuous_coe_ennreal_ereal.comp_upperSemicontinuous _ fun x y hxy =>
          EReal.coe_ennreal_le_coe_ennreal_iff.2 hxy
      exact ENNReal.continuous_coe.comp_upperSemicontinuous gmcont fun x y hxy =>
          ENNReal.coe_le_coe.2 hxy
    Â· intro x
      exact EReal.continuousAt_add (by simp) (by simp)"
Mathlib/Geometry/Manifold/BumpFunction.lean,SmoothBumpFunction.nhds_basis_tsupport,nhds_basis_tsupport,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  have :
    (ğ“ c).HasBasis (fun _ : SmoothBumpFunction I c => True) fun f =>
      (extChartAt I c).symm '' (closedBall (extChartAt I c c) f.rOut âˆ© range I) := by
    rw [â† map_extChartAt_symm_nhdsWithin_range I c]
    exact nhdsWithin_range_basis.map _
  refine' this.to_has_basis' (fun f _ => âŸ¨f, trivial, f.tsupport_subset_symm_image_closedBallâŸ©)
    fun f _ => f.tsupport_mem_nhds","error:  invalid field 'to_has_basis'', the environment does not contain 'Filter.HasBasis.to_has_basis''
  this
has type
  (ğ“ c).HasBasis (fun x â†¦ True) fun f â†¦ â†‘(extChartAt I c).symm '' (closedBall (â†‘(extChartAt I c) c) f.rOut âˆ© range â†‘I)","theorem nhds_basis_tsupport :
    (ğ“ c).HasBasis (fun _ : SmoothBumpFunction I c => True) fun f => tsupport f ",":= by
  have :
    (ğ“ c).HasBasis (fun _ : SmoothBumpFunction I c => True) fun f =>
      (extChartAt I c).symm '' (closedBall (extChartAt I c c) f.rOut âˆ© range I) := by
    rw [â† map_extChartAt_symm_nhdsWithin_range I c]
    exact nhdsWithin_range_basis.map _
  exact this.to_hasBasis' (fun f _ => âŸ¨f, trivial, f.tsupport_subset_symm_image_closedBallâŸ©)
    fun f _ => f.tsupport_mem_nhds"
Mathlib/Data/List/Cycle.lean,Cycle.subsingleton_nil,subsingleton_nil,a36d8932e98ea1d7efcdd316318586a6329f53a3,":=
  zero_le_one","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.next_nthLe` has been deprecated, use `List.next_get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe_pmap` has been deprecated, use `List.get_pmap` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
error:  failed to synthesize
  ZeroLEOneClass â„•
use `set_option diagnostics true` to get diagnostic information",theorem subsingleton_nil : Subsingleton (@nil Î±) ,:= Nat.zero_le _
Mathlib/Probability/Distributions/Gaussian.lean,ProbabilityTheory.gaussianReal_map_add_const,gaussianReal_map_add_const,1aadd4f4012334f6f1cd811e685b9c75a27ee9ed,":= by
  by_cases hv : v = 0
  Â· simp only [hv, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.add_const _) _
  let e : â„ â‰ƒáµ â„ := (Homeomorph.addRight y).symm.toMeasurableEquiv
  have he' : âˆ€ x, HasDerivAt e ((fun _ â†¦ 1) x) x := fun _ â†¦ (hasDerivAt_id _).sub_const y
  change (gaussianReal Î¼ v).map e.symm = gaussianReal (Î¼ + y) v
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs']
  simp only [abs_neg, abs_one, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, one_mul, ne_eq]
  rw [gaussianReal_apply_eq_integral _ hv hs']
  simp [gaussianPdfReal_sub _ y, Homeomorph.addRight, â† sub_eq_add_neg]","error:  application type mismatch
  gaussianReal_apply_eq_integral ?m.253953 hv hs'
argument
  hs'
has type
  MeasurableSet s' : Prop
but is expected to have type
  Set â„ : Type","lemma gaussianReal_map_add_const (y : â„) :
    (gaussianReal Î¼ v).map (Â· + y) = gaussianReal (Î¼ + y) v ",":= by
  by_cases hv : v = 0
  Â· simp only [hv, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.add_const _) _
  let e : â„ â‰ƒáµ â„ := (Homeomorph.addRight y).symm.toMeasurableEquiv
  have he' : âˆ€ x, HasDerivAt e ((fun _ â†¦ 1) x) x := fun _ â†¦ (hasDerivAt_id _).sub_const y
  change (gaussianReal Î¼ v).map e.symm = gaussianReal (Î¼ + y) v
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs']
  simp only [abs_neg, abs_one, MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, one_mul, ne_eq]
  rw [gaussianReal_apply_eq_integral _ hv s']
  simp [e, gaussianPDFReal_sub _ y, Homeomorph.addRight, â† sub_eq_add_neg]"
Mathlib/Analysis/PSeries.lean,summable_condensed_iff_of_nonneg,summable_condensed_iff_of_nonneg,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  lift f to â„• â†’ â„â‰¥0 using h_nonneg
  simp only [NNReal.coe_le_coe] at *
  exact_mod_cast NNReal.summable_condensed_iff h_mono","error:  failed to synthesize
  LE Type
use `set_option diagnostics true` to get diagnostic information","theorem summable_condensed_iff_of_nonneg {f : â„• â†’ â„} (h_nonneg : âˆ€ n, 0 â‰¤ f n)
    (h_mono : âˆ€ â¦ƒm nâ¦„, 0 < m â†’ m â‰¤ n â†’ f n â‰¤ f m) :
    (Summable fun k : â„• => (2 : â„) ^ k * f (2 ^ k)) â†” Summable f ",":= by
  have h_succ_diff : SuccDiffBounded 2 (2 ^ Â·) := by
    intro n
    simp [pow_succ, mul_two, two_mul]
  convert summable_schlomilch_iff_of_nonneg h_nonneg h_mono (pow_pos zero_lt_two)
    (pow_right_strictMono one_lt_two) two_ne_zero h_succ_diff
  simp [pow_succ, mul_two, two_mul]"
Mathlib/Computability/Primrec.lean,PrimrecRel.comp,PrimrecRel.comp,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  Primrec.compâ‚‚","error:  type mismatch
  Primrec.compâ‚‚
has type
  Primrec ?m.62192 â†’ Primrecâ‚‚ ?m.62193 â†’ Primrecâ‚‚ fun a b â†¦ ?m.62192 (?m.62193 a b) : Prop
but is expected to have type
  PrimrecRel R â†’ Primrec f â†’ Primrec g â†’ PrimrecPred fun a â†¦ R (f a) (g a) : Prop","theorem PrimrecRel.comp {R : Î² â†’ Î³ â†’ Prop} [âˆ€ a b, Decidable (R a b)] {f : Î± â†’ Î²} {g : Î± â†’ Î³} :
    PrimrecRel R â†’ Primrec f â†’ Primrec g â†’ PrimrecPred fun a => R (f a) (g a) ",":=
  Primrecâ‚‚.comp"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime,isIntegralClosure_adjoin_singleton_of_prime,dc75ecfadb9fc95b08f2668b88d64b26c11ab59b,":= by
  refine' âŸ¨Subtype.val_injective, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, _âŸ©, rflâŸ©, _âŸ©âŸ©
  swap
  Â· rintro âŸ¨y, rflâŸ©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hÎ¶.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hÎ¶.subOnePowerBasis â„š
  have hint : IsIntegral â„¤ B.gen := (hÎ¶.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} â„š K
  have H := discr_mul_isIntegral_mem_adjoin â„š hint h
  obtain âŸ¨u, n, hunâŸ© := discr_prime_pow_eq_unit_mul_pow' hÎ¶
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [â† smul_assoc, â† smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, â† Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  Â· haveI : IsCyclotomicExtension {1} â„š K := by simpa using hcycl
    have : x âˆˆ (âŠ¥ : Subalgebra â„š K) := by
      rw [singleton_one â„š K]
      exact mem_top
    obtain âŸ¨y, rflâŸ© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap â„š K).injective).1 h
    obtain âŸ¨z, hzâŸ© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [â† hz, â† IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  Â· have hmin : (minpoly â„¤ B.gen).IsEisensteinAt (Submodule.span â„¤ {((p : â„•) : â„¤)}) := by
      have hâ‚ := minpoly.isIntegrallyClosed_eq_field_fractions' â„š hint
      have hâ‚‚ := hÎ¶.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at hâ‚
      rw [hâ‚, â† map_cyclotomic_int, show Int.castRingHom â„š = algebraMap â„¤ â„š by rfl,
        show X + 1 = map (algebraMap â„¤ â„š) (X + 1) by simp, â† map_comp] at hâ‚‚
      haveI : CharZero â„š := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap â„¤ â„š) (algebraMap â„¤ â„š).injective_int hâ‚‚]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton â„¤ _) (Subalgebra.one_mem _)",error:  unknown constant 'StrictOrderedSemiring.to_charZero',"theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} â„š K]
    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)) : IsIntegralClosure (adjoin â„¤ ({Î¶} : Set K)) â„¤ K ",":= by
  refine âŸ¨Subtype.val_injective, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©, ?_âŸ©âŸ©
  swap
  Â· rintro âŸ¨y, rflâŸ©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hÎ¶.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hÎ¶.subOnePowerBasis â„š
  have hint : IsIntegral â„¤ B.gen := (hÎ¶.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} â„š K
  have H := discr_mul_isIntegral_mem_adjoin â„š hint h
  obtain âŸ¨u, n, hunâŸ© := discr_prime_pow_eq_unit_mul_pow' hÎ¶
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [â† smul_assoc, â† smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, â† Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  Â· haveI : IsCyclotomicExtension {1} â„š K := by simpa using hcycl
    have : x âˆˆ (âŠ¥ : Subalgebra â„š K) := by
      rw [singleton_one â„š K]
      exact mem_top
    obtain âŸ¨y, rflâŸ© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap â„š K).injective).1 h
    obtain âŸ¨z, hzâŸ© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [â† hz, â† IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  Â· have hmin : (minpoly â„¤ B.gen).IsEisensteinAt (Submodule.span â„¤ {((p : â„•) : â„¤)}) := by
      have hâ‚ := minpoly.isIntegrallyClosed_eq_field_fractions' â„š hint
      have hâ‚‚ := hÎ¶.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at hâ‚
      rw [hâ‚, â† map_cyclotomic_int, show Int.castRingHom â„š = algebraMap â„¤ â„š by rfl,
        show X + 1 = map (algebraMap â„¤ â„š) (X + 1) by simp, â† map_comp] at hâ‚‚
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap â„¤ â„š) (algebraMap â„¤ â„š).injective_int hâ‚‚]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton â„¤ _) (Subalgebra.one_mem _)"
Mathlib/Topology/Category/Profinite/EffectiveEpi.lean,Profinite.effectiveEpi_tfae,effectiveEpi_tfae,55619a095ad7cce23fe9818f4cf5fefa1fabf54e,":= by
  1 â†’ 2
  | _ => inferInstance
  2 â†” 3 := epi_iff_surjective Ï€
  3 â†’ 1 := fun hÏ€ â†¦ âŸ¨âŸ¨struct Ï€ hÏ€âŸ©âŸ©","error:  unexpected token; expected '{' or tactic
error:  unsolved goals
B X : Profinite
Ï€ : X âŸ¶ B
âŠ¢ [EffectiveEpi Ï€, Epi Ï€, Function.Surjective â‡‘Ï€].TFAE","theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (Ï€ : X âŸ¶ B) :
    TFAE
    [ EffectiveEpi Ï€
    , Epi Ï€
    , Function.Surjective Ï€
    ] ",":= by
  tfae_have 1 â†’ 2
  Â· intro; infer_instance
  tfae_have 2 â†” 3
  Â· exact epi_iff_surjective Ï€
  tfae_have 3 â†’ 1
  Â· exact fun hÏ€ â†¦ âŸ¨âŸ¨struct Ï€ hÏ€âŸ©âŸ©
  tfae_finish"
Mathlib/CategoryTheory/FiberedCategory/HomLift.lean,CategoryTheory.IsHomLift.fac,fac,95e75fcfd1c014add03de9b53a54ac3c1396bb20,":=
  Functor.IsHomLift.fac","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Functor.IsHomLift
has type
  ?m.4296 â¥¤ ?m.4295 â†’ {R S : ?m.4295} â†’ {a b : ?m.4296} â†’ (R âŸ¶ S) â†’ (a âŸ¶ b) â†’ Prop",lemma fac : f = eqToHom (domain_eq p f Ï†).symm â‰« p.map Ï† â‰« eqToHom (codomain_eq p f Ï†) ,":= by
  subst_hom_lift p f Ï†; simp"
Mathlib/LinearAlgebra/Ray.lean,units_smul_eq_self_iff,units_smul_eq_self_iff,c959b2f950b9c44268e36bcedef976356855e6fb,":= by
  induction' v with v hv
  simp only [smul_rayOfNeZero, ray_eq_iff, Units.smul_def, sameRay_smul_left_iff_of_ne hv u.ne_zero]","warning:  unused variable `R`
note: this linter can be disabled with `set_option linter.unusedVariables false`
error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
R : Type u_1
instâœÂ³ : LinearOrderedCommRing R
M : Type u_2
instâœÂ² : AddCommGroup M
instâœÂ¹ : Module R M
instâœ : NoZeroSMulDivisors R M
u : RË£
v : Module.Ray R M
âŠ¢ u â€¢ v = v â†” 0 < â†‘u",theorem units_smul_eq_self_iff {u : RË£} {v : Module.Ray R M} : u â€¢ v = v â†” 0 < u.1 ,":= by
  induction' v using Module.Ray.ind with v hv
  simp only [smul_rayOfNeZero, ray_eq_iff, Units.smul_def, sameRay_smul_left_iff_of_ne hv u.ne_zero]"
Mathlib/NumberTheory/Modular.lean,ModularGroup.abs_c_le_one,abs_c_le_one,a78b924c512027778631dfef33fbedc7173daaea,":= by
  let c' : â„¤ := (â†‘â‚˜g) 1 0
  let c : â„ := (c' : â„)
  suffices 3 * c ^ 2 < 4 by
    rw [â† Int.cast_pow, â† Int.cast_three, â† Int.cast_four, â† Int.cast_mul, Int.cast_lt] at this
    replace this : c' ^ 2 â‰¤ 1 ^ 2; Â· linarith
    rwa [sq_le_sq, abs_one] at this
  suffices c â‰  0 â†’ 9 * c ^ 4 < 16 by
    rcases eq_or_ne c 0 with (hc | hc)
    Â· rw [hc]; norm_num
    Â· refine' (abs_lt_of_sq_lt_sq' _ (by norm_num)).2
      specialize this hc
      linarith
  intro hc
  replace hc : 0 < c ^ 4;
  Â· change 0 < c ^ (2 * 2); rw [pow_mul]; apply sq_pos_of_pos (sq_pos_of_ne_zero _ hc)
  have hâ‚ :=
    mul_lt_mul_of_pos_right
      (mul_lt_mul'' (three_lt_four_mul_im_sq_of_mem_fdo hg) (three_lt_four_mul_im_sq_of_mem_fdo hz)
        (by linarith) (by linarith))
      hc
  have hâ‚‚ : (c * z.im) ^ 4 / normSq (denom (â†‘g) z) ^ 2 â‰¤ 1 :=
    div_le_one_of_le
      (pow_four_le_pow_two_of_pow_two_le (UpperHalfPlane.c_mul_im_sq_le_normSq_denom z g))
      (sq_nonneg _)
  let nsq := normSq (denom g z)
  calc
    9 * c ^ 4 < c ^ 4 * z.im ^ 2 * (g â€¢ z).im ^ 2 * 16 := by linarith
    _ = c ^ 4 * z.im ^ 4 / nsq ^ 2 * 16 := by
      rw [SpecialLinearGroup.im_smul_eq_div_normSq, div_pow]
      ring
    _ â‰¤ 16 := by rw [â† mul_pow]; linarith","warning:  fd does not have a doc string
warning:  fdo does not have a doc string
error:  unexpected token ';'; expected '|'
error:  unsolved goals
g : SL(2, â„¤)
z : â„
hz : z âˆˆ ğ’Ÿáµ’
hg : g â€¢ z âˆˆ ğ’Ÿáµ’
c' : â„¤ := â†‘g 1 0
c : â„ := â†‘c'
this : c' ^ 2 â‰¤ 1 ^ 2
âŠ¢ |â†‘g 1 0| â‰¤ 1
error:  unsolved goals
g : SL(2, â„¤)
z : â„
hz : z âˆˆ ğ’Ÿáµ’
hg : g â€¢ z âˆˆ ğ’Ÿáµ’
c' : â„¤ := â†‘g 1 0
c : â„ := â†‘c'
âŠ¢ 3 * c ^ 2 < 4",theorem abs_c_le_one (hz : z âˆˆ ğ’Ÿáµ’) (hg : g â€¢ z âˆˆ ğ’Ÿáµ’) : |(â†‘â‚˜g) 1 0| â‰¤ 1 ,":= by
  let c' : â„¤ := (â†‘â‚˜g) 1 0
  let c : â„ := (c' : â„)
  suffices 3 * c ^ 2 < 4 by
    rw [â† Int.cast_pow, â† Int.cast_three, â† Int.cast_four, â† Int.cast_mul, Int.cast_lt] at this
    replace this : c' ^ 2 â‰¤ 1 ^ 2 := by linarith
    rwa [sq_le_sq, abs_one] at this
  suffices c â‰  0 â†’ 9 * c ^ 4 < 16 by
    rcases eq_or_ne c 0 with (hc | hc)
    Â· rw [hc]; norm_num
    Â· refine (abs_lt_of_sq_lt_sq' ?_ (by norm_num)).2
      specialize this hc
      linarith
  intro hc
  replace hc : 0 < c ^ 4 := by
    change 0 < c ^ (2 * 2); rw [pow_mul]; apply sq_pos_of_pos (sq_pos_of_ne_zero hc)
  have hâ‚ :=
    mul_lt_mul_of_pos_right
      (mul_lt_mul'' (three_lt_four_mul_im_sq_of_mem_fdo hg) (three_lt_four_mul_im_sq_of_mem_fdo hz)
        (by linarith) (by linarith))
      hc
  have hâ‚‚ : (c * z.im) ^ 4 / normSq (denom (â†‘g) z) ^ 2 â‰¤ 1 :=
    div_le_one_of_le
      (pow_four_le_pow_two_of_pow_two_le (UpperHalfPlane.c_mul_im_sq_le_normSq_denom z g))
      (sq_nonneg _)
  let nsq := normSq (denom g z)
  calc
    9 * c ^ 4 < c ^ 4 * z.im ^ 2 * (g â€¢ z).im ^ 2 * 16 := by linarith
    _ = c ^ 4 * z.im ^ 4 / nsq ^ 2 * 16 := by
      rw [ModularGroup.im_smul_eq_div_normSq, div_pow]
      ring
    _ â‰¤ 16 := by rw [â† mul_pow]; linarith"
Mathlib/Computability/AkraBazzi/AkraBazzi.lean,AkraBazziRecurrence.rpow_p_mul_one_add_smoothingFn_ge,rpow_p_mul_one_add_smoothingFn_ge,399f04bf3c57d43d9f70a32662007a7562003890,":= by
  rw [Filter.eventually_all]
  intro i
  let q : â„ â†’ â„ := fun x => x ^ (p a b) * (1 + Îµ x)
  have h_diff_q : DifferentiableOn â„ q (Set.Ioi 1) := by
    refine DifferentiableOn.mul
        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)
        differentiableOn_one_add_smoothingFn
    rw [Set.mem_compl_singleton_iff]
    rw [Set.mem_Ioi] at hz
    exact ne_of_gt <| zero_lt_one.trans hz
  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc
    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + Îµ z) x := by rfl
          _ =á¶ [atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + Îµ x)
              + x ^ (p a b) * deriv (fun z => 1 + Îµ z) x := by
                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'
                rw [deriv_mul] <;> aesop
          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by
                refine IsBigO.add ?left ?right
                case left => calc
                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + Îµ x))
                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + Îµ x) := by
                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)
                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=
                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO
                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]
                case right => calc
                  (fun x => x ^ (p a b) * deriv (fun z => 1 + Îµ z) x)
                      =O[atTop] (fun x => x ^ (p a b) * xâ»Â¹) := by
                        exact IsBigO.mul (isBigO_refl _ _)
                          isLittleO_deriv_one_add_smoothingFn.isBigO
                    _ =á¶ [atTop] fun x => x ^ ((p a b) - 1) := by
                        filter_upwards [eventually_gt_atTop 0] with x hx
                        rw [â† Real.rpow_neg_one, â† Real.rpow_add hx, â† sub_eq_add_neg]
  have h_main_norm : (fun (n:â„•) => â€–q (r i n) - q (b i * n)â€–)
      â‰¤á¶ [atTop] fun (n:â„•) => â€–(b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)â€– := by
    refine IsLittleO.eventuallyLE ?_
    calc
      (fun (n:â„•) => q (r i n) - q (b i * n))
          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by
            exact R.isBigO_apply_r_sub_b q h_diff_q
              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i
        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by
            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)
        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by
            exact IsBigO.mul (IsBigO.nat_cast_atTop h_deriv_q) (isBigO_refl _ _)
        _ =á¶ [atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by
            filter_upwards [eventually_ne_atTop 0] with n hn
            have hn' : (n:â„) â‰  0 := by positivity
            simp [â† mul_div_assoc, â† Real.rpow_add_one hn']
        _ = fun (n:â„•) => (n:â„) ^ (p a b) * (1 / (log n) ^ 2)   := by simp_rw [mul_div, mul_one]
        _ =Î˜[atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) := by
            refine IsTheta.symm ?_
            simp_rw [mul_assoc]
            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)
            have := R.b_pos i; positivity
        _ =Î˜[atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)
                  <| R.isTheta_smoothingFn_sub_self i
  have h_main : (fun (n:â„•) => q (b i * n) - q (r i n))
      â‰¤á¶ [atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
    calc (fun (n:â„•) => q (b i * n) - q (r i n))
           â‰¤á¶ [atTop] fun (n:â„•) => â€–q (r i n) - q (b i * n)â€– := by
              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _
         _ â‰¤á¶ [atTop] fun (n:â„•) => â€–(b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)â€– :=
              h_main_norm
         _ =á¶ [atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
              filter_upwards [eventually_gt_atTop âŒˆ(b i)â»Â¹âŒ‰â‚Š, eventually_gt_atTop 1] with n hn hn'
              refine norm_of_nonneg ?_
              have hâ‚ := R.b_pos i
              have hâ‚‚ : 0 â‰¤ Îµ (b i * n) - Îµ n := by
                refine sub_nonneg_of_le <|
                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le
                case n_gt_one =>
                  show 1 < (n:â„)
                  rw [Nat.one_lt_cast]
                  exact hn'
                case bn_gt_one =>
                  calc 1 = b i * (b i)â»Â¹ := by rw [mul_inv_cancel (by positivity)]
                      _ â‰¤ b i * âŒˆ(b i)â»Â¹âŒ‰â‚Š := by gcongr; exact Nat.le_ceil _
                      _ < b i * n := by gcongr; rw [Nat.cast_lt]; exact hn
                case le => calc b i * n â‰¤ 1 * n := by have := R.b_lt_one i; gcongr
                                        _ = n := by rw [one_mul]
              positivity
  filter_upwards [h_main] with n hn
  have hâ‚ : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)
      = (b i) ^ (p a b) * n ^ (p a b) * (1 + Îµ n) := by
    have := R.b_pos i
    simp only [mul_rpow (by positivity : (0:â„) â‰¤ b i) (by positivity : (0:â„) â‰¤ n)]
    ring
  show (b i) ^ (p a b) * n ^ (p a b) * (1 + Îµ n) â‰¤ q (r i n)
  rw [â† hâ‚, sub_le_iff_le_add', â† sub_le_iff_le_add]
  exact hn","warning:  `Asymptotics.IsBigO.nat_cast_atTop` has been deprecated, use `Asymptotics.IsBigO.natCast_atTop` instead
error:  simp made no progress","lemma rpow_p_mul_one_add_smoothingFn_ge :
    âˆ€á¶  (n : â„•) in atTop, âˆ€ i, (b i) ^ (p a b) * n ^ (p a b) * (1 + Îµ n)
      â‰¤ (r i n) ^ (p a b) * (1 + Îµ (r i n)) ",":= by
  rw [Filter.eventually_all]
  intro i
  let q : â„ â†’ â„ := fun x => x ^ (p a b) * (1 + Îµ x)
  have h_diff_q : DifferentiableOn â„ q (Set.Ioi 1) := by
    refine DifferentiableOn.mul
        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)
        differentiableOn_one_add_smoothingFn
    rw [Set.mem_compl_singleton_iff]
    rw [Set.mem_Ioi] at hz
    exact ne_of_gt <| zero_lt_one.trans hz
  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc
    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 + Îµ z) x := by rfl
          _ =á¶ [atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 + Îµ x)
              + x ^ (p a b) * deriv (fun z => 1 + Îµ z) x := by
                filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'
                rw [deriv_mul] <;> aesop
          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by
                refine IsBigO.add ?left ?right
                case left => calc
                  (fun x => deriv (fun z => z ^ (p a b)) x * (1 + Îµ x))
                      =O[atTop] fun x => x ^ ((p a b) - 1) * (1 + Îµ x) := by
                        exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)
                    _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 :=
                        IsBigO.mul (isBigO_refl _ _) isEquivalent_one_add_smoothingFn_one.isBigO
                    _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]
                case right => calc
                  (fun x => x ^ (p a b) * deriv (fun z => 1 + Îµ z) x)
                      =O[atTop] (fun x => x ^ (p a b) * xâ»Â¹) := by
                        exact IsBigO.mul (isBigO_refl _ _)
                          isLittleO_deriv_one_add_smoothingFn.isBigO
                    _ =á¶ [atTop] fun x => x ^ ((p a b) - 1) := by
                        filter_upwards [eventually_gt_atTop 0] with x hx
                        rw [â† Real.rpow_neg_one, â† Real.rpow_add hx, â† sub_eq_add_neg]
  have h_main_norm : (fun (n:â„•) => â€–q (r i n) - q (b i * n)â€–)
      â‰¤á¶ [atTop] fun (n:â„•) => â€–(b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)â€– := by
    refine IsLittleO.eventuallyLE ?_
    calc
      (fun (n:â„•) => q (r i n) - q (b i * n))
          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by
            exact R.isBigO_apply_r_sub_b q h_diff_q
              (growsPolynomially_deriv_rpow_p_mul_one_add_smoothingFn (p a b)) i
        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by
            exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)
        _ =O[atTop] fun n => n ^ ((p a b) - 1) * (n / log n ^ 2) := by
            exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)
        _ =á¶ [atTop] fun n => n ^ (p a b) / (log n) ^ 2 := by
            filter_upwards [eventually_ne_atTop 0] with n hn
            have hn' : (n:â„) â‰  0 := by positivity
            simp [â† mul_div_assoc, â† Real.rpow_add_one hn']
        _ = fun (n:â„•) => (n:â„) ^ (p a b) * (1 / (log n) ^ 2)   := by simp_rw [mul_div, mul_one]
        _ =Î˜[atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n) ^ 2) := by
            refine IsTheta.symm ?_
            simp_rw [mul_assoc]
            refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)
            have := R.b_pos i; positivity
        _ =Î˜[atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
            exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)
                  <| R.isTheta_smoothingFn_sub_self i
  have h_main : (fun (n:â„•) => q (b i * n) - q (r i n))
      â‰¤á¶ [atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
    calc (fun (n:â„•) => q (b i * n) - q (r i n))
           â‰¤á¶ [atTop] fun (n:â„•) => â€–q (r i n) - q (b i * n)â€– := by
              filter_upwards with _; rw [norm_sub_rev]; exact le_norm_self _
         _ â‰¤á¶ [atTop] fun (n:â„•) => â€–(b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)â€– :=
              h_main_norm
         _ =á¶ [atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
              filter_upwards [eventually_gt_atTop âŒˆ(b i)â»Â¹âŒ‰â‚Š, eventually_gt_atTop 1] with n hn hn'
              refine norm_of_nonneg ?_
              have hâ‚ := R.b_pos i
              have hâ‚‚ : 0 â‰¤ Îµ (b i * n) - Îµ n := by
                refine sub_nonneg_of_le <|
                  (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le
                case n_gt_one =>
                  show 1 < (n:â„)
                  rw [Nat.one_lt_cast]
                  exact hn'
                case bn_gt_one =>
                  calc 1 = b i * (b i)â»Â¹ := by rw [mul_inv_cancel (by positivity)]
                      _ â‰¤ b i * âŒˆ(b i)â»Â¹âŒ‰â‚Š := by gcongr; exact Nat.le_ceil _
                      _ < b i * n := by gcongr; rw [Nat.cast_lt]; exact hn
                case le => calc b i * n â‰¤ 1 * n := by have := R.b_lt_one i; gcongr
                                        _ = n := by rw [one_mul]
              positivity
  filter_upwards [h_main] with n hn
  have hâ‚ : q (b i * n) - (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)
      = (b i) ^ (p a b) * n ^ (p a b) * (1 + Îµ n) := by
    have := R.b_pos i
    simp only [q, mul_rpow (by positivity : (0:â„) â‰¤ b i) (by positivity : (0:â„) â‰¤ n)]
    ring
  show (b i) ^ (p a b) * n ^ (p a b) * (1 + Îµ n) â‰¤ q (r i n)
  rw [â† hâ‚, sub_le_iff_le_add', â† sub_le_iff_le_add]
  exact hn"
Mathlib/Topology/Order/IntermediateValue.lean,Continuous.strictMonoOn_of_inj_rigidity,Continuous.strictMonoOn_of_inj_rigidity,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  intro x y hxy
  let s := min a x
  let t := max b y
  have hsa : s â‰¤ a := min_le_left a x
  have hbt : b â‰¤ t := le_max_left b y
  have hst : s â‰¤ t := hsa.trans $ hbt.trans' hab.le
  have hf_mono_st : StrictMonoOn f (Icc s t) âˆ¨ StrictAntiOn f (Icc s t) := by
    letI := Icc.completeLinearOrder hst
    have := Continuous.strictMono_of_inj_boundedOrder' (f := Set.restrict (Icc s t) f)
      hf_c.continuousOn.restrict (hf_i.injOn _).injective
    exact this.imp strictMono_restrict.mp strictAntiOn_iff_strictAnti.mpr
  have (h : StrictAntiOn f (Icc s t)) : False := by
    have : Icc a b âŠ† Icc s t := Icc_subset_Icc hsa hbt
    replace : StrictAntiOn f (Icc a b) := StrictAntiOn.mono h this
    replace : IsAntichain (Â· â‰¤ Â·) (Icc a b) :=
      IsAntichain.of_strictMonoOn_antitoneOn hf_mono this.antitoneOn
    exact this.not_lt (left_mem_Icc.mpr (le_of_lt hab)) (right_mem_Icc.mpr (le_of_lt hab)) hab
  replace hf_mono_st : StrictMonoOn f (Icc s t) := hf_mono_st.resolve_right this
  have hsx : s â‰¤ x := min_le_right a x
  have hyt : y â‰¤ t := le_max_right b y
  replace : Icc x y âŠ† Icc s t := Icc_subset_Icc hsx hyt
  replace : StrictMonoOn f (Icc x y) := StrictMonoOn.mono hf_mono_st this
  exact this (left_mem_Icc.mpr (le_of_lt hxy)) (right_mem_Icc.mpr (le_of_lt hxy)) hxy","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Injective.injOn hf_i ?m.343955
has type
  âˆ€ â¦ƒxâ‚‚ : Î±â¦„, xâ‚‚ âˆˆ ?m.343953 â†’ f ?m.343954 = f xâ‚‚ â†’ ?m.343954 = xâ‚‚","theorem Continuous.strictMonoOn_of_inj_rigidity {f : Î± â†’ Î´}
    (hf_c : Continuous f) (hf_i : Injective f) {a b : Î±} (hab : a < b)
    (hf_mono : StrictMonoOn f (Icc a b)) : StrictMono f ",":= by
  intro x y hxy
  let s := min a x
  let t := max b y
  have hsa : s â‰¤ a := min_le_left a x
  have hbt : b â‰¤ t := le_max_left b y
  have hst : s â‰¤ t := hsa.trans $ hbt.trans' hab.le
  have hf_mono_st : StrictMonoOn f (Icc s t) âˆ¨ StrictAntiOn f (Icc s t) := by
    letI := Icc.completeLinearOrder hst
    have := Continuous.strictMono_of_inj_boundedOrder' (f := Set.restrict (Icc s t) f)
      hf_c.continuousOn.restrict hf_i.injOn.injective
    exact this.imp strictMono_restrict.mp strictAntiOn_iff_strictAnti.mpr
  have (h : StrictAntiOn f (Icc s t)) : False := by
    have : Icc a b âŠ† Icc s t := Icc_subset_Icc hsa hbt
    replace : StrictAntiOn f (Icc a b) := StrictAntiOn.mono h this
    replace : IsAntichain (Â· â‰¤ Â·) (Icc a b) :=
      IsAntichain.of_strictMonoOn_antitoneOn hf_mono this.antitoneOn
    exact this.not_lt (left_mem_Icc.mpr (le_of_lt hab)) (right_mem_Icc.mpr (le_of_lt hab)) hab
  replace hf_mono_st : StrictMonoOn f (Icc s t) := hf_mono_st.resolve_right this
  have hsx : s â‰¤ x := min_le_right a x
  have hyt : y â‰¤ t := le_max_right b y
  replace : Icc x y âŠ† Icc s t := Icc_subset_Icc hsx hyt
  replace : StrictMonoOn f (Icc x y) := StrictMonoOn.mono hf_mono_st this
  exact this (left_mem_Icc.mpr (le_of_lt hxy)) (right_mem_Icc.mpr (le_of_lt hxy)) hxy"
Mathlib/NumberTheory/Padics/RingHoms.lean,PadicInt.dvd_appr_sub_appr,dvd_appr_sub_appr,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain âŸ¨k, rflâŸ© := Nat.exists_eq_add_of_le h; clear h
  induction' k with k ih
  Â· simp only [zero_eq, add_zero, le_refl, tsub_eq_zero_of_le, ne_eq, Nat.isUnit_iff, dvd_zero]
  rw [Nat.succ_eq_add_one, â† add_assoc]
  dsimp [appr]
  split_ifs with h
  Â· exact ih
  rw [add_comm, add_tsub_assoc_of_le (appr_mono _ (Nat.le_add_right m k))]
  apply dvd_add _ ih
  apply dvd_mul_of_dvd_left
  apply pow_dvd_pow _ (Nat.le_add_right m k)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case intro.succ
p : â„•
hp_prime : Fact (Nat.Prime p)
r : â„š
xâœ x : â„¤_[p]
m k : â„•
ih : p ^ m âˆ£ x.appr (m + k) - x.appr m
âŠ¢ p ^ m âˆ£ x.appr (m + (k + 1)) - x.appr m",theorem dvd_appr_sub_appr (x : â„¤_[p]) (m n : â„•) (h : m â‰¤ n) : p ^ m âˆ£ x.appr n - x.appr m ,":= by
  obtain âŸ¨k, rflâŸ© := Nat.exists_eq_add_of_le h; clear h
  induction' k with k ih
  Â· simp only [zero_eq, add_zero, le_refl, tsub_eq_zero_of_le, ne_eq, Nat.isUnit_iff, dvd_zero]
  rw [â† add_assoc]
  dsimp [appr]
  split_ifs with h
  Â· exact ih
  rw [add_comm, add_tsub_assoc_of_le (appr_mono _ (Nat.le_add_right m k))]
  apply dvd_add _ ih
  apply dvd_mul_of_dvd_left
  apply pow_dvd_pow _ (Nat.le_add_right m k)"
Mathlib/Geometry/Euclidean/Circumcenter.lean,EuclideanGeometry.existsUnique_dist_eq_of_insert,existsUnique_dist_eq_of_insert,df80f92cd37291ae10f3efaf1c701700cac70a5d,":= by
  haveI : Nonempty s := Set.Nonempty.to_subtype (hnps.mono hps)
  rcases hu with âŸ¨âŸ¨cc, crâŸ©, âŸ¨hcc, hcrâŸ©, hcccruâŸ©
  simp only at hcc hcr hcccru
  let x := dist cc (orthogonalProjection s p)
  let y := dist p (orthogonalProjection s p)
  have hy0 : y â‰  0 := dist_orthogonalProjection_ne_zero_of_not_mem hp
  let yccâ‚‚ := (x * x + y * y - cr * cr) / (2 * y)
  let ccâ‚‚ := (yccâ‚‚ / y) â€¢ (p -áµ¥ orthogonalProjection s p : V) +áµ¥ cc
  let crâ‚‚ := Real.sqrt (cr * cr + yccâ‚‚ * yccâ‚‚)
  use âŸ¨ccâ‚‚, crâ‚‚âŸ©
  simp (config := { zeta := false, proj := false }) only
  have hpo : p = (1 : â„) â€¢ (p -áµ¥ orthogonalProjection s p : V) +áµ¥ (orthogonalProjection s p : P) :=
    by simp
  constructor
  Â· constructor
    Â· refine' vadd_mem_of_mem_direction _ (mem_affineSpan â„ (Set.mem_insert_of_mem _ hcc))
      rw [direction_affineSpan]
      exact
        Submodule.smul_mem _ _
          (vsub_mem_vectorSpan â„ (Set.mem_insert _ _)
            (Set.mem_insert_of_mem _ (orthogonalProjection_mem _)))
    Â· intro p1 hp1
      rw [Sphere.mem_coe, mem_sphere, â† mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
        Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _))]
      cases' hp1 with hp1 hp1
      Â· rw [hp1]
        rw [hpo,
          dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd (orthogonalProjection_mem p) hcc _ _
            (vsub_orthogonalProjection_mem_direction_orthogonal s p),
          â† dist_eq_norm_vsub V p, dist_comm _ cc]
        field_simp [hy0]
        ring
      Â· rw [dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq _ (hps hp1),
          orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hcc, Subtype.coe_mk,
          dist_of_mem_subset_mk_sphere hp1 hcr, dist_eq_norm_vsub V ccâ‚‚ cc, vadd_vsub, norm_smul, â†
          dist_eq_norm_vsub V, Real.norm_eq_abs, abs_div, abs_of_nonneg dist_nonneg,
          div_mul_cancel _ hy0, abs_mul_abs_self]
  Â· rintro âŸ¨ccâ‚ƒ, crâ‚ƒâŸ© âŸ¨hccâ‚ƒ, hcrâ‚ƒâŸ©
    simp only at hccâ‚ƒ hcrâ‚ƒ
    obtain âŸ¨tâ‚ƒ, ccâ‚ƒ', hccâ‚ƒ', hccâ‚ƒ''âŸ© :
      âˆƒ r : â„, âˆƒ p0 âˆˆ s, ccâ‚ƒ = r â€¢ (p -áµ¥ â†‘((orthogonalProjection s) p)) +áµ¥ p0 := by
      rwa [mem_affineSpan_insert_iff (orthogonalProjection_mem p)] at hccâ‚ƒ
    have hcrâ‚ƒ' : âˆƒ r, âˆ€ p1 âˆˆ ps, dist p1 ccâ‚ƒ = r :=
      âŸ¨crâ‚ƒ, fun p1 hp1 => dist_of_mem_subset_mk_sphere (Set.mem_insert_of_mem _ hp1) hcrâ‚ƒâŸ©
    rw [exists_dist_eq_iff_exists_dist_orthogonalProjection_eq hps ccâ‚ƒ, hccâ‚ƒ'',
      orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hccâ‚ƒ'] at hcrâ‚ƒ'
    cases' hcrâ‚ƒ' with crâ‚ƒ' hcrâ‚ƒ'
    have hu := hcccru âŸ¨ccâ‚ƒ', crâ‚ƒ'âŸ©
    simp only at hu
    replace hu := hu âŸ¨hccâ‚ƒ', hcrâ‚ƒ'âŸ©
    cases' hu
    have hcrâ‚ƒval : crâ‚ƒ = Real.sqrt (cr * cr + tâ‚ƒ * y * (tâ‚ƒ * y)) := by
      cases' hnps with p0 hp0
      have h' : â†‘(âŸ¨cc, hccâ‚ƒ'âŸ© : s) = cc := rfl
      rw [â† dist_of_mem_subset_mk_sphere (Set.mem_insert_of_mem _ hp0) hcrâ‚ƒ, hccâ‚ƒ'', â†
        mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
        Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _)),
        dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq _ (hps hp0),
        orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hccâ‚ƒ', h',
        dist_of_mem_subset_mk_sphere hp0 hcr, dist_eq_norm_vsub V _ cc, vadd_vsub, norm_smul, â†
        dist_eq_norm_vsub V p, Real.norm_eq_abs, â† mul_assoc, mul_comm _ |tâ‚ƒ|, â† mul_assoc,
        abs_mul_abs_self]
      ring
    replace hcrâ‚ƒ := dist_of_mem_subset_mk_sphere (Set.mem_insert _ _) hcrâ‚ƒ
    rw [hpo, hccâ‚ƒ'', hcrâ‚ƒval, â† mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
      dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd (orthogonalProjection_mem p) hccâ‚ƒ' _ _
        (vsub_orthogonalProjection_mem_direction_orthogonal s p),
      dist_comm, â† dist_eq_norm_vsub V p,
      Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _))] at hcrâ‚ƒ
    change x * x + _ * (y * y) = _ at hcrâ‚ƒ
    rw [show
        x * x + (1 - tâ‚ƒ) * (1 - tâ‚ƒ) * (y * y) = x * x + y * y - 2 * y * (tâ‚ƒ * y) + tâ‚ƒ * y * (tâ‚ƒ * y)
        by ring,
      add_left_inj] at hcrâ‚ƒ
    have htâ‚ƒ : tâ‚ƒ = yccâ‚‚ / y := by
      field_simp [â† hcrâ‚ƒ, hy0]
      ring
    subst htâ‚ƒ
    change ccâ‚ƒ = ccâ‚‚ at hccâ‚ƒ''
    congr
    rw [hcrâ‚ƒval]
    congr 2
    field_simp [hy0]
    ring","info:  Try this: ring_nf
error:  unsolved goals
case h.left.right.inl
V : Type u_1
P : Type u_2
instâœâ´ : NormedAddCommGroup V
instâœÂ³ : InnerProductSpace â„ V
instâœÂ² : MetricSpace P
instâœÂ¹ : NormedAddTorsor V P
s : AffineSubspace â„ P
instâœ : HasOrthogonalProjection s.direction
ps : Set P
hnps : ps.Nonempty
p : P
hps : ps âŠ† â†‘s
hp : p âˆ‰ s
this : Nonempty â†¥s
cc : P
cr : â„
hcccru : âˆ€ (y : Sphere P), y.center âˆˆ s âˆ§ ps âŠ† Metric.sphere y.center y.radius â†’ y = { center := cc, radius := cr }
hcc : cc âˆˆ s
hcr : ps âŠ† Metric.sphere cc cr
x : â„ := dist cc â†‘((orthogonalProjection s) p)
y : â„ := dist p â†‘((orthogonalProjection s) p)
hy0 : y â‰  0
yccâ‚‚ : â„ := (x * x + y * y - cr * cr) / (2 * y)
ccâ‚‚ : P := (yccâ‚‚ / y) â€¢ (p -áµ¥ â†‘((orthogonalProjection s) p)) +áµ¥ cc
crâ‚‚ : â„ := âˆš(cr * cr + yccâ‚‚ * yccâ‚‚)
hpo : p = 1 â€¢ (p -áµ¥ â†‘((orthogonalProjection s) p)) +áµ¥ â†‘((orthogonalProjection s) p)
p1 : P
hp1 : p1 = p
âŠ¢ dist cc â†‘((orthogonalProjection s) p) ^ 2 - x ^ 2 * y * yâ»Â¹ + x ^ 2 * y ^ 2 * yâ»Â¹ ^ 2 * (1 / 2) +
                  x ^ 2 * cr ^ 2 * yâ»Â¹ ^ 2 * (-1 / 2) +
                x ^ 4 * yâ»Â¹ ^ 2 * (1 / 4) +
              y * cr ^ 2 * yâ»Â¹ +
            y ^ 2 +
          (y ^ 2 * cr ^ 2 * yâ»Â¹ ^ 2 * (-1 / 2) - y ^ 3 * yâ»Â¹) +
        y ^ 4 * yâ»Â¹ ^ 2 * (1 / 4) +
      cr ^ 4 * yâ»Â¹ ^ 2 * (1 / 4) =
    x ^ 2 * y ^ 2 * yâ»Â¹ ^ 2 * (1 / 2) + x ^ 2 * cr ^ 2 * yâ»Â¹ ^ 2 * (-1 / 2) + x ^ 4 * yâ»Â¹ ^ 2 * (1 / 4) +
            y ^ 2 * cr ^ 2 * yâ»Â¹ ^ 2 * (-1 / 2) +
          y ^ 4 * yâ»Â¹ ^ 2 * (1 / 4) +
        cr ^ 2 +
      cr ^ 4 * yâ»Â¹ ^ 2 * (1 / 4)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.52595 / ?m.52609 * ?m.52609
case h.left.right.inr
V : Type u_1
P : Type u_2
instâœâ´ : NormedAddCommGroup V
instâœÂ³ : InnerProductSpace â„ V
instâœÂ² : MetricSpace P
instâœÂ¹ : NormedAddTorsor V P
s : AffineSubspace â„ P
instâœ : HasOrthogonalProjection s.direction
ps : Set P
hnps : ps.Nonempty
p : P
hps : ps âŠ† â†‘s
hp : p âˆ‰ s
this : Nonempty â†¥s
cc : P
cr : â„
hcccru : âˆ€ (y : Sphere P), y.center âˆˆ s âˆ§ ps âŠ† Metric.sphere y.center y.radius â†’ y = { center := cc, radius := cr }
hcc : cc âˆˆ s
hcr : ps âŠ† Metric.sphere cc cr
x : â„ := dist cc â†‘((orthogonalProjection s) p)
y : â„ := dist p â†‘((orthogonalProjection s) p)
hy0 : y â‰  0
yccâ‚‚ : â„ := (x * x + y * y - cr * cr) / (2 * y)
ccâ‚‚ : P := (yccâ‚‚ / y) â€¢ (p -áµ¥ â†‘((orthogonalProjection s) p)) +áµ¥ cc
crâ‚‚ : â„ := âˆš(cr * cr + yccâ‚‚ * yccâ‚‚)
hpo : p = 1 â€¢ (p -áµ¥ â†‘((orthogonalProjection s) p)) +áµ¥ â†‘((orthogonalProjection s) p)
p1 : P
hp1 : p1 âˆˆ ps
âŠ¢ cr * cr +
      |yccâ‚‚| / dist p â†‘((orthogonalProjection s) p) * dist p â†‘((orthogonalProjection s) p) *
        (|yccâ‚‚| / dist p â†‘((orthogonalProjection s) p) * dist p â†‘((orthogonalProjection s) p)) =
    cr * cr + yccâ‚‚ * yccâ‚‚
error:  application type mismatch
  div_mul_cancel ?m.52595 hy0
argument
  hy0
has type
  y â‰  0 : Prop
but is expected to have type
  ?m.52593 : Type ?u.52592","theorem existsUnique_dist_eq_of_insert {s : AffineSubspace â„ P}
    [HasOrthogonalProjection s.direction] {ps : Set P} (hnps : ps.Nonempty) {p : P} (hps : ps âŠ† s)
    (hp : p âˆ‰ s) (hu : âˆƒ! cs : Sphere P, cs.center âˆˆ s âˆ§ ps âŠ† (cs : Set P)) :
    âˆƒ! csâ‚‚ : Sphere P,
      csâ‚‚.center âˆˆ affineSpan â„ (insert p (s : Set P)) âˆ§ insert p ps âŠ† (csâ‚‚ : Set P) ",":= by
  haveI : Nonempty s := Set.Nonempty.to_subtype (hnps.mono hps)
  rcases hu with âŸ¨âŸ¨cc, crâŸ©, âŸ¨hcc, hcrâŸ©, hcccruâŸ©
  simp only at hcc hcr hcccru
  let x := dist cc (orthogonalProjection s p)
  let y := dist p (orthogonalProjection s p)
  have hy0 : y â‰  0 := dist_orthogonalProjection_ne_zero_of_not_mem hp
  let yccâ‚‚ := (x * x + y * y - cr * cr) / (2 * y)
  let ccâ‚‚ := (yccâ‚‚ / y) â€¢ (p -áµ¥ orthogonalProjection s p : V) +áµ¥ cc
  let crâ‚‚ := âˆš(cr * cr + yccâ‚‚ * yccâ‚‚)
  use âŸ¨ccâ‚‚, crâ‚‚âŸ©
  simp (config := { zeta := false, proj := false }) only
  have hpo : p = (1 : â„) â€¢ (p -áµ¥ orthogonalProjection s p : V) +áµ¥ (orthogonalProjection s p : P) :=
    by simp
  constructor
  Â· constructor
    Â· refine vadd_mem_of_mem_direction ?_ (mem_affineSpan â„ (Set.mem_insert_of_mem _ hcc))
      rw [direction_affineSpan]
      exact
        Submodule.smul_mem _ _
          (vsub_mem_vectorSpan â„ (Set.mem_insert _ _)
            (Set.mem_insert_of_mem _ (orthogonalProjection_mem _)))
    Â· intro p1 hp1
      rw [Sphere.mem_coe, mem_sphere, â† mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
        Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _))]
      cases' hp1 with hp1 hp1
      Â· rw [hp1]
        rw [hpo,
          dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd (orthogonalProjection_mem p) hcc _ _
            (vsub_orthogonalProjection_mem_direction_orthogonal s p),
          â† dist_eq_norm_vsub V p, dist_comm _ cc]
        field_simp [yccâ‚‚, hy0]
        ring
      Â· rw [dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq _ (hps hp1),
          orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hcc, Subtype.coe_mk,
          dist_of_mem_subset_mk_sphere hp1 hcr, dist_eq_norm_vsub V ccâ‚‚ cc, vadd_vsub, norm_smul, â†
          dist_eq_norm_vsub V, Real.norm_eq_abs, abs_div, abs_of_nonneg dist_nonneg,
          div_mul_cancelâ‚€ _ hy0, abs_mul_abs_self]
  Â· rintro âŸ¨ccâ‚ƒ, crâ‚ƒâŸ© âŸ¨hccâ‚ƒ, hcrâ‚ƒâŸ©
    simp only at hccâ‚ƒ hcrâ‚ƒ
    obtain âŸ¨tâ‚ƒ, ccâ‚ƒ', hccâ‚ƒ', hccâ‚ƒ''âŸ© :
      âˆƒ r : â„, âˆƒ p0 âˆˆ s, ccâ‚ƒ = r â€¢ (p -áµ¥ â†‘((orthogonalProjection s) p)) +áµ¥ p0 := by
      rwa [mem_affineSpan_insert_iff (orthogonalProjection_mem p)] at hccâ‚ƒ
    have hcrâ‚ƒ' : âˆƒ r, âˆ€ p1 âˆˆ ps, dist p1 ccâ‚ƒ = r :=
      âŸ¨crâ‚ƒ, fun p1 hp1 => dist_of_mem_subset_mk_sphere (Set.mem_insert_of_mem _ hp1) hcrâ‚ƒâŸ©
    rw [exists_dist_eq_iff_exists_dist_orthogonalProjection_eq hps ccâ‚ƒ, hccâ‚ƒ'',
      orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hccâ‚ƒ'] at hcrâ‚ƒ'
    cases' hcrâ‚ƒ' with crâ‚ƒ' hcrâ‚ƒ'
    have hu := hcccru âŸ¨ccâ‚ƒ', crâ‚ƒ'âŸ©
    simp only at hu
    replace hu := hu âŸ¨hccâ‚ƒ', hcrâ‚ƒ'âŸ©
    cases' hu
    have hcrâ‚ƒval : crâ‚ƒ = âˆš(cr * cr + tâ‚ƒ * y * (tâ‚ƒ * y)) := by
      cases' hnps with p0 hp0
      have h' : â†‘(âŸ¨cc, hccâ‚ƒ'âŸ© : s) = cc := rfl
      rw [â† dist_of_mem_subset_mk_sphere (Set.mem_insert_of_mem _ hp0) hcrâ‚ƒ, hccâ‚ƒ'', â†
        mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
        Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _)),
        dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq _ (hps hp0),
        orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hccâ‚ƒ', h',
        dist_of_mem_subset_mk_sphere hp0 hcr, dist_eq_norm_vsub V _ cc, vadd_vsub, norm_smul, â†
        dist_eq_norm_vsub V p, Real.norm_eq_abs, â† mul_assoc, mul_comm _ |tâ‚ƒ|, â† mul_assoc,
        abs_mul_abs_self]
      ring
    replace hcrâ‚ƒ := dist_of_mem_subset_mk_sphere (Set.mem_insert _ _) hcrâ‚ƒ
    rw [hpo, hccâ‚ƒ'', hcrâ‚ƒval, â† mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),
      dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd (orthogonalProjection_mem p) hccâ‚ƒ' _ _
        (vsub_orthogonalProjection_mem_direction_orthogonal s p),
      dist_comm, â† dist_eq_norm_vsub V p,
      Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _))] at hcrâ‚ƒ
    change x * x + _ * (y * y) = _ at hcrâ‚ƒ
    rw [show
        x * x + (1 - tâ‚ƒ) * (1 - tâ‚ƒ) * (y * y) = x * x + y * y - 2 * y * (tâ‚ƒ * y) + tâ‚ƒ * y * (tâ‚ƒ * y)
        by ring,
      add_left_inj] at hcrâ‚ƒ
    have htâ‚ƒ : tâ‚ƒ = yccâ‚‚ / y := by field_simp [yccâ‚‚, â† hcrâ‚ƒ, hy0]
    subst htâ‚ƒ
    change ccâ‚ƒ = ccâ‚‚ at hccâ‚ƒ''
    congr
    rw [hcrâ‚ƒval]
    congr 2
    field_simp [hy0]"
Mathlib/Topology/Homotopy/HomotopyGroup.lean,GenLoop.homotopicFrom,homotopicFrom,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  refine' Nonempty.map fun H => âŸ¨âŸ¨homotopyFrom i H, _, _âŸ©, _âŸ©
  pick_goal 3
  Â· rintro t y âŸ¨j, jHâŸ©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    Â· rw [H.eq_fst]; exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    Â· rw [p.2 _ âŸ¨j, jHâŸ©]; apply boundary; exact âŸ¨âŸ¨j, hâŸ©, jHâŸ©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    first
    | rw [H.apply_zero]
    | rw [H.apply_one]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv","warning:  GenLoop does not have a doc string
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  H (?t, ?x)
case refine'_3.intro.inl
N : Type u_1
X : Type u_2
instâœÂ¹ : TopologicalSpace X
x : X
instâœ : DecidableEq N
p q : â†‘(Î©^ N X x)
t : â†‘I
y : N â†’ â†‘I
j : N
jH : y j = 0 âˆ¨ y j = 1
H : Path.Homotopy (toLoop j p) (toLoop j q)
âŠ¢ Function.uncurry (fun x_1 y â†¦ Function.uncurry (fun x_2 y â†¦ â†‘(H (x_1, x_2)) y) y)
      (Prod.map id â‡‘(Cube.splitAt j).toContinuousMap (t, y)) =
    â†‘p y
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  H (1, ?x)
case refine'_1
N : Type u_1
X : Type u_2
instâœÂ¹ : TopologicalSpace X
x : X
instâœ : DecidableEq N
i : N
p q : â†‘(Î©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
xâœ : N â†’ â†‘I
âŠ¢ Function.uncurry (fun x_1 y â†¦ Function.uncurry (fun x_2 y â†¦ â†‘(H (x_1, x_2)) y) y)
      (Prod.map id â‡‘(Cube.splitAt i).toContinuousMap (0, xâœ)) =
    â†‘p xâœ
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  H (1, ?x)
case refine'_2
N : Type u_1
X : Type u_2
instâœÂ¹ : TopologicalSpace X
x : X
instâœ : DecidableEq N
i : N
p q : â†‘(Î©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
xâœ : N â†’ â†‘I
âŠ¢ Function.uncurry (fun x_1 y â†¦ Function.uncurry (fun x_2 y â†¦ â†‘(H (x_1, x_2)) y) y)
      (Prod.map id â‡‘(Cube.splitAt i).toContinuousMap (1, xâœ)) =
    â†‘q xâœ
error:  unsolved goals
case refine'_1
N : Type u_1
X : Type u_2
instâœÂ¹ : TopologicalSpace X
x : X
instâœ : DecidableEq N
i : N
p q : â†‘(Î©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
âŠ¢ âˆ€ (x_1 : N â†’ â†‘I), (homotopyFrom i H).toFun (0, x_1) = â†‘p x_1

case refine'_2
N : Type u_1
X : Type u_2
instâœÂ¹ : TopologicalSpace X
x : X
instâœ : DecidableEq N
i : N
p q : â†‘(Î©^ N X x)
H : Path.Homotopy (toLoop i p) (toLoop i q)
âŠ¢ âˆ€ (x_1 : N â†’ â†‘I), (homotopyFrom i H).toFun (1, x_1) = â†‘q x_1","theorem homotopicFrom (i : N) {p q : Î©^ N X x} :
    (toLoop i p).Homotopic (toLoop i q) â†’ Homotopic p q ",":= by
  refine Nonempty.map fun H => âŸ¨âŸ¨homotopyFrom i H, ?_, ?_âŸ©, ?_âŸ©
  pick_goal 3
  Â· rintro t y âŸ¨j, jHâŸ©
    erw [homotopyFrom_apply]
    obtain rfl | h := eq_or_ne j i
    Â· simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
        Function.uncurry_apply_pair]
      rw [H.eq_fst]
      exacts [congr_arg p ((Cube.splitAt j).left_inv _), jH]
    Â· rw [p.2 _ âŸ¨j, jHâŸ©]; apply boundary; exact âŸ¨âŸ¨j, hâŸ©, jHâŸ©
  all_goals
    intro
    apply (homotopyFrom_apply _ _ _).trans
    simp only [Prod.map_apply, id_eq, toContinuousMap_apply, funSplitAt_apply,
      Function.uncurry_apply_pair, ContinuousMap.HomotopyWith.apply_zero,
      ContinuousMap.HomotopyWith.apply_one, ne_eq, Path.coe_toContinuousMap, toLoop_apply_coe,
      ContinuousMap.curry_apply, ContinuousMap.comp_apply]
    first
    | apply congr_arg p
    | apply congr_arg q
    apply (Cube.splitAt i).left_inv"
Mathlib/Combinatorics/SimpleGraph/Regularity/Lemma.lean,szemeredi_regularity,szemeredi_regularity,b3a26fbcc3f3c303f13e9efc3404d0dd64c32dfc,":= by
  obtain hÎ± | hÎ± := le_total (card Î±) (bound Îµ l)
  Â· refine' âŸ¨âŠ¥, bot_isEquipartition _, _âŸ©
    rw [card_bot, card_univ]
    exact âŸ¨hl, hÎ±, botIsUniform _ hÎµâŸ©
  let t := initialBound Îµ l
  have htÎ± : t â‰¤ (univ : Finset Î±).card :=
    (initialBound_le_bound _ _).trans (by rwa [Finset.card_univ])
  obtain âŸ¨dum, hdumâ‚, hdumâ‚‚âŸ© :=
    exists_equipartition_card_eq (univ : Finset Î±) (initialBound_pos _ _).ne' htÎ±
  obtain hÎµâ‚ | hÎµâ‚ := le_total 1 Îµ
  Â· exact âŸ¨dum, hdumâ‚, (le_initialBound Îµ l).trans hdumâ‚‚.ge,
      hdumâ‚‚.le.trans (initialBound_le_bound Îµ l), (dum.isUniformOne G).mono hÎµâ‚âŸ©
  have : Nonempty Î± := by
    rw [â† Fintype.card_pos_iff]
    exact (bound_pos _ _).trans_le hÎ±
  suffices h : âˆ€ i, âˆƒ P : Finpartition (univ : Finset Î±), P.IsEquipartition âˆ§ t â‰¤ P.parts.card âˆ§
    P.parts.card â‰¤ (stepBound^[i]) t âˆ§ (P.IsUniform G Îµ âˆ¨ Îµ ^ 5 / 4 * i â‰¤ P.energy G)
  Â· obtain âŸ¨P, hPâ‚, hPâ‚‚, hPâ‚ƒ, hPâ‚„âŸ© := h (âŒŠ4 / Îµ ^ 5âŒ‹â‚Š + 1)
    refine' âŸ¨P, hPâ‚, (le_initialBound _ _).trans hPâ‚‚, hPâ‚ƒ.trans _,
      hPâ‚„.resolve_right fun hPenergy => lt_irrefl (1 : â„) _âŸ©
    Â· rw [iterate_succ_apply']
      exact mul_le_mul_left' (pow_le_pow_of_le_left (by norm_num) (by norm_num) _) _
    calc
      (1 : â„) = Îµ ^ 5 / â†‘4 * (â†‘4 / Îµ ^ 5) := by
        rw [mul_comm, div_mul_div_cancel 4 (pow_pos hÎµ 5).ne']; norm_num
      _ < Îµ ^ 5 / 4 * (âŒŠ4 / Îµ ^ 5âŒ‹â‚Š + 1) :=
        ((mul_lt_mul_left <| by positivity).2 (Nat.lt_floor_add_one _))
      _ â‰¤ (P.energy G : â„) := by rwa [â† Nat.cast_add_one]
      _ â‰¤ 1 := by exact_mod_cast P.energy_le_one G
  intro i
  induction' i with i ih
  Â· refine' âŸ¨dum, hdumâ‚, hdumâ‚‚.ge, hdumâ‚‚.le, Or.inr _âŸ©
    rw [Nat.cast_zero, MulZeroClass.mul_zero]
    exact_mod_cast dum.energy_nonneg G
  obtain âŸ¨P, hPâ‚, hPâ‚‚, hPâ‚ƒ, hPâ‚„âŸ© := ih
  by_cases huniform : P.IsUniform G Îµ
  Â· refine' âŸ¨P, hPâ‚, hPâ‚‚, _, Or.inl huniformâŸ©
    rw [iterate_succ_apply']
    exact hPâ‚ƒ.trans (le_stepBound _)
  replace hPâ‚„ := hPâ‚„.resolve_left huniform
  have hÎµl' : â†‘100 < â†‘4 ^ P.parts.card * Îµ ^ 5 :=
    (hundred_lt_pow_initialBound_mul hÎµ l).trans_le
      (mul_le_mul_of_nonneg_right (pow_le_pow (by norm_num) hPâ‚‚) <| by positivity)
  have hi : (i : â„) â‰¤ 4 / Îµ ^ 5 := by
    have hi : Îµ ^ 5 / 4 * â†‘i â‰¤ 1 := hPâ‚„.trans (by exact_mod_cast P.energy_le_one G)
    rw [div_mul_eq_mul_div, div_le_iff (show (0 : â„) < 4 by norm_num)] at hi
    norm_num at hi
    rwa [le_div_iff' (pow_pos hÎµ _)]
  have hsize : P.parts.card â‰¤ (stepBound^[âŒŠ4 / Îµ ^ 5âŒ‹â‚Š]) t :=
    hPâ‚ƒ.trans (monotone_iterate_of_id_le le_stepBound (Nat.le_floor hi) _)
  have hPÎ± : P.parts.card * 16 ^ P.parts.card â‰¤ card Î± :=
    (Nat.mul_le_mul hsize (Nat.pow_le_pow_of_le_right (by norm_num) hsize)).trans hÎ±
  refine' âŸ¨increment hPâ‚ G Îµ, increment_isEquipartition hPâ‚ G Îµ, _, _, Or.inr <| le_trans _ <|
    energy_increment hPâ‚ ((seven_le_initialBound Îµ l).trans hPâ‚‚) hÎµl' hPÎ± huniform hÎµâ‚âŸ©
  Â· rw [card_increment hPÎ± huniform]
    exact hPâ‚‚.trans (le_stepBound _)
  Â· rw [card_increment hPÎ± huniform, iterate_succ_apply']
    exact stepBound_mono hPâ‚ƒ
  Â· rw [Nat.cast_succ, mul_add, mul_one]
    exact add_le_add_right hPâ‚„ _",error:  unexpected token 'Â·'; expected 'by' or 'from',"theorem szemeredi_regularity (hÎµ : 0 < Îµ) (hl : l â‰¤ card Î±) :
    âˆƒ P : Finpartition univ,
      P.IsEquipartition âˆ§ l â‰¤ P.parts.card âˆ§ P.parts.card â‰¤ bound Îµ l âˆ§ P.IsUniform G Îµ ",":= by
  obtain hÎ± | hÎ± := le_total (card Î±) (bound Îµ l)
  Â· refine âŸ¨âŠ¥, bot_isEquipartition _, ?_âŸ©
    rw [card_bot, card_univ]
    exact âŸ¨hl, hÎ±, bot_isUniform _ hÎµâŸ©
  let t := initialBound Îµ l
  have htÎ± : t â‰¤ (univ : Finset Î±).card :=
    (initialBound_le_bound _ _).trans (by rwa [Finset.card_univ])
  obtain âŸ¨dum, hdumâ‚, hdumâ‚‚âŸ© :=
    exists_equipartition_card_eq (univ : Finset Î±) (initialBound_pos _ _).ne' htÎ±
  obtain hÎµâ‚ | hÎµâ‚ := le_total 1 Îµ
  Â· exact âŸ¨dum, hdumâ‚, (le_initialBound Îµ l).trans hdumâ‚‚.ge,
      hdumâ‚‚.le.trans (initialBound_le_bound Îµ l), (dum.isUniform_one G).mono hÎµâ‚âŸ©
  have : Nonempty Î± := by
    rw [â† Fintype.card_pos_iff]
    exact (bound_pos _ _).trans_le hÎ±
  suffices h : âˆ€ i, âˆƒ P : Finpartition (univ : Finset Î±), P.IsEquipartition âˆ§ t â‰¤ P.parts.card âˆ§
    P.parts.card â‰¤ stepBound^[i] t âˆ§ (P.IsUniform G Îµ âˆ¨ Îµ ^ 5 / 4 * i â‰¤ P.energy G) by
    obtain âŸ¨P, hPâ‚, hPâ‚‚, hPâ‚ƒ, hPâ‚„âŸ© := h (âŒŠ4 / Îµ ^ 5âŒ‹â‚Š + 1)
    refine âŸ¨P, hPâ‚, (le_initialBound _ _).trans hPâ‚‚, hPâ‚ƒ.trans ?_,
      hPâ‚„.resolve_right fun hPenergy => lt_irrefl (1 : â„) ?_âŸ©
    Â· rw [iterate_succ_apply']
      exact mul_le_mul_left' (pow_le_pow_left (by norm_num) (by norm_num) _) _
    calc
      (1 : â„) = Îµ ^ 5 / â†‘4 * (â†‘4 / Îµ ^ 5) := by
        rw [mul_comm, div_mul_div_cancel 4 (pow_pos hÎµ 5).ne']; norm_num
      _ < Îµ ^ 5 / 4 * (âŒŠ4 / Îµ ^ 5âŒ‹â‚Š + 1) :=
        ((mul_lt_mul_left <| by positivity).2 (Nat.lt_floor_add_one _))
      _ â‰¤ (P.energy G : â„) := by rwa [â† Nat.cast_add_one]
      _ â‰¤ 1 := mod_cast P.energy_le_one G
  intro i
  induction' i with i ih
  Â· refine âŸ¨dum, hdumâ‚, hdumâ‚‚.ge, hdumâ‚‚.le, Or.inr ?_âŸ©
    rw [Nat.cast_zero, mul_zero]
    exact mod_cast dum.energy_nonneg G
  obtain âŸ¨P, hPâ‚, hPâ‚‚, hPâ‚ƒ, hPâ‚„âŸ© := ih
  by_cases huniform : P.IsUniform G Îµ
  Â· refine âŸ¨P, hPâ‚, hPâ‚‚, ?_, Or.inl huniformâŸ©
    rw [iterate_succ_apply']
    exact hPâ‚ƒ.trans (le_stepBound _)
  replace hPâ‚„ := hPâ‚„.resolve_left huniform
  have hÎµl' : 100 â‰¤ 4 ^ P.parts.card * Îµ ^ 5 :=
    (hundred_lt_pow_initialBound_mul hÎµ l).le.trans
      (mul_le_mul_of_nonneg_right (pow_le_pow_right (by norm_num) hPâ‚‚) <| by positivity)
  have hi : (i : â„) â‰¤ 4 / Îµ ^ 5 := by
    have hi : Îµ ^ 5 / 4 * â†‘i â‰¤ 1 := hPâ‚„.trans (mod_cast P.energy_le_one G)
    rw [div_mul_eq_mul_div, div_le_iff (show (0 : â„) < 4 by norm_num)] at hi
    norm_num at hi
    rwa [le_div_iff' (pow_pos hÎµ _)]
  have hsize : P.parts.card â‰¤ stepBound^[âŒŠ4 / Îµ ^ 5âŒ‹â‚Š] t :=
    hPâ‚ƒ.trans (monotone_iterate_of_id_le le_stepBound (Nat.le_floor hi) _)
  have hPÎ± : P.parts.card * 16 ^ P.parts.card â‰¤ card Î± :=
    (Nat.mul_le_mul hsize (Nat.pow_le_pow_of_le_right (by norm_num) hsize)).trans hÎ±
  refine âŸ¨increment hPâ‚ G Îµ, increment_isEquipartition hPâ‚ G Îµ, ?_, ?_, Or.inr <| le_trans ?_ <|
    energy_increment hPâ‚ ((seven_le_initialBound Îµ l).trans hPâ‚‚) hÎµl' hPÎ± huniform hÎµ.le hÎµâ‚âŸ©
  Â· rw [card_increment hPÎ± huniform]
    exact hPâ‚‚.trans (le_stepBound _)
  Â· rw [card_increment hPÎ± huniform, iterate_succ_apply']
    exact stepBound_mono hPâ‚ƒ
  Â· rw [Nat.cast_succ, mul_add, mul_one]
    exact add_le_add_right hPâ‚„ _"
Mathlib/GroupTheory/Index.lean,Subgroup.index_eq_two_iff,index_eq_two_iff,8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85,":= by
  simp only [index, Nat.card_eq_two_iff' ((1 : G) : G â§¸ H), ExistsUnique, inv_mem_iff,
    QuotientGroup.exists_mk, QuotientGroup.forall_mk, Ne, QuotientGroup.eq, mul_one,
    xor_iff_iff_not]
  refine exists_congr fun a =>
    âŸ¨fun ha b => âŸ¨fun hba hb => ?_, fun hb => ?_âŸ©, fun ha => ?âŸ¨_, fun b hb ?=> _âŸ©âŸ©
  Â· exact ha.1 ((mul_mem_cancel_left hb).1 hba)
  Â· exact inv_inv b â–¸ ha.2 _ (mt (inv_mem_iff (x := b)).1 hb)
  Â· rw [â† inv_mem_iff (x := a), â† ha, inv_mul_self]
    exact one_mem _
  Â· rwa [ha, inv_mem_iff (x := b)]","error:  unexpected token 'âŸ¨'; expected '_' or identifier
error:  unsolved goals
case refine_1
G : Type u_1
instâœ : Group G
H K L : Subgroup G
a : G
ha : a âˆ‰ H âˆ§ âˆ€ x âˆ‰ H, xâ»Â¹ * a âˆˆ H
b : G
hba : b * a âˆˆ H
hb : b âˆˆ H
âŠ¢ False

case refine_2
G : Type u_1
instâœ : Group G
H K L : Subgroup G
a : G
ha : a âˆ‰ H âˆ§ âˆ€ x âˆ‰ H, xâ»Â¹ * a âˆˆ H
b : G
hb : b âˆ‰ H
âŠ¢ b * a âˆˆ H

case refine_3
G : Type u_1
instâœ : Group G
H K L : Subgroup G
a : G
ha : âˆ€ (b : G), b * a âˆˆ H â†” b âˆ‰ H
âŠ¢ a âˆ‰ H âˆ§ âˆ€ x âˆ‰ H, xâ»Â¹ * a âˆˆ H","theorem index_eq_two_iff : H.index = 2 â†” âˆƒ a, âˆ€ b, Xor' (b * a âˆˆ H) (b âˆˆ H) ",":= by
  simp only [index, Nat.card_eq_two_iff' ((1 : G) : G â§¸ H), ExistsUnique, inv_mem_iff,
    QuotientGroup.exists_mk, QuotientGroup.forall_mk, Ne, QuotientGroup.eq, mul_one,
    xor_iff_iff_not]
  refine exists_congr fun a =>
    âŸ¨fun ha b => âŸ¨fun hba hb => ?_, fun hb => ?_âŸ©, fun ha => âŸ¨?_, fun b hb => ?_âŸ©âŸ©
  Â· exact ha.1 ((mul_mem_cancel_left hb).1 hba)
  Â· exact inv_inv b â–¸ ha.2 _ (mt (inv_mem_iff (x := b)).1 hb)
  Â· rw [â† inv_mem_iff (x := a), â† ha, inv_mul_self]
    exact one_mem _
  Â· rwa [ha, inv_mem_iff (x := b)]"
Mathlib/FieldTheory/Minpoly/Basic.lean,minpoly.min,min,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  refine' dif_ctx_congr (isIntegral_algHom_iff _ hf) (fun _ => _) fun _ => rfl
  simp_rw [â† Polynomial.aeval_def, aeval_algHom, AlgHom.comp_apply, _root_.map_eq_zero_iff f hf]",error:  unknown identifier 'hf',"theorem min {p : A[X]} (pmonic : p.Monic) (hp : Polynomial.aeval x p = 0) :
    degree (minpoly A x) â‰¤ degree p ",":= by
  delta minpoly; split_ifs with hx
  Â· exact le_of_not_lt (degree_lt_wf.not_lt_min _ hx âŸ¨pmonic, hpâŸ©)
  Â· simp only [degree_zero, bot_le]"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine' âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, _âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, âŸ¨_, _, _âŸ©, _âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 âˆˆ ?m.116759 âˆª ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120516 â†’ ?m.120516
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.124403 â†’ ?m.124403
error:  unsolved goals
case zero
Î± : Type u_1
instâœâµ : MetricSpace Î±
Î² : Type u
instâœâ´ : SecondCountableTopology Î±
instâœÂ³ : MeasurableSpace Î±
instâœÂ² : OpensMeasurableSpace Î±
instâœÂ¹ : HasBesicovitchCovering Î±
Î¼ : Measure Î±
instâœ : IsFiniteMeasure Î¼
f : Î± â†’ Set â„
s : Set Î±
hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty
N : â„•
Ï„ : â„
hÏ„ : 1 < Ï„
hN : IsEmpty (SatelliteConfig Î± N Ï„)
P : Finset (Î± Ã— â„) â†’ Prop :=
  fun t â†¦ ((â†‘t).PairwiseDisjoint fun p â†¦ closedBall p.1 p.2) âˆ§ (âˆ€ p âˆˆ t, p.1 âˆˆ s) âˆ§ âˆ€ p âˆˆ t, p.2 âˆˆ f p.1
F : Finset (Î± Ã— â„) â†’ Finset (Î± Ã— â„)
hF :
  âˆ€ (t : Finset (Î± Ã— â„)),
    P t â†’
      t âŠ† F t âˆ§ P (F t) âˆ§ Î¼ (s \ â‹ƒ p âˆˆ F t, closedBall p.1 p.2) â‰¤ â†‘N / (â†‘N + 1) * Î¼ (s \ â‹ƒ p âˆˆ t, closedBall p.1 p.2)
u : â„• â†’ Finset (Î± Ã— â„) := fun n â†¦ F^[n] âˆ…
u_succ : âˆ€ (n : â„•), u n.succ = F (u n)
Pu : âˆ€ (n : â„•), P (u n)
A : âˆ€ (n : â„•), Î¼ (s \ â‹ƒ p âˆˆ â‹ƒ n, â†‘(u n), closedBall p.1 p.2) â‰¤ Î¼ (s \ â‹ƒ p âˆˆ u n, closedBall p.1 p.2)
âŠ¢ Î¼ (s \ â‹ƒ p âˆˆ id âˆ…, closedBall p.1 p.2) â‰¤ Î¼ s
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.132197 â†’ ?m.132197 â†’ Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.132333 â†’ ?m.132333 â†’ Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Î¼ : Measure Î±)
    [IsFiniteMeasure Î¼] (f : Î± â†’ Set â„) (s : Set Î±)
    (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty) :
    âˆƒ t : Set (Î± Ã— â„), t.Countable âˆ§ (âˆ€ p âˆˆ t, p.1 âˆˆ s) âˆ§ (âˆ€ p âˆˆ t, p.2 âˆˆ f p.1) âˆ§
      Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) = 0 âˆ§
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, ?_âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, âŸ¨?_, ?_, ?_âŸ©, ?_âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Î¼ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/Combinatorics/SimpleGraph/Triangle/Basic.lean,SimpleGraph.EdgeDisjointTriangles.map,EdgeDisjointTriangles.map,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [EdgeDisjointTriangles, cliqueSet_map (by norm_num : 3 â‰  1),
    ((Finset.map_injective f).injOn _).pairwise_image]
  classical
  rintro s hs t ht hst
  dsimp [Function.onFun]
  rw [â† coe_inter, â† map_inter, coe_map, coe_inter]
  exact (hG hs ht hst).image _","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Function.Injective.injOn (Finset.map_injective f) ?m.2746
has type
  âˆ€ â¦ƒxâ‚‚ : Finset Î±â¦„, xâ‚‚ âˆˆ ?m.2744 â†’ Finset.map f ?m.2745 = Finset.map f xâ‚‚ â†’ ?m.2745 = xâ‚‚
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.2748
Î± : Type u_1
Î² : Type u_2
ğ•œ : Type u_3
instâœ : LinearOrderedField ğ•œ
G H : SimpleGraph Î±
Îµ Î´ : ğ•œ
n : â„•
s : Finset Î±
f : Î± â†ª Î²
hG : G.EdgeDisjointTriangles
âŠ¢ (Finset.map f '' G.cliqueSet 3).Pairwise fun x y â†¦ (â†‘x âˆ© â†‘y).Subsingleton","lemma EdgeDisjointTriangles.map (f : Î± â†ª Î²) (hG : G.EdgeDisjointTriangles) :
    (G.map f).EdgeDisjointTriangles ",":= by
  rw [EdgeDisjointTriangles, cliqueSet_map (by norm_num : 3 â‰  1),
    (Finset.map_injective f).injOn.pairwise_image]
  classical
  rintro s hs t ht hst
  dsimp [Function.onFun]
  rw [â† coe_inter, â† map_inter, coe_map, coe_inter]
  exact (hG hs ht hst).image _"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim_aux,LinearIsometryEquiv.reflections_generate_dim_aux,3cb2bdef8481160ee4f3f3a94fca1f5824c2798a,":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine âŸ¨[], rfl.le, show Ï† = 1 from ?_âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [Nat.zero_eq, Nat.le_zero, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      omega
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine' âŸ¨x::l, Nat.succ_le_succ hl, _âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâµ : _root_.RCLike ğ•œ
instâœâ´ : NormedAddCommGroup E
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : InnerProductSpace ğ•œ E
instâœÂ¹ : InnerProductSpace â„ F
K : Submodule ğ•œ E
instâœ : FiniteDimensional â„ F
Ï† : F â‰ƒâ‚—áµ¢[â„] F
hn :
  finrank â„
      â†¥(LinearMap.ker
            (ContinuousLinearMap.id â„ F -
              â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }))á—® â‰¤
    0
âŠ¢ LinearMap.ker
      (ContinuousLinearMap.id â„ F -
        â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }) =
    âŠ¤","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional â„ F] {n : â„•}
    (Ï† : F â‰ƒâ‚—áµ¢[â„] F) (hn : finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—® â‰¤ n) :
    âˆƒ l : List F, l.length â‰¤ n âˆ§ Ï† = (l.map fun v => reflection (â„ âˆ™ v)á—®).prod ",":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine âŸ¨[], rfl.le, show Ï† = 1 from ?_âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      omega
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine âŸ¨x::l, Nat.succ_le_succ hl, ?_âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this"
Mathlib/Topology/Category/Stonean/EffectiveEpi.lean,Stonean.effectiveEpi_tfae,effectiveEpi_tfae,58de6a1c33e964db25c184d0d1809e6b5b414b50,":= by
  tfae_have : 1 â†’ 2
  | _ => inferInstance
  tfae_have : 2 â†” 3 := epi_iff_surjective Ï€
  tfae_have : 3 â†’ 1 := fun hÏ€ â†¦ âŸ¨âŸ¨struct Ï€ hÏ€âŸ©âŸ©
  tfae_finish",error:  unexpected token ':'; expected numeral,"theorem effectiveEpi_tfae
    {B X : Stonean.{u}} (Ï€ : X âŸ¶ B) :
    TFAE
    [ EffectiveEpi Ï€
    , Epi Ï€
    , Function.Surjective Ï€
    ] ",":= by
  tfae_have 1 â†’ 2
  Â· intro; infer_instance
  tfae_have 2 â†” 3
  Â· exact epi_iff_surjective Ï€
  tfae_have 3 â†’ 1
  Â· exact fun hÏ€ â†¦ âŸ¨âŸ¨struct Ï€ hÏ€âŸ©âŸ©
  tfae_finish"
Mathlib/CategoryTheory/Localization/Triangulated.lean,CategoryTheory.Triangulated.Localization.distinguished_cocone_triangle,distinguished_cocone_triangle,660d4d5e85504851f32fdcb363260a8048d0609c,:= by,"error:  unexpected token 'lemma'; expected '{' or tactic
error:  unsolved goals
C : Type u_1
D : Type u_2
instâœÂ¹âµ : Category.{u_4, u_1} C
instâœÂ¹â´ : Category.{u_3, u_2} D
L : C â¥¤ D
instâœÂ¹Â³ : HasShift C â„¤
instâœÂ¹Â² : Preadditive C
instâœÂ¹Â¹ : HasZeroObject C
instâœÂ¹â° : âˆ€ (n : â„¤), (shiftFunctor C n).Additive
instâœâ¹ : Pretriangulated C
instâœâ¸ : HasShift D â„¤
instâœâ· : L.CommShift â„¤
W : MorphismProperty C
instâœâ¶ : L.IsLocalization W
instâœâµ : W.IsCompatibleWithTriangulation
instâœâ´ : W.HasLeftCalculusOfFractions
instâœÂ³ : Preadditive D
instâœÂ² : HasZeroObject D
instâœÂ¹ : âˆ€ (n : â„¤), (shiftFunctor D n).Additive
instâœ : L.Additive
X Y : D
f : X âŸ¶ Y
âŠ¢ âˆƒ Z g h, Triangle.mk f g h âˆˆ L.essImageDistTriang
error:  application type mismatch
  distinguished_cocone_triangle L W
argument
  W
has type
  MorphismProperty C : Type (max u_1 ?u.75958)
but is expected to have type
  ?m.77184 âŸ¶ ?m.77185 : Type ?u.75962","lemma distinguished_cocone_triangle {X Y : D} (f : X âŸ¶ Y) :
    âˆƒ (Z : D) (g : Y âŸ¶ Z) (h : Z âŸ¶ XâŸ¦(1 : â„¤)âŸ§),
      Triangle.mk f g h âˆˆ L.essImageDistTriang ",":= by
  have := essSurj_mapArrow L W
  obtain âŸ¨Ï†, âŸ¨eâŸ©âŸ© : âˆƒ (Ï† : Arrow C), Nonempty (L.mapArrow.obj Ï† â‰… Arrow.mk f) :=
    âŸ¨_, âŸ¨Functor.objObjPreimageIso _ _âŸ©âŸ©
  obtain âŸ¨Z, g, h, HâŸ© := Pretriangulated.distinguished_cocone_triangle Ï†.hom
  refine âŸ¨L.obj Z, e.inv.right â‰« L.map g,
    L.map h â‰« (L.commShiftIso (1 : â„¤)).hom.app _ â‰« e.hom.leftâŸ¦(1 : â„¤)âŸ§', _, ?_, HâŸ©
  refine Triangle.isoMk _ _ (Arrow.leftFunc.mapIso e.symm) (Arrow.rightFunc.mapIso e.symm)
    (Iso.refl _) e.inv.w.symm (by simp) ?_
  dsimp
  simp only [assoc, id_comp, â† Functor.map_comp, â† Arrow.comp_left, e.hom_inv_id, Arrow.id_left,
    Functor.mapArrow_obj_left, Functor.map_id, comp_id]"
Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean,AbsoluteValue.IsAdmissible.exists_approx_aux,exists_approx_aux,61ca0ea882c23bb336df737657ab5b9a48ebdbbe,":= by
  haveI := Classical.decEq R
  induction' n with n ih
  Â· intro Îµ _hÎµ b _hb A
    refine' âŸ¨0, 1, _, _âŸ©
    Â· simp
    rintro âŸ¨i, âŸ¨âŸ©âŸ©
  intro Îµ hÎµ b hb A
  let M := h.card Îµ
  obtain âŸ¨s, s_inj, hsâŸ© :
    âˆƒ s : Fin (M ^ n).succ â†’ Fin (M ^ n.succ).succ,
      Function.Injective s âˆ§ âˆ€ iâ‚€ iâ‚, (abv (A (s iâ‚) 0 % b - A (s iâ‚€) 0 % b) : â„) < abv b â€¢ Îµ :=
    by
    obtain âŸ¨t, htâŸ© :
      âˆƒ t : Fin (M ^ n.succ).succ â†’ Fin M,
        âˆ€ iâ‚€ iâ‚, t iâ‚€ = t iâ‚ â†’ (abv (A iâ‚ 0 % b - A iâ‚€ 0 % b) : â„) < abv b â€¢ Îµ :=
      h.exists_partition hÎµ hb fun x â†¦ A x 0
    obtain âŸ¨s, hsâŸ© :=
      @Fintype.exists_lt_card_fiber_of_mul_lt_card _ _ _ _ _ t (M ^ n)
        (by simpa only [Fintype.card_fin, pow_succ] using Nat.lt_succ_self (M ^ n.succ))
    refine'
      âŸ¨fun i â†¦ (Finset.univ.filter fun x â†¦ t x = s).toList.nthLe i _, _, fun iâ‚€ iâ‚ â†¦ ht _ _ _âŸ©
    Â· refine' i.2.trans_le _
      rwa [Finset.length_toList]
    Â· intro i j h
      ext
      exact Fin.mk.inj_iff.mp (List.nodup_iff_injective_get.mp (Finset.nodup_toList _) h)
    have :
      âˆ€ i h,
        (Finset.univ.filter fun x â†¦ t x = s).toList.nthLe i h âˆˆ
          Finset.univ.filter fun x â†¦ t x = s :=
      by
      intro i h
      exact Finset.mem_toList.mp (List.get_mem _ i h)
    obtain âŸ¨_, hâ‚€âŸ© := Finset.mem_filter.mp (this iâ‚€ _)
    obtain âŸ¨_, hâ‚âŸ© := Finset.mem_filter.mp (this iâ‚ _)
    exact hâ‚€.trans hâ‚.symm
  obtain âŸ¨kâ‚€, kâ‚, hk, hâŸ© := ih hÎµ hb fun x â†¦ Fin.tail (A (s x))
  refine' âŸ¨s kâ‚€, s kâ‚, fun h â†¦ hk (s_inj h), fun i â†¦ Fin.cases _ (fun i â†¦ _) iâŸ©
  Â· exact hs kâ‚€ kâ‚
  Â· exact h i","error:  type mismatch
  hâœ
has type
  M ^ n * M < (M ^ n * M).succ : Prop
but is expected to have type
  M * M ^ n < (M ^ n * M).succ : Prop
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem exists_approx_aux (n : â„•) (h : abv.IsAdmissible) :
    âˆ€ {Îµ : â„} (_hÎµ : 0 < Îµ) {b : R} (_hb : b â‰  0) (A : Fin (h.card Îµ ^ n).succ â†’ Fin n â†’ R),
      âˆƒ iâ‚€ iâ‚, iâ‚€ â‰  iâ‚ âˆ§ âˆ€ k, (abv (A iâ‚ k % b - A iâ‚€ k % b) : â„) < abv b â€¢ Îµ ",":= by
  haveI := Classical.decEq R
  induction' n with n ih
  Â· intro Îµ _hÎµ b _hb A
    refine âŸ¨0, 1, ?_, ?_âŸ©
    Â· simp
    rintro âŸ¨i, âŸ¨âŸ©âŸ©
  intro Îµ hÎµ b hb A
  let M := h.card Îµ
  obtain âŸ¨s, s_inj, hsâŸ© :
    âˆƒ s : Fin (M ^ n).succ â†’ Fin (M ^ n.succ).succ,
      Function.Injective s âˆ§ âˆ€ iâ‚€ iâ‚, (abv (A (s iâ‚) 0 % b - A (s iâ‚€) 0 % b) : â„) < abv b â€¢ Îµ := by
    obtain âŸ¨t, htâŸ© :
      âˆƒ t : Fin (M ^ n.succ).succ â†’ Fin M,
        âˆ€ iâ‚€ iâ‚, t iâ‚€ = t iâ‚ â†’ (abv (A iâ‚ 0 % b - A iâ‚€ 0 % b) : â„) < abv b â€¢ Îµ :=
      h.exists_partition hÎµ hb fun x â†¦ A x 0
    obtain âŸ¨s, hsâŸ© :=
      Fintype.exists_lt_card_fiber_of_mul_lt_card (f := t)
        (by simpa only [Fintype.card_fin, pow_succ'] using Nat.lt_succ_self (M ^ n.succ))
    refine âŸ¨fun i â†¦ (Finset.univ.filter fun x â†¦ t x = s).toList.get <| i.castLE ?_, fun i j h â†¦ ?_,
      fun iâ‚€ iâ‚ â†¦ ht _ _ ?_âŸ©
    Â· rwa [Finset.length_toList]
    Â· ext
      simpa [(Finset.nodup_toList _).getElem_inj_iff] using h
    Â· have : âˆ€ i h, t ((Finset.univ.filter fun x â†¦ t x = s).toList.get âŸ¨i, hâŸ©) = s := fun i h â†¦
        (Finset.mem_filter.mp (Finset.mem_toList.mp (List.get_mem _ i h))).2
      simp only [Nat.succ_eq_add_one, Finset.length_toList, List.get_eq_getElem] at this
      simp only [Nat.succ_eq_add_one, List.get_eq_getElem, Fin.coe_castLE]
      rw [this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ iâ‚.2) hs),
        this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ iâ‚€.2) hs)]
  obtain âŸ¨kâ‚€, kâ‚, hk, hâŸ© := ih hÎµ hb fun x â†¦ Fin.tail (A (s x))
  refine âŸ¨s kâ‚€, s kâ‚, fun h â†¦ hk (s_inj h), fun i â†¦ Fin.cases ?_ (fun i â†¦ ?_) iâŸ©
  Â· exact hs kâ‚€ kâ‚
  Â· exact h i"
Mathlib/Topology/FiberBundle/Basic.lean,FiberBundle.exists_trivialization_Icc_subset,FiberBundle.exists_trivialization_Icc_subset,338b29638884b26649782bacab58b0ffd86541dc,":= by
  obtain âŸ¨ea, heaâŸ© : âˆƒ ea : Trivialization F (Ï€ F E), a âˆˆ ea.baseSet :=
    âŸ¨trivializationAt F E a, mem_baseSet_trivializationAt F E aâŸ©
  cases' lt_or_le b a with hab hab
  Â· exact âŸ¨ea, by simp [*]âŸ©
  set s : Set B := { x âˆˆ Icc a b | âˆƒ e : Trivialization F (Ï€ F E), Icc a x âŠ† e.baseSet }
  have ha : a âˆˆ s := âŸ¨left_mem_Icc.2 hab, ea, by simp [hea]âŸ©
  have sne : s.Nonempty := âŸ¨a, haâŸ©
  have hsb : b âˆˆ upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := âŸ¨b, hsbâŸ©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c âˆˆ Icc a b := âŸ¨hsc.1 ha, hsc.2 hsbâŸ©
  obtain âŸ¨-, ec : Trivialization F (Ï€ F E), hec : Icc a c âŠ† ec.baseSetâŸ© : c âˆˆ s := by
    cases' hc.1.eq_or_lt with heq hlt
    Â· rwa [â† heq]
    refine âŸ¨hc, ?_âŸ©
    obtain âŸ¨ec, hcâŸ© : âˆƒ ec : Trivialization F (Ï€ F E), c âˆˆ ec.baseSet :=
      âŸ¨trivializationAt F E c, mem_baseSet_trivializationAt F E câŸ©
    obtain âŸ¨c', hc', hc'eâŸ© : âˆƒ c' âˆˆ Ico a c, Ioc c' c âŠ† ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain âŸ¨d, âŸ¨hdab, ead, hadâŸ©, hdâŸ© : âˆƒ d âˆˆ s, d âˆˆ Ioc c' c := hsc.exists_between hc'.2
    refine' âŸ¨ead.piecewiseLe ec d (had âŸ¨hdab.1, le_rflâŸ©) (hc'e hd), subset_ite.2 _âŸ©
    refine' âŸ¨fun x hx => had âŸ¨hx.1.1, hx.2âŸ©, fun x hx => hc'e âŸ¨hd.1.trans (not_le.1 hx.2), hx.1.2âŸ©âŸ©
  cases' hc.2.eq_or_lt with heq hlt
  Â· exact âŸ¨ec, heq â–¸ hecâŸ©
  suffices : âˆƒ d âˆˆ Ioc c b, âˆƒ e : Trivialization F (Ï€ F E), Icc a d âŠ† e.baseSet
  Â· rcases this with  âŸ¨d, hdcb, hdâŸ© 
    exact ((hsc.1 âŸ¨âŸ¨hc.1.trans hdcb.1.le, hdcb.2âŸ©, hdâŸ©).not_lt hdcb.1).elim
  obtain âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, Ico c d âŠ† ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec âŸ¨hc.1, le_rflâŸ©))
  have had : Ico a d âŠ† ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  Â· obtain âŸ¨ed, hedâŸ© : âˆƒ ed : Trivialization F (Ï€ F E), d âˆˆ ed.baseSet :=
      âŸ¨trivializationAt F E d, mem_baseSet_trivializationAt F E dâŸ©
    refine' âŸ¨d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono (inter_subset_right _ _) (inter_subset_right _ _)), fun x hx => _âŸ©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr âŸ¨hed, hdcb.1âŸ©, Or.inl âŸ¨had âŸ¨hx.1, hxdâŸ©, hxdâŸ©]
  Â· rw [disjoint_left] at he
    push_neg at he
    rcases he with âŸ¨d', hdd' : d' < d, hd'câŸ©
    exact âŸ¨d', âŸ¨hd'c, hdd'.le.trans hdcb.2âŸ©, ec, (Icc_subset_Ico_right hdd').trans hadâŸ©",error:  unexpected token ':'; expected term,"theorem FiberBundle.exists_trivialization_Icc_subset [ConditionallyCompleteLinearOrder B]
    [OrderTopology B] [FiberBundle F E] (a b : B) :
    âˆƒ e : Trivialization F (Ï€ F E), Icc a b âŠ† e.baseSet ",":= by
  obtain âŸ¨ea, heaâŸ© : âˆƒ ea : Trivialization F (Ï€ F E), a âˆˆ ea.baseSet :=
    âŸ¨trivializationAt F E a, mem_baseSet_trivializationAt F E aâŸ©
  cases' lt_or_le b a with hab hab
  Â· exact âŸ¨ea, by simp [*]âŸ©
  set s : Set B := { x âˆˆ Icc a b | âˆƒ e : Trivialization F (Ï€ F E), Icc a x âŠ† e.baseSet }
  have ha : a âˆˆ s := âŸ¨left_mem_Icc.2 hab, ea, by simp [hea]âŸ©
  have sne : s.Nonempty := âŸ¨a, haâŸ©
  have hsb : b âˆˆ upperBounds s := fun x hx => hx.1.2
  have sbd : BddAbove s := âŸ¨b, hsbâŸ©
  set c := sSup s
  have hsc : IsLUB s c := isLUB_csSup sne sbd
  have hc : c âˆˆ Icc a b := âŸ¨hsc.1 ha, hsc.2 hsbâŸ©
  obtain âŸ¨-, ec : Trivialization F (Ï€ F E), hec : Icc a c âŠ† ec.baseSetâŸ© : c âˆˆ s := by
    rcases hc.1.eq_or_lt with heq | hlt
    Â· rwa [â† heq]
    refine âŸ¨hc, ?_âŸ©
    obtain âŸ¨ec, hcâŸ© : âˆƒ ec : Trivialization F (Ï€ F E), c âˆˆ ec.baseSet :=
      âŸ¨trivializationAt F E c, mem_baseSet_trivializationAt F E câŸ©
    obtain âŸ¨c', hc', hc'eâŸ© : âˆƒ c' âˆˆ Ico a c, Ioc c' c âŠ† ec.baseSet :=
      (mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset hlt).1
        (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet hc)
    obtain âŸ¨d, âŸ¨hdab, ead, hadâŸ©, hdâŸ© : âˆƒ d âˆˆ s, d âˆˆ Ioc c' c := hsc.exists_between hc'.2
    refine âŸ¨ead.piecewiseLe ec d (had âŸ¨hdab.1, le_rflâŸ©) (hc'e hd), subset_ite.2 ?_âŸ©
    exact âŸ¨fun x hx => had âŸ¨hx.1.1, hx.2âŸ©, fun x hx => hc'e âŸ¨hd.1.trans (not_le.1 hx.2), hx.1.2âŸ©âŸ©
  rcases hc.2.eq_or_lt with heq | hlt
  Â· exact âŸ¨ec, heq â–¸ hecâŸ©
  rsuffices âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, âˆƒ e : Trivialization F (Ï€ F E), Icc a d âŠ† e.baseSet
  Â· exact ((hsc.1 âŸ¨âŸ¨hc.1.trans hdcb.1.le, hdcb.2âŸ©, hdâŸ©).not_lt hdcb.1).elim
  obtain âŸ¨d, hdcb, hdâŸ© : âˆƒ d âˆˆ Ioc c b, Ico c d âŠ† ec.baseSet :=
    (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1
      (mem_nhdsWithin_of_mem_nhds <| IsOpen.mem_nhds ec.open_baseSet (hec âŸ¨hc.1, le_rflâŸ©))
  have had : Ico a d âŠ† ec.baseSet := Ico_subset_Icc_union_Ico.trans (union_subset hec hd)
  by_cases he : Disjoint (Iio d) (Ioi c)
  Â· obtain âŸ¨ed, hedâŸ© : âˆƒ ed : Trivialization F (Ï€ F E), d âˆˆ ed.baseSet :=
      âŸ¨trivializationAt F E d, mem_baseSet_trivializationAt F E dâŸ©
    refine âŸ¨d, hdcb,
      (ec.restrOpen (Iio d) isOpen_Iio).disjointUnion (ed.restrOpen (Ioi c) isOpen_Ioi)
        (he.mono inter_subset_right inter_subset_right), fun x hx => ?_âŸ©
    rcases hx.2.eq_or_lt with (rfl | hxd)
    exacts [Or.inr âŸ¨hed, hdcb.1âŸ©, Or.inl âŸ¨had âŸ¨hx.1, hxdâŸ©, hxdâŸ©]
  Â· rw [disjoint_left] at he
    push_neg at he
    rcases he with âŸ¨d', hdd' : d' < d, hd'câŸ©
    exact âŸ¨d', âŸ¨hd'c, hdd'.le.trans hdcb.2âŸ©, ec, (Icc_subset_Ico_right hdd').trans hadâŸ©"
Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean,MeasureTheory.SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge,SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge,7fa0a827960832ef960210f51c78c246882fbb79,":= by
  induction' f using MeasureTheory.SimpleFunc.induction with c s hs fâ‚ fâ‚‚ _ hâ‚ hâ‚‚ generalizing Îµ
  Â· let f := SimpleFunc.piecewise s hs (SimpleFunc.const Î± c) (SimpleFunc.const Î± 0)
    by_cases h : âˆ«â» x, f x âˆ‚Î¼ = âŠ¤
    Â· refine'
        âŸ¨fun _ => c, fun x => _, lowerSemicontinuous_const, by
          simp only [_root_.top_add, le_top, h]âŸ©
      simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,
        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]
      exact Set.indicator_le_self _ _ _
    by_cases hc : c = 0
    Â· refine' âŸ¨fun _ => 0, _, lowerSemicontinuous_const, _âŸ©
      Â· classical
        simp only [hc, Set.indicator_zero', Pi.zero_apply, SimpleFunc.const_zero, imp_true_iff,
          eq_self_iff_true, SimpleFunc.coe_zero, Set.piecewise_eq_indicator,
          SimpleFunc.coe_piecewise, le_zero_iff]
      Â· simp only [lintegral_const, zero_mul, zero_le, ENNReal.coe_zero]
    have : Î¼ s < Î¼ s + Îµ / c := by
      have : (0 : â„â‰¥0âˆ) < Îµ / c := ENNReal.div_pos_iff.2 âŸ¨Îµ0, ENNReal.coe_ne_topâŸ©
      simpa using ENNReal.add_lt_add_left ?aux this
    case aux =>
      classical
      simpa [f, hs, hc, lt_top_iff_ne_top, true_and_iff, SimpleFunc.coe_const,
        Function.const_apply, lintegral_const, ENNReal.coe_indicator, Set.univ_inter,
        ENNReal.coe_ne_top, MeasurableSet.univ, ENNReal.mul_eq_top, SimpleFunc.const_zero,
        or_false_iff, lintegral_indicator, ENNReal.coe_eq_zero, Ne.def, not_false_iff,
        SimpleFunc.coe_zero, Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise, false_and_iff,
        restrict_apply] using h
    obtain âŸ¨u, su, u_open, Î¼uâŸ© : âˆƒ (u : _), u âŠ‡ s âˆ§ IsOpen u âˆ§ Î¼ u < Î¼ s + Îµ / c :=
      s.exists_isOpen_lt_of_lt _ this
    refine'
      âŸ¨Set.indicator u fun _ => c, fun x => _, u_open.lowerSemicontinuous_indicator (zero_le _), _âŸ©
    Â· simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,
        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]
      exact Set.indicator_le_indicator_of_subset su (fun x => zero_le _) _
    Â· suffices (c : â„â‰¥0âˆ) * Î¼ u â‰¤ c * Î¼ s + Îµ by
        classical
        simpa only [ENNReal.coe_indicator, u_open.measurableSet, lintegral_indicator,
          lintegral_const, MeasurableSet.univ, Measure.restrict_apply, Set.univ_inter, const_zero,
          coe_piecewise, coe_const, coe_zero, Set.piecewise_eq_indicator, Function.const_apply, hs]
      calc
        (c : â„â‰¥0âˆ) * Î¼ u â‰¤ c * (Î¼ s + Îµ / c) := mul_le_mul_left' Î¼u.le _
        _ = c * Î¼ s + Îµ := by
          simp_rw [mul_add]
          rw [ENNReal.mul_div_cancel' _ ENNReal.coe_ne_top]
          simpa using hc

  Â· rcases hâ‚ (ENNReal.half_pos Îµ0).ne' with âŸ¨gâ‚, fâ‚_le_gâ‚, gâ‚cont, gâ‚intâŸ©
    rcases hâ‚‚ (ENNReal.half_pos Îµ0).ne' with âŸ¨gâ‚‚, fâ‚‚_le_gâ‚‚, gâ‚‚cont, gâ‚‚intâŸ©
    refine'
      âŸ¨fun x => gâ‚ x + gâ‚‚ x, fun x => add_le_add (fâ‚_le_gâ‚ x) (fâ‚‚_le_gâ‚‚ x), gâ‚cont.add gâ‚‚cont, _âŸ©
    simp only [SimpleFunc.coe_add, ENNReal.coe_add, Pi.add_apply]
    rw [lintegral_add_left fâ‚.measurable.coe_nnreal_ennreal,
      lintegral_add_left gâ‚cont.measurable.coe_nnreal_ennreal]
    convert add_le_add gâ‚int gâ‚‚int using 1
    conv_lhs => rw [â† ENNReal.add_halves Îµ]
    abel","error:  Case tag 'aux' not found.

The only available case tag is 'neg._@.Mathlib.MeasureTheory.Integral.VitaliCaratheodory._hyg.739'.","theorem SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge (f : Î± â†’â‚› â„â‰¥0) {Îµ : â„â‰¥0âˆ}
    (Îµ0 : Îµ â‰  0) :
    âˆƒ g : Î± â†’ â„â‰¥0, (âˆ€ x, f x â‰¤ g x) âˆ§ LowerSemicontinuous g âˆ§
      (âˆ«â» x, g x âˆ‚Î¼) â‰¤ (âˆ«â» x, f x âˆ‚Î¼) + Îµ ",":= by
  induction' f using MeasureTheory.SimpleFunc.induction with c s hs fâ‚ fâ‚‚ _ hâ‚ hâ‚‚ generalizing Îµ
  Â· let f := SimpleFunc.piecewise s hs (SimpleFunc.const Î± c) (SimpleFunc.const Î± 0)
    by_cases h : âˆ«â» x, f x âˆ‚Î¼ = âŠ¤
    Â· refine
        âŸ¨fun _ => c, fun x => ?_, lowerSemicontinuous_const, by
          simp only [_root_.top_add, le_top, h]âŸ©
      simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,
        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]
      exact Set.indicator_le_self _ _ _
    by_cases hc : c = 0
    Â· refine âŸ¨fun _ => 0, ?_, lowerSemicontinuous_const, ?_âŸ©
      Â· classical
        simp only [hc, Set.indicator_zero', Pi.zero_apply, SimpleFunc.const_zero, imp_true_iff,
          eq_self_iff_true, SimpleFunc.coe_zero, Set.piecewise_eq_indicator,
          SimpleFunc.coe_piecewise, le_zero_iff]
      Â· simp only [lintegral_const, zero_mul, zero_le, ENNReal.coe_zero]
    have ne_top : Î¼ s â‰  âŠ¤ := by
      classical
      simpa [f, hs, hc, lt_top_iff_ne_top, true_and_iff, SimpleFunc.coe_const,
        Function.const_apply, lintegral_const, ENNReal.coe_indicator, Set.univ_inter,
        ENNReal.coe_ne_top, MeasurableSet.univ, ENNReal.mul_eq_top, SimpleFunc.const_zero,
        or_false_iff, lintegral_indicator, ENNReal.coe_eq_zero, Ne, not_false_iff,
        SimpleFunc.coe_zero, Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise, false_and_iff,
        restrict_apply] using h
    have : Î¼ s < Î¼ s + Îµ / c := by
      have : (0 : â„â‰¥0âˆ) < Îµ / c := ENNReal.div_pos_iff.2 âŸ¨Îµ0, ENNReal.coe_ne_topâŸ©
      simpa using ENNReal.add_lt_add_left ne_top this
    obtain âŸ¨u, su, u_open, Î¼uâŸ© : âˆƒ (u : _), u âŠ‡ s âˆ§ IsOpen u âˆ§ Î¼ u < Î¼ s + Îµ / c :=
      s.exists_isOpen_lt_of_lt _ this
    refine âŸ¨Set.indicator u fun _ => c,
            fun x => ?_, u_open.lowerSemicontinuous_indicator (zero_le _), ?_âŸ©
    Â· simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,
        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]
      exact Set.indicator_le_indicator_of_subset su (fun x => zero_le _) _
    Â· suffices (c : â„â‰¥0âˆ) * Î¼ u â‰¤ c * Î¼ s + Îµ by
        classical
        simpa only [ENNReal.coe_indicator, u_open.measurableSet, lintegral_indicator,
          lintegral_const, MeasurableSet.univ, Measure.restrict_apply, Set.univ_inter, const_zero,
          coe_piecewise, coe_const, coe_zero, Set.piecewise_eq_indicator, Function.const_apply, hs]
      calc
        (c : â„â‰¥0âˆ) * Î¼ u â‰¤ c * (Î¼ s + Îµ / c) := mul_le_mul_left' Î¼u.le _
        _ = c * Î¼ s + Îµ := by
          simp_rw [mul_add]
          rw [ENNReal.mul_div_cancel' _ ENNReal.coe_ne_top]
          simpa using hc

  Â· rcases hâ‚ (ENNReal.half_pos Îµ0).ne' with âŸ¨gâ‚, fâ‚_le_gâ‚, gâ‚cont, gâ‚intâŸ©
    rcases hâ‚‚ (ENNReal.half_pos Îµ0).ne' with âŸ¨gâ‚‚, fâ‚‚_le_gâ‚‚, gâ‚‚cont, gâ‚‚intâŸ©
    refine
      âŸ¨fun x => gâ‚ x + gâ‚‚ x, fun x => add_le_add (fâ‚_le_gâ‚ x) (fâ‚‚_le_gâ‚‚ x), gâ‚cont.add gâ‚‚cont, ?_âŸ©
    simp only [SimpleFunc.coe_add, ENNReal.coe_add, Pi.add_apply]
    rw [lintegral_add_left fâ‚.measurable.coe_nnreal_ennreal,
      lintegral_add_left gâ‚cont.measurable.coe_nnreal_ennreal]
    convert add_le_add gâ‚int gâ‚‚int using 1
    conv_lhs => rw [â† ENNReal.add_halves Îµ]
    abel"
Mathlib/MeasureTheory/Covering/BesicovitchVectorSpace.lean,Besicovitch.exists_goodÎ´,exists_goodÎ´,b50a8b2e9760b6f582390d3948a953c553480df1,":= by
  classical
  by_contra! h
  set N := multiplicity E + 1 with hN
  have :
    âˆ€ Î´ : â„, 0 < Î´ â†’ âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§
      Pairwise fun i j => 1 - Î´ â‰¤ â€–f i - f jâ€– := by
    intro Î´ hÎ´
    rcases lt_or_le Î´ 1 with (hÎ´' | hÎ´')
    Â· rcases h Î´ hÎ´ hÎ´' with âŸ¨s, hs, h's, s_cardâŸ©
      obtain âŸ¨f, f_inj, hfsâŸ© : âˆƒ f : Fin N â†’ E, Function.Injective f âˆ§ range f âŠ† â†‘s := by
        have : Fintype.card (Fin N) â‰¤ s.card := by simp only [Fintype.card_fin]; exact s_card
        rcases Function.Embedding.exists_of_card_le_finset this with âŸ¨f, hfâŸ©
        exact âŸ¨f, f.injective, hfâŸ©
      simp only [range_subset_iff, Finset.mem_coe] at hfs
      exact âŸ¨f, fun i => hs _ (hfs i), fun i j hij => h's _ (hfs i) _ (hfs j) (f_inj.ne hij)âŸ©
    Â· exact
        âŸ¨fun _ => 0, by simp, fun i j _ => by
          simpa only [norm_zero, sub_nonpos, sub_self]âŸ©
  choose! F hF using this
  have : âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§ Pairwise fun i j => 1 â‰¤ â€–f i - f jâ€– := by
    obtain âŸ¨u, _, zero_lt_u, huâŸ© :
      âˆƒ u : â„• â†’ â„,
        (âˆ€ m n : â„•, m < n â†’ u n < u m) âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Filter.Tendsto u Filter.atTop (ğ“ 0) :=
      exists_seq_strictAnti_tendsto (0 : â„)
    have A : âˆ€ n, F (u n) âˆˆ closedBall (0 : Fin N â†’ E) 2 := by
      intro n
      simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right,
        (hF (u n) (zero_lt_u n)).left, forall_const]
    obtain âŸ¨f, fmem, Ï†, Ï†_mono, hfâŸ© :
      âˆƒ f âˆˆ closedBall (0 : Fin N â†’ E) 2,
        âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (ğ“ f) :=
      IsCompact.tendsto_subseq (isCompact_closedBall _ _) A
    refine' âŸ¨f, fun i => _, fun i j hij => _âŸ©
    Â· simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right] at fmem
      exact fmem i
    Â· have A : Tendsto (fun n => â€–F (u (Ï† n)) i - F (u (Ï† n)) jâ€–) atTop (ğ“ â€–f i - f jâ€–) :=
        ((hf.apply i).sub (hf.apply j)).norm
      have B : Tendsto (fun n => 1 - u (Ï† n)) atTop (ğ“ (1 - 0)) :=
        tendsto_const_nhds.sub (hu.comp Ï†_mono.tendsto_atTop)
      rw [sub_zero] at B
      exact le_of_tendsto_of_tendsto' B A fun n => (hF (u (Ï† n)) (zero_lt_u _)).2 hij
  rcases this with âŸ¨f, hf, h'fâŸ©
  have finj : Function.Injective f := by
    intro i j hij
    by_contra h
    have : 1 â‰¤ â€–f i - f jâ€– := h'f h
    simp only [hij, norm_zero, sub_self] at this
    exact lt_irrefl _ (this.trans_lt zero_lt_one)
  let s := Finset.image f Finset.univ
  have s_card : s.card = N := by rw [Finset.card_image_of_injective _ finj]; exact Finset.card_fin N
  have hs : âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2 := by
    simp only [s, hf, forall_apply_eq_imp_iff, forall_const, forall_exists_index, Finset.mem_univ,
      Finset.mem_image, true_and]
  have h's : âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 â‰¤ â€–c - dâ€– := by
    simp only [s, forall_apply_eq_imp_iff, forall_exists_index, Finset.mem_univ, Finset.mem_image,
      Ne, exists_true_left, forall_apply_eq_imp_iff, forall_true_left, true_and]
    intro i j hij
    have : i â‰  j := fun h => by rw [h] at hij; exact hij rfl
    exact h'f this
  have : s.card â‰¤ multiplicity E := card_le_multiplicity hs h's
  rw [s_card, hN] at this
  exact lt_irrefl _ ((Nat.lt_succ_self (multiplicity E)).trans_le this)","error:  application type mismatch
  Tendsto.apply hf
argument
  hf
has type
  Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (ğ“ f) : Prop
but is expected to have type
  Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (Filter.pi ?m.76671) : Prop
error:  application type mismatch
  Tendsto.apply hf
argument
  hf
has type
  Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (ğ“ f) : Prop
but is expected to have type
  Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (Filter.pi ?m.77078) : Prop","theorem exists_goodÎ´ :
    âˆƒ Î´ : â„, 0 < Î´ âˆ§ Î´ < 1 âˆ§ âˆ€ s : Finset E, (âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2) â†’
      (âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 - Î´ â‰¤ â€–c - dâ€–) â†’ s.card â‰¤ multiplicity E ",":= by
  classical
  by_contra! h
  set N := multiplicity E + 1 with hN
  have :
    âˆ€ Î´ : â„, 0 < Î´ â†’ âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§
      Pairwise fun i j => 1 - Î´ â‰¤ â€–f i - f jâ€– := by
    intro Î´ hÎ´
    rcases lt_or_le Î´ 1 with (hÎ´' | hÎ´')
    Â· rcases h Î´ hÎ´ hÎ´' with âŸ¨s, hs, h's, s_cardâŸ©
      obtain âŸ¨f, f_inj, hfsâŸ© : âˆƒ f : Fin N â†’ E, Function.Injective f âˆ§ range f âŠ† â†‘s := by
        have : Fintype.card (Fin N) â‰¤ s.card := by simp only [Fintype.card_fin]; exact s_card
        rcases Function.Embedding.exists_of_card_le_finset this with âŸ¨f, hfâŸ©
        exact âŸ¨f, f.injective, hfâŸ©
      simp only [range_subset_iff, Finset.mem_coe] at hfs
      exact âŸ¨f, fun i => hs _ (hfs i), fun i j hij => h's _ (hfs i) _ (hfs j) (f_inj.ne hij)âŸ©
    Â· exact
        âŸ¨fun _ => 0, by simp, fun i j _ => by
          simpa only [norm_zero, sub_nonpos, sub_self]âŸ©
  choose! F hF using this
  have : âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§ Pairwise fun i j => 1 â‰¤ â€–f i - f jâ€– := by
    obtain âŸ¨u, _, zero_lt_u, huâŸ© :
      âˆƒ u : â„• â†’ â„,
        (âˆ€ m n : â„•, m < n â†’ u n < u m) âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Filter.Tendsto u Filter.atTop (ğ“ 0) :=
      exists_seq_strictAnti_tendsto (0 : â„)
    have A : âˆ€ n, F (u n) âˆˆ closedBall (0 : Fin N â†’ E) 2 := by
      intro n
      simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right,
        (hF (u n) (zero_lt_u n)).left, forall_const]
    obtain âŸ¨f, fmem, Ï†, Ï†_mono, hfâŸ© :
      âˆƒ f âˆˆ closedBall (0 : Fin N â†’ E) 2,
        âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (ğ“ f) :=
      IsCompact.tendsto_subseq (isCompact_closedBall _ _) A
    refine âŸ¨f, fun i => ?_, fun i j hij => ?_âŸ©
    Â· simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right] at fmem
      exact fmem i
    Â· have A : Tendsto (fun n => â€–F (u (Ï† n)) i - F (u (Ï† n)) jâ€–) atTop (ğ“ â€–f i - f jâ€–) :=
        ((hf.apply_nhds i).sub (hf.apply_nhds j)).norm
      have B : Tendsto (fun n => 1 - u (Ï† n)) atTop (ğ“ (1 - 0)) :=
        tendsto_const_nhds.sub (hu.comp Ï†_mono.tendsto_atTop)
      rw [sub_zero] at B
      exact le_of_tendsto_of_tendsto' B A fun n => (hF (u (Ï† n)) (zero_lt_u _)).2 hij
  rcases this with âŸ¨f, hf, h'fâŸ©
  have finj : Function.Injective f := by
    intro i j hij
    by_contra h
    have : 1 â‰¤ â€–f i - f jâ€– := h'f h
    simp only [hij, norm_zero, sub_self] at this
    exact lt_irrefl _ (this.trans_lt zero_lt_one)
  let s := Finset.image f Finset.univ
  have s_card : s.card = N := by rw [Finset.card_image_of_injective _ finj]; exact Finset.card_fin N
  have hs : âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2 := by
    simp only [s, hf, forall_apply_eq_imp_iff, forall_const, forall_exists_index, Finset.mem_univ,
      Finset.mem_image, true_and]
  have h's : âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 â‰¤ â€–c - dâ€– := by
    simp only [s, forall_apply_eq_imp_iff, forall_exists_index, Finset.mem_univ, Finset.mem_image,
      Ne, exists_true_left, forall_apply_eq_imp_iff, forall_true_left, true_and]
    intro i j hij
    have : i â‰  j := fun h => by rw [h] at hij; exact hij rfl
    exact h'f this
  have : s.card â‰¤ multiplicity E := card_le_multiplicity hs h's
  rw [s_card, hN] at this
  exact lt_irrefl _ ((Nat.lt_succ_self (multiplicity E)).trans_le this)"
Mathlib/NumberTheory/Multiplicity.lean,multiplicity.pow_prime_pow_sub_pow_prime_pow,pow_prime_pow_sub_pow_prime_pow,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' a with a h_ind
  Â· rw [Nat.cast_zero, add_zero, pow_zero, pow_one, pow_one]
  rw [â† Nat.add_one, Nat.cast_add, Nat.cast_one, â† add_assoc, â† h_ind, pow_succ, pow_mul, pow_mul]
  apply pow_prime_sub_pow_prime hp hp1
  Â· rw [â† geom_sumâ‚‚_mul]
    exact dvd_mul_of_dvd_right hxy _
  Â· exact fun h => hx (hp.dvd_of_dvd_pow h)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ
R : Type u_1
n : â„•
instâœÂ² : CommRing R
aâœ b x y : R
p : â„•
instâœÂ¹ : IsDomain R
instâœ : DecidableRel fun x x_1 â†¦ x âˆ£ x_1
hp : Prime â†‘p
hp1 : Odd p
hxy : â†‘p âˆ£ x - y
hx : Â¬â†‘p âˆ£ x
a : â„•
h_ind : multiplicity (â†‘p) (x ^ p ^ a - y ^ p ^ a) = multiplicity (â†‘p) (x - y) + â†‘a
âŠ¢ multiplicity (â†‘p) (x ^ p ^ (a + 1) - y ^ p ^ (a + 1)) = multiplicity (â†‘p) (x - y) + â†‘(a + 1)
error:  application type mismatch
  pow_prime_pow_sub_pow_prime_pow hp
argument
  hp
has type
  Prime â†‘p : Prop
but is expected to have type
  â„• : Type
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.113066
case succ.intro.intro
R : Type u_1
nâœ : â„•
instâœ : CommRing R
a b xâœ yâœ : R
p : â„•
hp : Prime â†‘p
hp1 : Odd p
x y : â„¤
hxy : â†‘p âˆ£ x - y
hx : Â¬â†‘p âˆ£ x
n : â„•
h : (multiplicity p (n + 1)).Dom
hpn : Â¬p ^ ((multiplicity p (n + 1)).get h + 1) âˆ£ n + 1
k : â„•
hk : n + 1 = p ^ (multiplicity p (n + 1)).get h * k
âŠ¢ multiplicity (â†‘p) (x ^ p ^ (multiplicity p (n + 1)).get h - y ^ p ^ (multiplicity p (n + 1)).get h) =
    multiplicity (â†‘p) (x - y) + multiplicity p (n + 1)","theorem pow_prime_pow_sub_pow_prime_pow (a : â„•) :
    multiplicity (â†‘p) (x ^ p ^ a - y ^ p ^ a) = multiplicity (â†‘p) (x - y) + a ",":= by
  induction' a with a h_ind
  Â· rw [Nat.cast_zero, add_zero, pow_zero, pow_one, pow_one]
  rw [Nat.cast_add, Nat.cast_one, â† add_assoc, â† h_ind, pow_succ, pow_mul, pow_mul]
  apply pow_prime_sub_pow_prime hp hp1
  Â· rw [â† geom_sumâ‚‚_mul]
    exact dvd_mul_of_dvd_right hxy _
  Â· exact fun h => hx (hp.dvd_of_dvd_pow h)"
Mathlib/Analysis/Calculus/FDeriv/Measurable.lean,measurableSet_of_differentiableAt,measurableSet_of_differentiableAt,fdbb97baae10f5304e9ce72344499cd3620a87c2,":= by
  simp only [D, differentiable_set_eq_d K hK]
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iUnion fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine MeasurableSet.iInter fun _ => ?_
  refine isOpen_b.measurableSet","error:  unknown identifier 'differentiable_set_eq_d'
error:  simp made no progress","theorem measurableSet_of_differentiableAt_of_isComplete {K : Set (E â†’L[ğ•œ] F)} (hK : IsComplete K) :
    MeasurableSet { x | DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K } ",":= by
  simp only [D, differentiable_set_eq_D K hK]
  repeat apply_rules [MeasurableSet.iUnion, MeasurableSet.iInter] <;> intro
  exact isOpen_B.measurableSet"
Mathlib/SetTheory/Ordinal/CantorNormalForm.lean,Ordinal.CNF_sorted,CNF_sorted,5d07683a061300f8b6b528a735af4914570748ef,":= by
  refine' CNFRec b _ (fun o ho IH â†¦ _) o
  Â· simp only [CNF_zero]
  Â· cases' le_or_lt b 1 with hb hb
    Â· simp only [CNF_of_le_one hb ho, List.map]
    Â· cases' lt_or_le o b with hob hbo
      Â· simp only [CNF_of_lt ho hob, List.map]
      Â· rw [CNF_ne_zero ho, List.map_cons, List.sorted_cons]
        refine' âŸ¨fun a H â†¦ _, IHâŸ©
        rw [List.mem_map'] at H
        rcases H with âŸ¨âŸ¨a, a'âŸ©, H, rflâŸ©
        exact (CNF_fst_le_log H).trans_lt (log_mod_opow_log_lt_log_self hb ho hbo)","error:  unsolved goals
case refine'_1
b o : Ordinal.{u_1}
âŠ¢ Sorted (fun x x_1 â†¦ x > x_1) (map Prod.fst [])
error:  unsolved goals
case refine'_2.inl
b oâœ o : Ordinal.{u_1}
ho : o â‰  0
IH : Sorted (fun x x_1 â†¦ x > x_1) (map Prod.fst (CNF b (o % b ^ log b o)))
hb : b â‰¤ 1
âŠ¢ Sorted (fun x x_1 â†¦ x > x_1) [0]
error:  unsolved goals
case refine'_2.inr.inl
b oâœ o : Ordinal.{u_1}
ho : o â‰  0
IH : Sorted (fun x x_1 â†¦ x > x_1) (map Prod.fst (CNF b (o % b ^ log b o)))
hb : 1 < b
hob : o < b
âŠ¢ Sorted (fun x x_1 â†¦ x > x_1) [0]
error:  unknown constant 'List.mem_map''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.6943
case refine'_2.inr.inr
b oâœ o : Ordinal.{u_1}
ho : o â‰  0
IH : Sorted (fun x x_1 â†¦ x > x_1) (map Prod.fst (CNF b (o % b ^ log b o)))
hb : 1 < b
hbo : b â‰¤ o
a : Ordinal.{u_1}
H : a âˆˆ map Prod.fst (CNF b (o % b ^ log b o))
âŠ¢ (log b o, o / b ^ log b o).1 > a",theorem CNF_sorted (b o : Ordinal) : ((CNF b o).map Prod.fst).Sorted (Â· > Â·) ,":= by
  refine CNFRec b ?_ (fun o ho IH â†¦ ?_) o
  Â· simp only [gt_iff_lt, CNF_zero, map_nil, sorted_nil]
  Â· rcases le_or_lt b 1 with hb | hb
    Â· simp only [CNF_of_le_one hb ho, gt_iff_lt, map_cons, map, sorted_singleton]
    Â· cases' lt_or_le o b with hob hbo
      Â· simp only [CNF_of_lt ho hob, gt_iff_lt, map_cons, map, sorted_singleton]
      Â· rw [CNF_ne_zero ho, map_cons, sorted_cons]
        refine âŸ¨fun a H â†¦ ?_, IHâŸ©
        rw [mem_map] at H
        rcases H with âŸ¨âŸ¨a, a'âŸ©, H, rflâŸ©
        exact (CNF_fst_le_log H).trans_lt (log_mod_opow_log_lt_log_self hb ho hbo)"
Mathlib/CategoryTheory/Monoidal/Bimod.lean,Bimod.whiskerRight_comp_bimod,whiskerRight_comp_bimod,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  dsimp [tensorHom, tensorBimod, associatorBimod]
  ext
  apply coequalizer.hom_ext
  dsimp
  slice_lhs 1 2 => rw [Î¹_colimMap, parallelPairHom_app_one]
  dsimp [TensorBimod.X, AssociatorBimod.inv]
  slice_rhs 1 2 => rw [coequalizer.Ï€_desc]
  dsimp [AssociatorBimod.invAux, AssociatorBimod.hom]
  refine' (cancel_epi ((tensorLeft _).map (coequalizer.Ï€ _ _))).1 _
  rw [tensorLeft_map]
  slice_rhs 1 3 => rw [id_tensor_Ï€_preserves_coequalizer_inv_desc]
  slice_rhs 3 4 => rw [Î¹_colimMap, parallelPairHom_app_one]
  slice_rhs 2 3 => rw [â† comp_whiskerRight, Î¹_colimMap, parallelPairHom_app_one]
  slice_rhs 3 4 => rw [coequalizer.Ï€_desc]
  dsimp [AssociatorBimod.homAux]
  slice_rhs 2 2 => rw [comp_whiskerRight]
  slice_rhs 3 5 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]
  slice_rhs 2 3 => rw [associator_naturality_left]
  slice_rhs 1 3 => rw [Iso.inv_hom_id_assoc]
  slice_lhs 1 2 => rw [whisker_exchange]","error:  unsolved goals
case h.h
C : Type uâ‚
instâœâ´ : Category.{vâ‚, uâ‚} C
instâœÂ³ : MonoidalCategory C
A B : Mon_ C
Mâœ : Bimod A B
instâœÂ² : HasCoequalizers C
instâœÂ¹ : (X : C) â†’ PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (tensorLeft X)
instâœ : (X : C) â†’ PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (tensorRight X)
W X Y Z : Mon_ C
M M' : Bimod W X
f : M âŸ¶ M'
N : Bimod X Y
P : Bimod Y Z
âŠ¢ (f.hom â–· (N.X âŠ— P.X) â‰« M'.X â— coequalizer.Ï€ (N.actRight â–· P.X) ((Î±_ N.X Y.X P.X).hom â‰« N.X â— P.actLeft)) â‰«
      colimit.Î¹
        (parallelPair (M'.actRight â–· coequalizer (N.actRight â–· P.X) ((Î±_ N.X Y.X P.X).hom â‰« N.X â— P.actLeft))
          ((Î±_ M'.X X.X (coequalizer (N.actRight â–· P.X) ((Î±_ N.X Y.X P.X).hom â‰« N.X â— P.actLeft))).hom â‰«
            M'.X â— TensorBimod.actLeft N P))
        WalkingParallelPair.one =
    (f.hom â–· (N.X âŠ— P.X) â‰« M'.X â— coequalizer.Ï€ (N.actRight â–· P.X) ((Î±_ N.X Y.X P.X).hom â‰« N.X â— P.actLeft)) â‰«
      coequalizer.Ï€ (M'.actRight â–· TensorBimod.X N P)
        ((Î±_ M'.X X.X (TensorBimod.X N P)).hom â‰« M'.X â— TensorBimod.actLeft N P)","theorem whiskerRight_comp_bimod {W X Y Z : Mon_ C} {M M' : Bimod W X} (f : M âŸ¶ M') (N : Bimod X Y)
    (P : Bimod Y Z) :
    whiskerRight f (N.tensorBimod P) =
      (associatorBimod M N P).inv â‰«
        whiskerRight (whiskerRight f N) P â‰« (associatorBimod M' N P).hom ",":= by
  dsimp [tensorHom, tensorBimod, associatorBimod]
  ext
  apply coequalizer.hom_ext
  dsimp
  slice_lhs 1 2 => rw [Î¹_colimMap, parallelPairHom_app_one]
  dsimp [TensorBimod.X, AssociatorBimod.inv]
  slice_rhs 1 2 => rw [coequalizer.Ï€_desc]
  dsimp [AssociatorBimod.invAux, AssociatorBimod.hom]
  refine (cancel_epi ((tensorLeft _).map (coequalizer.Ï€ _ _))).1 ?_
  rw [tensorLeft_map]
  slice_rhs 1 3 => rw [id_tensor_Ï€_preserves_coequalizer_inv_desc]
  slice_rhs 3 4 => rw [Î¹_colimMap, parallelPairHom_app_one]
  slice_rhs 2 3 => rw [â† comp_whiskerRight, Î¹_colimMap, parallelPairHom_app_one]
  slice_rhs 3 4 => rw [coequalizer.Ï€_desc]
  dsimp [AssociatorBimod.homAux]
  slice_rhs 2 2 => rw [comp_whiskerRight]
  slice_rhs 3 5 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]
  slice_rhs 2 3 => rw [associator_naturality_left]
  slice_rhs 1 3 => rw [Iso.inv_hom_id_assoc]
  slice_lhs 1 2 => rw [whisker_exchange]
  rfl"
Mathlib/RingTheory/PowerSeries/Basic.lean,Polynomial.coe_inj,coe_inj,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,"  ext
  simp_rw [â† coeff_coe]
  congr","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
error:  unexpected token 'variable'; expected ':=', 'where' or '|'
error:  function expected at
  Function.Injective Coe.coe
term has type
  Prop
error:  unknown identifier 'coe_injective'",theorem coe_injective : Function.Injective (Coe.coe : R[X] â†’ PowerSeries R) ,":= fun x y h => by
  ext
  simp_rw [â† coeff_coe]
  congr"
Mathlib/Analysis/Complex/AbelLimit.lean,Complex.nhdsWithin_stolzCone_le_nhdsWithin_stolzSet,nhdsWithin_stolzCone_le_nhdsWithin_stolzSet,1c74fbb744999408b06c003283b12b8fbd775fdc,":= by
  obtain âŸ¨M, Îµ, _, hÎµ, HâŸ© := stolzCone_subset_StolzSet_aux hs
  use M
  rw [nhdsWithin_le_iff, mem_nhdsWithin]
  refine âŸ¨{w | 1 - Îµ < w.re}, isOpen_lt continuous_const continuous_re, ?_, HâŸ©
  simp only [Set.mem_setOf_eq, one_re, sub_lt_self_iff, hÎµ]","error:  unknown identifier 'stolzCone_subset_StolzSet_aux'
error:  rcases tactic failed: xâœ : ?m.43902 is not an inductive datatype","lemma nhdsWithin_stolzCone_le_nhdsWithin_stolzSet {s : â„} (hs : 0 < s) :
    âˆƒ M, ğ“[stolzCone s] 1 â‰¤ ğ“[stolzSet M] 1 ",":= by
  obtain âŸ¨M, Îµ, _, hÎµ, HâŸ© := stolzCone_subset_stolzSet_aux hs
  use M
  rw [nhdsWithin_le_iff, mem_nhdsWithin]
  refine âŸ¨{w | 1 - Îµ < w.re}, isOpen_lt continuous_const continuous_re, ?_, HâŸ©
  simp only [Set.mem_setOf_eq, one_re, sub_lt_self_iff, hÎµ]"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.single_left_inj,single_left_inj,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.single_left_injective (fun _ => h)","warning:  Finsupp does not have a doc string
error:  unknown identifier 'DFinsupp.single_left_injective'",theorem single_left_injective (h : b â‰  0) : Function.Injective fun a : Î± => single a b ,":=
  fun _a _a' H => (((single_eq_single_iff _ _ _ _).mp H).resolve_right fun hb => h hb.1).left"
Mathlib/Data/Multiset/Basic.lean,Multiset.foldr_induction',foldr_induction',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  revert s
  refine' Multiset.induction (by simp [px]) _
  intro a s hs hsa
  rw [foldr_cons]
  have hps : âˆ€ x : Î±, x âˆˆ s â†’ q x := fun x hxs => hsa x (mem_cons_of_mem hxs)
  exact hpqf a (foldr f H x s) (hsa a (mem_cons_self a s)) (hs hps)","warning:  @cons does not have a doc string
error:  simp made no progress
warning:  `List.filter_congr'` has been deprecated, use `List.filter_congr` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead","theorem foldr_induction' (f : Î± â†’ Î² â†’ Î²) (H : LeftCommutative f) (x : Î²) (q : Î± â†’ Prop)
    (p : Î² â†’ Prop) (s : Multiset Î±) (hpqf : âˆ€ a b, q a â†’ p b â†’ p (f a b)) (px : p x)
    (q_s : âˆ€ a âˆˆ s, q a) : p (foldr f H x s) ",":= by
  induction s using Multiset.induction with
  | empty => simpa
  | cons a s ihs =>
    simp only [forall_mem_cons, foldr_cons] at q_s âŠ¢
    exact hpqf _ _ q_s.1 (ihs q_s.2)"
Mathlib/Combinatorics/Hall/Finite.lean,HallMarriageTheorem.hall_hard_inductive,hall_hard_inductive,4bd6aa25b85c3d8548582d98e1409e1d35d1cc49,":= by
  haveI : Nonempty Î¹ := Fintype.card_pos_iff.mp (hn.symm â–¸ Nat.succ_pos _)
  haveI := Classical.decEq Î¹
  let x := Classical.arbitrary Î¹
  have tx_ne : (t x).Nonempty := by
    rw [â† Finset.card_pos]
    calc
      0 < 1 := Nat.one_pos
      _ â‰¤ (Finset.biUnion {x} t).card := ht {x}
      _ = (t x).card := by rw [Finset.singleton_biUnion]

  choose y hy using tx_ne
  let Î¹' := { x' : Î¹ | x' â‰  x }
  let t' : Î¹' â†’ Finset Î± := fun x' => (t x').erase y
  have card_Î¹' : Fintype.card Î¹' = n :=
    calc
      Fintype.card Î¹' = Fintype.card Î¹ - 1 := Set.card_ne_eq _
      _ = n := by rw [hn, Nat.add_succ_sub_one, add_zero]

  rcases ih t' card_Î¹'.le (hall_cond_of_erase y ha) with âŸ¨f', hfinj, hfrâŸ©
  refine' âŸ¨fun z => if h : z = x then y else f' âŸ¨z, hâŸ©, _, _âŸ©
  Â· rintro zâ‚ zâ‚‚
    have key : âˆ€ {x}, y â‰  f' x := by
      intro x h
      simpa [â† h] using hfr x
    by_cases hâ‚ : zâ‚ = x <;> by_cases hâ‚‚ : zâ‚‚ = x <;> simp [hâ‚, hâ‚‚, hfinj.eq_iff, key, key.symm]
  Â· intro z
    simp only [ne_eq, Set.mem_setOf_eq]
    split_ifs with hz
    Â· rwa [hz]
    Â· specialize hfr âŸ¨z, hzâŸ©
      rw [mem_erase] at hfr
      exact hfr.2","error:  type mismatch
  hâœ
has type
  y âˆˆ t' x : Prop
but is expected to have type
  False : Prop","theorem hall_hard_inductive_step_A {n : â„•} (hn : Fintype.card Î¹ = n + 1)
    (ht : âˆ€ s : Finset Î¹, s.card â‰¤ (s.biUnion t).card)
    (ih :
      âˆ€ {Î¹' : Type u} [Fintype Î¹'] (t' : Î¹' â†’ Finset Î±),
        Fintype.card Î¹' â‰¤ n â†’
          (âˆ€ s' : Finset Î¹', s'.card â‰¤ (s'.biUnion t').card) â†’
            âˆƒ f : Î¹' â†’ Î±, Function.Injective f âˆ§ âˆ€ x, f x âˆˆ t' x)
    (ha : âˆ€ s : Finset Î¹, s.Nonempty â†’ s â‰  univ â†’ s.card < (s.biUnion t).card) :
    âˆƒ f : Î¹ â†’ Î±, Function.Injective f âˆ§ âˆ€ x, f x âˆˆ t x ",":= by
  haveI : Nonempty Î¹ := Fintype.card_pos_iff.mp (hn.symm â–¸ Nat.succ_pos _)
  haveI := Classical.decEq Î¹
  let x := Classical.arbitrary Î¹
  have tx_ne : (t x).Nonempty := by
    rw [â† Finset.card_pos]
    calc
      0 < 1 := Nat.one_pos
      _ â‰¤ (Finset.biUnion {x} t).card := ht {x}
      _ = (t x).card := by rw [Finset.singleton_biUnion]

  choose y hy using tx_ne
  let Î¹' := { x' : Î¹ | x' â‰  x }
  let t' : Î¹' â†’ Finset Î± := fun x' => (t x').erase y
  have card_Î¹' : Fintype.card Î¹' = n :=
    calc
      Fintype.card Î¹' = Fintype.card Î¹ - 1 := Set.card_ne_eq _
      _ = n := by rw [hn, Nat.add_succ_sub_one, add_zero]

  rcases ih t' card_Î¹'.le (hall_cond_of_erase y ha) with âŸ¨f', hfinj, hfrâŸ©
  refine âŸ¨fun z => if h : z = x then y else f' âŸ¨z, hâŸ©, ?_, ?_âŸ©
  Â· rintro zâ‚ zâ‚‚
    have key : âˆ€ {x}, y â‰  f' x := by
      intro x h
      simpa [t', â† h] using hfr x
    by_cases hâ‚ : zâ‚ = x <;> by_cases hâ‚‚ : zâ‚‚ = x <;> simp [hâ‚, hâ‚‚, hfinj.eq_iff, key, key.symm]
  Â· intro z
    simp only [ne_eq, Set.mem_setOf_eq]
    split_ifs with hz
    Â· rwa [hz]
    Â· specialize hfr âŸ¨z, hzâŸ©
      rw [mem_erase] at hfr
      exact hfr.2"
Mathlib/Analysis/Calculus/Taylor.lean,taylor_mean_remainder_bound,taylor_mean_remainder_bound,fe39449a52435740a920a996c38a2b7c688c3a7e,":= by
  rcases eq_or_lt_of_le hab with (rfl | h)
  Â· rw [Icc_self, mem_singleton_iff] at hx
    simp [hx]
  have hf' : DifferentiableOn â„ (iteratedDerivWithin n f (Icc a b)) (Icc a b) :=
    hf.differentiableOn_iteratedDerivWithin (WithTop.coe_lt_coe.mpr n.lt_succ_self)
      (uniqueDiffOn_Icc h)
  have h' : âˆ€ (y : â„) (_ : y âˆˆ Ico a x),
      â€–((n ! : â„)â»Â¹ * (x - y) ^ n) â€¢ iteratedDerivWithin (n + 1) f (Icc a b) yâ€– â‰¤
        (n ! : â„)â»Â¹ * |x - a| ^ n * C := by
    rintro y âŸ¨hay, hyxâŸ©
    rw [norm_smul, Real.norm_eq_abs]
    refine' mul_le_mul _ (hC y âŸ¨hay, hyx.le.trans hx.2âŸ©) (by positivity) (by positivity)
    rw [abs_mul, abs_pow, abs_inv, Nat.abs_cast]
    gcongr
    rw [abs_of_nonneg, abs_of_nonneg] <;> linarith
  have A : âˆ€ t âˆˆ Icc a x, HasDerivWithinAt (fun y => taylorWithinEval f n (Icc a b) y x)
      (((â†‘n !)â»Â¹ * (x - t) ^ n) â€¢ iteratedDerivWithin (n + 1) f (Icc a b) t) (Icc a x) t := by
    intro t ht
    have I : Icc a x âŠ† Icc a b := Icc_subset_Icc_right hx.2
    exact (has_deriv_within_taylorWithinEval_at_Icc x h (I ht) hf.of_succ hf').mono I
  have := norm_image_sub_le_of_norm_deriv_le_segment' A h' x (right_mem_Icc.2 hx.1)
  simp only [taylorWithinEval_self] at this
  refine' this.trans_eq _
  rw [abs_of_nonneg (sub_nonneg.mpr hx.1)]
  ring","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  |?m.232108|
case intro.h.hab.ha
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace â„ E
f : â„ â†’ E
a b C x : â„
n : â„•
hab : a â‰¤ b
hf : ContDiffOn â„ (â†‘n + 1) f (Icc a b)
hx : x âˆˆ Icc a b
hC : âˆ€ y âˆˆ Icc a b, â€–iteratedDerivWithin (n + 1) f (Icc a b) yâ€– â‰¤ C
h : a < b
hf' : DifferentiableOn â„ (iteratedDerivWithin n f (Icc a b)) (Icc a b)
y : â„
hay : a â‰¤ y
hyx : y < x
âŠ¢ 0 â‰¤ x - y
error:  unknown identifier 'has_deriv_within_taylorWithinEval_at_Icc'","theorem taylor_mean_remainder_bound {f : â„ â†’ E} {a b C x : â„} {n : â„•} (hab : a â‰¤ b)
    (hf : ContDiffOn â„ (n + 1) f (Icc a b)) (hx : x âˆˆ Icc a b)
    (hC : âˆ€ y âˆˆ Icc a b, â€–iteratedDerivWithin (n + 1) f (Icc a b) yâ€– â‰¤ C) :
    â€–f x - taylorWithinEval f n (Icc a b) a xâ€– â‰¤ C * (x - a) ^ (n + 1) / n ! ",":= by
  rcases eq_or_lt_of_le hab with (rfl | h)
  Â· rw [Icc_self, mem_singleton_iff] at hx
    simp [hx]
  have hf' : DifferentiableOn â„ (iteratedDerivWithin n f (Icc a b)) (Icc a b) :=
    hf.differentiableOn_iteratedDerivWithin (WithTop.coe_lt_coe.mpr n.lt_succ_self)
      (uniqueDiffOn_Icc h)
  have h' : âˆ€ y âˆˆ Ico a x,
      â€–((n ! : â„)â»Â¹ * (x - y) ^ n) â€¢ iteratedDerivWithin (n + 1) f (Icc a b) yâ€– â‰¤
        (n ! : â„)â»Â¹ * |x - a| ^ n * C := by
    rintro y âŸ¨hay, hyxâŸ©
    rw [norm_smul, Real.norm_eq_abs]
    gcongr
    Â· rw [abs_mul, abs_pow, abs_inv, Nat.abs_cast]
      gcongr
      exact sub_nonneg.2 hyx.le
    Â· exact hC y âŸ¨hay, hyx.le.trans hx.2âŸ©
  have A : âˆ€ t âˆˆ Icc a x, HasDerivWithinAt (fun y => taylorWithinEval f n (Icc a b) y x)
      (((â†‘n !)â»Â¹ * (x - t) ^ n) â€¢ iteratedDerivWithin (n + 1) f (Icc a b) t) (Icc a x) t := by
    intro t ht
    have I : Icc a x âŠ† Icc a b := Icc_subset_Icc_right hx.2
    exact (hasDerivWithinAt_taylorWithinEval_at_Icc x h (I ht) hf.of_succ hf').mono I
  have := norm_image_sub_le_of_norm_deriv_le_segment' A h' x (right_mem_Icc.2 hx.1)
  simp only [taylorWithinEval_self] at this
  refine this.trans_eq ?_
  rw [abs_of_nonneg (sub_nonneg.mpr hx.1)]
  ring"
Mathlib/Analysis/Calculus/FDeriv/Extend.lean,has_fderiv_at_boundary_of_tendsto_fderiv,has_fderiv_at_boundary_of_tendsto_fderiv,9145723cb814c658ce29e00efbc7181b947c0552,":= by
  classical
    by_cases hx : x âˆ‰ closure s
    Â· rw [â† closure_closure] at hx; exact hasFDerivWithinAt_of_nmem_closure hx
    push_neg at hx
    rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, Asymptotics.isLittleO_iff]
    intro Îµ Îµ_pos
    obtain âŸ¨Î´, Î´_pos, hÎ´âŸ© : âˆƒ Î´ > 0, âˆ€ y âˆˆ s, dist y x < Î´ â†’ â€–fderiv â„ f y - f'â€– < Îµ := by
      simpa [dist_zero_right] using tendsto_nhdsWithin_nhds.1 h Îµ Îµ_pos
    set B := ball x Î´
    suffices âˆ€ y âˆˆ B âˆ© closure s, â€–f y - f x - (f' y - f' x)â€– â‰¤ Îµ * â€–y - xâ€– from
      mem_nhdsWithin_iff.2 âŸ¨Î´, Î´_pos, fun y hy => by simpa using this y hyâŸ©
    suffices
      âˆ€ p : E Ã— E,
        p âˆˆ closure ((B âˆ© s) Ã—Ë¢ (B âˆ© s)) â†’ â€–f p.2 - f p.1 - (f' p.2 - f' p.1)â€– â‰¤ Îµ * â€–p.2 - p.1â€– by
      rw [closure_prod_eq] at this
      intro y y_in
      apply this âŸ¨x, yâŸ©
      have : B âˆ© closure s âŠ† closure (B âˆ© s) := isOpen_ball.inter_closure
      exact âŸ¨this âŸ¨mem_ball_self Î´_pos, hxâŸ©, this y_inâŸ©
    have key : âˆ€ p : E Ã— E, p âˆˆ (B âˆ© s) Ã—Ë¢ (B âˆ© s) â†’
          â€–f p.2 - f p.1 - (f' p.2 - f' p.1)â€– â‰¤ Îµ * â€–p.2 - p.1â€– := by
      rintro âŸ¨u, vâŸ© âŸ¨u_in, v_inâŸ©
      have conv : Convex â„ (B âˆ© s) := (convex_ball _ _).inter s_conv
      have diff : DifferentiableOn â„ f (B âˆ© s) := f_diff.mono (inter_subset_right _ _)
      have bound : âˆ€ z âˆˆ B âˆ© s, â€–fderivWithin â„ f (B âˆ© s) z - f'â€– â‰¤ Îµ := by
        intro z z_in
        have h := hÎ´ z
        have : fderivWithin â„ f (B âˆ© s) z = fderiv â„ f z := by
          have op : IsOpen (B âˆ© s) := isOpen_ball.inter s_open
          rw [DifferentiableAt.fderivWithin _ (op.uniqueDiffOn z z_in)]
          exact (diff z z_in).differentiableAt (IsOpen.mem_nhds op z_in)
        rw [â† this] at h
        exact le_of_lt (h z_in.2 z_in.1)
      simpa using conv.norm_image_sub_le_of_norm_fderivWithin_le' diff bound u_in v_in
    rintro âŸ¨u, vâŸ© uv_in
    refine' ContinuousWithinAt.closure_le uv_in _ _ key
    have f_cont' : âˆ€ y âˆˆ closure s, ContinuousWithinAt (f - â‡‘f') s y := by
      intro y y_in
      exact Tendsto.sub (f_cont y y_in) f'.cont.continuousWithinAt
    all_goals
      have : (B âˆ© s) Ã—Ë¢ (B âˆ© s) âŠ† s Ã—Ë¢ s := by mono <;> exact inter_subset_right _ _
      obtain âŸ¨u_in, v_inâŸ© : u âˆˆ closure s âˆ§ v âˆˆ closure s := by
        simpa [closure_prod_eq] using closure_mono this uv_in
      apply ContinuousWithinAt.mono _ this
      simp only [ContinuousWithinAt]
    rw [nhdsWithin_prod_eq]
    Â· have : âˆ€ u v, f v - f u - (f' v - f' u) = f v - f' v - (f u - f' u) := by intros; abel
      simp only [this]
      exact
        Tendsto.comp continuous_norm.continuousAt
          ((Tendsto.comp (f_cont' v v_in) tendsto_snd).sub <|
            Tendsto.comp (f_cont' u u_in) tendsto_fst)
    Â· apply tendsto_nhdsWithin_of_tendsto_nhds
      rw [nhds_prod_eq]
      exact
        tendsto_const_nhds.mul
          (Tendsto.comp continuous_norm.continuousAt <| tendsto_snd.sub tendsto_fst)","error:  function expected at
  inter_subset_right ?m.39563
term has type
  ?m.39562 âˆˆ ?m.39561
error:  function expected at
  inter_subset_right ?m.79888
term has type
  ?m.79887 âˆˆ ?m.79886
error:  function expected at
  inter_subset_right ?m.79930
term has type
  ?m.79929 âˆˆ ?m.79928
error:  function expected at
  inter_subset_right ?m.107395
term has type
  ?m.107394 âˆˆ ?m.107393
error:  function expected at
  inter_subset_right ?m.107437
term has type
  ?m.107436 âˆˆ ?m.107435","theorem has_fderiv_at_boundary_of_tendsto_fderiv {f : E â†’ F} {s : Set E} {x : E} {f' : E â†’L[â„] F}
    (f_diff : DifferentiableOn â„ f s) (s_conv : Convex â„ s) (s_open : IsOpen s)
    (f_cont : âˆ€ y âˆˆ closure s, ContinuousWithinAt f s y)
    (h : Tendsto (fun y => fderiv â„ f y) (ğ“[s] x) (ğ“ f')) :
    HasFDerivWithinAt f f' (closure s) x ",":= by
  classical
    by_cases hx : x âˆ‰ closure s
    Â· rw [â† closure_closure] at hx; exact hasFDerivWithinAt_of_nmem_closure hx
    push_neg at hx
    rw [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleO, Asymptotics.isLittleO_iff]
    intro Îµ Îµ_pos
    obtain âŸ¨Î´, Î´_pos, hÎ´âŸ© : âˆƒ Î´ > 0, âˆ€ y âˆˆ s, dist y x < Î´ â†’ â€–fderiv â„ f y - f'â€– < Îµ := by
      simpa [dist_zero_right] using tendsto_nhdsWithin_nhds.1 h Îµ Îµ_pos
    set B := ball x Î´
    suffices âˆ€ y âˆˆ B âˆ© closure s, â€–f y - f x - (f' y - f' x)â€– â‰¤ Îµ * â€–y - xâ€– from
      mem_nhdsWithin_iff.2 âŸ¨Î´, Î´_pos, fun y hy => by simpa using this y hyâŸ©
    suffices
      âˆ€ p : E Ã— E,
        p âˆˆ closure ((B âˆ© s) Ã—Ë¢ (B âˆ© s)) â†’ â€–f p.2 - f p.1 - (f' p.2 - f' p.1)â€– â‰¤ Îµ * â€–p.2 - p.1â€– by
      rw [closure_prod_eq] at this
      intro y y_in
      apply this âŸ¨x, yâŸ©
      have : B âˆ© closure s âŠ† closure (B âˆ© s) := isOpen_ball.inter_closure
      exact âŸ¨this âŸ¨mem_ball_self Î´_pos, hxâŸ©, this y_inâŸ©
    have key : âˆ€ p : E Ã— E, p âˆˆ (B âˆ© s) Ã—Ë¢ (B âˆ© s) â†’
          â€–f p.2 - f p.1 - (f' p.2 - f' p.1)â€– â‰¤ Îµ * â€–p.2 - p.1â€– := by
      rintro âŸ¨u, vâŸ© âŸ¨u_in, v_inâŸ©
      have conv : Convex â„ (B âˆ© s) := (convex_ball _ _).inter s_conv
      have diff : DifferentiableOn â„ f (B âˆ© s) := f_diff.mono inter_subset_right
      have bound : âˆ€ z âˆˆ B âˆ© s, â€–fderivWithin â„ f (B âˆ© s) z - f'â€– â‰¤ Îµ := by
        intro z z_in
        have h := hÎ´ z
        have : fderivWithin â„ f (B âˆ© s) z = fderiv â„ f z := by
          have op : IsOpen (B âˆ© s) := isOpen_ball.inter s_open
          rw [DifferentiableAt.fderivWithin _ (op.uniqueDiffOn z z_in)]
          exact (diff z z_in).differentiableAt (IsOpen.mem_nhds op z_in)
        rw [â† this] at h
        exact le_of_lt (h z_in.2 z_in.1)
      simpa using conv.norm_image_sub_le_of_norm_fderivWithin_le' diff bound u_in v_in
    rintro âŸ¨u, vâŸ© uv_in
    have f_cont' : âˆ€ y âˆˆ closure s, ContinuousWithinAt (f -  â‡‘f') s y := by
      intro y y_in
      exact Tendsto.sub (f_cont y y_in) f'.cont.continuousWithinAt
    refine ContinuousWithinAt.closure_le uv_in ?_ ?_ key
    all_goals
      have : (B âˆ© s) Ã—Ë¢ (B âˆ© s) âŠ† s Ã—Ë¢ s := by gcongr <;> exact inter_subset_right
      obtain âŸ¨u_in, v_inâŸ© : u âˆˆ closure s âˆ§ v âˆˆ closure s := by
        simpa [closure_prod_eq] using closure_mono this uv_in
      apply ContinuousWithinAt.mono _ this
      simp only [ContinuousWithinAt]
    Â· rw [nhdsWithin_prod_eq]
      have : âˆ€ u v, f v - f u - (f' v - f' u) = f v - f' v - (f u - f' u) := by intros; abel
      simp only [this]
      exact
        Tendsto.comp continuous_norm.continuousAt
          ((Tendsto.comp (f_cont' v v_in) tendsto_snd).sub <|
            Tendsto.comp (f_cont' u u_in) tendsto_fst)
    Â· apply tendsto_nhdsWithin_of_tendsto_nhds
      rw [nhds_prod_eq]
      exact
        tendsto_const_nhds.mul
          (Tendsto.comp continuous_norm.continuousAt <| tendsto_snd.sub tendsto_fst)"
Mathlib/Data/Finset/Sym.lean,Finset.sym_union,sym_union,67ee3b7709353762fdc01cfb00722ee8c27ff6a5,":=
  union_subset (sym_mono (subset_union_left s t) n) (sym_mono (subset_union_right s t) n)","error:  application type mismatch
  subset_union_left s
argument
  s
has type
  Finset Î± : Type u_1
but is expected to have type
  ?m.17328 âˆˆ ?m.17326 : Prop
error:  application type mismatch
  subset_union_right s
argument
  s
has type
  Finset Î± : Type u_1
but is expected to have type
  ?m.17809 âˆˆ ?m.17808 : Prop",theorem sym_union (s t : Finset Î±) (n : â„•) : s.sym n âˆª t.sym n âŠ† (s âˆª t).sym n ,":=
  union_subset (sym_mono subset_union_left n) (sym_mono subset_union_right n)"
Mathlib/Data/Nat/Totient.lean,Nat.totient_prime,totient_prime,40b58304ad9cb6913d2d4e97172b2c306fdb61f2,":=
  calc
    Ï† (p ^ (n + 1)) = ((range (p ^ (n + 1))).filter (coprime (p ^ (n + 1)))).card :=
      totient_eq_card_coprime _
    _ = (range (p ^ (n + 1)) \ (range (p ^ n)).image (Â· * p)).card :=
      (congr_arg card
        (by
          rw [sdiff_eq_filter]
          apply filter_congr
          simp only [mem_range, mem_filter, coprime_pow_left_iff n.succ_pos, mem_image, not_exists,
            hp.coprime_iff_not_dvd]
          intro a ha
          constructor
          Â· intro hap b h; rcases h with âŸ¨_, rflâŸ©
            exact hap (dvd_mul_left _ _)
          Â· rintro h âŸ¨b, rflâŸ©
            rw [pow_succ'] at ha
            exact h b âŸ¨lt_of_mul_lt_mul_left ha (zero_le _), mul_comm _ _âŸ©))
    _ = _ := by
      have h1 : Function.Injective (Â· * p) := mul_left_injectiveâ‚€ hp.ne_zero
      have h2 : (range (p ^ n)).image (Â· * p) âŠ† range (p ^ (n + 1)) := fun a => by
        simp only [mem_image, mem_range, exists_imp]
        rintro b âŸ¨h, rflâŸ©
        rw [pow_succ]
        exact (mul_lt_mul_right hp.pos).2 h
      rw [card_sdiff h2, card_image_of_injOn (h1.injOn _), card_range, card_range, â†
        one_mul (p ^ n), pow_succ', â† tsub_mul, one_mul, mul_comm]","warning:  totient does not have a doc string
error:  unknown identifier 'coprime'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?sâ‚ \ ?sâ‚‚
p : â„•
hp : Prime p
n : â„•
âŠ¢ ?m.51057 = ?m.51058
error:  application type mismatch
  card_image_of_injOn (Function.Injective.injOn h1 ?m.55531)
argument
  Function.Injective.injOn h1 ?m.55531
has type
  âˆ€ â¦ƒxâ‚‚ : â„•â¦„, xâ‚‚ âˆˆ ?m.55529 â†’ ?m.55530 * p = xâ‚‚ * p â†’ ?m.55530 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn ?m.55507 ?m.55506 : Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.card â†‘(?m.55507 '' ?m.55506)
p : â„•
hp : Prime p
n : â„•
h1 : Function.Injective fun x â†¦ x * p
h2 : image (fun x â†¦ x * p) (range (p ^ n)) âŠ† range (p ^ (n + 1))
âŠ¢ (range (p ^ (n + 1))).card - (image (fun x â†¦ x * p) (range (p ^ n))).card = p ^ n * (p - 1)",theorem totient_prime_pow_succ {p : â„•} (hp : p.Prime) (n : â„•) : Ï† (p ^ (n + 1)) = p ^ n * (p - 1) ,":=
  calc
    Ï† (p ^ (n + 1)) = ((range (p ^ (n + 1))).filter (Coprime (p ^ (n + 1)))).card :=
      totient_eq_card_coprime _
    _ = (range (p ^ (n + 1)) \ (range (p ^ n)).image (Â· * p)).card :=
      (congr_arg card
        (by
          rw [sdiff_eq_filter]
          apply filter_congr
          simp only [mem_range, mem_filter, coprime_pow_left_iff n.succ_pos, mem_image, not_exists,
            hp.coprime_iff_not_dvd]
          intro a ha
          constructor
          Â· intro hap b h; rcases h with âŸ¨_, rflâŸ©
            exact hap (dvd_mul_left _ _)
          Â· rintro h âŸ¨b, rflâŸ©
            rw [pow_succ'] at ha
            exact h b âŸ¨lt_of_mul_lt_mul_left ha (zero_le _), mul_comm _ _âŸ©))
    _ = _ := by
      have h1 : Function.Injective (Â· * p) := mul_left_injectiveâ‚€ hp.ne_zero
      have h2 : (range (p ^ n)).image (Â· * p) âŠ† range (p ^ (n + 1)) := fun a => by
        simp only [mem_image, mem_range, exists_imp]
        rintro b âŸ¨h, rflâŸ©
        rw [Nat.pow_succ]
        exact (mul_lt_mul_right hp.pos).2 h
      rw [card_sdiff h2, Finset.card_image_of_injective _ h1, card_range, card_range, â†
        one_mul (p ^ n), pow_succ', â† tsub_mul, one_mul, mul_comm]"
Mathlib/Data/QPF/Multivariate/Constructions/Cofix.lean,MvQPF.liftR_map_last,liftR_map_last,67ee3b7709353762fdc01cfb00722ee8c27ff6a5,":=
  let h : Î¹ â†’ { x : Î¹' Ã— Î¹' // uncurry R x } := fun x => âŸ¨(f x, g x), hh xâŸ©
  let b : (Î± ::: Î¹) âŸ¹ _ := @diagSub n Î± ::: h
  let c :
    (Subtype_ Î±.repeatEq ::: { x // uncurry R x }) âŸ¹
      ((fun i : Fin2 n => { x // ofRepeat (Î±.RelLast' R i.fs x) }) ::: Subtype (uncurry R)) :=
    ofSubtype _ ::: id
  have hh :
    subtypeVal _ âŠš toSubtype _ âŠš fromAppend1DropLast âŠš c âŠš b =
      ((id ::: f) âŠ—' (id ::: g)) âŠš prod.diag := by
    dsimp [b]
    apply eq_of_drop_last_eq
    Â· dsimp
      simp only [prod_map_id, dropFun_prod, dropFun_appendFun, dropFun_diag, TypeVec.id_comp,
        dropFun_toSubtype]
      erw [toSubtype_of_subtype_assoc, TypeVec.id_comp]
      clear liftR_map_last q mvf lawful F x R f g hh h b c
      ext (i x) : 2
      induction i with
      | fz => rfl
      | fs _ ih =>
        apply ih
    simp only [lastFun_from_append1_drop_last, lastFun_toSubtype, lastFun_appendFun,
      lastFun_subtypeVal, Function.id_comp, lastFun_comp, lastFun_prod]
    ext1
    rfl
  liftR_map _ _ _ _ (toSubtype _ âŠš fromAppend1DropLast âŠš c âŠš b) hh",error:  unknown identifier 'mvf',"theorem liftR_map_last [lawful : LawfulMvFunctor F]
    {Î± : TypeVec n} {Î¹ Î¹'} (R : Î¹' â†’ Î¹' â†’ Prop)
    (x : F (Î± ::: Î¹)) (f g : Î¹ â†’ Î¹') (hh : âˆ€ x : Î¹, R (f x) (g x)) :
    LiftR' (RelLast' _ R) ((id ::: f) <$$> x) ((id ::: g) <$$> x) ",":=
  let h : Î¹ â†’ { x : Î¹' Ã— Î¹' // uncurry R x } := fun x => âŸ¨(f x, g x), hh xâŸ©
  let b : (Î± ::: Î¹) âŸ¹ _ := @diagSub n Î± ::: h
  let c :
    (Subtype_ Î±.repeatEq ::: { x // uncurry R x }) âŸ¹
      ((fun i : Fin2 n => { x // ofRepeat (Î±.RelLast' R i.fs x) }) ::: Subtype (uncurry R)) :=
    ofSubtype _ ::: id
  have hh :
    subtypeVal _ âŠš toSubtype _ âŠš fromAppend1DropLast âŠš c âŠš b =
      ((id ::: f) âŠ—' (id ::: g)) âŠš prod.diag := by
    dsimp [b]
    apply eq_of_drop_last_eq
    Â· dsimp
      simp only [prod_map_id, dropFun_prod, dropFun_appendFun, dropFun_diag, TypeVec.id_comp,
        dropFun_toSubtype]
      erw [toSubtype_of_subtype_assoc, TypeVec.id_comp]
      clear liftR_map_last q lawful F x R f g hh h b c
      ext (i x) : 2
      induction i with
      | fz => rfl
      | fs _ ih =>
        apply ih
    simp only [lastFun_from_append1_drop_last, lastFun_toSubtype, lastFun_appendFun,
      lastFun_subtypeVal, Function.id_comp, lastFun_comp, lastFun_prod]
    ext1
    rfl
  liftR_map _ _ _ _ (toSubtype _ âŠš fromAppend1DropLast âŠš c âŠš b) hh"
Mathlib/Topology/ShrinkingLemma.lean,ShrinkingLemma.PartialRefinement.exists_gt,exists_gt,2a87032320c8a6441a601ba5b37374ff532cf9b9,":= by
  have I : (s âˆ© â‹‚ (j) (_ : j â‰  i), v já¶œ) âŠ† v i := by
    simp only [subset_def, mem_inter_iff, mem_iInter, and_imp]
    intro x hxs H
    rcases mem_iUnion.1 (v.subset_iUnion hxs) with âŸ¨j, hjâŸ©
    exact (em (j = i)).elim (fun h => h â–¸ hj) fun h => (H j h hj).elim
  have C : IsClosed (s âˆ© â‹‚ (j) (_ : j â‰  i), v já¶œ) :=
    IsClosed.inter hs (isClosed_biInter fun _ _ => isClosed_compl_iff.2 <| v.isOpen _)
  rcases normal_exists_closure_subset C (v.isOpen i) I with âŸ¨vi, ovi, hvi, cviâŸ©
  refine' âŸ¨âŸ¨update v i vi, insert i v.carrier, _, _, _, _âŸ©, _, _âŸ©
  Â· intro j
    rcases eq_or_ne j i with (rfl| hne) <;> simp [*, v.isOpen]
  Â· refine' fun x hx => mem_iUnion.2 _
    rcases em (âˆƒ (j : _) (_ : j â‰  i), x âˆˆ v j) with (âŸ¨j, hji, hjâŸ© | h)
    Â· use j
      rwa [update_noteq hji]
    Â· push_neg at h
      use i
      rw [update_same]
      exact hvi âŸ¨hx, mem_biInter hâŸ©
  Â· rintro j (rfl | hj)
    Â· rwa [update_same, â† v.apply_eq hi]
    Â· rw [update_noteq (ne_of_mem_of_not_mem hj hi)]
      exact v.closure_subset hj
  Â· intro j hj
    rw [mem_insert_iff, not_or] at hj
    rw [update_noteq hj.1, v.apply_eq hj.2]
  Â· refine' âŸ¨subset_insert _ _, fun j hj => _âŸ©
    exact (update_noteq (ne_of_mem_of_not_mem hj hi) _ _).symm
  Â· exact fun hle => hi (hle.1 <| mem_insert _ _)","error:  failed to synthesize
  HasCompl Î¹
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  HasCompl Î¹
use `set_option diagnostics true` to get diagnostic information","theorem exists_gt (v : PartialRefinement u s) (hs : IsClosed s) (i : Î¹) (hi : i âˆ‰ v.carrier) :
    âˆƒ v' : PartialRefinement u s, v < v' ",":= by
  have I : (s âˆ© â‹‚ (j) (_ : j â‰  i), (v j)á¶œ) âŠ† v i := by
    simp only [subset_def, mem_inter_iff, mem_iInter, and_imp]
    intro x hxs H
    rcases mem_iUnion.1 (v.subset_iUnion hxs) with âŸ¨j, hjâŸ©
    exact (em (j = i)).elim (fun h => h â–¸ hj) fun h => (H j h hj).elim
  have C : IsClosed (s âˆ© â‹‚ (j) (_ : j â‰  i), (v j)á¶œ) :=
    IsClosed.inter hs (isClosed_biInter fun _ _ => isClosed_compl_iff.2 <| v.isOpen _)
  rcases normal_exists_closure_subset C (v.isOpen i) I with âŸ¨vi, ovi, hvi, cviâŸ©
  refine âŸ¨âŸ¨update v i vi, insert i v.carrier, ?_, ?_, ?_, ?_âŸ©, ?_, ?_âŸ©
  Â· intro j
    rcases eq_or_ne j i with (rfl| hne) <;> simp [*, v.isOpen]
  Â· refine fun x hx => mem_iUnion.2 ?_
    rcases em (âˆƒ j â‰  i, x âˆˆ v j) with (âŸ¨j, hji, hjâŸ© | h)
    Â· use j
      rwa [update_noteq hji]
    Â· push_neg at h
      use i
      rw [update_same]
      exact hvi âŸ¨hx, mem_biInter hâŸ©
  Â· rintro j (rfl | hj)
    Â· rwa [update_same, â† v.apply_eq hi]
    Â· rw [update_noteq (ne_of_mem_of_not_mem hj hi)]
      exact v.closure_subset hj
  Â· intro j hj
    rw [mem_insert_iff, not_or] at hj
    rw [update_noteq hj.1, v.apply_eq hj.2]
  Â· refine âŸ¨subset_insert _ _, fun j hj => ?_âŸ©
    exact (update_noteq (ne_of_mem_of_not_mem hj hi) _ _).symm
  Â· exact fun hle => hi (hle.1 <| mem_insert _ _)"
Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean,MeasureTheory.exists_le_lowerSemicontinuous_lintegral_ge,exists_le_lowerSemicontinuous_lintegral_ge,775e01228dac511545eaea91c9d7e90a5ffa55b4,":= by
  rcases ENNReal.exists_pos_sum_of_countable' Îµpos â„• with âŸ¨Î´, Î´pos, hÎ´âŸ©
  have :
    âˆ€ n,
      âˆƒ g : Î± â†’ â„â‰¥0,
        (âˆ€ x, SimpleFunc.eapproxDiff f n x â‰¤ g x) âˆ§
          LowerSemicontinuous g âˆ§
            (âˆ«â» x, g x âˆ‚Î¼) â‰¤ (âˆ«â» x, SimpleFunc.eapproxDiff f n x âˆ‚Î¼) + Î´ n :=
    fun n =>
    SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge Î¼ (SimpleFunc.eapproxDiff f n)
      (Î´pos n).ne'
  choose g f_le_g gcont hg using this
  refine' âŸ¨fun x => âˆ‘' n, g n x, fun x => _, _, _âŸ©
  Â· rw [â† SimpleFunc.tsum_eapproxDiff f hf]
    exact ENNReal.tsum_le_tsum fun n => ENNReal.coe_le_coe.2 (f_le_g n x)
  Â· refine' lowerSemicontinuous_tsum fun n => _
    exact
      ENNReal.continuous_coe.comp_lowerSemicontinuous (gcont n) fun x y hxy =>
        ENNReal.coe_le_coe.2 hxy
  Â· calc
      âˆ«â» x, âˆ‘' n : â„•, g n x âˆ‚Î¼ = âˆ‘' n, âˆ«â» x, g n x âˆ‚Î¼ := by
        rw [lintegral_tsum fun n => (gcont n).measurable.coe_nnreal_ennreal.aemeasurable]
      _ â‰¤ âˆ‘' n, (âˆ«â» x, SimpleFunc.eapproxDiff f n x âˆ‚Î¼) + Î´ n := (ENNReal.tsum_le_tsum hg)
      _ = (âˆ‘' n, âˆ«â» x, SimpleFunc.eapproxDiff f n x âˆ‚Î¼) + âˆ‘' n, Î´ n := ENNReal.tsum_add
      _ â‰¤ (âˆ«â» x : Î±, f x âˆ‚Î¼) + Îµ := by
        refine' add_le_add _ hÎ´.le
        rw [â† lintegral_tsum]
        Â· simp_rw [SimpleFunc.tsum_eapproxDiff f hf, le_refl]
        Â· intro n; exact (SimpleFunc.measurable _).coe_nnreal_ennreal.aemeasurable",error:  unknown identifier 'n',"theorem exists_le_lowerSemicontinuous_lintegral_ge (f : Î± â†’ â„â‰¥0âˆ) (hf : Measurable f) {Îµ : â„â‰¥0âˆ}
    (Îµpos : Îµ â‰  0) :
    âˆƒ g : Î± â†’ â„â‰¥0âˆ,
      (âˆ€ x, f x â‰¤ g x) âˆ§ LowerSemicontinuous g âˆ§ (âˆ«â» x, g x âˆ‚Î¼) â‰¤ (âˆ«â» x, f x âˆ‚Î¼) + Îµ ",":= by
  rcases ENNReal.exists_pos_sum_of_countable' Îµpos â„• with âŸ¨Î´, Î´pos, hÎ´âŸ©
  have :
    âˆ€ n,
      âˆƒ g : Î± â†’ â„â‰¥0,
        (âˆ€ x, SimpleFunc.eapproxDiff f n x â‰¤ g x) âˆ§
          LowerSemicontinuous g âˆ§
            (âˆ«â» x, g x âˆ‚Î¼) â‰¤ (âˆ«â» x, SimpleFunc.eapproxDiff f n x âˆ‚Î¼) + Î´ n :=
    fun n =>
    SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge Î¼ (SimpleFunc.eapproxDiff f n)
      (Î´pos n).ne'
  choose g f_le_g gcont hg using this
  refine âŸ¨fun x => âˆ‘' n, g n x, fun x => ?_, ?_, ?_âŸ©
  Â· rw [â† SimpleFunc.tsum_eapproxDiff f hf]
    exact ENNReal.tsum_le_tsum fun n => ENNReal.coe_le_coe.2 (f_le_g n x)
  Â· refine lowerSemicontinuous_tsum fun n => ?_
    exact
      ENNReal.continuous_coe.comp_lowerSemicontinuous (gcont n) fun x y hxy =>
        ENNReal.coe_le_coe.2 hxy
  Â· calc
      âˆ«â» x, âˆ‘' n : â„•, g n x âˆ‚Î¼ = âˆ‘' n, âˆ«â» x, g n x âˆ‚Î¼ := by
        rw [lintegral_tsum fun n => (gcont n).measurable.coe_nnreal_ennreal.aemeasurable]
      _ â‰¤ âˆ‘' n, ((âˆ«â» x, SimpleFunc.eapproxDiff f n x âˆ‚Î¼) + Î´ n) := ENNReal.tsum_le_tsum hg
      _ = âˆ‘' n, âˆ«â» x, SimpleFunc.eapproxDiff f n x âˆ‚Î¼ + âˆ‘' n, Î´ n := ENNReal.tsum_add
      _ â‰¤ (âˆ«â» x : Î±, f x âˆ‚Î¼) + Îµ := by
        refine add_le_add ?_ hÎ´.le
        rw [â† lintegral_tsum]
        Â· simp_rw [SimpleFunc.tsum_eapproxDiff f hf, le_refl]
        Â· intro n; exact (SimpleFunc.measurable _).coe_nnreal_ennreal.aemeasurable"
Mathlib/RingTheory/FiniteType.lean,RingHom.FiniteType.comp,comp,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  letI : SMul A B := f.toSMul
  letI : Algebra A B := f.toAlgebra
  letI : SMul A C := (g.comp f).toSMul
  letI : Algebra A C := (g.comp f).toAlgebra
  exact Algebra.FiniteType.of_surjective hf
    { g with
      toFun := g
      commutes' := fun a => rfl }
    hg","error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  f
has type
  A â†’+* B
error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  g.comp f
has type
  A â†’+* C","theorem comp_surjective {f : A â†’+* B} {g : B â†’+* C} (hf : f.FiniteType) (hg : Surjective g) :
    (g.comp f).FiniteType ",":= by
  let _ : Algebra A B := f.toAlgebra
  let _ : Algebra A C := (g.comp f).toAlgebra
  exact Algebra.FiniteType.of_surjective hf
    { g with
      toFun := g
      commutes' := fun a => rfl }
    hg"
Mathlib/Combinatorics/SetFamily/HarrisKleitman.lean,IsLowerSet.le_card_inter_finset,IsLowerSet.le_card_inter_finset,1efbb9e50a71340493cbce9f10f70a71b845c454,":= by
  induction' s with a s hs ih generalizing ğ’œ â„¬
  Â· simp_rw [subset_empty, â† subset_singleton_iff', subset_singleton_iff] at hğ’œs hâ„¬s
    obtain rfl | rfl := hğ’œs
    Â· simp only [card_empty, zero_mul, empty_inter, mul_zero, le_refl]
    obtain rfl | rfl := hâ„¬s
    Â· simp only [card_empty, inter_empty, mul_zero, zero_mul, le_refl]
    Â· simp only [card_empty, pow_zero, inter_singleton_of_mem, mem_singleton, card_singleton,
        le_refl]
  rw [card_insert_of_not_mem hs, â† card_memberSubfamily_add_card_nonMemberSubfamily a ğ’œ, â†
    card_memberSubfamily_add_card_nonMemberSubfamily a â„¬, add_mul, mul_add, mul_add,
    add_comm (_ * _), add_add_add_comm]
  refine'
    (add_le_add_right
          (mul_add_mul_le_mul_add_mul
              (card_le_card hğ’œ.memberSubfamily_subset_nonMemberSubfamily) <|
            card_le_card hâ„¬.memberSubfamily_subset_nonMemberSubfamily)
          _).trans
      _
  rw [â† two_mul, pow_succ', mul_assoc]
  have hâ‚€ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’
      âˆ€ t âˆˆ ğ’.nonMemberSubfamily a, t âŠ† s := by
    rintro ğ’ hğ’ t ht
    rw [mem_nonMemberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 (hğ’ _ ht.1)
  have hâ‚ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’
      âˆ€ t âˆˆ ğ’.memberSubfamily a, t âŠ† s := by
    rintro ğ’ hğ’ t ht
    rw [mem_memberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 ((subset_insert _ _).trans <| hğ’ _ ht.1)
  refine' mul_le_mul_left' _ _
  refine' (add_le_add (ih hğ’œ.memberSubfamily hâ„¬.memberSubfamily (hâ‚ _ hğ’œs) <| hâ‚ _ hâ„¬s) <|
    ih hğ’œ.nonMemberSubfamily hâ„¬.nonMemberSubfamily (hâ‚€ _ hğ’œs) <| hâ‚€ _ hâ„¬s).trans_eq _
  rw [â† mul_add, â† memberSubfamily_inter, â† nonMemberSubfamily_inter,
    card_memberSubfamily_add_card_nonMemberSubfamily]","error:  simp made no progress
error:  no goals to be solved","theorem IsLowerSet.le_card_inter_finset' (hğ’œ : IsLowerSet (ğ’œ : Set (Finset Î±)))
    (hâ„¬ : IsLowerSet (â„¬ : Set (Finset Î±))) (hğ’œs : âˆ€ t âˆˆ ğ’œ, t âŠ† s) (hâ„¬s : âˆ€ t âˆˆ â„¬, t âŠ† s) :
    ğ’œ.card * â„¬.card â‰¤ 2 ^ s.card * (ğ’œ âˆ© â„¬).card ",":= by
  induction' s using Finset.induction with a s hs ih generalizing ğ’œ â„¬
  Â· simp_rw [subset_empty, â† subset_singleton_iff', subset_singleton_iff] at hğ’œs hâ„¬s
    obtain rfl | rfl := hğ’œs
    Â· simp only [card_empty, zero_mul, empty_inter, mul_zero, le_refl]
    obtain rfl | rfl := hâ„¬s
    Â· simp only [card_empty, inter_empty, mul_zero, zero_mul, le_refl]
    Â· simp only [card_empty, pow_zero, inter_singleton_of_mem, mem_singleton, card_singleton,
        le_refl]
  rw [card_insert_of_not_mem hs, â† card_memberSubfamily_add_card_nonMemberSubfamily a ğ’œ, â†
    card_memberSubfamily_add_card_nonMemberSubfamily a â„¬, add_mul, mul_add, mul_add,
    add_comm (_ * _), add_add_add_comm]
  refine
    (add_le_add_right
          (mul_add_mul_le_mul_add_mul
              (card_le_card hğ’œ.memberSubfamily_subset_nonMemberSubfamily) <|
            card_le_card hâ„¬.memberSubfamily_subset_nonMemberSubfamily)
          _).trans
      ?_
  rw [â† two_mul, pow_succ', mul_assoc]
  have hâ‚€ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’
      âˆ€ t âˆˆ ğ’.nonMemberSubfamily a, t âŠ† s := by
    rintro ğ’ hğ’ t ht
    rw [mem_nonMemberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 (hğ’ _ ht.1)
  have hâ‚ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’
      âˆ€ t âˆˆ ğ’.memberSubfamily a, t âŠ† s := by
    rintro ğ’ hğ’ t ht
    rw [mem_memberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 ((subset_insert _ _).trans <| hğ’ _ ht.1)
  refine mul_le_mul_left' ?_ _
  refine (add_le_add (ih hğ’œ.memberSubfamily hâ„¬.memberSubfamily (hâ‚ _ hğ’œs) <| hâ‚ _ hâ„¬s) <|
    ih hğ’œ.nonMemberSubfamily hâ„¬.nonMemberSubfamily (hâ‚€ _ hğ’œs) <| hâ‚€ _ hâ„¬s).trans_eq ?_
  rw [â† mul_add, â† memberSubfamily_inter, â† nonMemberSubfamily_inter,
    card_memberSubfamily_add_card_nonMemberSubfamily]"
Mathlib/MeasureTheory/Integral/CircleIntegral.lean,circleIntegral.integral_sub_inv_of_mem_ball,integral_sub_inv_of_mem_ball,af48ebb5b18ea3832374fe8b89c0db3a0955175b,":= by
  have hR : 0 < R := dist_nonneg.trans_lt hw
  suffices H : HasSum (fun n : â„• => âˆ® z in C(c, R), ((w - c) / (z - c)) ^ n * (z - c)â»Â¹)
      (2 * Ï€ * I) by
    have A : CircleIntegrable (fun _ => (1 : â„‚)) c R := continuousOn_const.circleIntegrable'
    refine' (H.unique _).symm
    simpa only [smul_eq_mul, mul_one, add_sub_cancel'_right] using
      hasSum_two_pi_I_cauchyPowerSeries_integral A hw
  have H : âˆ€ n : â„•, n â‰  0 â†’ (âˆ® z in C(c, R), (z - c) ^ (-n - 1 : â„¤)) = 0 := by
    refine' fun n hn => integral_sub_zpow_of_ne _ _ _ _; simpa
  have : (âˆ® z in C(c, R), ((w - c) / (z - c)) ^ 0 * (z - c)â»Â¹) = 2 * Ï€ * I := by simp [hR.ne']
  refine' this â–¸ hasSum_single _ fun n hn => _
  simp only [div_eq_mul_inv, mul_pow, integral_const_mul, mul_assoc]
  rw [(integral_congr hR.le fun z hz => _).trans (H n hn), mul_zero]
  intro z _
  rw [â† pow_succ', â† zpow_coe_nat, inv_zpow, â† zpow_neg, Int.ofNat_succ, neg_add,
    sub_eq_add_neg _ (1 : â„¤)]","warning:  `add_sub_cancel'_right` has been deprecated, use `add_sub_cancel` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * ?a ^ ?n
E : Type u_1
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„‚ E
instâœ : CompleteSpace E
c w : â„‚
R : â„
hw : w âˆˆ ball c R
hR : 0 < R
H : âˆ€ (n : â„•), n â‰  0 â†’ (âˆ® (z : â„‚) in C(c, R), (z - c) ^ (-â†‘n - 1)) = 0
this : (âˆ® (z : â„‚) in C(c, R), ((w - c) / (z - c)) ^ 0 * (z - c)â»Â¹) = 2 * â†‘Ï€ * I
n : â„•
hn : n â‰  0
z : â„‚
hzâœ : z âˆˆ sphere c R
âŠ¢ (z - c)â»Â¹ ^ n * (z - c)â»Â¹ = (z - c) ^ (-â†‘n - 1)","theorem integral_sub_inv_of_mem_ball {c w : â„‚} {R : â„} (hw : w âˆˆ ball c R) :
    (âˆ® z in C(c, R), (z - w)â»Â¹) = 2 * Ï€ * I ",":= by
  have hR : 0 < R := dist_nonneg.trans_lt hw
  suffices H : HasSum (fun n : â„• => âˆ® z in C(c, R), ((w - c) / (z - c)) ^ n * (z - c)â»Â¹)
      (2 * Ï€ * I) by
    have A : CircleIntegrable (fun _ => (1 : â„‚)) c R := continuousOn_const.circleIntegrable'
    refine (H.unique ?_).symm
    simpa only [smul_eq_mul, mul_one, add_sub_cancel] using
      hasSum_two_pi_I_cauchyPowerSeries_integral A hw
  have H : âˆ€ n : â„•, n â‰  0 â†’ (âˆ® z in C(c, R), (z - c) ^ (-n - 1 : â„¤)) = 0 := by
    refine fun n hn => integral_sub_zpow_of_ne ?_ _ _ _; simpa
  have : (âˆ® z in C(c, R), ((w - c) / (z - c)) ^ 0 * (z - c)â»Â¹) = 2 * Ï€ * I := by simp [hR.ne']
  refine this â–¸ hasSum_single _ fun n hn => ?_
  simp only [div_eq_mul_inv, mul_pow, integral_const_mul, mul_assoc]
  rw [(integral_congr hR.le fun z hz => _).trans (H n hn), mul_zero]
  intro z _
  rw [â† pow_succ, â† zpow_natCast, inv_zpow, â† zpow_neg, Int.ofNat_succ, neg_add,
    sub_eq_add_neg _ (1 : â„¤)]"
Mathlib/CategoryTheory/Monoidal/Rigid/Basic.lean,CategoryTheory.ExactPairing.evaluation_coevaluation'',evaluation_coevaluation'',15acb5502f0b3c70cad35d2309324298925b2a6b,":= by
  convert evaluation_coevaluation X Y <;> simp [Mathlib.Tactic.Coherence.monoidalComp]","warning:  @coevaluation does not have a doc string
warning:  @evaluation does not have a doc string
error:  simp made no progress
error:  unknown identifier 'Mathlib.Tactic.Coherence.monoidalComp'
error:  unsolved goals
case h.e'_2
C : Type uâ‚
instâœÂ² : Category.{vâ‚, uâ‚} C
instâœÂ¹ : MonoidalCategory C
X Y : C
instâœ : ExactPairing X Y
âŠ¢ Î·_ X Y â–· X âŠ—â‰« X â— Îµ_ X Y = Î·_ X Y â–· X â‰« (Î±_ X Y X).hom â‰« X â— Îµ_ X Y
warning:  @leftDual does not have a doc string
warning:  @rightDual does not have a doc string
warning:  @rightAdjointMate does not have a doc string
warning:  @leftAdjointMate does not have a doc string","lemma evaluation_coevaluation'' :
    Î·_ X Y â–· X âŠ—â‰« X â— Îµ_ X Y = âŠ—ğŸ™ ",":= by
  convert evaluation_coevaluation X Y <;> simp [monoidalComp]"
Mathlib/Analysis/NormedSpace/Banach.lean,ContinuousLinearMap.exists_approx_preimage_norm_le,exists_approx_preimage_norm_le,1da5842566a76408ce7d09b3a6545bcb5a533b31,":= by
  have A : (â‹ƒ n : â„•, closure (f '' ball 0 n)) = Set.univ := by
    refine' Subset.antisymm (subset_univ _) fun y _ => _
    rcases surj y with âŸ¨x, hxâŸ©
    rcases exists_nat_gt â€–xâ€– with âŸ¨n, hnâŸ©
    refine' mem_iUnion.2 âŸ¨n, subset_closure _âŸ©
    refine' (mem_image _ _ _).2 âŸ¨x, âŸ¨_, hxâŸ©âŸ©
    rwa [mem_ball, dist_eq_norm, sub_zero]
  have : âˆƒ (n : â„•) (x : _), x âˆˆ interior (closure (f '' ball 0 n)) :=
    nonempty_interior_of_iUnion_of_closed (fun n => isClosed_closure) A
  simp only [mem_interior_iff_mem_nhds, Metric.mem_nhds_iff] at this
  rcases this with âŸ¨n, a, Îµ, âŸ¨Îµpos, HâŸ©âŸ©
  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©
  refine' âŸ¨(Îµ / 2)â»Â¹ * â€–câ€– * 2 * n, _, fun y => _âŸ©
  Â· refine' mul_nonneg (mul_nonneg (mul_nonneg _ (norm_nonneg _)) (by norm_num)) _
    exacts [inv_nonneg.2 (div_nonneg (le_of_lt Îµpos) (by norm_num)), n.cast_nonneg]
  Â· by_cases hy : y = 0
    Â· use 0
      simp [hy]
    Â· rcases rescale_to_shell hc (half_pos Îµpos) hy with âŸ¨d, hd, ydlt, -, dinvâŸ©
      let Î´ := â€–dâ€– * â€–yâ€– / 4
      have Î´pos : 0 < Î´ := div_pos (mul_pos (norm_pos_iff.2 hd) (norm_pos_iff.2 hy)) (by norm_num)
      have : a + d â€¢ y âˆˆ ball a Îµ := by
        simp [dist_eq_norm, lt_of_le_of_lt ydlt.le (half_lt_self Îµpos)]
      rcases Metric.mem_closure_iff.1 (H this) _ Î´pos with âŸ¨zâ‚, zâ‚im, hâ‚âŸ©
      rcases(mem_image _ _ _).1 zâ‚im with âŸ¨xâ‚, hxâ‚, xzâ‚âŸ©
      rw [â† xzâ‚] at hâ‚
      rw [mem_ball, dist_eq_norm, sub_zero] at hxâ‚
      have : a âˆˆ ball a Îµ := by
        simp
        exact Îµpos
      rcases Metric.mem_closure_iff.1 (H this) _ Î´pos with âŸ¨zâ‚‚, zâ‚‚im, hâ‚‚âŸ©
      rcases(mem_image _ _ _).1 zâ‚‚im with âŸ¨xâ‚‚, hxâ‚‚, xzâ‚‚âŸ©
      rw [â† xzâ‚‚] at hâ‚‚
      rw [mem_ball, dist_eq_norm, sub_zero] at hxâ‚‚
      let x := xâ‚ - xâ‚‚
      have I : â€–f x - d â€¢ yâ€– â‰¤ 2 * Î´ :=
        calc
          â€–f x - d â€¢ yâ€– = â€–f xâ‚ - (a + d â€¢ y) - (f xâ‚‚ - a)â€– := by
            congr 1
            simp only [f.map_sub]
            abel
          _ â‰¤ â€–f xâ‚ - (a + d â€¢ y)â€– + â€–f xâ‚‚ - aâ€– := (norm_sub_le _ _)
          _ â‰¤ Î´ + Î´ := by
            apply add_le_add
            Â· rw [â† dist_eq_norm, dist_comm]
              exact le_of_lt hâ‚
            Â· rw [â† dist_eq_norm, dist_comm]
              exact le_of_lt hâ‚‚
          _ = 2 * Î´ := (two_mul _).symm
      have J : â€–f (dâ»Â¹ â€¢ x) - yâ€– â‰¤ 1 / 2 * â€–yâ€– :=
        calc
          â€–f (dâ»Â¹ â€¢ x) - yâ€– = â€–dâ»Â¹ â€¢ f x - (dâ»Â¹ * d) â€¢ yâ€– := by
            rwa [f.map_smul _, inv_mul_cancel, one_smul]
          _ = â€–dâ»Â¹ â€¢ (f x - d â€¢ y)â€– := by rw [mul_smul, smul_sub]
          _ = â€–dâ€–â»Â¹ * â€–f x - d â€¢ yâ€– := by rw [norm_smul, norm_inv]
          _ â‰¤ â€–dâ€–â»Â¹ * (2 * Î´) := by
            apply mul_le_mul_of_nonneg_left I
            rw [inv_nonneg]
            exact norm_nonneg _
          _ = â€–dâ€–â»Â¹ * â€–dâ€– * â€–yâ€– / 2 := by
            simp only
            ring
          _ = â€–yâ€– / 2 := by
            rw [inv_mul_cancel, one_mul]
            simp [norm_eq_zero, hd]
          _ = 1 / 2 * â€–yâ€– := by ring
      rw [â† dist_eq_norm] at J
      have K : â€–dâ»Â¹ â€¢ xâ€– â‰¤ (Îµ / 2)â»Â¹ * â€–câ€– * 2 * â†‘n * â€–yâ€– :=
        calc
          â€–dâ»Â¹ â€¢ xâ€– = â€–dâ€–â»Â¹ * â€–xâ‚ - xâ‚‚â€– := by rw [norm_smul, norm_inv]
          _ â‰¤ (Îµ / 2)â»Â¹ * â€–câ€– * â€–yâ€– * (n + n) := by
            refine' mul_le_mul dinv _ (norm_nonneg _) _
            Â· exact le_trans (norm_sub_le _ _) (add_le_add (le_of_lt hxâ‚) (le_of_lt hxâ‚‚))
            Â· apply mul_nonneg (mul_nonneg _ (norm_nonneg _)) (norm_nonneg _)
              exact inv_nonneg.2 (le_of_lt (half_pos Îµpos))
          _ = (Îµ / 2)â»Â¹ * â€–câ€– * 2 * â†‘n * â€–yâ€– := by ring

      exact âŸ¨dâ»Â¹ â€¢ x, J, KâŸ©","error:  failed to synthesize
  NormedSpace ğ•œ F
use `set_option diagnostics true` to get diagnostic information
error:  rcases tactic failed: xâœ : ?m.71381 is not an inductive datatype","theorem exists_approx_preimage_norm_le (surj : Surjective f) :
    âˆƒ C â‰¥ 0, âˆ€ y, âˆƒ x, dist (f x) y â‰¤ 1 / 2 * â€–yâ€– âˆ§ â€–xâ€– â‰¤ C * â€–yâ€– ",":= by
  have A : â‹ƒ n : â„•, closure (f '' ball 0 n) = Set.univ := by
    refine Subset.antisymm (subset_univ _) fun y _ => ?_
    rcases surj y with âŸ¨x, hxâŸ©
    rcases exists_nat_gt â€–xâ€– with âŸ¨n, hnâŸ©
    refine mem_iUnion.2 âŸ¨n, subset_closure ?_âŸ©
    refine (mem_image _ _ _).2 âŸ¨x, âŸ¨?_, hxâŸ©âŸ©
    rwa [mem_ball, dist_eq_norm, sub_zero]
  have : âˆƒ (n : â„•) (x : _), x âˆˆ interior (closure (f '' ball 0 n)) :=
    nonempty_interior_of_iUnion_of_closed (fun n => isClosed_closure) A
  simp only [mem_interior_iff_mem_nhds, Metric.mem_nhds_iff] at this
  rcases this with âŸ¨n, a, Îµ, âŸ¨Îµpos, HâŸ©âŸ©
  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©
  refine âŸ¨(Îµ / 2)â»Â¹ * â€–câ€– * 2 * n, by positivity, fun y => ?_âŸ©
  rcases eq_or_ne y 0 with rfl | hy
  Â· use 0
    simp
  Â· have hc' : 1 < â€–Ïƒ câ€– := by simp only [RingHomIsometric.is_iso, hc]
    rcases rescale_to_shell hc' (half_pos Îµpos) hy with âŸ¨d, hd, ydlt, -, dinvâŸ©
    let Î´ := â€–dâ€– * â€–yâ€– / 4
    have Î´pos : 0 < Î´ := div_pos (mul_pos (norm_pos_iff.2 hd) (norm_pos_iff.2 hy)) (by norm_num)
    have : a + d â€¢ y âˆˆ ball a Îµ := by
      simp [dist_eq_norm, lt_of_le_of_lt ydlt.le (half_lt_self Îµpos)]
    rcases Metric.mem_closure_iff.1 (H this) _ Î´pos with âŸ¨zâ‚, zâ‚im, hâ‚âŸ©
    rcases (mem_image _ _ _).1 zâ‚im with âŸ¨xâ‚, hxâ‚, xzâ‚âŸ©
    rw [â† xzâ‚] at hâ‚
    rw [mem_ball, dist_eq_norm, sub_zero] at hxâ‚
    have : a âˆˆ ball a Îµ := by
      simp only [mem_ball, dist_self]
      exact Îµpos
    rcases Metric.mem_closure_iff.1 (H this) _ Î´pos with âŸ¨zâ‚‚, zâ‚‚im, hâ‚‚âŸ©
    rcases (mem_image _ _ _).1 zâ‚‚im with âŸ¨xâ‚‚, hxâ‚‚, xzâ‚‚âŸ©
    rw [â† xzâ‚‚] at hâ‚‚
    rw [mem_ball, dist_eq_norm, sub_zero] at hxâ‚‚
    let x := xâ‚ - xâ‚‚
    have I : â€–f x - d â€¢ yâ€– â‰¤ 2 * Î´ :=
      calc
        â€–f x - d â€¢ yâ€– = â€–f xâ‚ - (a + d â€¢ y) - (f xâ‚‚ - a)â€– := by
          congr 1
          simp only [f.map_sub]
          abel
        _ â‰¤ â€–f xâ‚ - (a + d â€¢ y)â€– + â€–f xâ‚‚ - aâ€– := norm_sub_le _ _
        _ â‰¤ Î´ + Î´ := by rw [dist_eq_norm'] at hâ‚ hâ‚‚; gcongr
        _ = 2 * Î´ := (two_mul _).symm
    have J : â€–f (Ïƒ' dâ»Â¹ â€¢ x) - yâ€– â‰¤ 1 / 2 * â€–yâ€– :=
      calc
        â€–f (Ïƒ' dâ»Â¹ â€¢ x) - yâ€– = â€–dâ»Â¹ â€¢ f x - (dâ»Â¹ * d) â€¢ yâ€– := by
          rwa [f.map_smulâ‚›â‚— _, inv_mul_cancel, one_smul, map_invâ‚€, map_invâ‚€,
            RingHomCompTriple.comp_apply, RingHom.id_apply]
        _ = â€–dâ»Â¹ â€¢ (f x - d â€¢ y)â€– := by rw [mul_smul, smul_sub]
        _ = â€–dâ€–â»Â¹ * â€–f x - d â€¢ yâ€– := by rw [norm_smul, norm_inv]
        _ â‰¤ â€–dâ€–â»Â¹ * (2 * Î´) := by gcongr
        _ = â€–dâ€–â»Â¹ * â€–dâ€– * â€–yâ€– / 2 := by
          simp only [Î´]
          ring
        _ = â€–yâ€– / 2 := by
          rw [inv_mul_cancel, one_mul]
          simp [norm_eq_zero, hd]
        _ = 1 / 2 * â€–yâ€– := by ring
    rw [â† dist_eq_norm] at J
    have K : â€–Ïƒ' dâ»Â¹ â€¢ xâ€– â‰¤ (Îµ / 2)â»Â¹ * â€–câ€– * 2 * â†‘n * â€–yâ€– :=
      calc
        â€–Ïƒ' dâ»Â¹ â€¢ xâ€– = â€–dâ€–â»Â¹ * â€–xâ‚ - xâ‚‚â€– := by rw [norm_smul, RingHomIsometric.is_iso, norm_inv]
        _ â‰¤ (Îµ / 2)â»Â¹ * â€–câ€– * â€–yâ€– * (n + n) := by
          gcongr
          Â· simpa using dinv
          Â· exact le_trans (norm_sub_le _ _) (by gcongr)
        _ = (Îµ / 2)â»Â¹ * â€–câ€– * 2 * â†‘n * â€–yâ€– := by ring
    exact âŸ¨Ïƒ' dâ»Â¹ â€¢ x, J, KâŸ©"
Mathlib/MeasureTheory/Decomposition/UnsignedHahn.lean,MeasureTheory.hahn_decomposition,hahn_decomposition,916c75c1d9f2fcdcd11d5d5b32f69afcc94bb9c4,":= by
  let d : Set Î± â†’ â„ := fun s => ((Î¼ s).toNNReal : â„) - (Î½ s).toNNReal
  let c : Set â„ := d '' { s | MeasurableSet s }
  let Î³ : â„ := sSup c
  have hÎ¼ : âˆ€ s, Î¼ s â‰  âˆ := measure_ne_top Î¼
  have hÎ½ : âˆ€ s, Î½ s â‰  âˆ := measure_ne_top Î½
  have to_nnreal_Î¼ : âˆ€ s, ((Î¼ s).toNNReal : â„â‰¥0âˆ) = Î¼ s := fun s => ENNReal.coe_toNNReal <| hÎ¼ _
  have to_nnreal_Î½ : âˆ€ s, ((Î½ s).toNNReal : â„â‰¥0âˆ) = Î½ s := fun s => ENNReal.coe_toNNReal <| hÎ½ _
  have d_split : âˆ€ s t, MeasurableSet s â†’ MeasurableSet t â†’ d s = d (s \ t) + d (s âˆ© t) := by
    intro s t _hs ht
    dsimp only
    rw [â† measure_inter_add_diff s ht, â† measure_inter_add_diff s ht,
      ENNReal.toNNReal_add (hÎ¼ _) (hÎ¼ _), ENNReal.toNNReal_add (hÎ½ _) (hÎ½ _), NNReal.coe_add,
      NNReal.coe_add]
    simp only [sub_eq_add_neg, neg_add]
    abel
  have d_Union :
    âˆ€ s : â„• â†’ Set Î±, Monotone s â†’ Tendsto (fun n => d (s n)) atTop (ğ“ (d (â‹ƒ n, s n))) := by
    intro s hm
    refine' Tendsto.sub _ _ <;>
      refine' NNReal.tendsto_coe.2 <| (ENNReal.tendsto_toNNReal _).comp <| tendsto_measure_iUnion hm
    exact hÎ¼ _
    exact hÎ½ _
  have d_Inter :
    âˆ€ s : â„• â†’ Set Î±,
      (âˆ€ n, MeasurableSet (s n)) â†’
        (âˆ€ n m, n â‰¤ m â†’ s m âŠ† s n) â†’ Tendsto (fun n => d (s n)) atTop (ğ“ (d (â‹‚ n, s n))) := by
    intro s hs hm
    refine' Tendsto.sub _ _ <;>
      refine'
        NNReal.tendsto_coe.2 <|
          (ENNReal.tendsto_toNNReal <| _).comp <| tendsto_measure_iInter hs hm _
    exacts [hÎ¼ _, âŸ¨0, hÎ¼ _âŸ©, hÎ½ _, âŸ¨0, hÎ½ _âŸ©]
  have bdd_c : BddAbove c := by
    use (Î¼ univ).toNNReal
    rintro r âŸ¨s, _hs, rflâŸ©
    refine' le_trans (sub_le_self _ <| NNReal.coe_nonneg _) _
    rw [NNReal.coe_le_coe, â† ENNReal.coe_le_coe, to_nnreal_Î¼, to_nnreal_Î¼]
    exact measure_mono (subset_univ _)
  have c_nonempty : c.Nonempty := Nonempty.image _ âŸ¨_, MeasurableSet.emptyâŸ©
  have d_le_Î³ : âˆ€ s, MeasurableSet s â†’ d s â‰¤ Î³ := fun s hs => le_csSup bdd_c âŸ¨s, hs, rflâŸ©
  have : âˆ€ n : â„•, âˆƒ s : Set Î±, MeasurableSet s âˆ§ Î³ - (1 / 2) ^ n < d s := by
    intro n
    have : Î³ - (1 / 2) ^ n < Î³ := sub_lt_self Î³ (pow_pos (half_pos zero_lt_one) n)
    rcases exists_lt_of_lt_csSup c_nonempty this with âŸ¨r, âŸ¨s, hs, rflâŸ©, hltâŸ©
    exact âŸ¨s, hs, hltâŸ©
  rcases Classical.axiom_of_choice this with âŸ¨e, heâŸ©
  change â„• â†’ Set Î± at e
  have heâ‚ : âˆ€ n, MeasurableSet (e n) := fun n => (he n).1
  have heâ‚‚ : âˆ€ n, Î³ - (1 / 2) ^ n < d (e n) := fun n => (he n).2
  let f : â„• â†’ â„• â†’ Set Î± := fun n m => (Finset.Ico n (m + 1)).inf e
  have hf : âˆ€ n m, MeasurableSet (f n m) := by
    intro n m
    simp only [Finset.inf_eq_iInf]
    exact MeasurableSet.biInter (to_countable _) fun i _ => heâ‚ _
  have f_subset_f : âˆ€ {a b c d}, a â‰¤ b â†’ c â‰¤ d â†’ f a d âŠ† f b c := by
    intro a b c d hab hcd
    simp_rw [Finset.inf_eq_iInf]
    exact biInter_subset_biInter_left (Finset.Ico_subset_Ico hab <| Nat.succ_le_succ hcd)
  have f_succ : âˆ€ n m, n â‰¤ m â†’ f n (m + 1) = f n m âˆ© e (m + 1) := by
    intro n m hnm
    have : n â‰¤ m + 1 := le_of_lt (Nat.succ_le_succ hnm)
    simp_rw [Nat.Ico_succ_right_eq_insert_Ico this, Finset.inf_insert, Set.inter_comm]
    rfl
  have le_d_f : âˆ€ n m, m â‰¤ n â†’ Î³ - 2 * (1 / 2) ^ m + (1 / 2) ^ n â‰¤ d (f m n) := by
    intro n m h
    refine' Nat.le_induction _ _ n h
    Â· have := heâ‚‚ m
      simp_rw [Nat.Ico_succ_singleton, Finset.inf_singleton]
      linarith
    Â· intro n(hmn : m â‰¤ n)ih
      have : Î³ + (Î³ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) â‰¤ Î³ + d (f m (n + 1)) := by
        calc
          Î³ + (Î³ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) â‰¤
              Î³ + (Î³ - 2 * (1 / 2) ^ m + ((1 / 2) ^ n - (1 / 2) ^ (n + 1))) := by
            refine' add_le_add_left (add_le_add_left _ _) Î³
            simp only [pow_add, pow_one, le_sub_iff_add_le]
            linarith
          _ = Î³ - (1 / 2) ^ (n + 1) + (Î³ - 2 * (1 / 2) ^ m + (1 / 2) ^ n) := by
            simp only [sub_eq_add_neg]; abel
          _ â‰¤ d (e (n + 1)) + d (f m n) := (add_le_add (le_of_lt <| heâ‚‚ _) ih)
          _ â‰¤ d (e (n + 1)) + d (f m n \ e (n + 1)) + d (f m (n + 1)) := by
            rw [f_succ _ _ hmn, d_split (f m n) (e (n + 1)) (hf _ _) (heâ‚ _), add_assoc]
          _ = d (e (n + 1) âˆª f m n) + d (f m (n + 1)) := by
            rw [d_split (e (n + 1) âˆª f m n) (e (n + 1)), union_diff_left, union_inter_cancel_left]
            abel
            exact (heâ‚ _).union (hf _ _)
            exact heâ‚ _
          _ â‰¤ Î³ + d (f m (n + 1)) := add_le_add_right (d_le_Î³ _ <| (heâ‚ _).union (hf _ _)) _

      exact (add_le_add_iff_left Î³).1 this
  let s := â‹ƒ m, â‹‚ n, f m n
  have Î³_le_d_s : Î³ â‰¤ d s := by
    have hÎ³ : Tendsto (fun m : â„• => Î³ - 2 * (1 / 2) ^ m) atTop (ğ“ Î³) := by
      suffices Tendsto (fun m : â„• => Î³ - 2 * (1 / 2) ^ m) atTop (ğ“ (Î³ - 2 * 0)) by
        simpa only [MulZeroClass.mul_zero, tsub_zero]
      exact
        tendsto_const_nhds.sub <|
          tendsto_const_nhds.mul <|
            tendsto_pow_atTop_nhds_0_of_lt_1 (le_of_lt <| half_pos <| zero_lt_one)
              (half_lt_self zero_lt_one)
    have hd : Tendsto (fun m => d (â‹‚ n, f m n)) atTop (ğ“ (d (â‹ƒ m, â‹‚ n, f m n))) := by
      refine' d_Union _ _
      exact fun n m hnm =>
        subset_iInter fun i => Subset.trans (iInter_subset (f n) i) <| f_subset_f hnm <| le_rfl
    refine' le_of_tendsto_of_tendsto' hÎ³ hd fun m => _
    have : Tendsto (fun n => d (f m n)) atTop (ğ“ (d (â‹‚ n, f m n))) := by
      refine' d_Inter _ _ _
      Â· intro n
        exact hf _ _
      Â· intro n m hnm
        exact f_subset_f le_rfl hnm
    refine' ge_of_tendsto this (eventually_atTop.2 âŸ¨m, fun n hmn => _âŸ©)
    change Î³ - 2 * (1 / 2) ^ m â‰¤ d (f m n)
    refine' le_trans _ (le_d_f _ _ hmn)
    exact le_add_of_le_of_nonneg le_rfl (pow_nonneg (le_of_lt <| half_pos <| zero_lt_one) _)
  have hs : MeasurableSet s := MeasurableSet.iUnion fun n => MeasurableSet.iInter fun m => hf _ _
  refine' âŸ¨s, hs, _, _âŸ©
  Â· intro t ht hts
    have : 0 â‰¤ d t :=
      (add_le_add_iff_left Î³).1 <|
        calc
          Î³ + 0 â‰¤ d s := by rw [add_zero]; exact Î³_le_d_s
          _ = d (s \ t) + d t := by rw [d_split _ _ hs ht, inter_eq_self_of_subset_right hts]
          _ â‰¤ Î³ + d t := add_le_add (d_le_Î³ _ (hs.diff ht)) le_rfl

    rw [â† to_nnreal_Î¼, â† to_nnreal_Î½, ENNReal.coe_le_coe, â† NNReal.coe_le_coe]
    simpa only [le_sub_iff_add_le, zero_add] using this
  Â· intro t ht hts
    have : d t â‰¤ 0 :=
      (add_le_add_iff_left Î³).1 <|
        calc
          Î³ + d t â‰¤ d s + d t := add_le_add Î³_le_d_s le_rfl
          _ = d (s âˆª t) := by
            rw [d_split _ _ (hs.union ht) ht, union_diff_right, union_inter_cancel_right,
              (subset_compl_iff_disjoint_left.1 hts).sdiff_eq_left]
          _ â‰¤ Î³ + 0 := by rw [add_zero]; exact d_le_Î³ _ (hs.union ht)

    rw [â† to_nnreal_Î¼, â† to_nnreal_Î½, ENNReal.coe_le_coe, â† NNReal.coe_le_coe]
    simpa only [sub_le_iff_le_add, zero_add] using this","error:  dsimp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
error:  simp made no progress
warning:  `ENNReal.tendsto_pow_atTop_nhds_0_of_lt_1` has been deprecated, use `ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one` instead
warning:  `tendsto_pow_atTop_nhds_0_of_lt_1` has been deprecated, use `tendsto_pow_atTop_nhds_zero_of_lt_one` instead
error:  type mismatch
  hâœ
has type
  0 â‰¤ d t : Prop
but is expected to have type
  â†‘(Î½ t).toNNReal â‰¤ â†‘(Î¼ t).toNNReal : Prop
error:  type mismatch
  hâœ
has type
  d t â‰¤ 0 : Prop
but is expected to have type
  â†‘(Î¼ t).toNNReal â‰¤ â†‘(Î½ t).toNNReal : Prop","theorem hahn_decomposition [IsFiniteMeasure Î¼] [IsFiniteMeasure Î½] :
    âˆƒ s,
      MeasurableSet s âˆ§
        (âˆ€ t, MeasurableSet t â†’ t âŠ† s â†’ Î½ t â‰¤ Î¼ t) âˆ§ âˆ€ t, MeasurableSet t â†’ t âŠ† sá¶œ â†’ Î¼ t â‰¤ Î½ t ",":= by
  let d : Set Î± â†’ â„ := fun s => ((Î¼ s).toNNReal : â„) - (Î½ s).toNNReal
  let c : Set â„ := d '' { s | MeasurableSet s }
  let Î³ : â„ := sSup c
  have hÎ¼ : âˆ€ s, Î¼ s â‰  âˆ := measure_ne_top Î¼
  have hÎ½ : âˆ€ s, Î½ s â‰  âˆ := measure_ne_top Î½
  have to_nnreal_Î¼ : âˆ€ s, ((Î¼ s).toNNReal : â„â‰¥0âˆ) = Î¼ s := fun s => ENNReal.coe_toNNReal <| hÎ¼ _
  have to_nnreal_Î½ : âˆ€ s, ((Î½ s).toNNReal : â„â‰¥0âˆ) = Î½ s := fun s => ENNReal.coe_toNNReal <| hÎ½ _
  have d_split : âˆ€ s t, MeasurableSet s â†’ MeasurableSet t â†’ d s = d (s \ t) + d (s âˆ© t) := by
    intro s t _hs ht
    dsimp only [d]
    rw [â† measure_inter_add_diff s ht, â† measure_inter_add_diff s ht,
      ENNReal.toNNReal_add (hÎ¼ _) (hÎ¼ _), ENNReal.toNNReal_add (hÎ½ _) (hÎ½ _), NNReal.coe_add,
      NNReal.coe_add]
    simp only [sub_eq_add_neg, neg_add]
    abel
  have d_Union :
    âˆ€ s : â„• â†’ Set Î±, Monotone s â†’ Tendsto (fun n => d (s n)) atTop (ğ“ (d (â‹ƒ n, s n))) := by
    intro s hm
    refine Tendsto.sub ?_ ?_ <;>
      refine NNReal.tendsto_coe.2 <| (ENNReal.tendsto_toNNReal ?_).comp <| tendsto_measure_iUnion hm
    Â· exact hÎ¼ _
    Â· exact hÎ½ _
  have d_Inter :
    âˆ€ s : â„• â†’ Set Î±,
      (âˆ€ n, MeasurableSet (s n)) â†’
        (âˆ€ n m, n â‰¤ m â†’ s m âŠ† s n) â†’ Tendsto (fun n => d (s n)) atTop (ğ“ (d (â‹‚ n, s n))) := by
    intro s hs hm
    refine Tendsto.sub ?_ ?_ <;>
      refine
        NNReal.tendsto_coe.2 <|
          (ENNReal.tendsto_toNNReal <| ?_).comp <| tendsto_measure_iInter hs hm ?_
    exacts [hÎ¼ _, âŸ¨0, hÎ¼ _âŸ©, hÎ½ _, âŸ¨0, hÎ½ _âŸ©]
  have bdd_c : BddAbove c := by
    use (Î¼ univ).toNNReal
    rintro r âŸ¨s, _hs, rflâŸ©
    refine le_trans (sub_le_self _ <| NNReal.coe_nonneg _) ?_
    rw [NNReal.coe_le_coe, â† ENNReal.coe_le_coe, to_nnreal_Î¼, to_nnreal_Î¼]
    exact measure_mono (subset_univ _)
  have c_nonempty : c.Nonempty := Nonempty.image _ âŸ¨_, MeasurableSet.emptyâŸ©
  have d_le_Î³ : âˆ€ s, MeasurableSet s â†’ d s â‰¤ Î³ := fun s hs => le_csSup bdd_c âŸ¨s, hs, rflâŸ©
  have : âˆ€ n : â„•, âˆƒ s : Set Î±, MeasurableSet s âˆ§ Î³ - (1 / 2) ^ n < d s := by
    intro n
    have : Î³ - (1 / 2) ^ n < Î³ := sub_lt_self Î³ (pow_pos (half_pos zero_lt_one) n)
    rcases exists_lt_of_lt_csSup c_nonempty this with âŸ¨r, âŸ¨s, hs, rflâŸ©, hltâŸ©
    exact âŸ¨s, hs, hltâŸ©
  rcases Classical.axiom_of_choice this with âŸ¨e, heâŸ©
  change â„• â†’ Set Î± at e
  have heâ‚ : âˆ€ n, MeasurableSet (e n) := fun n => (he n).1
  have heâ‚‚ : âˆ€ n, Î³ - (1 / 2) ^ n < d (e n) := fun n => (he n).2
  let f : â„• â†’ â„• â†’ Set Î± := fun n m => (Finset.Ico n (m + 1)).inf e
  have hf : âˆ€ n m, MeasurableSet (f n m) := by
    intro n m
    simp only [f, Finset.inf_eq_iInf]
    exact MeasurableSet.biInter (to_countable _) fun i _ => heâ‚ _
  have f_subset_f : âˆ€ {a b c d}, a â‰¤ b â†’ c â‰¤ d â†’ f a d âŠ† f b c := by
    intro a b c d hab hcd
    simp_rw [f, Finset.inf_eq_iInf]
    exact biInter_subset_biInter_left (Finset.Ico_subset_Ico hab <| Nat.succ_le_succ hcd)
  have f_succ : âˆ€ n m, n â‰¤ m â†’ f n (m + 1) = f n m âˆ© e (m + 1) := by
    intro n m hnm
    have : n â‰¤ m + 1 := le_of_lt (Nat.succ_le_succ hnm)
    simp_rw [f, Nat.Ico_succ_right_eq_insert_Ico this, Finset.inf_insert, Set.inter_comm]
    rfl
  have le_d_f : âˆ€ n m, m â‰¤ n â†’ Î³ - 2 * (1 / 2) ^ m + (1 / 2) ^ n â‰¤ d (f m n) := by
    intro n m h
    refine Nat.le_induction ?_ ?_ n h
    Â· have := heâ‚‚ m
      simp_rw [f, Nat.Ico_succ_singleton, Finset.inf_singleton]
      linarith
    Â· intro n (hmn : m â‰¤ n) ih
      have : Î³ + (Î³ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) â‰¤ Î³ + d (f m (n + 1)) := by
        calc
          Î³ + (Î³ - 2 * (1 / 2) ^ m + (1 / 2) ^ (n + 1)) =
              Î³ + (Î³ - 2 * (1 / 2) ^ m + ((1 / 2) ^ n - (1 / 2) ^ (n + 1))) := by
            rw [pow_succ, mul_one_div, _root_.sub_half]
          _ = Î³ - (1 / 2) ^ (n + 1) + (Î³ - 2 * (1 / 2) ^ m + (1 / 2) ^ n) := by
            simp only [sub_eq_add_neg]; abel
          _ â‰¤ d (e (n + 1)) + d (f m n) := add_le_add (le_of_lt <| heâ‚‚ _) ih
          _ â‰¤ d (e (n + 1)) + d (f m n \ e (n + 1)) + d (f m (n + 1)) := by
            rw [f_succ _ _ hmn, d_split (f m n) (e (n + 1)) (hf _ _) (heâ‚ _), add_assoc]
          _ = d (e (n + 1) âˆª f m n) + d (f m (n + 1)) := by
            rw [d_split (e (n + 1) âˆª f m n) (e (n + 1)), union_diff_left, union_inter_cancel_left]
            Â· abel
            Â· exact (heâ‚ _).union (hf _ _)
            Â· exact heâ‚ _
          _ â‰¤ Î³ + d (f m (n + 1)) := add_le_add_right (d_le_Î³ _ <| (heâ‚ _).union (hf _ _)) _
      exact (add_le_add_iff_left Î³).1 this
  let s := â‹ƒ m, â‹‚ n, f m n
  have Î³_le_d_s : Î³ â‰¤ d s := by
    have hÎ³ : Tendsto (fun m : â„• => Î³ - 2 * (1 / 2) ^ m) atTop (ğ“ Î³) := by
      suffices Tendsto (fun m : â„• => Î³ - 2 * (1 / 2) ^ m) atTop (ğ“ (Î³ - 2 * 0)) by
        simpa only [mul_zero, tsub_zero]
      exact
        tendsto_const_nhds.sub <|
          tendsto_const_nhds.mul <|
            tendsto_pow_atTop_nhds_zero_of_lt_one (le_of_lt <| half_pos <| zero_lt_one)
              (half_lt_self zero_lt_one)
    have hd : Tendsto (fun m => d (â‹‚ n, f m n)) atTop (ğ“ (d (â‹ƒ m, â‹‚ n, f m n))) := by
      refine d_Union _ ?_
      exact fun n m hnm =>
        subset_iInter fun i => Subset.trans (iInter_subset (f n) i) <| f_subset_f hnm <| le_rfl
    refine le_of_tendsto_of_tendsto' hÎ³ hd fun m => ?_
    have : Tendsto (fun n => d (f m n)) atTop (ğ“ (d (â‹‚ n, f m n))) := by
      refine d_Inter _ ?_ ?_
      Â· intro n
        exact hf _ _
      Â· intro n m hnm
        exact f_subset_f le_rfl hnm
    refine ge_of_tendsto this (eventually_atTop.2 âŸ¨m, fun n hmn => ?_âŸ©)
    change Î³ - 2 * (1 / 2) ^ m â‰¤ d (f m n)
    refine le_trans ?_ (le_d_f _ _ hmn)
    exact le_add_of_le_of_nonneg le_rfl (pow_nonneg (le_of_lt <| half_pos <| zero_lt_one) _)
  have hs : MeasurableSet s := MeasurableSet.iUnion fun n => MeasurableSet.iInter fun m => hf _ _
  refine âŸ¨s, hs, ?_, ?_âŸ©
  Â· intro t ht hts
    have : 0 â‰¤ d t :=
      (add_le_add_iff_left Î³).1 <|
        calc
          Î³ + 0 â‰¤ d s := by rw [add_zero]; exact Î³_le_d_s
          _ = d (s \ t) + d t := by rw [d_split _ _ hs ht, inter_eq_self_of_subset_right hts]
          _ â‰¤ Î³ + d t := add_le_add (d_le_Î³ _ (hs.diff ht)) le_rfl

    rw [â† to_nnreal_Î¼, â† to_nnreal_Î½, ENNReal.coe_le_coe, â† NNReal.coe_le_coe]
    simpa only [d, le_sub_iff_add_le, zero_add] using this
  Â· intro t ht hts
    have : d t â‰¤ 0 :=
      (add_le_add_iff_left Î³).1 <|
        calc
          Î³ + d t â‰¤ d s + d t := by gcongr
          _ = d (s âˆª t) := by
            rw [d_split _ _ (hs.union ht) ht, union_diff_right, union_inter_cancel_right,
              (subset_compl_iff_disjoint_left.1 hts).sdiff_eq_left]
          _ â‰¤ Î³ + 0 := by rw [add_zero]; exact d_le_Î³ _ (hs.union ht)

    rw [â† to_nnreal_Î¼, â† to_nnreal_Î½, ENNReal.coe_le_coe, â† NNReal.coe_le_coe]
    simpa only [d, sub_le_iff_le_add, zero_add] using this"
Mathlib/Data/List/Join.lean,List.eq_iff_join_eq,eq_iff_join_eq,1ab122267c20bd3edfcd7569e8751657b42d6221,":= by
  refine' âŸ¨fun H => by simp [H], _âŸ©
  rintro âŸ¨join_eq, length_eqâŸ©
  apply ext_get
  Â· have : length (map length L) = length (map length L') := by rw [length_eq]
    simpa using this
  Â· intro n hâ‚ hâ‚‚
    rw [â† drop_take_succ_join_eq_get, â† drop_take_succ_join_eq_get, join_eq, length_eq]","warning:  `List.nthLe` has been deprecated, use `List.get` instead
error:  unknown identifier 'drop_take_succ_join_eq_get'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.8753
case intro.h
Î± : Type u_1
Î² : Type u_2
L L' : List (List Î±)
join_eq : L.join = L'.join
length_eq : map length L = map length L'
n : â„•
hâ‚ : n < L.length
hâ‚‚ : n < L'.length
âŠ¢ L.get âŸ¨n, hâ‚âŸ© = L'.get âŸ¨n, hâ‚‚âŸ©","theorem eq_iff_join_eq (L L' : List (List Î±)) :
    L = L' â†” L.join = L'.join âˆ§ map length L = map length L' ",":= by
  refine âŸ¨fun H => by simp [H], ?_âŸ©
  rintro âŸ¨join_eq, length_eqâŸ©
  apply ext_getElem
  Â· have : length (map length L) = length (map length L') := by rw [length_eq]
    simpa using this
  Â· intro n hâ‚ hâ‚‚
    rw [â† drop_take_succ_join_eq_getElem', â† drop_take_succ_join_eq_getElem', join_eq, length_eq]"
Mathlib/Analysis/InnerProductSpace/Spectrum.lean,LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces_eq_bot,orthogonalComplement_iSup_eigenspaces_eq_bot,1ae64bbf934bcd2af48b18d9122bea1fc72ff2cd,":= by
  have hT' : IsSymmetric _ :=
    hT.restrict_invariant hT.orthogonalComplement_iSup_eigenspaces_invariant
  haveI :=
    hT'.subsingleton_of_no_eigenvalue_finiteDimensional hT.orthogonalComplement_iSup_eigenspaces
  exact Submodule.eq_bot_of_subsingleton _","error:  function expected at
  Submodule.eq_bot_of_subsingleton
term has type
  ?m.66806 = âŠ¥","theorem orthogonalComplement_iSup_eigenspaces_eq_bot : (â¨† Î¼, eigenspace T Î¼)á—® = âŠ¥ ",":= by
  have hT' : IsSymmetric _ :=
    hT.restrict_invariant hT.orthogonalComplement_iSup_eigenspaces_invariant
  haveI :=
    hT'.subsingleton_of_no_eigenvalue_finiteDimensional hT.orthogonalComplement_iSup_eigenspaces
  exact Submodule.eq_bot_of_subsingleton"
Mathlib/MeasureTheory/Function/SimpleFunc.lean,Measurable.simpleFunc_add,_root_.Measurable.simpleFunc_add,0a9bb39c356a429bfc1e9e10af35f15fc6b79fff,":= by
  classical
  induction' f using SimpleFunc.induction with c s hs f f' hff' hf hf'
  Â· simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,
      SimpleFunc.coe_zero]
    change Measurable (s.piecewise (Function.const Î± c) (0 : Î± â†’ E) + g)
    rw [â† s.piecewise_same g, â† piecewise_add]
    exact Measurable.piecewise hs (hg.const_add _) (hg.const_add _)
  Â· have : (â†‘(f + f') + g)
        = (Function.support f).piecewise ((f : Î± â†’ E) + g) (f' + g) := by
      ext x
      by_cases hx : x âˆˆ Function.support f
      Â· simpa only [coe_add, Pi.add_apply, Function.mem_support, ne_eq, not_not,
          Set.piecewise_eq_of_mem _ _ _ hx, add_left_inj, add_right_eq_self]
          using Set.disjoint_left.1 hff' hx
      Â· simpa only [SimpleFunc.coe_add, Pi.add_apply, Function.mem_support, ne_eq, not_not,
          Set.piecewise_eq_of_not_mem _ _ _ hx, add_left_inj, add_left_eq_self] using hx
    rw [this]
    exact Measurable.piecewise f.measurableSet_support hf hf'","error:  ambiguous, possible interpretations 
  _root_.add_left_inj : âˆ€ (a : ?m.271934) {b c : ?m.271934}, b + a = c + a â†” b = c
  
  ENNReal.add_left_inj : ?m.272034 â‰  âŠ¤ â†’ (?m.272035 + ?m.272034 = ?m.272036 + ?m.272034 â†” ?m.272035 = ?m.272036)
error:  type mismatch
  hâœ
has type
  â†‘f' x = 0 : Prop
but is expected to have type
  â†‘f x + â†‘f' x + g x = â†‘f x + g x : Prop
error:  ambiguous, possible interpretations 
  _root_.add_left_inj : âˆ€ (a : ?m.273042) {b c : ?m.273042}, b + a = c + a â†” b = c
  
  ENNReal.add_left_inj : ?m.273142 â‰  âŠ¤ â†’ (?m.273143 + ?m.273142 = ?m.273144 + ?m.273142 â†” ?m.273143 = ?m.273144)
error:  type mismatch
  hâœ
has type
  â†‘f x = 0 : Prop
but is expected to have type
  â†‘f x + â†‘f' x + g x = â†‘f' x + g x : Prop","theorem _root_.Measurable.simpleFunc_add
    {E : Type*} {_ : MeasurableSpace Î±} [MeasurableSpace E] [AddGroup E] [MeasurableAdd E]
    {g : Î± â†’ E} (hg : Measurable g) (f : SimpleFunc Î± E) :
    Measurable ((f : Î± â†’ E) + g) ",":= by
  classical
  induction' f using SimpleFunc.induction with c s hs f f' hff' hf hf'
  Â· simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,
      SimpleFunc.coe_zero]
    change Measurable (s.piecewise (Function.const Î± c) (0 : Î± â†’ E) + g)
    rw [â† s.piecewise_same g, â† piecewise_add]
    exact Measurable.piecewise hs (hg.const_add _) (hg.const_add _)
  Â· have : (â†‘(f + f') + g)
        = (Function.support f).piecewise ((f : Î± â†’ E) + g) (f' + g) := by
      ext x
      by_cases hx : x âˆˆ Function.support f
      Â· simpa only [coe_add, Pi.add_apply, Function.mem_support, ne_eq, not_not,
          Set.piecewise_eq_of_mem _ _ _ hx, _root_.add_left_inj, add_right_eq_self]
          using Set.disjoint_left.1 hff' hx
      Â· simpa only [SimpleFunc.coe_add, Pi.add_apply, Function.mem_support, ne_eq, not_not,
          Set.piecewise_eq_of_not_mem _ _ _ hx, _root_.add_left_inj, add_left_eq_self] using hx
    rw [this]
    exact Measurable.piecewise f.measurableSet_support hf hf'"
Mathlib/Order/Filter/NAry.lean,Filter.mapâ‚‚_distrib_le_left,mapâ‚‚_distrib_le_left,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rintro s âŸ¨tâ‚, âŸ¨uâ‚, huâ‚, v, hv, htâ‚âŸ©, tâ‚‚, âŸ¨uâ‚‚, huâ‚‚, w, hw, htâ‚‚âŸ©, hsâŸ©
  refine âŸ¨uâ‚ âˆ© uâ‚‚, inter_mem huâ‚ huâ‚‚, _, image2_mem_mapâ‚‚ hv hw, ?_âŸ©
  refine (image2_distrib_subset_left h_distrib).trans ((image2_subset ?_ ?_).trans hs)
  Â· exact (image2_subset_right <| inter_subset_left _ _).trans htâ‚
  Â· exact (image2_subset_right <| inter_subset_right _ _).trans htâ‚‚","error:  function expected at
  inter_subset_left ?m.16920
term has type
  ?m.16919 âˆˆ ?m.16917
error:  function expected at
  inter_subset_right ?m.17039
term has type
  ?m.17038 âˆˆ ?m.17037","theorem mapâ‚‚_distrib_le_left {m : Î± â†’ Î´ â†’ Îµ} {n : Î² â†’ Î³ â†’ Î´} {mâ‚ : Î± â†’ Î² â†’ Î²'} {mâ‚‚ : Î± â†’ Î³ â†’ Î³'}
    {n' : Î²' â†’ Î³' â†’ Îµ} (h_distrib : âˆ€ a b c, m a (n b c) = n' (mâ‚ a b) (mâ‚‚ a c)) :
    mapâ‚‚ m f (mapâ‚‚ n g h) â‰¤ mapâ‚‚ n' (mapâ‚‚ mâ‚ f g) (mapâ‚‚ mâ‚‚ f h) ",":= by
  rintro s âŸ¨tâ‚, âŸ¨uâ‚, huâ‚, v, hv, htâ‚âŸ©, tâ‚‚, âŸ¨uâ‚‚, huâ‚‚, w, hw, htâ‚‚âŸ©, hsâŸ©
  refine âŸ¨uâ‚ âˆ© uâ‚‚, inter_mem huâ‚ huâ‚‚, _, image2_mem_mapâ‚‚ hv hw, ?_âŸ©
  refine (image2_distrib_subset_left h_distrib).trans ((image2_subset ?_ ?_).trans hs)
  Â· exact (image2_subset_right inter_subset_left).trans htâ‚
  Â· exact (image2_subset_right inter_subset_right).trans htâ‚‚"
Mathlib/Algebra/BigOperators/Fin.lean,Fin.prod_univ_succ,prod_univ_succ,9c0d900915679ca1c657b463d621a4aa9412a4fe,":= by
  rw [univ_succAbove, prod_cons, Finset.prod_map _ x.succAbove.toEmbedding,
    RelEmbedding.coe_toEmbedding]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  x.succAbove
has type
  Fin n â†’ Fin (n + 1)","theorem prod_univ_succAbove [CommMonoid Î²] {n : â„•} (f : Fin (n + 1) â†’ Î²) (x : Fin (n + 1)) :
    âˆ i, f i = f x * âˆ i : Fin n, f (x.succAbove i) ",":= by
  rw [univ_succAbove, prod_cons, Finset.prod_map _ x.succAboveEmb]
  rfl"
Mathlib/Data/Nat/Choose/Basic.lean,Nat.choose_two_right,choose_two_right,4ad46d4a6677dcfb96418e03062ff39837a061ae,":= by
  induction' n with n ih
  Â· simp
  Â· rw [triangle_succ n, choose, ih]
    simp [add_comm]","error:  unknown identifier 'add_comm'
error:  unsolved goals
case succ
n : â„•
ih : n.choose 2 = n * (n - 1) / 2
âŠ¢ n + n * (n - 1) / 2 = n * (n - 1) / 2 + n",theorem choose_two_right (n : â„•) : choose n 2 = n * (n - 1) / 2 ,":= by
  induction' n with n ih
  Â· simp
  Â· rw [triangle_succ n, choose, ih]
    simp [Nat.add_comm]"
Mathlib/Geometry/Manifold/IntegralCurve.lean,IsIntegralCurveOn.isIntegralCurveAt,IsIntegralCurveOn.isIntegralCurveAt,7d7a7169c0c35b35c150a198dd8eaa2a47578e1d,":= âŸ¨s, hs, hâŸ©","error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  (ğ“ tâ‚€).1 {x | (fun t â†¦ HasMFDerivAt ğ“˜(â„, â„) I Î³ t (ContinuousLinearMap.smulRight 1 (v (Î³ t)))) x}","lemma IsIntegralCurveOn.isIntegralCurveAt (h : IsIntegralCurveOn Î³ v s) (hs : s âˆˆ ğ“ tâ‚€) :
    IsIntegralCurveAt Î³ v tâ‚€ ",":= isIntegralCurveAt_iff.mpr âŸ¨s, hs, hâŸ©"
Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean,CategoryTheory.Pretriangulated.contractible_distinguishedâ‚,contractible_distinguishedâ‚,8535b08ef59bcdb8a9d09a473f4b6c583f54aef0,":= by
  refine' isomorphic_distinguished _
    (inv_rot_of_dist_triangle _ (contractible_distinguished X)) _ _
  exact Triangle.isoMk _ _ (Functor.mapZeroObject _).symm (Iso.refl _) (Iso.refl _)
    (by aesop_cat) (by aesop_cat) (by aesop_cat)","error:  unknown identifier 'inv_rot_of_dist_triangle'
error:  application type mismatch
  @Triangle.isoMk ?m.57548 ?m.57549 ?m.57550 ?m.57551 ?m.57552 ?m.57712.mapZeroObject.symm
argument
  ?m.57712.mapZeroObject.symm
has type
  0 â‰… ?m.57712.obj 0 : Type ?u.57547
but is expected to have type
  ?m.57551.objâ‚ â‰… ?m.57552.objâ‚ : Type ?u.57547
error:  tactic 'aesop' failed, failed to prove the goal after exhaustive search.
Initial goal:
  C : Type u
  instâœâ´ : Category.{v, u} C
  instâœÂ³ : HasZeroObject C
  instâœÂ² : HasShift C â„¤
  instâœÂ¹ : Preadditive C
  instâœ : âˆ€ (n : â„¤), (shiftFunctor C n).Additive
  hC : Pretriangulated C
  X : C
  âŠ¢ ?m.57551.morâ‚ â‰« (Iso.refl ?m.57551.objâ‚‚).hom = (sorryAx (?m.57551.objâ‚ â‰… ?m.57551.objâ‚) true).hom â‰« ?m.57551.morâ‚
Remaining goals after safe rules:
  C : Type u
  inst : Category.{v, u} C
  inst_1 : HasZeroObject C
  inst_2 : HasShift C â„¤
  inst_3 : Preadditive C
  inst_4 : âˆ€ (n : â„¤), (shiftFunctor C n).Additive
  hC : Pretriangulated C
  X : C
  âŠ¢ ?m.57551.morâ‚ = (sorryAx (?m.57551.objâ‚ â‰… ?m.57551.objâ‚) true).hom â‰« ?m.57551.morâ‚","lemma contractible_distinguishedâ‚ (X : C) :
    Triangle.mk (0 : 0 âŸ¶ X) (ğŸ™ X) 0 âˆˆ distTriang C ",":= by
  refine isomorphic_distinguished _
    (inv_rot_of_distTriang _ (contractible_distinguished X)) _ ?_
  exact Triangle.isoMk _ _ (Functor.mapZeroObject _).symm (Iso.refl _) (Iso.refl _)
    (by aesop_cat) (by aesop_cat) (by aesop_cat)"
Mathlib/Probability/Kernel/RadonNikodym.lean,ProbabilityTheory.kernel.withDensity_rnDeriv_of_subset_compl_mutuallySingularSetSlice,withDensity_rnDeriv_of_subset_compl_mutuallySingularSetSlice,1953582979d6fb22253b407bc35a0372934263c5,":= by
  have : withDensity Î· (rnDeriv Îº Î·)
      = withDensity (withDensity (Îº + Î·)
        (fun a x â†¦ Real.toNNReal (1 - rnDerivAux Îº (Îº + Î·) a x))) (rnDeriv Îº Î·) := by
    rw [rnDeriv_def']
    congr
    exact (withDensity_one_sub_rnDerivAux Îº Î·).symm
  rw [this, â† withDensity_mul, kernel.withDensity_apply']
  rotate_left
  Â· exact ((measurable_const.sub (measurable_rnDerivAux _ _)).ennreal_ofReal.mul
    (measurable_rnDeriv _ _))
  Â· exact (measurable_const.sub (measurable_rnDerivAux _ _)).real_toNNReal
  Â· exact measurable_rnDeriv _ _
  simp_rw [rnDeriv]
  have hs' : âˆ€ x âˆˆ s, rnDerivAux Îº (Îº + Î·) a x < 1 := by
    simp_rw [â† not_mem_mutuallySingularSetSlice]
    exact fun x hx hx_mem â†¦ hs hx hx_mem
  calc
    âˆ«â» x in s, â†‘(Real.toNNReal (1 - rnDerivAux Îº (Îº + Î·) a x)) *
      (ENNReal.ofReal (rnDerivAux Îº (Îº + Î·) a x) /
        ENNReal.ofReal (1 - rnDerivAux Îº (Îº + Î·) a x)) âˆ‚(Îº + Î·) a
  _ = âˆ«â» x in s, ENNReal.ofReal (rnDerivAux Îº (Îº + Î·) a x) âˆ‚(Îº + Î·) a := by
      refine set_lintegral_congr_fun hsm (ae_of_all _ fun x hx â†¦ ?_)
      rw [ofNNReal_toNNReal, â† ENNReal.ofReal_div_of_pos, div_eq_inv_mul, â† ENNReal.ofReal_mul,
        â† mul_assoc, mul_inv_cancel, one_mul]
      Â· rw [ne_eq, sub_eq_zero]
        exact (hs' x hx).ne'
      Â· simp [(hs' x hx).le]
      Â· simp [hs' x hx]
  _ = Îº a s := set_lintegral_rnDerivAux Îº Î· a hsm","warning:  `ProbabilityTheory.kernel.set_lintegral_rnDerivAux` has been deprecated, use `ProbabilityTheory.kernel.setLIntegral_rnDerivAux` instead
warning:  `MeasureTheory.set_lintegral_congr_fun` has been deprecated, use `MeasureTheory.setLIntegral_congr_fun` instead
error:  unknown identifier 'ofNNReal_toNNReal'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.100578
Î± : Type u_1
Î³ : Type u_2
mÎ± : MeasurableSpace Î±
mÎ³ : MeasurableSpace Î³
Îº Î· : â†¥(kernel Î± Î³)
hÎ±Î³ : MeasurableSpace.CountableOrCountablyGenerated Î± Î³
instâœÂ¹ : IsFiniteKernel Îº
instâœ : IsFiniteKernel Î·
a : Î±
s : Set Î³
hsm : MeasurableSet s
hs : s âŠ† (mutuallySingularSetSlice Îº Î· a)á¶œ
this :
  withDensity Î· (rnDeriv Îº Î·) =
    withDensity (withDensity (Îº + Î·) fun a x â†¦ â†‘(1 - rnDerivAux Îº (Îº + Î·) a x).toNNReal) (rnDeriv Îº Î·)
hs' : âˆ€ x âˆˆ s, rnDerivAux Îº (Îº + Î·) a x < 1
x : Î³
hx : x âˆˆ s
âŠ¢ â†‘(1 - rnDerivAux Îº (Îº + Î·) a x).toNNReal *
      (ENNReal.ofReal (rnDerivAux Îº (Îº + Î·) a x) / ENNReal.ofReal (1 - rnDerivAux Îº (Îº + Î·) a x)) =
    ENNReal.ofReal (rnDerivAux Îº (Îº + Î·) a x)","lemma withDensity_rnDeriv_of_subset_compl_mutuallySingularSetSlice
    [IsFiniteKernel Îº] [IsFiniteKernel Î·] {a : Î±} {s : Set Î³} (hsm : MeasurableSet s)
    (hs : s âŠ† (mutuallySingularSetSlice Îº Î· a)á¶œ) :
    withDensity Î· (rnDeriv Îº Î·) a s = Îº a s ",":= by
  have h_coe : âˆ€ b, (Real.toNNReal b : â„â‰¥0âˆ) = ENNReal.ofReal b := fun _ â†¦ rfl
  have : withDensity Î· (rnDeriv Îº Î·)
      = withDensity (withDensity (Îº + Î·)
        (fun a x â†¦ Real.toNNReal (1 - rnDerivAux Îº (Îº + Î·) a x))) (rnDeriv Îº Î·) := by
    rw [rnDeriv_def']
    congr
    exact (withDensity_one_sub_rnDerivAux Îº Î·).symm
  rw [this, â† withDensity_mul, kernel.withDensity_apply']
  rotate_left
  Â· exact ((measurable_const.sub (measurable_rnDerivAux _ _)).ennreal_ofReal.mul
    (measurable_rnDeriv _ _))
  Â· exact (measurable_const.sub (measurable_rnDerivAux _ _)).real_toNNReal
  Â· exact measurable_rnDeriv _ _
  simp_rw [rnDeriv]
  have hs' : âˆ€ x âˆˆ s, rnDerivAux Îº (Îº + Î·) a x < 1 := by
    simp_rw [â† not_mem_mutuallySingularSetSlice]
    exact fun x hx hx_mem â†¦ hs hx hx_mem
  calc
    âˆ«â» x in s, â†‘(Real.toNNReal (1 - rnDerivAux Îº (Îº + Î·) a x)) *
      (ENNReal.ofReal (rnDerivAux Îº (Îº + Î·) a x) /
        ENNReal.ofReal (1 - rnDerivAux Îº (Îº + Î·) a x)) âˆ‚(Îº + Î·) a
  _ = âˆ«â» x in s, ENNReal.ofReal (rnDerivAux Îº (Îº + Î·) a x) âˆ‚(Îº + Î·) a := by
      refine setLIntegral_congr_fun hsm (ae_of_all _ fun x hx â†¦ ?_)
      rw [h_coe, â† ENNReal.ofReal_div_of_pos, div_eq_inv_mul, â† ENNReal.ofReal_mul, â† mul_assoc,
        mul_inv_cancel, one_mul]
      Â· rw [ne_eq, sub_eq_zero]
        exact (hs' x hx).ne'
      Â· simp [(hs' x hx).le]
      Â· simp [hs' x hx]
  _ = Îº a s := setLIntegral_rnDerivAux Îº Î· a hsm"
Mathlib/RingTheory/LocalProperties.lean,localization_finite,localization_finite,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  introv R hf
  letI := f.toSMul
  letI := f.toAlgebra
  letI := ((algebraMap S S').comp f).toSMul
  letI := ((algebraMap S S').comp f).toAlgebra
  let f' : R' â†’+* S' := IsLocalization.map S' f (Submonoid.le_comap_map M)
  letI := f'.toSMul
  letI := f'.toAlgebra
  have : IsScalarTower R R' S' := IsScalarTower.of_algebraMap_eq'
    (IsLocalization.map_comp M.le_comap_map).symm
  have : IsScalarTower R S S' := IsScalarTower.of_algebraMap_eq' rfl
  have : IsLocalization (Algebra.algebraMapSubmonoid S M) S' := by
    rwa [Algebra.algebraMapSubmonoid, RingHom.algebraMap_toAlgebra]
  have : Module.Finite R S := hf
  apply Module.Finite_of_isLocalization R S R' S' M","error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  f
has type
  R â†’+* S
error:  unsolved goals
Râœ Sâœ : Type u
instâœÂ¹Â³ : CommRing Râœ
instâœÂ¹Â² : CommRing Sâœ
Mâœ : Submonoid Râœ
N : Submonoid Sâœ
R'âœ S'âœ : Type u
instâœÂ¹Â¹ : CommRing R'âœ
instâœÂ¹â° : CommRing S'âœ
fâœ : Râœ â†’+* Sâœ
instâœâ¹ : Algebra Râœ R'âœ
instâœâ¸ : Algebra Sâœ S'âœ
R S : Type u_1
instâœâ· : CommRing R
instâœâ¶ : CommRing S
f : R â†’+* S
M : Submonoid R
R' S' : Type u_1
instâœâµ : CommRing R'
instâœâ´ : CommRing S'
instâœÂ³ : Algebra R R'
instâœÂ² : Algebra S S'
instâœÂ¹ : IsLocalization M R'
instâœ : IsLocalization (Submonoid.map f M) S'
hf : f.Finite
âŠ¢ (IsLocalization.map S' f â‹¯).Finite",theorem localization_finite : RingHom.LocalizationPreserves @RingHom.Finite ,":= by
  introv R hf
  letI := f.toAlgebra
  letI := ((algebraMap S S').comp f).toAlgebra
  let f' : R' â†’+* S' := IsLocalization.map S' f (Submonoid.le_comap_map M)
  letI := f'.toAlgebra
  have : IsScalarTower R R' S' := IsScalarTower.of_algebraMap_eq'
    (IsLocalization.map_comp M.le_comap_map).symm
  have : IsScalarTower R S S' := IsScalarTower.of_algebraMap_eq' rfl
  have : IsLocalization (Algebra.algebraMapSubmonoid S M) S' := by
    rwa [Algebra.algebraMapSubmonoid, RingHom.algebraMap_toAlgebra]
  have : Module.Finite R S := hf
  apply Module.Finite_of_isLocalization R S R' S' M"
Mathlib/MeasureTheory/Measure/WithDensity.lean,MeasureTheory.withDensity_mono,withDensity_mono,1c91c2706a3ccd891c3dcb859d92f31890fa3090,":= by
  intro s hs
  rw [withDensity_apply _ hs, withDensity_apply _ hs]
  refine set_lintegral_mono_ae' hs ?_
  filter_upwards [hfg] with x h_le using fun _ â†¦ h_le","error:  application type mismatch
  withDensity_apply ?m.7651 hs
argument
  hs
has type
  â„â‰¥0 : Type
but is expected to have type
  MeasurableSet ?m.7652 : Prop
error:  application type mismatch
  withDensity_apply ?m.8093 hs
argument
  hs
has type
  â„â‰¥0 : Type
but is expected to have type
  MeasurableSet ?m.8094 : Prop
warning:  `MeasureTheory.set_lintegral_mono_ae'` has been deprecated, use `MeasureTheory.setLIntegral_mono_ae'` instead
error:  application type mismatch
  set_lintegral_mono_ae' hs
argument
  hs
has type
  â„â‰¥0 : Type
but is expected to have type
  MeasurableSet ?m.8505 : Prop","lemma withDensity_mono {f g : Î± â†’ â„â‰¥0âˆ} (hfg : f â‰¤áµ[Î¼] g) :
    Î¼.withDensity f â‰¤ Î¼.withDensity g ",":= by
  refine le_iff.2 fun s hs â†¦ ?_
  rw [withDensity_apply _ hs, withDensity_apply _ hs]
  refine setLIntegral_mono_ae' hs ?_
  filter_upwards [hfg] with x h_le using fun _ â†¦ h_le"
Mathlib/RingTheory/Polynomial/Cyclotomic/Expand.lean,Polynomial.isRoot_cyclotomic_prime_pow_mul_iff_of_charP,isRoot_cyclotomic_prime_pow_mul_iff_of_charP,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  rcases k.eq_zero_or_pos with (rfl | hk)
  Â· rw [pow_zero, one_mul, isRoot_cyclotomic_iff]
  refine' âŸ¨fun h => _, fun h => _âŸ©
  Â· rw [IsRoot.definition, cyclotomic_mul_prime_pow_eq R (NeZero.not_char_dvd R p m) hk, eval_pow]
      at h
    replace h := pow_eq_zero h
    rwa [â† IsRoot.definition, isRoot_cyclotomic_iff] at h
  Â· rw [â† isRoot_cyclotomic_iff, IsRoot.definition] at h
    rw [cyclotomic_mul_prime_pow_eq R (NeZero.not_char_dvd R p m) hk, IsRoot.definition, eval_pow,
      h, zero_pow]
    exact Nat.sub_ne_zero_of_lt $ pow_right_strictMono hp.out.one_lt $ Nat.pred_lt hk.ne'","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsRoot
has type
  ?m.37387[X] â†’ ?m.37387 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.37444
case inr.refine'_1
m k p : â„•
R : Type u_1
instâœÂ² : CommRing R
instâœÂ¹ : IsDomain R
hp : Fact (Nat.Prime p)
hchar : CharP R p
Î¼ : R
instâœ : NeZero â†‘m
hk : k > 0
h : (cyclotomic (p ^ k * m) R).IsRoot Î¼
âŠ¢ IsPrimitiveRoot Î¼ m
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsRoot
has type
  ?m.37771[X] â†’ ?m.37771 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.37828
case inr.refine'_2
m k p : â„•
R : Type u_1
instâœÂ² : CommRing R
instâœÂ¹ : IsDomain R
hp : Fact (Nat.Prime p)
hchar : CharP R p
Î¼ : R
instâœ : NeZero â†‘m
hk : k > 0
h : (cyclotomic m R).IsRoot Î¼
âŠ¢ (cyclotomic (p ^ k * m) R).IsRoot Î¼","theorem isRoot_cyclotomic_prime_pow_mul_iff_of_charP {m k p : â„•} {R : Type*} [CommRing R]
    [IsDomain R] [hp : Fact (Nat.Prime p)] [hchar : CharP R p] {Î¼ : R} [NeZero (m : R)] :
    (Polynomial.cyclotomic (p ^ k * m) R).IsRoot Î¼ â†” IsPrimitiveRoot Î¼ m ",":= by
  rcases k.eq_zero_or_pos with (rfl | hk)
  Â· rw [pow_zero, one_mul, isRoot_cyclotomic_iff]
  refine âŸ¨fun h => ?_, fun h => ?_âŸ©
  Â· rw [IsRoot.def, cyclotomic_mul_prime_pow_eq R (NeZero.not_char_dvd R p m) hk, eval_pow]
      at h
    replace h := pow_eq_zero h
    rwa [â† IsRoot.def, isRoot_cyclotomic_iff] at h
  Â· rw [â† isRoot_cyclotomic_iff, IsRoot.def] at h
    rw [cyclotomic_mul_prime_pow_eq R (NeZero.not_char_dvd R p m) hk, IsRoot.def, eval_pow,
      h, zero_pow]
    exact Nat.sub_ne_zero_of_lt $ pow_right_strictMono hp.out.one_lt $ Nat.pred_lt hk.ne'"
Mathlib/LinearAlgebra/Matrix/Transvection.lean,Matrix.updateRow_eq_transvection,updateRow_eq_transvection,7fb6740ebf8b2ebc546aec35ecf96b6471f2b804,":= by
  cases nonempty_fintype n
  ext a b
  by_cases ha : i = a
  Â· by_cases hb : j = b
    Â· simp only [updateRow_self, transvection, ha, hb, Pi.add_apply, StdBasisMatrix.apply_same,
        one_apply_eq, Pi.smul_apply, mul_one, Algebra.id.smul_eq_mul, add_apply]
    Â· simp only [updateRow_self, transvection, ha, hb, StdBasisMatrix.apply_of_ne, Pi.add_apply,
        Ne, not_false_iff, Pi.smul_apply, and_false_iff, one_apply_ne, Algebra.id.smul_eq_mul,
        mul_zero, add_apply]
  Â· simp only [updateRow_ne, transvection, ha, Ne.symm ha, StdBasisMatrix.apply_of_ne, add_zero,
      Algebra.id.smul_eq_mul, Ne, not_false_iff, DMatrix.add_apply, Pi.smul_apply,
      mul_zero, false_and_iff, add_apply]","error:  unsolved goals
case pos
n : Type u_1
p : Type u_2
R : Type uâ‚‚
ğ•œ : Type u_3
instâœâ´ : Field ğ•œ
instâœÂ³ : DecidableEq n
instâœÂ² : DecidableEq p
instâœÂ¹ : CommRing R
i j : n
instâœ : Finite n
c : R
valâœ : Fintype n
a b : n
ha : i = a
hb : j = b
âŠ¢ 1 i b + c * 1 j b = 1 a b + c
error:  unsolved goals
case neg
n : Type u_1
p : Type u_2
R : Type uâ‚‚
ğ•œ : Type u_3
instâœâ´ : Field ğ•œ
instâœÂ³ : DecidableEq n
instâœÂ² : DecidableEq p
instâœÂ¹ : CommRing R
i j : n
instâœ : Finite n
c : R
valâœ : Fintype n
a b : n
ha : i = a
hb : Â¬j = b
âŠ¢ 1 i b + 0 = 1 a b + 0","theorem updateRow_eq_transvection [Finite n] (c : R) :
    updateRow (1 : Matrix n n R) i ((1 : Matrix n n R) i + c â€¢ (1 : Matrix n n R) j) =
      transvection i j c ",":= by
  cases nonempty_fintype n
  ext a b
  by_cases ha : i = a
  Â· by_cases hb : j = b
    Â· simp only [ha, updateRow_self, Pi.add_apply, one_apply, Pi.smul_apply, hb, â†“reduceIte,
        smul_eq_mul, mul_one, transvection, add_apply, StdBasisMatrix.apply_same]
    Â· simp only [ha, updateRow_self, Pi.add_apply, one_apply, Pi.smul_apply, hb, â†“reduceIte,
        smul_eq_mul, mul_zero, add_zero, transvection, add_apply, and_false, not_false_eq_true,
        StdBasisMatrix.apply_of_ne]
  Â· simp only [updateRow_ne, transvection, ha, Ne.symm ha, StdBasisMatrix.apply_of_ne, add_zero,
      Algebra.id.smul_eq_mul, Ne, not_false_iff, DMatrix.add_apply, Pi.smul_apply,
      mul_zero, false_and_iff, add_apply]"
Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean,MeasureTheory.SimpleFunc.exists_upperSemicontinuous_le_lintegral_le,SimpleFunc.exists_upperSemicontinuous_le_lintegral_le,916c75c1d9f2fcdcd11d5d5b32f69afcc94bb9c4,":= by
  induction' f using MeasureTheory.SimpleFunc.induction with c s hs fâ‚ fâ‚‚ _ hâ‚ hâ‚‚ generalizing Îµ
  Â· by_cases hc : c = 0
    Â· refine' âŸ¨fun _ => 0, _, upperSemicontinuous_const, _âŸ©
      Â· classical
        simp only [hc, Set.indicator_zero', Pi.zero_apply, SimpleFunc.const_zero, imp_true_iff,
          eq_self_iff_true, SimpleFunc.coe_zero, Set.piecewise_eq_indicator,
          SimpleFunc.coe_piecewise, le_zero_iff]
      Â· classical
        simp only [hc, Set.indicator_zero', lintegral_const, MulZeroClass.zero_mul, Pi.zero_apply,
          SimpleFunc.const_zero, zero_add, zero_le', SimpleFunc.coe_zero,
          Set.piecewise_eq_indicator, ENNReal.coe_zero, SimpleFunc.coe_piecewise, zero_le]
    have Î¼s_lt_top : Î¼ s < âˆ := by
      classical
      simpa only [hs, hc, lt_top_iff_ne_top, true_and_iff, SimpleFunc.coe_const, or_false_iff,
        lintegral_const, ENNReal.coe_indicator, Set.univ_inter, ENNReal.coe_ne_top,
        Measure.restrict_apply MeasurableSet.univ, ENNReal.mul_eq_top, SimpleFunc.const_zero,
        Function.const_apply, lintegral_indicator, ENNReal.coe_eq_zero, Ne.def, not_false_iff,
        SimpleFunc.coe_zero, Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise,
        false_and_iff] using int_f
    have : (0 : â„â‰¥0âˆ) < Îµ / c := ENNReal.div_pos_iff.2 âŸ¨Îµ0, ENNReal.coe_ne_topâŸ©
    obtain âŸ¨F, Fs, F_closed, Î¼FâŸ© : âˆƒ (F : _), F âŠ† s âˆ§ IsClosed F âˆ§ Î¼ s < Î¼ F + Îµ / c :=
      hs.exists_isClosed_lt_add Î¼s_lt_top.ne this.ne'
    refine'
      âŸ¨Set.indicator F fun _ => c, fun x => _, F_closed.upperSemicontinuous_indicator (zero_le _),
        _âŸ©
    Â· simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,
        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]
      exact Set.indicator_le_indicator_of_subset Fs (fun x => zero_le _) _
    Â· suffices (c : â„â‰¥0âˆ) * Î¼ s â‰¤ c * Î¼ F + Îµ by
        classical
        simpa only [hs, F_closed.measurableSet, SimpleFunc.coe_const, Function.const_apply,
          lintegral_const, ENNReal.coe_indicator, Set.univ_inter, MeasurableSet.univ,
          SimpleFunc.const_zero, lintegral_indicator, SimpleFunc.coe_zero,
          Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise, Measure.restrict_apply]
      calc
        (c : â„â‰¥0âˆ) * Î¼ s â‰¤ c * (Î¼ F + Îµ / c) := mul_le_mul_left' Î¼F.le _
        _ = c * Î¼ F + Îµ := by
          simp_rw [mul_add]
          rw [ENNReal.mul_div_cancel' _ ENNReal.coe_ne_top]
          simpa using hc
  Â· have A : ((âˆ«â» x : Î±, fâ‚ x âˆ‚Î¼) + âˆ«â» x : Î±, fâ‚‚ x âˆ‚Î¼) â‰  âŠ¤ := by
      rwa [â† lintegral_add_left fâ‚.measurable.coe_nnreal_ennreal]
    rcases hâ‚ (ENNReal.add_ne_top.1 A).1 (ENNReal.half_pos Îµ0).ne' with
      âŸ¨gâ‚, fâ‚_le_gâ‚, gâ‚cont, gâ‚intâŸ©
    rcases hâ‚‚ (ENNReal.add_ne_top.1 A).2 (ENNReal.half_pos Îµ0).ne' with
      âŸ¨gâ‚‚, fâ‚‚_le_gâ‚‚, gâ‚‚cont, gâ‚‚intâŸ©
    refine'
      âŸ¨fun x => gâ‚ x + gâ‚‚ x, fun x => add_le_add (fâ‚_le_gâ‚ x) (fâ‚‚_le_gâ‚‚ x), gâ‚cont.add gâ‚‚cont, _âŸ©
    simp only [SimpleFunc.coe_add, ENNReal.coe_add, Pi.add_apply]
    rw [lintegral_add_left fâ‚.measurable.coe_nnreal_ennreal,
      lintegral_add_left gâ‚cont.measurable.coe_nnreal_ennreal]
    convert add_le_add gâ‚int gâ‚‚int using 1
    conv_lhs => rw [â† ENNReal.add_halves Îµ]
    abel","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.85045 â†’ ?m.85045 â†’ Prop
error:  type mismatch
  hâœ
has type
  â†‘c * Î¼ s â‰  âŠ¤ : Prop
but is expected to have type
  Î¼ s â‰  âŠ¤ : Prop","theorem SimpleFunc.exists_upperSemicontinuous_le_lintegral_le (f : Î± â†’â‚› â„â‰¥0)
    (int_f : (âˆ«â» x, f x âˆ‚Î¼) â‰  âˆ) {Îµ : â„â‰¥0âˆ} (Îµ0 : Îµ â‰  0) :
    âˆƒ g : Î± â†’ â„â‰¥0, (âˆ€ x, g x â‰¤ f x) âˆ§ UpperSemicontinuous g âˆ§
      (âˆ«â» x, f x âˆ‚Î¼) â‰¤ (âˆ«â» x, g x âˆ‚Î¼) + Îµ ",":= by
  induction' f using MeasureTheory.SimpleFunc.induction with c s hs fâ‚ fâ‚‚ _ hâ‚ hâ‚‚ generalizing Îµ
  Â· by_cases hc : c = 0
    Â· refine âŸ¨fun _ => 0, ?_, upperSemicontinuous_const, ?_âŸ©
      Â· classical
        simp only [hc, Set.indicator_zero', Pi.zero_apply, SimpleFunc.const_zero, imp_true_iff,
          eq_self_iff_true, SimpleFunc.coe_zero, Set.piecewise_eq_indicator,
          SimpleFunc.coe_piecewise, le_zero_iff]
      Â· classical
        simp only [hc, Set.indicator_zero', lintegral_const, zero_mul, Pi.zero_apply,
          SimpleFunc.const_zero, zero_add, zero_le', SimpleFunc.coe_zero,
          Set.piecewise_eq_indicator, ENNReal.coe_zero, SimpleFunc.coe_piecewise, zero_le]
    have Î¼s_lt_top : Î¼ s < âˆ := by
      classical
      simpa only [hs, hc, lt_top_iff_ne_top, true_and_iff, SimpleFunc.coe_const, or_false_iff,
        lintegral_const, ENNReal.coe_indicator, Set.univ_inter, ENNReal.coe_ne_top,
        Measure.restrict_apply MeasurableSet.univ, ENNReal.mul_eq_top, SimpleFunc.const_zero,
        Function.const_apply, lintegral_indicator, ENNReal.coe_eq_zero, Ne, not_false_iff,
        SimpleFunc.coe_zero, Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise,
        false_and_iff] using int_f
    have : (0 : â„â‰¥0âˆ) < Îµ / c := ENNReal.div_pos_iff.2 âŸ¨Îµ0, ENNReal.coe_ne_topâŸ©
    obtain âŸ¨F, Fs, F_closed, Î¼FâŸ© : âˆƒ (F : _), F âŠ† s âˆ§ IsClosed F âˆ§ Î¼ s < Î¼ F + Îµ / c :=
      hs.exists_isClosed_lt_add Î¼s_lt_top.ne this.ne'
    refine
      âŸ¨Set.indicator F fun _ => c, fun x => ?_, F_closed.upperSemicontinuous_indicator (zero_le _),
        ?_âŸ©
    Â· simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,
        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]
      exact Set.indicator_le_indicator_of_subset Fs (fun x => zero_le _) _
    Â· suffices (c : â„â‰¥0âˆ) * Î¼ s â‰¤ c * Î¼ F + Îµ by
        classical
        simpa only [hs, F_closed.measurableSet, SimpleFunc.coe_const, Function.const_apply,
          lintegral_const, ENNReal.coe_indicator, Set.univ_inter, MeasurableSet.univ,
          SimpleFunc.const_zero, lintegral_indicator, SimpleFunc.coe_zero,
          Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise, Measure.restrict_apply]
      calc
        (c : â„â‰¥0âˆ) * Î¼ s â‰¤ c * (Î¼ F + Îµ / c) := mul_le_mul_left' Î¼F.le _
        _ = c * Î¼ F + Îµ := by
          simp_rw [mul_add]
          rw [ENNReal.mul_div_cancel' _ ENNReal.coe_ne_top]
          simpa using hc
  Â· have A : ((âˆ«â» x : Î±, fâ‚ x âˆ‚Î¼) + âˆ«â» x : Î±, fâ‚‚ x âˆ‚Î¼) â‰  âŠ¤ := by
      rwa [â† lintegral_add_left fâ‚.measurable.coe_nnreal_ennreal]
    rcases hâ‚ (ENNReal.add_ne_top.1 A).1 (ENNReal.half_pos Îµ0).ne' with
      âŸ¨gâ‚, fâ‚_le_gâ‚, gâ‚cont, gâ‚intâŸ©
    rcases hâ‚‚ (ENNReal.add_ne_top.1 A).2 (ENNReal.half_pos Îµ0).ne' with
      âŸ¨gâ‚‚, fâ‚‚_le_gâ‚‚, gâ‚‚cont, gâ‚‚intâŸ©
    refine
      âŸ¨fun x => gâ‚ x + gâ‚‚ x, fun x => add_le_add (fâ‚_le_gâ‚ x) (fâ‚‚_le_gâ‚‚ x), gâ‚cont.add gâ‚‚cont, ?_âŸ©
    simp only [SimpleFunc.coe_add, ENNReal.coe_add, Pi.add_apply]
    rw [lintegral_add_left fâ‚.measurable.coe_nnreal_ennreal,
      lintegral_add_left gâ‚cont.measurable.coe_nnreal_ennreal]
    convert add_le_add gâ‚int gâ‚‚int using 1
    conv_lhs => rw [â† ENNReal.add_halves Îµ]
    abel"
Mathlib/CategoryTheory/Abelian/Pseudoelements.lean,CategoryTheory.Abelian.Pseudoelement.pseudo_injective_of_mono,pseudo_injective_of_mono,1cb1056b5a19f416d3fae3469d51eedb4f5b48cb,":= by
  intro abar abar'
  refine' Quotient.inductionOnâ‚‚ abar abar' fun a a' ha => _
  apply Quotient.sound
  have : âŸ¦(a.hom â‰« f : Over Q)âŸ§ = âŸ¦â†‘(a'.hom â‰« f)âŸ§ := by convert ha
  let âŸ¨R, p, q, ep, Eq, commâŸ© := Quotient.exact this
  exact âŸ¨R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact commâŸ©","error:  don't know how to synthesize implicit argument 'Î±'
  @Eq (Quotient ?m.42591) âŸ¦Over.mk (a.hom â‰« f)âŸ§ âŸ¦Over.mk (a'.hom â‰« f)âŸ§
context:
C : Type u
instâœÂ² : Category.{v, u} C
instâœÂ¹ : Abelian C
P Q : C
f : P âŸ¶ Q
instâœ : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f âŸ¦aâŸ§ = pseudoApply f âŸ¦a'âŸ§
âŠ¢ Type (max u v)
error:  don't know how to synthesize placeholder for argument 's'
context:
C : Type u
instâœÂ² : Category.{v, u} C
instâœÂ¹ : Abelian C
P Q : C
f : P âŸ¶ Q
instâœ : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f âŸ¦aâŸ§ = pseudoApply f âŸ¦a'âŸ§
âŠ¢ Setoid (Over Q)
error:  don't know how to synthesize placeholder for argument 's'
context:
C : Type u
instâœÂ² : Category.{v, u} C
instâœÂ¹ : Abelian C
P Q : C
f : P âŸ¶ Q
instâœ : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f âŸ¦aâŸ§ = pseudoApply f âŸ¦a'âŸ§
âŠ¢ Setoid (Over Q)
error:  unsolved goals
case a
C : Type u
instâœÂ² : Category.{v, u} C
instâœÂ¹ : Abelian C
P Q : C
f : P âŸ¶ Q
instâœ : Mono f
abar abar' : Pseudoelement P
a a' : Over P
ha : pseudoApply f âŸ¦aâŸ§ = pseudoApply f âŸ¦a'âŸ§
âŠ¢ a â‰ˆ a'",theorem pseudo_injective_of_mono {P Q : C} (f : P âŸ¶ Q) [Mono f] : Function.Injective f ,":= by
  intro abar abar'
  refine Quotient.inductionOnâ‚‚ abar abar' fun a a' ha => ?_
  apply Quotient.sound
  have : (âŸ¦(a.hom â‰« f : Over Q)âŸ§ : Quotient (setoid Q)) = âŸ¦â†‘(a'.hom â‰« f)âŸ§ := by convert ha
  have âŸ¨R, p, q, ep, Eq, commâŸ© := Quotient.exact this
  exact âŸ¨R, p, q, ep, Eq, (cancel_mono f).1 <| by
    simp only [Category.assoc]
    exact commâŸ©"
Mathlib/CategoryTheory/Triangulated/Subcategory.lean,CategoryTheory.Triangulated.Subcategory.isoClosure_W,isoClosure_W,574b7b95401ec114227c0aa3eb92af557a310c05,":= by
  ext X Y f
  constructor
  Â· rintro âŸ¨Z, g, h, mem, âŸ¨Z', hZ', âŸ¨eâŸ©âŸ©âŸ©
    refine' âŸ¨Z', g â‰« e.hom, e.inv â‰« h, isomorphic_distinguished _ mem _ _, hZ'âŸ©
    exact Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) e.symm
  Â· rintro âŸ¨Z, g, h, mem, hZâŸ©
    exact âŸ¨Z, g, h, mem, subset_isoClosure _ _ hZâŸ©",error:  unknown identifier 'subset_isoClosure',lemma isoClosure_W : S.isoClosure.W = S.W ,":= by
  ext X Y f
  constructor
  Â· rintro âŸ¨Z, g, h, mem, âŸ¨Z', hZ', âŸ¨eâŸ©âŸ©âŸ©
    refine' âŸ¨Z', g â‰« e.hom, e.inv â‰« h, isomorphic_distinguished _ mem _ _, hZ'âŸ©
    exact Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) e.symm
  Â· rintro âŸ¨Z, g, h, mem, hZâŸ©
    exact âŸ¨Z, g, h, mem, le_isoClosure _ _ hZâŸ©"
Mathlib/Geometry/Manifold/Instances/Sphere.lean,contMDiff_coe_sphere,contMDiff_coe_sphere,28f34517ea07a4ecc94b3d55041dd0ca1152a2a8,":= by
  have := smoothMfldWithCorners (E := E) (n := n)
  rw [contMDiff_iff]
  constructor
  Â· exact continuous_subtype_val
  Â· intro v _
    let U : _ â‰ƒâ‚—áµ¢[â„] _ :=
      (
          OrthonormalBasis.fromOrthogonalSpanSingleton
          n (ne_zero_of_mem_unit_sphere (-v))).repr
    exact
      ((contDiff_stereoInvFunAux.comp (â„ â€¢ (-v : E))á—®.subtypeL.contDiff).comp
          U.symm.contDiff).contDiffOn","error:  unknown identifier 'smoothMfldWithCorners'
error:  unsolved goals
E : Type u_1
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : InnerProductSpace â„ E
n : â„•
instâœ : Fact (finrank â„ E = n + 1)
âŠ¢ ContMDiff ğ“˜(â„, EuclideanSpace â„ (Fin n)) ğ“˜(â„, E) âŠ¤ Subtype.val","theorem contMDiff_coe_sphere {n : â„•} [Fact (finrank â„ E = n + 1)] :
    ContMDiff (ğ“¡ n) ğ“˜(â„, E) âˆ ((â†‘) : sphere (0 : E) 1 â†’ E) ",":= by
  have := EuclideanSpace.instSmoothManifoldWithCornersSphere (E := E) (n := n)
  rw [contMDiff_iff]
  constructor
  Â· exact continuous_subtype_val
  Â· intro v _
    let U : _ â‰ƒâ‚—áµ¢[â„] _ :=
      (
          OrthonormalBasis.fromOrthogonalSpanSingleton
          n (ne_zero_of_mem_unit_sphere (-v))).repr
    exact
      ((contDiff_stereoInvFunAux.comp (â„ âˆ™ (-v : E))á—®.subtypeL.contDiff).comp
          U.symm.contDiff).contDiffOn"
Mathlib/Data/Set/Pointwise/BigOperators.lean,Set.multiset_prod_subset_multiset_prod,multiset_prod_subset_multiset_prod,554c20d1eb6d2f1f6a5b53ccd3a727a93147a4de,":= by
  induction t using Quotient.inductionOn
  simp_rw [Multiset.quot_mk_to_coe, Multiset.coe_map, Multiset.coe_prod]
  exact list_prod_subset_list_prod _ _ _ hf","error:  unknown constant 'Multiset.coe_map'
error:  simp made no progress","theorem multiset_prod_subset_multiset_prod (t : Multiset Î¹) (fâ‚ fâ‚‚ : Î¹ â†’ Set Î±)
    (hf : âˆ€ i âˆˆ t, fâ‚ i âŠ† fâ‚‚ i) : (t.map fâ‚).prod âŠ† (t.map fâ‚‚).prod ",":= by
  induction t using Quotient.inductionOn
  simp_rw [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]
  exact list_prod_subset_list_prod _ _ _ hf"
Mathlib/Analysis/Calculus/ParametricIntegral.lean,hasFDerivAt_integral_of_dominated_loc_of_lip',hasFDerivAt_integral_of_dominated_loc_of_lip',0939faa78a0c4506a8aee4e86b897d6e84c6cb96,":= by
  have xâ‚€_in : xâ‚€ âˆˆ ball xâ‚€ Îµ := mem_ball_self Îµ_pos
  have nneg : âˆ€ x, 0 â‰¤ â€–x - xâ‚€â€–â»Â¹ := fun x â†¦ inv_nonneg.mpr (norm_nonneg _)
  set b : Î± â†’ â„ := fun a â†¦ |bound a|
  have b_int : Integrable b Î¼ := bound_integrable.norm
  have b_nonneg : âˆ€ a, 0 â‰¤ b a := fun a â†¦ abs_nonneg _
  replace h_lipsch : âˆ€áµ a âˆ‚Î¼, âˆ€ x âˆˆ ball xâ‚€ Îµ, â€–F x a - F xâ‚€ aâ€– â‰¤ b a * â€–x - xâ‚€â€–
  exact h_lipsch.mono fun a ha x hx â†¦
    (ha x hx).trans <| mul_le_mul_of_nonneg_right (le_abs_self _) (norm_nonneg _)
  have hF_int' : âˆ€ x âˆˆ ball xâ‚€ Îµ, Integrable (F x) Î¼ := fun x x_in â†¦ by
    have : âˆ€áµ a âˆ‚Î¼, â€–F xâ‚€ a - F x aâ€– â‰¤ Îµ * b a := by
      simp only [norm_sub_rev (F xâ‚€ _)]
      refine h_lipsch.mono fun a ha â†¦ (ha x x_in).trans ?_
      rw [mul_comm Îµ]
      rw [mem_ball, dist_eq_norm] at x_in
      exact mul_le_mul_of_nonneg_left x_in.le (b_nonneg _)
    exact integrable_of_norm_sub_le (hF_meas x x_in) hF_int
      (bound_integrable.norm.const_mul Îµ) this
  have hF'_int : Integrable F' Î¼ :=
    have : âˆ€áµ a âˆ‚Î¼, â€–F' aâ€– â‰¤ b a := by
      apply (h_diff.and h_lipsch).mono
      rintro a âŸ¨ha_diff, ha_lipâŸ©
      exact ha_diff.le_of_lip' (b_nonneg a) (mem_of_superset (ball_mem_nhds _ Îµ_pos) <| ha_lip)
    b_int.mono' hF'_meas this
  refine âŸ¨hF'_int, ?_âŸ©
  have h_ball : ball xâ‚€ Îµ âˆˆ ğ“ xâ‚€ := ball_mem_nhds xâ‚€ Îµ_pos
  have : âˆ€á¶  x in ğ“ xâ‚€, â€–x - xâ‚€â€–â»Â¹ * â€–((âˆ« a, F x a âˆ‚Î¼) - âˆ« a, F xâ‚€ a âˆ‚Î¼) - (âˆ« a, F' a âˆ‚Î¼) (x - xâ‚€)â€– =
      â€–âˆ« a, â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€)) âˆ‚Î¼â€– := by
    apply mem_of_superset (ball_mem_nhds _ Îµ_pos)
    intro x x_in; simp only
    rw [Set.mem_setOf_eq, â† norm_smul_of_nonneg (nneg _), integral_smul, integral_sub, integral_sub,
      â† ContinuousLinearMap.integral_apply hF'_int]
    exacts [hF_int' x x_in, hF_int, (hF_int' x x_in).sub hF_int,
      hF'_int.apply_continuousLinearMap _]
  rw [hasFDerivAt_iff_tendsto, tendsto_congr' this, â† tendsto_zero_iff_norm_tendsto_zero, â†
    show (âˆ« a : Î±, â€–xâ‚€ - xâ‚€â€–â»Â¹ â€¢ (F xâ‚€ a - F xâ‚€ a - (F' a) (xâ‚€ - xâ‚€)) âˆ‚Î¼) = 0 by simp]
  apply tendsto_integral_filter_of_dominated_convergence
  Â· filter_upwards [h_ball] with _ x_in
    apply AEStronglyMeasurable.const_smul
    exact ((hF_meas _ x_in).sub (hF_meas _ xâ‚€_in)).sub (hF'_meas.apply_continuousLinearMap _)
  Â· refine mem_of_superset h_ball fun x hx â†¦ ?_
    apply (h_diff.and h_lipsch).mono
    rintro a âŸ¨-, ha_boundâŸ©
    show â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))â€– â‰¤ b a + â€–F' aâ€–
    replace ha_bound : â€–F x a - F xâ‚€ aâ€– â‰¤ b a * â€–x - xâ‚€â€– := ha_bound x hx
    calc
      â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))â€– =
          â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a) - â€–x - xâ‚€â€–â»Â¹ â€¢ F' a (x - xâ‚€)â€– :=
        by rw [smul_sub]
      _ â‰¤ â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a)â€– + â€–â€–x - xâ‚€â€–â»Â¹ â€¢ F' a (x - xâ‚€)â€– := (norm_sub_le _ _)
      _ = â€–x - xâ‚€â€–â»Â¹ * â€–F x a - F xâ‚€ aâ€– + â€–x - xâ‚€â€–â»Â¹ * â€–F' a (x - xâ‚€)â€– := by
        rw [norm_smul_of_nonneg, norm_smul_of_nonneg] <;> exact nneg _
      _ â‰¤ â€–x - xâ‚€â€–â»Â¹ * (b a * â€–x - xâ‚€â€–) + â€–x - xâ‚€â€–â»Â¹ * (â€–F' aâ€– * â€–x - xâ‚€â€–) := by
        gcongr; exact (F' a).le_opNorm _
      _ â‰¤ b a + â€–F' aâ€– := ?_
    simp only [â† div_eq_inv_mul]
    apply_rules [add_le_add, div_le_of_nonneg_of_le_mul] <;> first | rfl | positivity
  Â· exact b_int.add hF'_int.norm
  Â· apply h_diff.mono
    intro a ha
    suffices Tendsto (fun x â†¦ â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))) (ğ“ xâ‚€) (ğ“ 0) by simpa
    rw [tendsto_zero_iff_norm_tendsto_zero]
    have : (fun x â†¦ â€–x - xâ‚€â€–â»Â¹ * â€–F x a - F xâ‚€ a - F' a (x - xâ‚€)â€–) = fun x â†¦
        â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))â€– := by
      ext x
      rw [norm_smul_of_nonneg (nneg _)]
    rwa [hasFDerivAt_iff_tendsto, this] at ha","error:  unexpected identifier; expected '|'
error:  unsolved goals
Î± : Type u_1
instâœâ¶ : MeasurableSpace Î±
Î¼ : Measure Î±
ğ•œ : Type u_2
instâœâµ : RCLike ğ•œ
E : Type u_3
instâœâ´ : NormedAddCommGroup E
instâœÂ³ : NormedSpace â„ E
instâœÂ² : NormedSpace ğ•œ E
H : Type u_4
instâœÂ¹ : NormedAddCommGroup H
instâœ : NormedSpace ğ•œ H
F : H â†’ Î± â†’ E
xâ‚€ : H
bound : Î± â†’ â„
Îµ : â„
F' : Î± â†’ H â†’L[ğ•œ] E
Îµ_pos : 0 < Îµ
hF_meas : âˆ€ x âˆˆ ball xâ‚€ Îµ, AEStronglyMeasurable (F x) Î¼
hF_int : Integrable (F xâ‚€) Î¼
hF'_meas : AEStronglyMeasurable F' Î¼
bound_integrable : Integrable bound Î¼
h_diff : âˆ€áµ (a : Î±) âˆ‚Î¼, HasFDerivAt (fun x â†¦ F x a) (F' a) xâ‚€
xâ‚€_in : xâ‚€ âˆˆ ball xâ‚€ Îµ
nneg : âˆ€ (x : H), 0 â‰¤ â€–x - xâ‚€â€–â»Â¹
b : Î± â†’ â„ := fun a â†¦ |bound a|
b_int : Integrable b Î¼
b_nonneg : âˆ€ (a : Î±), 0 â‰¤ b a
h_lipsch : âˆ€áµ (a : Î±) âˆ‚Î¼, âˆ€ x âˆˆ ball xâ‚€ Îµ, â€–F x a - F xâ‚€ aâ€– â‰¤ b a * â€–x - xâ‚€â€–
âŠ¢ Integrable F' Î¼ âˆ§ HasFDerivAt (fun x â†¦ âˆ« (a : Î±), F x a âˆ‚Î¼) (âˆ« (a : Î±), F' a âˆ‚Î¼) xâ‚€","theorem hasFDerivAt_integral_of_dominated_loc_of_lip' {F' : Î± â†’ H â†’L[ğ•œ] E} (Îµ_pos : 0 < Îµ)
    (hF_meas : âˆ€ x âˆˆ ball xâ‚€ Îµ, AEStronglyMeasurable (F x) Î¼) (hF_int : Integrable (F xâ‚€) Î¼)
    (hF'_meas : AEStronglyMeasurable F' Î¼)
    (h_lipsch : âˆ€áµ a âˆ‚Î¼, âˆ€ x âˆˆ ball xâ‚€ Îµ, â€–F x a - F xâ‚€ aâ€– â‰¤ bound a * â€–x - xâ‚€â€–)
    (bound_integrable : Integrable (bound : Î± â†’ â„) Î¼)
    (h_diff : âˆ€áµ a âˆ‚Î¼, HasFDerivAt (F Â· a) (F' a) xâ‚€) :
    Integrable F' Î¼ âˆ§ HasFDerivAt (fun x â†¦ âˆ« a, F x a âˆ‚Î¼) (âˆ« a, F' a âˆ‚Î¼) xâ‚€ ",":= by
  have xâ‚€_in : xâ‚€ âˆˆ ball xâ‚€ Îµ := mem_ball_self Îµ_pos
  have nneg : âˆ€ x, 0 â‰¤ â€–x - xâ‚€â€–â»Â¹ := fun x â†¦ inv_nonneg.mpr (norm_nonneg _)
  set b : Î± â†’ â„ := fun a â†¦ |bound a|
  have b_int : Integrable b Î¼ := bound_integrable.norm
  have b_nonneg : âˆ€ a, 0 â‰¤ b a := fun a â†¦ abs_nonneg _
  replace h_lipsch : âˆ€áµ a âˆ‚Î¼, âˆ€ x âˆˆ ball xâ‚€ Îµ, â€–F x a - F xâ‚€ aâ€– â‰¤ b a * â€–x - xâ‚€â€– :=
    h_lipsch.mono fun a ha x hx â†¦
      (ha x hx).trans <| mul_le_mul_of_nonneg_right (le_abs_self _) (norm_nonneg _)
  have hF_int' : âˆ€ x âˆˆ ball xâ‚€ Îµ, Integrable (F x) Î¼ := fun x x_in â†¦ by
    have : âˆ€áµ a âˆ‚Î¼, â€–F xâ‚€ a - F x aâ€– â‰¤ Îµ * b a := by
      simp only [norm_sub_rev (F xâ‚€ _)]
      refine h_lipsch.mono fun a ha â†¦ (ha x x_in).trans ?_
      rw [mul_comm Îµ]
      rw [mem_ball, dist_eq_norm] at x_in
      exact mul_le_mul_of_nonneg_left x_in.le (b_nonneg _)
    exact integrable_of_norm_sub_le (hF_meas x x_in) hF_int
      (bound_integrable.norm.const_mul Îµ) this
  have hF'_int : Integrable F' Î¼ :=
    have : âˆ€áµ a âˆ‚Î¼, â€–F' aâ€– â‰¤ b a := by
      apply (h_diff.and h_lipsch).mono
      rintro a âŸ¨ha_diff, ha_lipâŸ©
      exact ha_diff.le_of_lip' (b_nonneg a) (mem_of_superset (ball_mem_nhds _ Îµ_pos) <| ha_lip)
    b_int.mono' hF'_meas this
  refine âŸ¨hF'_int, ?_âŸ©
  by_cases hE : CompleteSpace E; swap
  Â· rcases subsingleton_or_nontrivial H with hH|hH
    Â· have : Subsingleton (H â†’L[ğ•œ] E) := inferInstance
      convert hasFDerivAt_of_subsingleton _ xâ‚€
    Â· have : Â¬(CompleteSpace (H â†’L[ğ•œ] E)) := by
        simpa [SeparatingDual.completeSpace_continuousLinearMap_iff] using hE
      simp only [integral, hE, â†“reduceDIte, this]
      exact hasFDerivAt_const 0 xâ‚€
  have h_ball : ball xâ‚€ Îµ âˆˆ ğ“ xâ‚€ := ball_mem_nhds xâ‚€ Îµ_pos
  have : âˆ€á¶  x in ğ“ xâ‚€, â€–x - xâ‚€â€–â»Â¹ * â€–((âˆ« a, F x a âˆ‚Î¼) - âˆ« a, F xâ‚€ a âˆ‚Î¼) - (âˆ« a, F' a âˆ‚Î¼) (x - xâ‚€)â€– =
      â€–âˆ« a, â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€)) âˆ‚Î¼â€– := by
    apply mem_of_superset (ball_mem_nhds _ Îµ_pos)
    intro x x_in; simp only
    rw [Set.mem_setOf_eq, â† norm_smul_of_nonneg (nneg _), integral_smul, integral_sub, integral_sub,
      â† ContinuousLinearMap.integral_apply hF'_int]
    exacts [hF_int' x x_in, hF_int, (hF_int' x x_in).sub hF_int,
      hF'_int.apply_continuousLinearMap _]
  rw [hasFDerivAt_iff_tendsto, tendsto_congr' this, â† tendsto_zero_iff_norm_tendsto_zero, â†
    show (âˆ« a : Î±, â€–xâ‚€ - xâ‚€â€–â»Â¹ â€¢ (F xâ‚€ a - F xâ‚€ a - (F' a) (xâ‚€ - xâ‚€)) âˆ‚Î¼) = 0 by simp]
  apply tendsto_integral_filter_of_dominated_convergence
  Â· filter_upwards [h_ball] with _ x_in
    apply AEStronglyMeasurable.const_smul
    exact ((hF_meas _ x_in).sub (hF_meas _ xâ‚€_in)).sub (hF'_meas.apply_continuousLinearMap _)
  Â· refine mem_of_superset h_ball fun x hx â†¦ ?_
    apply (h_diff.and h_lipsch).mono
    on_goal 1 => rintro a âŸ¨-, ha_boundâŸ©
    show â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))â€– â‰¤ b a + â€–F' aâ€–
    replace ha_bound : â€–F x a - F xâ‚€ aâ€– â‰¤ b a * â€–x - xâ‚€â€– := ha_bound x hx
    calc
      â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))â€– =
          â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a) - â€–x - xâ‚€â€–â»Â¹ â€¢ F' a (x - xâ‚€)â€– := by rw [smul_sub]
      _ â‰¤ â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a)â€– + â€–â€–x - xâ‚€â€–â»Â¹ â€¢ F' a (x - xâ‚€)â€– := norm_sub_le _ _
      _ = â€–x - xâ‚€â€–â»Â¹ * â€–F x a - F xâ‚€ aâ€– + â€–x - xâ‚€â€–â»Â¹ * â€–F' a (x - xâ‚€)â€– := by
        rw [norm_smul_of_nonneg, norm_smul_of_nonneg] <;> exact nneg _
      _ â‰¤ â€–x - xâ‚€â€–â»Â¹ * (b a * â€–x - xâ‚€â€–) + â€–x - xâ‚€â€–â»Â¹ * (â€–F' aâ€– * â€–x - xâ‚€â€–) := by
        gcongr; exact (F' a).le_opNorm _
      _ â‰¤ b a + â€–F' aâ€– := ?_
    simp only [â† div_eq_inv_mul]
    apply_rules [add_le_add, div_le_of_nonneg_of_le_mul] <;> first | rfl | positivity
  Â· exact b_int.add hF'_int.norm
  Â· apply h_diff.mono
    intro a ha
    suffices Tendsto (fun x â†¦ â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))) (ğ“ xâ‚€) (ğ“ 0) by simpa
    rw [tendsto_zero_iff_norm_tendsto_zero]
    have : (fun x â†¦ â€–x - xâ‚€â€–â»Â¹ * â€–F x a - F xâ‚€ a - F' a (x - xâ‚€)â€–) = fun x â†¦
        â€–â€–x - xâ‚€â€–â»Â¹ â€¢ (F x a - F xâ‚€ a - F' a (x - xâ‚€))â€– := by
      ext x
      rw [norm_smul_of_nonneg (nneg _)]
    rwa [hasFDerivAt_iff_tendsto, this] at ha"
Mathlib/Topology/Order/Basic.lean,order_separated,order_separated,46d4658f3d53b90e371238cba7834b12e431e312,":=
  let âŸ¨x, hx, y, hy, hâŸ© := h.exists_disjoint_Iio_Ioi
  âŸ¨Iio x, Ioi y, isOpen_iff_generate_intervals.2 <| .basic _ <| .inr <| mem_range_self _,
    isOpen_iff_generate_intervals.2 <| .basic _ <| .inl <| mem_range_self _, hx, hy, hâŸ©","error:  invalid dotted identifier notation, unknown identifier `Membership.mem.inr` from expected type
  Iio x âˆˆ {s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a}
error:  invalid dotted identifier notation, unknown identifier `Set.Mem.inr` from expected type
  Iio x âˆˆ {s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a}
error:  invalid dotted identifier notation, unknown identifier `setOf.inr` from expected type
  Iio x âˆˆ {s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a}
error:  invalid dotted identifier notation, unknown identifier `Exists.inr` from expected type
  Iio x âˆˆ {s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a}
error:  invalid dotted identifier notation, unknown identifier `Membership.mem.inl` from expected type
  Ioi y âˆˆ {s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a}
error:  invalid dotted identifier notation, unknown identifier `Set.Mem.inl` from expected type
  Ioi y âˆˆ {s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a}
error:  invalid dotted identifier notation, unknown identifier `setOf.inl` from expected type
  Ioi y âˆˆ {s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a}
error:  invalid dotted identifier notation, unknown identifier `Exists.inl` from expected type
  Ioi y âˆˆ {s | âˆƒ a, s = Ioi a âˆ¨ s = Iio a}","theorem order_separated {aâ‚ aâ‚‚ : Î±} (h : aâ‚ < aâ‚‚) :
    âˆƒ u v : Set Î±, IsOpen u âˆ§ IsOpen v âˆ§ aâ‚ âˆˆ u âˆ§ aâ‚‚ âˆˆ v âˆ§ âˆ€ bâ‚ âˆˆ u, âˆ€ bâ‚‚ âˆˆ v, bâ‚ < bâ‚‚ ",":=
  let âŸ¨x, hx, y, hy, hâŸ© := h.exists_disjoint_Iio_Ioi
  âŸ¨Iio x, Ioi y, isOpen_gt' _, isOpen_lt' _, hx, hy, hâŸ©"
Mathlib/Analysis/MellinTransform.lean,mellin_hasDerivAt_of_isBigO_rpow,mellin_hasDerivAt_of_isBigO_rpow,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  set F : â„‚ â†’ â„ â†’ E := fun (z : â„‚) (t : â„) => (t : â„‚) ^ (z - 1) â€¢ f t
  set F' : â„‚ â†’ â„ â†’ E := fun (z : â„‚) (t : â„) => ((t : â„‚) ^ (z - 1) * log t) â€¢ f t
  obtain âŸ¨v, hv0, hv1, hv2âŸ© : âˆƒ v : â„, 0 < v âˆ§ v < s.re - b âˆ§ v < a - s.re := by
    obtain âŸ¨w, hw1, hw2âŸ© := exists_between (sub_pos.mpr hs_top)
    obtain âŸ¨w', hw1', hw2'âŸ© := exists_between (sub_pos.mpr hs_bot)
    exact
      âŸ¨min w w', lt_min hw1 hw1', (min_le_right _ _).trans_lt hw2', (min_le_left _ _).trans_lt hw2âŸ©
  let bound : â„ â†’ â„ := fun t : â„ => (t ^ (s.re + v - 1) + t ^ (s.re - v - 1)) * |log t| * â€–f tâ€–
  have h1 : âˆ€á¶  z : â„‚ in ğ“ s, AEStronglyMeasurable (F z) (volume.restrict <| Ioi 0) := by
    refine eventually_of_forall fun z => AEStronglyMeasurable.smul ?_ hfc.aestronglyMeasurable
    refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
    refine ContinuousAt.continuousOn fun t ht => ?_
    exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
  have h2 : IntegrableOn (F s) (Ioi (0 : â„)) := by
    exact mellinConvergent_of_isBigO_rpow hfc hf_top hs_top hf_bot hs_bot
  have h3 : AEStronglyMeasurable (F' s) (volume.restrict <| Ioi 0) := by
    apply LocallyIntegrableOn.aestronglyMeasurable
    refine hfc.continuousOn_smul isOpen_Ioi ((ContinuousAt.continuousOn fun t ht => ?_).mul ?_)
    Â· exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
    Â· refine continuous_ofReal.comp_continuousOn ?_
      exact continuousOn_log.mono (subset_compl_singleton_iff.mpr not_mem_Ioi_self)
  have h4 : âˆ€áµ t : â„ âˆ‚volume.restrict (Ioi 0),
      âˆ€ z : â„‚, z âˆˆ Metric.ball s v â†’ â€–F' z tâ€– â‰¤ bound t := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht z hz => ?_
    simp_rw [F', bound, norm_smul, norm_mul, Complex.norm_eq_abs (log _), Complex.abs_ofReal,
      mul_assoc]
    gcongr
    rw [Complex.norm_eq_abs, abs_cpow_eq_rpow_re_of_pos ht]
    rcases le_or_lt 1 t with h | h
    Â· refine le_add_of_le_of_nonneg (rpow_le_rpow_of_exponent_le h ?_)
        (rpow_nonneg (zero_le_one.trans h) _)
      rw [sub_re, one_re, sub_le_sub_iff_right]
      rw [mem_ball_iff_norm, Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add'] at hz'
    Â· refine
        le_add_of_nonneg_of_le (rpow_pos_of_pos ht _).le (rpow_le_rpow_of_exponent_ge ht h.le ?_)
      rw [sub_re, one_re, sub_le_iff_le_add, sub_add_cancel]
      rw [mem_ball_iff_norm', Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add, â† sub_le_iff_le_add'] at hz'
  have h5 : IntegrableOn bound (Ioi 0) := by
    simp_rw [bound, add_mul, mul_assoc]
    suffices âˆ€ {j : â„}, b < j â†’ j < a â†’
        IntegrableOn (fun t : â„ => t ^ (j - 1) * (|log t| * â€–f tâ€–)) (Ioi 0) volume by
      refine Integrable.add (this ?_ ?_) (this? _ ?_)
      all_goals linarith
    Â· intro j hj hj'
      obtain âŸ¨w, hw1, hw2âŸ© := exists_between hj
      obtain âŸ¨w', hw1', hw2'âŸ© := exists_between hj'
      refine mellin_convergent_of_isBigO_scalar ?_ ?_ hw1?' _ hw2
      Â· simp_rw [mul_comm]
        refine hfc.norm.mul_continuousOn ?_ isOpen_Ioi
        refine Continuous.comp_continuousOn _root_.continuous_abs (continuousOn_log.mono ?_)
        exact subset_compl_singleton_iff.mpr not_mem_Ioi_self
      Â· refine (isBigO_rpow_top_log_smul hw2' hf_top).norm_left.congr_left fun t â†¦ ?_
        simp only [norm_smul, Real.norm_eq_abs]
      Â· refine (isBigO_rpow_zero_log_smul hw1 hf_bot).norm_left.congr_left fun t â†¦ ?_
        simp only [norm_smul, Real.norm_eq_abs]
  have h6 : âˆ€áµ t : â„ âˆ‚volume.restrict (Ioi 0),
      âˆ€ y : â„‚, y âˆˆ Metric.ball s v â†’ HasDerivAt (fun z : â„‚ => F z t) (F' y t) y := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht y _ => ?_
    have ht' : (t : â„‚) â‰  0 := ofReal_ne_zero.mpr (ne_of_gt ht)
    have u1 : HasDerivAt (fun z : â„‚ => (t : â„‚) ^ (z - 1)) (t ^ (y - 1) * log t) y := by
      convert ((hasDerivAt_id' y).sub_const 1).const_cpow (Or.inl ht') using 1
      rw [ofReal_log (le_of_lt ht)]
      ring
    exact u1.smul_const (f t)
  have main := hasDerivAt_integral_of_dominated_loc_of_deriv_le hv0 h1 h2 h3 h4 h5 h6
  simpa only [F', mul_smul] using main","error:  unknown identifier 'this?'
error:  unknown identifier 'hw1?''","theorem mellin_hasDerivAt_of_isBigO_rpow [NormedSpace â„‚ E] {a b : â„}
    {f : â„ â†’ E} {s : â„‚} (hfc : LocallyIntegrableOn f (Ioi 0)) (hf_top : f =O[atTop] (Â· ^ (-a)))
    (hs_top : s.re < a) (hf_bot : f =O[ğ“[>] 0] (Â· ^ (-b))) (hs_bot : b < s.re) :
    MellinConvergent (fun t => log t â€¢ f t) s âˆ§
      HasDerivAt (mellin f) (mellin (fun t => log t â€¢ f t) s) s ",":= by
  set F : â„‚ â†’ â„ â†’ E := fun (z : â„‚) (t : â„) => (t : â„‚) ^ (z - 1) â€¢ f t
  set F' : â„‚ â†’ â„ â†’ E := fun (z : â„‚) (t : â„) => ((t : â„‚) ^ (z - 1) * log t) â€¢ f t
  obtain âŸ¨v, hv0, hv1, hv2âŸ© : âˆƒ v : â„, 0 < v âˆ§ v < s.re - b âˆ§ v < a - s.re := by
    obtain âŸ¨w, hw1, hw2âŸ© := exists_between (sub_pos.mpr hs_top)
    obtain âŸ¨w', hw1', hw2'âŸ© := exists_between (sub_pos.mpr hs_bot)
    exact
      âŸ¨min w w', lt_min hw1 hw1', (min_le_right _ _).trans_lt hw2', (min_le_left _ _).trans_lt hw2âŸ©
  let bound : â„ â†’ â„ := fun t : â„ => (t ^ (s.re + v - 1) + t ^ (s.re - v - 1)) * |log t| * â€–f tâ€–
  have h1 : âˆ€á¶  z : â„‚ in ğ“ s, AEStronglyMeasurable (F z) (volume.restrict <| Ioi 0) := by
    refine eventually_of_forall fun z => AEStronglyMeasurable.smul ?_ hfc.aestronglyMeasurable
    refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
    refine ContinuousAt.continuousOn fun t ht => ?_
    exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
  have h2 : IntegrableOn (F s) (Ioi (0 : â„)) := by
    exact mellinConvergent_of_isBigO_rpow hfc hf_top hs_top hf_bot hs_bot
  have h3 : AEStronglyMeasurable (F' s) (volume.restrict <| Ioi 0) := by
    apply LocallyIntegrableOn.aestronglyMeasurable
    refine hfc.continuousOn_smul isOpen_Ioi ((ContinuousAt.continuousOn fun t ht => ?_).mul ?_)
    Â· exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
    Â· refine continuous_ofReal.comp_continuousOn ?_
      exact continuousOn_log.mono (subset_compl_singleton_iff.mpr not_mem_Ioi_self)
  have h4 : âˆ€áµ t : â„ âˆ‚volume.restrict (Ioi 0),
      âˆ€ z : â„‚, z âˆˆ Metric.ball s v â†’ â€–F' z tâ€– â‰¤ bound t := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht z hz => ?_
    simp_rw [F', bound, norm_smul, norm_mul, Complex.norm_eq_abs (log _), Complex.abs_ofReal,
      mul_assoc]
    gcongr
    rw [Complex.norm_eq_abs, abs_cpow_eq_rpow_re_of_pos ht]
    rcases le_or_lt 1 t with h | h
    Â· refine le_add_of_le_of_nonneg (rpow_le_rpow_of_exponent_le h ?_)
        (rpow_nonneg (zero_le_one.trans h) _)
      rw [sub_re, one_re, sub_le_sub_iff_right]
      rw [mem_ball_iff_norm, Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add'] at hz'
    Â· refine
        le_add_of_nonneg_of_le (rpow_pos_of_pos ht _).le (rpow_le_rpow_of_exponent_ge ht h.le ?_)
      rw [sub_re, one_re, sub_le_iff_le_add, sub_add_cancel]
      rw [mem_ball_iff_norm', Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add, â† sub_le_iff_le_add'] at hz'
  have h5 : IntegrableOn bound (Ioi 0) := by
    simp_rw [bound, add_mul, mul_assoc]
    suffices âˆ€ {j : â„}, b < j â†’ j < a â†’
        IntegrableOn (fun t : â„ => t ^ (j - 1) * (|log t| * â€–f tâ€–)) (Ioi 0) volume by
      refine Integrable.add (this ?_ ?_) (this ?_ ?_)
      all_goals linarith
    Â· intro j hj hj'
      obtain âŸ¨w, hw1, hw2âŸ© := exists_between hj
      obtain âŸ¨w', hw1', hw2'âŸ© := exists_between hj'
      refine mellin_convergent_of_isBigO_scalar ?_ ?_ hw1' ?_ hw2
      Â· simp_rw [mul_comm]
        refine hfc.norm.mul_continuousOn ?_ isOpen_Ioi
        refine Continuous.comp_continuousOn _root_.continuous_abs (continuousOn_log.mono ?_)
        exact subset_compl_singleton_iff.mpr not_mem_Ioi_self
      Â· refine (isBigO_rpow_top_log_smul hw2' hf_top).norm_left.congr_left fun t â†¦ ?_
        simp only [norm_smul, Real.norm_eq_abs]
      Â· refine (isBigO_rpow_zero_log_smul hw1 hf_bot).norm_left.congr_left fun t â†¦ ?_
        simp only [norm_smul, Real.norm_eq_abs]
  have h6 : âˆ€áµ t : â„ âˆ‚volume.restrict (Ioi 0),
      âˆ€ y : â„‚, y âˆˆ Metric.ball s v â†’ HasDerivAt (fun z : â„‚ => F z t) (F' y t) y := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht y _ => ?_
    have ht' : (t : â„‚) â‰  0 := ofReal_ne_zero.mpr (ne_of_gt ht)
    have u1 : HasDerivAt (fun z : â„‚ => (t : â„‚) ^ (z - 1)) (t ^ (y - 1) * log t) y := by
      convert ((hasDerivAt_id' y).sub_const 1).const_cpow (Or.inl ht') using 1
      rw [ofReal_log (le_of_lt ht)]
      ring
    exact u1.smul_const (f t)
  have main := hasDerivAt_integral_of_dominated_loc_of_deriv_le hv0 h1 h2 h3 h4 h5 h6
  simpa only [F', mul_smul] using main"
Mathlib/RingTheory/DedekindDomain/Different.lean,traceForm_dualSubmodule_adjoin,traceForm_dualSubmodule_adjoin,9cfef67e73e4260a44a22bfe7b74db43496315e1,":= by
  classical
  have hKx : IsIntegral K x := Algebra.IsIntegral.of_finite (R := K) (B := L) x
  let pb := (Algebra.adjoin.powerBasis' hKx).map
    ((Subalgebra.equivOfEq _ _ hx).trans (Subalgebra.topEquiv))
  have pbgen : pb.gen = x := by simp [pb]
  have hpb : â‡‘(LinearMap.BilinForm.dualBasis (traceForm K L) _ pb.basis) = _ :=
    _root_.funext (traceForm_dualBasis_powerBasis_eq pb)
  have : (Subalgebra.toSubmodule (Algebra.adjoin A {x})) =
      Submodule.span A (Set.range pb.basis) := by
    rw [â† span_range_natDegree_eq_adjoin (minpoly.monic hAx) (minpoly.aeval _ _)]
    congr; ext y
    have : natDegree (minpoly A x) = natDegree (minpoly K x) := by
      rw [minpoly.isIntegrallyClosed_eq_field_fractions' K hAx, (minpoly.monic hAx).natDegree_map]
    simp only [Finset.coe_image, Finset.coe_range, Set.mem_image, Set.mem_Iio, Set.mem_range,
      pb.basis_eq_pow, pbgen]
    simp only [PowerBasis.map_dim, adjoin.powerBasis'_dim, this]
    exact âŸ¨fun âŸ¨a, b, câŸ© â†¦ âŸ¨âŸ¨a, bâŸ©, câŸ©, fun âŸ¨âŸ¨a, bâŸ©, câŸ© â†¦ âŸ¨a, b, câŸ©âŸ©
  clear_value pb
  conv_lhs => rw [this]
  rw [â† span_coeff_minpolyDiv hAx, LinearMap.BilinForm.dualSubmodule_span_of_basis,
    Submodule.smul_span, hpb]
  show _ = Submodule.span A (_ '' _)
  simp only [â† Set.range_comp, smul_eq_mul, div_eq_inv_mul, pbgen,
    minpolyDiv_eq_of_isIntegrallyClosed K hAx]
  apply le_antisymm <;> rw [Submodule.span_le]
  Â· rintro _ âŸ¨i, rflâŸ©; exact Submodule.subset_span âŸ¨i, rflâŸ©
  Â· rintro _ âŸ¨i, rflâŸ©
    by_cases hi : i < pb.dim
    Â· exact Submodule.subset_span âŸ¨âŸ¨i, hiâŸ©, rflâŸ©
    Â· rw [Function.comp_apply, coeff_eq_zero_of_natDegree_lt, mul_zero]; exact zero_mem _
      rw [â† pb.natDegree_minpoly, pbgen, â† natDegree_minpolyDiv_succ hKx,
        â† Nat.succ_eq_add_one] at hi
      exact le_of_not_lt hi","error:  function expected at
  Algebra.IsIntegral.of_finite K L
term has type
  Algebra.IsIntegral K L","lemma traceForm_dualSubmodule_adjoin
    {x : L} (hx : Algebra.adjoin K {x} = âŠ¤) (hAx : IsIntegral A x) :
    (traceForm K L).dualSubmodule (Subalgebra.toSubmodule (Algebra.adjoin A {x})) =
      (aeval x (derivative <| minpoly K x) : L)â»Â¹ â€¢
        (Subalgebra.toSubmodule (Algebra.adjoin A {x})) ",":= by
  classical
  have hKx : IsIntegral K x := Algebra.IsIntegral.isIntegral x
  let pb := (Algebra.adjoin.powerBasis' hKx).map
    ((Subalgebra.equivOfEq _ _ hx).trans (Subalgebra.topEquiv))
  have pbgen : pb.gen = x := by simp [pb]
  have hpb : â‡‘(LinearMap.BilinForm.dualBasis (traceForm K L) _ pb.basis) = _ :=
    _root_.funext (traceForm_dualBasis_powerBasis_eq pb)
  have : (Subalgebra.toSubmodule (Algebra.adjoin A {x})) =
      Submodule.span A (Set.range pb.basis) := by
    rw [â† span_range_natDegree_eq_adjoin (minpoly.monic hAx) (minpoly.aeval _ _)]
    congr; ext y
    have : natDegree (minpoly A x) = natDegree (minpoly K x) := by
      rw [minpoly.isIntegrallyClosed_eq_field_fractions' K hAx, (minpoly.monic hAx).natDegree_map]
    simp only [Finset.coe_image, Finset.coe_range, Set.mem_image, Set.mem_Iio, Set.mem_range,
      pb.basis_eq_pow, pbgen]
    simp only [PowerBasis.map_dim, adjoin.powerBasis'_dim, this]
    exact âŸ¨fun âŸ¨a, b, câŸ© â†¦ âŸ¨âŸ¨a, bâŸ©, câŸ©, fun âŸ¨âŸ¨a, bâŸ©, câŸ© â†¦ âŸ¨a, b, câŸ©âŸ©
  clear_value pb
  conv_lhs => rw [this]
  rw [â† span_coeff_minpolyDiv hAx, LinearMap.BilinForm.dualSubmodule_span_of_basis,
    Submodule.smul_span, hpb]
  show _ = Submodule.span A (_ '' _)
  simp only [â† Set.range_comp, smul_eq_mul, div_eq_inv_mul, pbgen,
    minpolyDiv_eq_of_isIntegrallyClosed K hAx]
  apply le_antisymm <;> rw [Submodule.span_le]
  Â· rintro _ âŸ¨i, rflâŸ©; exact Submodule.subset_span âŸ¨i, rflâŸ©
  Â· rintro _ âŸ¨i, rflâŸ©
    by_cases hi : i < pb.dim
    Â· exact Submodule.subset_span âŸ¨âŸ¨i, hiâŸ©, rflâŸ©
    Â· rw [Function.comp_apply, coeff_eq_zero_of_natDegree_lt, mul_zero]
      Â· exact zero_mem _
      rw [â† pb.natDegree_minpoly, pbgen, â† natDegree_minpolyDiv_succ hKx,
        â† Nat.succ_eq_add_one] at hi
      exact le_of_not_lt hi"
Mathlib/Data/Int/Cast/Lemmas.lean,MonoidWithZeroHom.ext_int,ext_int,93812b0faaaed21290db2b79c325e1dbaecd4dce,":=
  have : f.comp (Int.ofNatHom : â„• â†’+ â„¤) = g.comp (Int.ofNatHom : â„• â†’+ â„¤) := ext_nat' _ _ h1
  have this' : âˆ€ n : â„•, f n = g n := ext_iff.1 this
  ext fun n => match n with
  | (n : â„•) => this' n
  | .negSucc n => eq_on_neg _ _ (this' <| n + 1)",error:  unknown identifier 'ext_iff',theorem ext_int [AddMonoid A] {f g : â„¤ â†’+ A} (h1 : f 1 = g 1) : f = g ,":=
  have : f.comp (Int.ofNatHom : â„• â†’+ â„¤) = g.comp (Int.ofNatHom : â„• â†’+ â„¤) := ext_nat' _ _ h1
  have this' : âˆ€ n : â„•, f n = g n := DFunLike.ext_iff.1 this
  ext fun n => match n with
  | (n : â„•) => this' n
  | .negSucc n => eq_on_neg _ _ (this' <| n + 1)"
Mathlib/RingTheory/Filtration.lean,Ideal.Filtration.Stable.exists_forall_le,Stable.exists_forall_le,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  obtain âŸ¨nâ‚€, hFâŸ© := h
  use nâ‚€
  intro n
  induction' n with n hn
  Â· refine' (F.antitone _).trans e; simp
  Â· rw [Nat.succ_eq_one_add, add_assoc, add_comm, add_comm 1 n, â† hF]
    exact (smul_mono_right _ hn).trans (F'.smul_le _)
    simp","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case h.succ
R M : Type u
instâœÂ² : CommRing R
instâœÂ¹ : AddCommGroup M
instâœ : Module R M
I : Ideal R
F F' : I.Filtration M
h : F.Stable
e : F.N 0 â‰¤ F'.N 0
nâ‚€ : â„•
hF : âˆ€ n â‰¥ nâ‚€, I â€¢ F.N n = F.N (n + 1)
n : â„•
hn : F.N (n + nâ‚€) â‰¤ F'.N n
âŠ¢ F.N (n + 1 + nâ‚€) â‰¤ F'.N (n + 1)","theorem Stable.exists_forall_le (h : F.Stable) (e : F.N 0 â‰¤ F'.N 0) :
    âˆƒ nâ‚€, âˆ€ n, F.N (n + nâ‚€) â‰¤ F'.N n ",":= by
  obtain âŸ¨nâ‚€, hFâŸ© := h
  use nâ‚€
  intro n
  induction' n with n hn
  Â· refine (F.antitone ?_).trans e; simp
  Â· rw [add_right_comm, â† hF]
    Â· exact (smul_mono_right _ hn).trans (F'.smul_le _)
    simp"
Mathlib/Combinatorics/Additive/AP/Three/Behrend.lean,Behrend.roth_lower_bound_explicit,roth_lower_bound_explicit,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  let n := nValue N
  have hn : 0 < (n : â„) := cast_pos.2 (nValue_pos <| hN.trans' <| by norm_num1)
  have hd : 0 < dValue N := dValue_pos (hN.trans' <| by norm_num1)
  have hNâ‚€ : 0 < (N : â„) := cast_pos.2 (hN.trans' <| by norm_num1)
  have hnâ‚‚ : 2 < n := three_le_nValue <| hN.trans' <| by norm_num1
  have : (2 * dValue N - 1) ^ n â‰¤ N := le_N (hN.trans' <| by norm_num1)
  calc
    _ â‰¤ (N ^ (nValue N : â„)â»Â¹ / rexp 1 : â„) ^ (n - 2) / n := ?_
    _ < _ := by gcongr; exacts [(tsub_pos_of_lt hnâ‚‚).ne', bound hN]
    _ â‰¤ rothNumberNat ((2 * dValue N - 1) ^ n) := bound_aux hd.ne' hnâ‚‚.le
    _ â‰¤ rothNumberNat N := mod_cast rothNumberNat.mono this
  rw [â† rpow_natCast, div_rpow (rpow_nonneg hNâ‚€.le _) (exp_pos _).le, â† rpow_mul hNâ‚€.le,
    inv_mul_eq_div, cast_sub hnâ‚‚.le, cast_two, same_sub_div hn.ne', exp_one_rpow,
    div_div, rpow_sub hNâ‚€, rpow_one, div_div, div_eq_mul_inv]
  refine mul_le_mul_of_nonneg_left ?_ (cast_nonneg _)
  rw [mul_inv, mul_inv, â† exp_neg, â† rpow_neg (cast_nonneg _), neg_sub, â† div_eq_mul_inv]
  have : exp (-4 * âˆš(log N)) = exp (-2 * âˆš(log N)) * exp (-2 * âˆš(log N)) := by
    rw [â† exp_add, â† add_mul]
    norm_num
  rw [this]
  refine mul_le_mul ?_ (exp_neg_two_mul_le <| Real.sqrt_pos.2 <| log_pos? _).le (exp_pos _).le <|
      rpow_nonneg (cast_nonneg _) _
  Â· rw [â† le_log_iff_exp_le (rpow_pos_of_pos hNâ‚€ _), log_rpow hNâ‚€, â† le_div_iff, mul_div_assoc,
      div_sqrt, neg_mul, neg_le_neg_iff, div_mul_eq_mul_div, div_le_iff hn]
    Â· exact mul_le_mul_of_nonneg_left (le_ceil _) zero_le_two
    refine Real.sqrt_pos.2 (log_pos ?_)
    rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  Â· rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)","error:  unknown identifier 'log_pos?'
error:  no goals to be solved","theorem roth_lower_bound_explicit (hN : 4096 â‰¤ N) :
    (N : â„) * exp (-4 * âˆš(log N)) < rothNumberNat N ",":= by
  let n := nValue N
  have hn : 0 < (n : â„) := cast_pos.2 (nValue_pos <| hN.trans' <| by norm_num1)
  have hd : 0 < dValue N := dValue_pos (hN.trans' <| by norm_num1)
  have hNâ‚€ : 0 < (N : â„) := cast_pos.2 (hN.trans' <| by norm_num1)
  have hnâ‚‚ : 2 < n := three_le_nValue <| hN.trans' <| by norm_num1
  have : (2 * dValue N - 1) ^ n â‰¤ N := le_N (hN.trans' <| by norm_num1)
  calc
    _ â‰¤ (N ^ (nValue N : â„)â»Â¹ / rexp 1 : â„) ^ (n - 2) / n := ?_
    _ < _ := by gcongr; exacts [(tsub_pos_of_lt hnâ‚‚).ne', bound hN]
    _ â‰¤ rothNumberNat ((2 * dValue N - 1) ^ n) := bound_aux hd.ne' hnâ‚‚.le
    _ â‰¤ rothNumberNat N := mod_cast rothNumberNat.mono this
  rw [â† rpow_natCast, div_rpow (rpow_nonneg hNâ‚€.le _) (exp_pos _).le, â† rpow_mul hNâ‚€.le,
    inv_mul_eq_div, cast_sub hnâ‚‚.le, cast_two, same_sub_div hn.ne', exp_one_rpow,
    div_div, rpow_sub hNâ‚€, rpow_one, div_div, div_eq_mul_inv]
  refine mul_le_mul_of_nonneg_left ?_ (cast_nonneg _)
  rw [mul_inv, mul_inv, â† exp_neg, â† rpow_neg (cast_nonneg _), neg_sub, â† div_eq_mul_inv]
  have : exp (-4 * âˆš(log N)) = exp (-2 * âˆš(log N)) * exp (-2 * âˆš(log N)) := by
    rw [â† exp_add, â† add_mul]
    norm_num
  rw [this]
  refine mul_le_mul ?_ (exp_neg_two_mul_le <| Real.sqrt_pos.2 <| log_pos ?_).le (exp_pos _).le <|
      rpow_nonneg (cast_nonneg _) _
  Â· rw [â† le_log_iff_exp_le (rpow_pos_of_pos hNâ‚€ _), log_rpow hNâ‚€, â† le_div_iff, mul_div_assoc,
      div_sqrt, neg_mul, neg_le_neg_iff, div_mul_eq_mul_div, div_le_iff hn]
    Â· exact mul_le_mul_of_nonneg_left (le_ceil _) zero_le_two
    refine Real.sqrt_pos.2 (log_pos ?_)
    rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)
  Â· rw [one_lt_cast]
    exact hN.trans_lt' (by norm_num1)"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,98e78f90ec6f93268c84b413fdae7dce5cbee0e6,":= by
  inhabit X
  obtain âŸ¨a, haâŸ© : âˆƒ a, IsGLB (range f) a
  exact âŸ¨_, isGLB_ciInf (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).1âŸ©
  obtain âŸ¨b, hbâŸ© : âˆƒ b, IsLUB (range f) b
  exact âŸ¨_, isLUB_ciSup (Real.isBounded_iff_bddBelow_bddAbove.1 f.isBounded_range).2âŸ©
  have hmem : âˆ€ x, f x âˆˆ Icc a b := fun x => âŸ¨ha.1 âŸ¨x, rflâŸ©, hb.1 âŸ¨x, rflâŸ©âŸ©
  have hle : a â‰¤ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  Â· have : âˆ€ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp
    ring
  obtain âŸ¨g, hg_mem, hgfâŸ© : âˆƒ g : Y â†’áµ‡ â„, (âˆ€ y, âˆƒ x, g y âˆˆ Icc (f x) b) âˆ§ g âˆ˜ e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with âŸ¨g, hg_mem, hgfâŸ©
    rcases em (âˆƒ x, f x = a) with (âŸ¨x, rflâŸ© | ha')
    Â· exact âŸ¨g, fun y => âŸ¨x, hg_mem _âŸ©, hgfâŸ©
    have hd : Disjoint (range e âˆª g â»Â¹' Ici c) (g â»Â¹' {a}) := by
      refine' disjoint_union_left.2 âŸ¨_, Disjoint.preimage _ _âŸ©
      Â· rw [Set.disjoint_left]
        rintro _ âŸ¨x, rflâŸ© (rfl : g (e x) = a)
        exact ha' âŸ¨x, (congr_fun hgf x).symmâŸ©
      Â· exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.closed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      âŸ¨dg, dg0, dga, dgmemâŸ©
    replace hgf : âˆ€ x, (g + dg) (e x) = f x
    Â· intro x
      simp [dg0 (Or.inl <| mem_range_self _), â† hgf]
    refine' âŸ¨g + dg, fun y => _, funext hgfâŸ©
    Â· have hay : a < (g + dg) y := by
        rcases(hg_mem y).1.eq_or_lt with (rfl | hlt)
        Â· refine' (lt_add_iff_pos_right _).2 _
          calc
            0 < c - g y := sub_pos.2 hac
            _ = dg y := (dga rfl).symm
        Â· exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
      rcases ha.exists_between hay with âŸ¨_, âŸ¨x, rflâŸ©, _, hxyâŸ©
      refine' âŸ¨x, hxy.le, _âŸ©
      cases' le_total c (g y) with hc hc
      Â· simp [dg0 (Or.inr hc), (hg_mem y).2]
      Â· calc
          g y + dg y â‰¤ c + (c - a) := add_le_add hc (dgmem _).2
          _ = b := by rw [hsub, add_sub_cancel'_right]
  choose xl hxl hgb using hg_mem
  rcases em (âˆƒ x, f x = b) with (âŸ¨x, rflâŸ© | hb')
  Â· exact âŸ¨g, fun y => âŸ¨xl y, x, hxl y, hgb yâŸ©, hgfâŸ©
  have hd : Disjoint (range e âˆª g â»Â¹' Iic c) (g â»Â¹' {b}) := by
    refine' disjoint_union_left.2 âŸ¨_, Disjoint.preimage _ _âŸ©
    Â· rw [Set.disjoint_left]
      rintro _ âŸ¨x, rflâŸ© (rfl : g (e x) = b)
      exact hb' âŸ¨x, (congr_fun hgf x).symmâŸ©
    Â· exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.closed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    âŸ¨dg, dg0, dgb, dgmemâŸ©
  replace hgf : âˆ€ x, (g - dg) (e x) = f x
  Â· intro x
    simp [dg0 (Or.inl <| mem_range_self _), â† hgf]
  refine' âŸ¨g - dg, fun y => _, funext hgfâŸ©
  Â· have hyb : (g - dg) y < b := by
      rcases(hgb y).eq_or_lt with (rfl | hlt)
      Â· refine' (sub_lt_self_iff _).2 _
        calc
          0 < g y - c := sub_pos.2 hcb
          _ = dg y := (dgb rfl).symm
      Â· exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
    rcases hb.exists_between hyb with âŸ¨_, âŸ¨xu, rflâŸ©, hyxu, _âŸ©
    cases' lt_or_le c (g y) with hc hc
    Â· rcases em (a âˆˆ range f) with (âŸ¨x, rflâŸ© | _)
      Â· refine' âŸ¨x, xu, _, hyxu.leâŸ©
        calc
          f x = c - (b - c) := by rw [â† hsub, sub_sub_cancel]
          _ â‰¤ g y - dg y := sub_le_sub hc.le (dgmem _).2
      Â· have hay : a < (g - dg) y := by
          calc
            a = c - (b - c) := by rw [â† hsub, sub_sub_cancel]
            _ < g y - (b - c) := (sub_lt_sub_right hc _)
            _ â‰¤ g y - dg y := sub_le_sub_left (dgmem _).2 _
        rcases ha.exists_between hay with âŸ¨_, âŸ¨x, rflâŸ©, _, hxyâŸ©
        exact âŸ¨x, xu, hxy.le, hyxu.leâŸ©
    Â· refine' âŸ¨xl y, xu, _, hyxu.leâŸ©
      simp [dg0 (Or.inr hc), hxl]","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case intro.intro.inr.intro.intro.intro
X : Type u_1
Y : Type u_2
instâœÂ³ : TopologicalSpace X
instâœÂ² : TopologicalSpace Y
instâœÂ¹ : NormalSpace Y
instâœ : Nonempty X
f : X â†’áµ‡ â„
e : X â†’ Y
he : ClosedEmbedding e
inhabited_h : Inhabited X
a : â„
ha : IsGLB (range â‡‘f) a
b : â„
hb : IsLUB (range â‡‘f) b
hmem : âˆ€ (x : X), f x âˆˆ Icc a b
hle : a â‰¤ b
hlt : a < b
c : â„ := (a + b) / 2
hac : a < c
hcb : c < b
hsub : c - a = b - c
g : Y â†’áµ‡ â„
hg_mem : âˆ€ (y : Y), g y âˆˆ Icc a b
ha' : Â¬âˆƒ x, f x = a
hd : Disjoint (range e âˆª â‡‘g â»Â¹' Ici c) (â‡‘g â»Â¹' {a})
dg : Y â†’áµ‡ â„
dg0 : EqOn (â‡‘dg) (Function.const Y 0) (range e âˆª â‡‘g â»Â¹' Ici c)
dga : EqOn (â‡‘dg) (Function.const Y (c - a)) (â‡‘g â»Â¹' {a})
dgmem : âˆ€ (x : Y), dg x âˆˆ Icc 0 (c - a)
hgf : âˆ€ (x : X), (g + dg) (e x) = f x
âŠ¢ âˆƒ g, (âˆ€ (y : Y), âˆƒ x, g y âˆˆ Icc (f x) b) âˆ§ â‡‘g âˆ˜ e = â‡‘f
error:  unsolved goals
case intro.intro.inr.intro.intro
X : Type u_1
Y : Type u_2
instâœÂ³ : TopologicalSpace X
instâœÂ² : TopologicalSpace Y
instâœÂ¹ : NormalSpace Y
instâœ : Nonempty X
f : X â†’áµ‡ â„
e : X â†’ Y
he : ClosedEmbedding e
inhabited_h : Inhabited X
a : â„
ha : IsGLB (range â‡‘f) a
b : â„
hb : IsLUB (range â‡‘f) b
hmem : âˆ€ (x : X), f x âˆˆ Icc a b
hle : a â‰¤ b
hlt : a < b
c : â„ := (a + b) / 2
hac : a < c
hcb : c < b
hsub : c - a = b - c
g : Y â†’áµ‡ â„
hg_mem : âˆ€ (y : Y), âˆƒ x, g y âˆˆ Icc (f x) b
hgf : â‡‘g âˆ˜ e = â‡‘f
âŠ¢ âˆƒ g, (âˆ€ (y : Y), âˆƒ xâ‚ xâ‚‚, g y âˆˆ Icc (f xâ‚) (f xâ‚‚)) âˆ§ â‡‘g âˆ˜ e = â‡‘f","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X â†’áµ‡ â„)
    {e : X â†’ Y} (he : ClosedEmbedding e) :
    âˆƒ g : Y â†’áµ‡ â„, (âˆ€ y, âˆƒ xâ‚ xâ‚‚, g y âˆˆ Icc (f xâ‚) (f xâ‚‚)) âˆ§ g âˆ˜ e = f ",":= by
  inhabit X
  obtain âŸ¨a, haâŸ© : âˆƒ a, IsGLB (range f) a := âŸ¨_, isGLB_ciInf f.isBounded_range.bddBelowâŸ©
  obtain âŸ¨b, hbâŸ© : âˆƒ b, IsLUB (range f) b := âŸ¨_, isLUB_ciSup f.isBounded_range.bddAboveâŸ©
  have hmem : âˆ€ x, f x âˆˆ Icc a b := fun x => âŸ¨ha.1 âŸ¨x, rflâŸ©, hb.1 âŸ¨x, rflâŸ©âŸ©
  have hle : a â‰¤ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  Â· have : âˆ€ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain âŸ¨g, hg_mem, hgfâŸ© : âˆƒ g : Y â†’áµ‡ â„, (âˆ€ y, âˆƒ x, g y âˆˆ Icc (f x) b) âˆ§ g âˆ˜ e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with âŸ¨g, hg_mem, hgfâŸ©
    rcases em (âˆƒ x, f x = a) with (âŸ¨x, rflâŸ© | ha')
    Â· exact âŸ¨g, fun y => âŸ¨x, hg_mem _âŸ©, hgfâŸ©
    have hd : Disjoint (range e âˆª g â»Â¹' Ici c) (g â»Â¹' {a}) := by
      refine disjoint_union_left.2 âŸ¨?_, Disjoint.preimage _ ?_âŸ©
      Â· rw [Set.disjoint_left]
        rintro _ âŸ¨x, rflâŸ© (rfl : g (e x) = a)
        exact ha' âŸ¨x, (congr_fun hgf x).symmâŸ©
      Â· exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      âŸ¨dg, dg0, dga, dgmemâŸ©
    replace hgf : âˆ€ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), â† hgf]
    refine âŸ¨g + dg, fun y => ?_, funext hgfâŸ©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      Â· refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      Â· exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with âŸ¨_, âŸ¨x, rflâŸ©, _, hxyâŸ©
    refine âŸ¨x, hxy.le, ?_âŸ©
    rcases le_total c (g y) with hc | hc
    Â· simp [dg0 (Or.inr hc), (hg_mem y).2]
    Â· calc
        g y + dg y â‰¤ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (âˆƒ x, f x = b) with (âŸ¨x, rflâŸ© | hb')
  Â· exact âŸ¨g, fun y => âŸ¨xl y, x, hxl y, hgb yâŸ©, hgfâŸ©
  have hd : Disjoint (range e âˆª g â»Â¹' Iic c) (g â»Â¹' {b}) := by
    refine disjoint_union_left.2 âŸ¨?_, Disjoint.preimage _ ?_âŸ©
    Â· rw [Set.disjoint_left]
      rintro _ âŸ¨x, rflâŸ© (rfl : g (e x) = b)
      exact hb' âŸ¨x, (congr_fun hgf x).symmâŸ©
    Â· exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    âŸ¨dg, dg0, dgb, dgmemâŸ©
  replace hgf : âˆ€ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), â† hgf]
  refine âŸ¨g - dg, fun y => ?_, funext hgfâŸ©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    Â· refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    Â· exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with âŸ¨_, âŸ¨xu, rflâŸ©, hyxu, _âŸ©
  cases' lt_or_le c (g y) with hc hc
  Â· rcases em (a âˆˆ range f) with (âŸ¨x, rflâŸ© | _)
    Â· refine âŸ¨x, xu, ?_, hyxu.leâŸ©
      calc
        f x = c - (b - c) := by rw [â† hsub, sub_sub_cancel]
        _ â‰¤ g y - dg y := sub_le_sub hc.le (dgmem _).2
    Â· have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [â† hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ â‰¤ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with âŸ¨_, âŸ¨x, rflâŸ©, _, hxyâŸ©
      exact âŸ¨x, xu, hxy.le, hyxu.leâŸ©
  Â· refine âŸ¨xl y, xu, ?_, hyxu.leâŸ©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/Data/Seq/Computation.lean,Computation.think_bind,think_bind,3c930599229893e1b6a931304cf4efff4a01b172,":= by
  apply dest_eq_think
  simp [bind]",error:  unknown identifier 'dest_eq_think',theorem think_bind (c) (f : Î± â†’ Computation Î²) : bind (think c) f = think (bind c f) ,":=
  destruct_eq_think <| by simp [bind, Bind.f]"
Mathlib/Computability/AkraBazzi/AkraBazzi.lean,AkraBazziRecurrence.tendsto_zero_sumCoeffsExp,tendsto_zero_sumCoeffsExp,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  have hâ‚ : Finset.univ.sum (fun _ : Î± => (0 : â„)) = 0 : = by simp
  rw [â† hâ‚]
  refine tendsto_finset_sum (univ : Finset Î±) (fun i _ => ?_)
  rw [â† mul_zero (a i)]
  refine Tendsto.mul (by simp) <| tendsto_rpow_atTop_of_base_lt_one _ ?_ (R.b_lt_one i)
  have := R.b_pos i
  linarith","error:  unexpected token ':'; expected '|'
error:  unsolved goals
Î± : Type u_1
instâœÂ¹ : Fintype Î±
instâœ : Nonempty Î±
T : â„• â†’ â„
g : â„ â†’ â„
a b : Î± â†’ â„
r : Î± â†’ â„• â†’ â„•
R : AkraBazziRecurrence T g a b r
hâ‚ : âˆ‘ x : Î±, 0 = 0
âŠ¢ Tendsto (fun p â†¦ âˆ‘ i : Î±, a i * b i ^ p) atTop (ğ“ 0)
error:  invalid field notation, function 'AkraBazziRecurrence.tendsto_zero_sumCoeffsExp' does not have argument with type (AkraBazziRecurrence ...) that can be used, it must be explicit or implicit with a unique name","lemma tendsto_zero_sumCoeffsExp : Tendsto (fun (p : â„) => âˆ‘ i, a i * (b i) ^ p) atTop (ğ“ 0) ",":= by
  have hâ‚ : Finset.univ.sum (fun _ : Î± => (0:â„)) = 0 := by simp
  rw [â† hâ‚]
  refine tendsto_finset_sum (univ : Finset Î±) (fun i _ => ?_)
  rw [â† mul_zero (a i)]
  refine Tendsto.mul (by simp) <| tendsto_rpow_atTop_of_base_lt_one _ ?_ (R.b_lt_one i)
  have := R.b_pos i
  linarith"
Mathlib/RingTheory/IntegralClosure.lean,RingHom.IsIntegralElem.of_mul_unit,RingHom.IsIntegralElem.of_mul_unit,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":=
  letI : SMul R S := f.toSMul
  letI : Algebra R S := f.toAlgebra
  IsIntegral.of_mul_unit hr hx","error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  f
has type
  R â†’+* S","theorem RingHom.IsIntegralElem.of_mul_unit (x y : S) (r : R) (hr : f r * y = 1)
    (hx : f.IsIntegralElem (x * y)) : f.IsIntegralElem x ",":=
  letI : Algebra R S := f.toAlgebra
  IsIntegral.of_mul_unit hr hx"
Mathlib/Data/List/Rotate.lean,List.nthLe_rotate',nthLe_rotate',526ab32ac62f3b2a9004d911c7ead5f3468d13ed,":= by
  rw [nthLe_rotate]
  congr
  let m := l.length
  rw [mod_add_mod, add_assoc, add_left_comm, add_comm, add_mod, add_mod _ n]
  cases' (n % m).zero_le.eq_or_lt with hn hn
  Â· simpa [â† hn] using Nat.mod_eq_of_lt hk
  Â· have mpos : 0 < m := k.zero_le.trans_lt hk
    have hm : m - n % m < m := tsub_lt_self mpos hn
    have hn' : n % m < m := Nat.mod_lt _ mpos
    simpa [mod_eq_of_lt hm, tsub_add_cancel_of_le hn'.le] using Nat.mod_eq_of_lt hk","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
error:  unknown identifier 'add_assoc'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.17141
case e_n
Î± : Type u
l : List Î±
n k : â„•
hk : k < l.length
m : â„• := l.length
âŠ¢ (l.length - n % l.length + k + n) % l.length = k
warning:  @IsRotated does not have a doc string","theorem nthLe_rotate' (l : List Î±) (n k : â„•) (hk : k < l.length) :
    (l.rotate n).nthLe ((l.length - n % l.length + k) % l.length)
        ((Nat.mod_lt _ (k.zero_le.trans_lt hk)).trans_le (length_rotate _ _).ge) =
      l.nthLe k hk ",":=
  (get_eq_get_rotate l n âŸ¨k, hkâŸ©).symm"
Mathlib/Probability/ConditionalProbability.lean,ProbabilityTheory.cond_cond_eq_cond_inter,cond_cond_eq_cond_inter,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Î¼ (s âˆ© t)) 0
  Â· have : Î¼ (s âˆ© t âˆ© u) = 0 :=
      le_antisymm (le_trans (measure_mono (Set.inter_subset_left _ _)) hst.le) bot_le
    simp [this, â† Set.inter_assoc]
  Â· have hcs' : Î¼ s â‰  0 :=
      (Î¼.toOuterMeasure.pos_of_subset_ne_zero (Set.inter_subset_left _ _) hst).ne'
    simp [*, hms.inter hmt, cond_apply, â† mul_assoc, â† Set.inter_assoc, ENNReal.mul_inv, mul_comm, â†
      mul_assoc, ENNReal.mul_inv_cancel]","warning:  @cond does not have a doc string
warning:  @cond does not have a doc string
error:  function expected at
  inter_subset_left ?m.28251
term has type
  ?m.28250 âˆˆ ?m.28248
warning:  `MeasureTheory.OuterMeasure.pos_of_subset_ne_zero` has been deprecated, use `MeasureTheory.measure_pos_of_superset` instead
error:  function expected at
  inter_subset_left ?m.30975
term has type
  ?m.30974 âˆˆ ?m.30972
error:  unsolved goals
case h.inr
Î© : Type u_1
Î©' : Type u_2
Î± : Type u_3
m : MeasurableSpace Î©
m' : MeasurableSpace Î©'
Î¼ : Measure Î©
s t : Set Î©
hms : MeasurableSet s
hmt : MeasurableSet t
hcs : Î¼ s â‰  âŠ¤
u : Set Î©
aâœ : MeasurableSet u
hst : Î¼ (s âˆ© t) â‰  0
hcs' : Î¼ s â‰  0
âŠ¢ Î¼ s * Î¼ (s âˆ© t âˆ© u) * (Î¼ s)â»Â¹ * (Î¼ (s âˆ© t))â»Â¹ = Î¼ (s âˆ© t âˆ© u) * (Î¼ (s âˆ© t))â»Â¹","lemma cond_cond_eq_cond_inter' (hms : MeasurableSet s) (hmt : MeasurableSet t) (hcs : Î¼ s â‰  âˆ) :
    Î¼[|s][|t] = Î¼[|s âˆ© t] ",":= by
  ext u
  rw [cond_apply _ hmt, cond_apply _ hms, cond_apply _ hms, cond_apply _ (hms.inter hmt)]
  obtain hst | hst := eq_or_ne (Î¼ (s âˆ© t)) 0
  Â· have : Î¼ (s âˆ© t âˆ© u) = 0 := measure_mono_null Set.inter_subset_left hst
    simp [this, â† Set.inter_assoc]
  Â· have hcs' : Î¼ s â‰  0 :=
      (measure_pos_of_superset Set.inter_subset_left hst).ne'
    simp [*, â† mul_assoc, â† Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,
      mul_right_comm _ _ (Î¼ s)â»Â¹]"
Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Degree.lean,WeierstrassCurve.natDegree_Î¦,natDegree_Î¦,409be1ff4c306030afd38a2641547686c28f2646,":= by
  induction n using Int.negInduction with
  | nat n => exact (W.natDegree_coeff_Î¦_ofNat n).left
  | neg ih => simp only [Î¦_neg, Int.natAbs_neg, ih]","error:  invalid argument, variable is not a proposition or let-declaration
error:  unsolved goals
case neg
R : Type u
instâœ : CommRing R
W : WeierstrassCurve R
ih : â„•
aâœ : (W.Î¦ â†‘ih).natDegree â‰¤ (â†‘ih).natAbs ^ 2
âŠ¢ (W.Î¦ â†‘ih).natDegree â‰¤ (â†‘ih).natAbs ^ 2",lemma natDegree_Î¦_le (n : â„¤) : (W.Î¦ n).natDegree â‰¤ n.natAbs ^ 2 ,":= by
  induction n using Int.negInduction with
  | nat n => exact (W.natDegree_coeff_Î¦_ofNat n).left
  | neg => rwa [Î¦_neg, Int.natAbs_neg]"
Mathlib/Data/Nat/MaxPowDiv.lean,Nat.maxPowDiv.zero,zero,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  dsimp [maxPowDiv]
  rw [maxPowDiv.go_eq]
  simp","warning:  maxPowDiv does not have a doc string
error:  unknown constant 'Nat.maxPowDiv.go_eq'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.2833
n : â„•
âŠ¢ go 0 0 n = 0",theorem zero_base {n : â„•} : maxPowDiv 0 n = 0 ,":= by
  dsimp [maxPowDiv]
  rw [maxPowDiv.go]
  simp"
Mathlib/LinearAlgebra/Charpoly/ToMatrix.lean,LinearMap.charpoly_toMatrix,charpoly_toMatrix,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  let A := toMatrix b b f
  let b' := chooseBasis R M
  let Î¹' := ChooseBasisIndex R M
  let A' := toMatrix b' b' f
  let e := Basis.indexEquiv b b'
  let Ï† := reindexLinearEquiv R R e e
  let Ï†â‚ := reindexLinearEquiv R R e (Equiv.refl Î¹')
  let Ï†â‚‚ := reindexLinearEquiv R R (Equiv.refl Î¹') (Equiv.refl Î¹')
  let Ï†â‚ƒ := reindexLinearEquiv R R (Equiv.refl Î¹') e
  let P := b.toMatrix b'
  let Q := b'.toMatrix b
  have hPQ : C.mapMatrix (Ï†â‚ P) * C.mapMatrix (Ï†â‚ƒ Q) = 1 := by
    rw [RingHom.mapMatrix_apply, RingHom.mapMatrix_apply, â† Matrix.map_mul,
      reindexLinearEquiv_mul R R, Basis.toMatrix_mul_toMatrix_flip,
      reindexLinearEquiv_one, â† RingHom.mapMatrix_apply, RingHom.map_one]
  calc
    A.charpoly = (reindex e e A).charpoly := (charpoly_reindex _ _).symm
    _ = det (scalar Î¹' X - C.mapMatrix (Ï† A)) := rfl
    _ = det (scalar Î¹' X - C.mapMatrix (Ï† (P * A' * Q))) := by
      rw [basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix]
    _ = det (scalar Î¹' X - C.mapMatrix (Ï†â‚ P * Ï†â‚‚ A' * Ï†â‚ƒ Q)) := by
      rw [reindexLinearEquiv_mul, reindexLinearEquiv_mul]
    _ = det (scalar Î¹' X - C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by simp
    _ = det (scalar Î¹' X * C.mapMatrix (Ï†â‚ P) * C.mapMatrix (Ï†â‚ƒ Q) -
          C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [Matrix.mul_assoc ((scalar Î¹') X), hPQ, Matrix.mul_one]
    _ = det (C.mapMatrix (Ï†â‚ P) * scalar Î¹' X * C.mapMatrix (Ï†â‚ƒ Q) -
          C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by simp
    _ = det (C.mapMatrix (Ï†â‚ P) * (scalar Î¹' X - C.mapMatrix A') * C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [â† Matrix.sub_mul, â† Matrix.mul_sub]
    _ = det (C.mapMatrix (Ï†â‚ P)) * det (scalar Î¹' X - C.mapMatrix A') * det (C.mapMatrix (Ï†â‚ƒ Q)) :=
      by rw [det_mul, det_mul]
    _ = det (C.mapMatrix (Ï†â‚ P)) * det (C.mapMatrix (Ï†â‚ƒ Q)) * det (scalar Î¹' X - C.mapMatrix A') :=
      by ring
    _ = det (scalar Î¹' X - C.mapMatrix A') := by
      rw [â† det_mul, hPQ, det_one, one_mul]
    _ = f.charpoly := rfl","error:  unsolved goals
R : Type u_1
M : Type u_2
Mâ‚ : Type u_3
Mâ‚‚ : Type u_4
instâœÂ¹âµ : CommRing R
instâœÂ¹â´ : Nontrivial R
instâœÂ¹Â³ : AddCommGroup M
instâœÂ¹Â² : Module R M
instâœÂ¹Â¹ : Module.Free R M
instâœÂ¹â° : Module.Finite R M
instâœâ¹ : AddCommGroup Mâ‚
instâœâ¸ : Module R Mâ‚
instâœâ· : Module.Finite R Mâ‚
instâœâ¶ : Module.Free R Mâ‚
instâœâµ : AddCommGroup Mâ‚‚
instâœâ´ : Module R Mâ‚‚
instâœÂ³ : Module.Finite R Mâ‚‚
instâœÂ² : Module.Free R Mâ‚‚
f : M â†’â‚—[R] M
Î¹ : Type w
instâœÂ¹ : DecidableEq Î¹
instâœ : Fintype Î¹
b : Basis Î¹ R M
A : Matrix Î¹ Î¹ R := (toMatrix b b) f
b' : Basis (ChooseBasisIndex R M) R M := chooseBasis R M
Î¹' : Type u_2 := ChooseBasisIndex R M
A' : Matrix (ChooseBasisIndex R M) (ChooseBasisIndex R M) R := (toMatrix b' b') f
e : Î¹ â‰ƒ ChooseBasisIndex R M := b.indexEquiv b'
Ï† : Matrix Î¹ Î¹ R â‰ƒâ‚—[R] Matrix (ChooseBasisIndex R M) (ChooseBasisIndex R M) R := reindexLinearEquiv R R e e
Ï†â‚ : Matrix Î¹ Î¹' R â‰ƒâ‚—[R] Matrix (ChooseBasisIndex R M) Î¹' R := reindexLinearEquiv R R e (Equiv.refl Î¹')
Ï†â‚‚ : Matrix Î¹' Î¹' R â‰ƒâ‚—[R] Matrix Î¹' Î¹' R := reindexLinearEquiv R R (Equiv.refl Î¹') (Equiv.refl Î¹')
Ï†â‚ƒ : Matrix Î¹' Î¹ R â‰ƒâ‚—[R] Matrix Î¹' (ChooseBasisIndex R M) R := reindexLinearEquiv R R (Equiv.refl Î¹') e
P : Matrix Î¹ (ChooseBasisIndex R M) R := b.toMatrix â‡‘b'
Q : Matrix (ChooseBasisIndex R M) Î¹ R := b'.toMatrix â‡‘b
hPQ : C.mapMatrix (Ï†â‚ P) * C.mapMatrix (Ï†â‚ƒ Q) = 1
âŠ¢ ((diagonal fun x â†¦ X) - (Ï†â‚ P).map â‡‘C * (Ï†â‚‚ A').map â‡‘C * (Ï†â‚ƒ Q).map â‡‘C).det =
    ((diagonal fun x â†¦ X) - (Ï†â‚ P).map â‡‘C * A'.map â‡‘C * (Ï†â‚ƒ Q).map â‡‘C).det
error:  unsolved goals
R : Type u_1
M : Type u_2
Mâ‚ : Type u_3
Mâ‚‚ : Type u_4
instâœÂ¹âµ : CommRing R
instâœÂ¹â´ : Nontrivial R
instâœÂ¹Â³ : AddCommGroup M
instâœÂ¹Â² : Module R M
instâœÂ¹Â¹ : Module.Free R M
instâœÂ¹â° : Module.Finite R M
instâœâ¹ : AddCommGroup Mâ‚
instâœâ¸ : Module R Mâ‚
instâœâ· : Module.Finite R Mâ‚
instâœâ¶ : Module.Free R Mâ‚
instâœâµ : AddCommGroup Mâ‚‚
instâœâ´ : Module R Mâ‚‚
instâœÂ³ : Module.Finite R Mâ‚‚
instâœÂ² : Module.Free R Mâ‚‚
f : M â†’â‚—[R] M
Î¹ : Type w
instâœÂ¹ : DecidableEq Î¹
instâœ : Fintype Î¹
b : Basis Î¹ R M
A : Matrix Î¹ Î¹ R := (toMatrix b b) f
b' : Basis (ChooseBasisIndex R M) R M := chooseBasis R M
Î¹' : Type u_2 := ChooseBasisIndex R M
A' : Matrix (ChooseBasisIndex R M) (ChooseBasisIndex R M) R := (toMatrix b' b') f
e : Î¹ â‰ƒ ChooseBasisIndex R M := b.indexEquiv b'
Ï† : Matrix Î¹ Î¹ R â‰ƒâ‚—[R] Matrix (ChooseBasisIndex R M) (ChooseBasisIndex R M) R := reindexLinearEquiv R R e e
Ï†â‚ : Matrix Î¹ Î¹' R â‰ƒâ‚—[R] Matrix (ChooseBasisIndex R M) Î¹' R := reindexLinearEquiv R R e (Equiv.refl Î¹')
Ï†â‚‚ : Matrix Î¹' Î¹' R â‰ƒâ‚—[R] Matrix Î¹' Î¹' R := reindexLinearEquiv R R (Equiv.refl Î¹') (Equiv.refl Î¹')
Ï†â‚ƒ : Matrix Î¹' Î¹ R â‰ƒâ‚—[R] Matrix Î¹' (ChooseBasisIndex R M) R := reindexLinearEquiv R R (Equiv.refl Î¹') e
P : Matrix Î¹ (ChooseBasisIndex R M) R := b.toMatrix â‡‘b'
Q : Matrix (ChooseBasisIndex R M) Î¹ R := b'.toMatrix â‡‘b
hPQ : C.mapMatrix (Ï†â‚ P) * C.mapMatrix (Ï†â‚ƒ Q) = 1
âŠ¢ ((diagonal fun x â†¦ X) * (Ï†â‚ P).map â‡‘C * (Ï†â‚ƒ Q).map â‡‘C - (Ï†â‚ P).map â‡‘C * A'.map â‡‘C * (Ï†â‚ƒ Q).map â‡‘C).det =
    (((Ï†â‚ P).map â‡‘C * diagonal fun x â†¦ X) * (Ï†â‚ƒ Q).map â‡‘C - (Ï†â‚ P).map â‡‘C * A'.map â‡‘C * (Ï†â‚ƒ Q).map â‡‘C).det","theorem charpoly_toMatrix {Î¹ : Type w} [DecidableEq Î¹] [Fintype Î¹] (b : Basis Î¹ R M) :
    (toMatrix b b f).charpoly = f.charpoly ",":= by
  let A := toMatrix b b f
  let b' := chooseBasis R M
  let Î¹' := ChooseBasisIndex R M
  let A' := toMatrix b' b' f
  let e := Basis.indexEquiv b b'
  let Ï† := reindexLinearEquiv R R e e
  let Ï†â‚ := reindexLinearEquiv R R e (Equiv.refl Î¹')
  let Ï†â‚‚ := reindexLinearEquiv R R (Equiv.refl Î¹') (Equiv.refl Î¹')
  let Ï†â‚ƒ := reindexLinearEquiv R R (Equiv.refl Î¹') e
  let P := b.toMatrix b'
  let Q := b'.toMatrix b
  have hPQ : C.mapMatrix (Ï†â‚ P) * C.mapMatrix (Ï†â‚ƒ Q) = 1 := by
    rw [RingHom.mapMatrix_apply, RingHom.mapMatrix_apply, â† Matrix.map_mul,
      reindexLinearEquiv_mul R R, Basis.toMatrix_mul_toMatrix_flip,
      reindexLinearEquiv_one, â† RingHom.mapMatrix_apply, RingHom.map_one]
  calc
    A.charpoly = (reindex e e A).charpoly := (charpoly_reindex _ _).symm
    _ = det (scalar Î¹' X - C.mapMatrix (Ï† A)) := rfl
    _ = det (scalar Î¹' X - C.mapMatrix (Ï† (P * A' * Q))) := by
      rw [basis_toMatrix_mul_linearMap_toMatrix_mul_basis_toMatrix]
    _ = det (scalar Î¹' X - C.mapMatrix (Ï†â‚ P * Ï†â‚‚ A' * Ï†â‚ƒ Q)) := by
      rw [reindexLinearEquiv_mul, reindexLinearEquiv_mul]
    _ = det (scalar Î¹' X - C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by simp [Ï†â‚‚]
    _ = det (scalar Î¹' X * C.mapMatrix (Ï†â‚ P) * C.mapMatrix (Ï†â‚ƒ Q) -
          C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [Matrix.mul_assoc ((scalar Î¹') X), hPQ, Matrix.mul_one]
    _ = det (C.mapMatrix (Ï†â‚ P) * scalar Î¹' X * C.mapMatrix (Ï†â‚ƒ Q) -
          C.mapMatrix (Ï†â‚ P) * C.mapMatrix A' * C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [scalar_commute _ commute_X]
    _ = det (C.mapMatrix (Ï†â‚ P) * (scalar Î¹' X - C.mapMatrix A') * C.mapMatrix (Ï†â‚ƒ Q)) := by
      rw [â† Matrix.sub_mul, â† Matrix.mul_sub]
    _ = det (C.mapMatrix (Ï†â‚ P)) * det (scalar Î¹' X - C.mapMatrix A') * det (C.mapMatrix (Ï†â‚ƒ Q)) :=
      by rw [det_mul, det_mul]
    _ = det (C.mapMatrix (Ï†â‚ P)) * det (C.mapMatrix (Ï†â‚ƒ Q)) * det (scalar Î¹' X - C.mapMatrix A') :=
      by ring
    _ = det (scalar Î¹' X - C.mapMatrix A') := by
      rw [â† det_mul, hPQ, det_one, one_mul]
    _ = f.charpoly := rfl"
Mathlib/Algebra/Order/CauSeq/BigOperators.lean,IsCauSeq.of_decreasing_bounded,of_decreasing_bounded,403f0036f3625bbf32f578e4b9f9f7ff5d5648bd,":= fun Îµ Îµ0 â†¦ by
  classical
  let âŸ¨k, hkâŸ© := Archimedean.arch a Îµ0
  have h : âˆƒ l, âˆ€ n â‰¥ m, a - l â€¢ Îµ < f n :=
    âŸ¨k + k + 1, fun n hnm â†¦
      lt_of_lt_of_le (show a - (k + (k + 1)) â€¢ Îµ < -|f n| from
          lt_neg.1 <| (ham n hnm).trans_lt
              (by
                rw [neg_sub, lt_sub_iff_add_lt, add_nsmul, add_nsmul, one_nsmul]
                exact add_lt_add_of_le_of_lt hk (lt_of_le_of_lt hk (lt_add_of_pos_right _ Îµ0))))
        (neg_le.2 <| abs_neg (f n) â–¸ le_abs_self _)âŸ©
  let l := Nat.find h
  have hl : âˆ€ n : â„•, n â‰¥ m â†’ f n > a - l â€¢ Îµ := Nat.find_spec h
  have hl0 : l â‰  0 := fun hl0 â†¦
    not_lt_of_ge (ham m le_rfl)
      (lt_of_lt_of_le (by have := hl m (le_refl m); simpa [hl0] using this) (le_abs_self (f m)))
  cases' not_forall.1 (Nat.find_min h (Nat.pred_lt hl0)) with i hi
  rw [Classical.not_imp, not_lt] at hi
  exists i
  intro j hj
  have hfij : f j â‰¤ f i := (Nat.rel_of_forall_rel_succ_of_le_of_le (Â· â‰¥ Â·) hnm hi.1 hj).le
  rw [abs_of_nonpos (sub_nonpos.2 hfij), neg_sub, sub_lt_iff_lt_add']
  calc
    f i â‰¤ a - Nat.pred l â€¢ Îµ := hi.2
    _ = a - l â€¢ Îµ + Îµ := by
      conv =>
        rhs
        rw [â† Nat.succ_pred_eq_of_pos (Nat.pos_of_ne_zero hl0), succ_nsmul', sub_add,
          add_sub_cancel_right]
    _ < f j + Îµ := add_lt_add_right (hl j (le_trans hi.1 hj)) _","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + ?b - ?b
Î± : Type u_1
Î² : Type u_2
instâœÂ³ : LinearOrderedField Î±
instâœÂ² : Ring Î²
abv : Î² â†’ Î±
instâœÂ¹ : IsAbsoluteValue abv
fâœ g : â„• â†’ Î²
aâœ : â„• â†’ Î±
instâœ : Archimedean Î±
f : â„• â†’ Î±
a : Î±
m : â„•
ham : âˆ€ n â‰¥ m, |f n| â‰¤ a
hnm : âˆ€ n â‰¥ m, f n.succ â‰¤ f n
Îµ : Î±
Îµ0 : Îµ > 0
k : â„•
hk : a â‰¤ k â€¢ Îµ
h : âˆƒ l, âˆ€ n â‰¥ m, a - l â€¢ Îµ < f n
l : â„• := Nat.find h
hl : âˆ€ n â‰¥ m, f n > a - l â€¢ Îµ
hl0 : l â‰  0
i : â„•
hi : i â‰¥ m âˆ§ f i â‰¤ a - (Nat.find h).pred â€¢ Îµ
j : â„•
hj : j â‰¥ i
hfij : f j â‰¤ f i
| a - (Îµ + l.pred â€¢ Îµ - Îµ)","lemma of_decreasing_bounded (f : â„• â†’ Î±) {a : Î±} {m : â„•} (ham : âˆ€ n â‰¥ m, |f n| â‰¤ a)
    (hnm : âˆ€ n â‰¥ m, f n.succ â‰¤ f n) : IsCauSeq abs f ",":= fun Îµ Îµ0 â†¦ by
  classical
  let âŸ¨k, hkâŸ© := Archimedean.arch a Îµ0
  have h : âˆƒ l, âˆ€ n â‰¥ m, a - l â€¢ Îµ < f n :=
    âŸ¨k + k + 1, fun n hnm â†¦
      lt_of_lt_of_le (show a - (k + (k + 1)) â€¢ Îµ < -|f n| from
          lt_neg.1 <| (ham n hnm).trans_lt
              (by
                rw [neg_sub, lt_sub_iff_add_lt, add_nsmul, add_nsmul, one_nsmul]
                exact add_lt_add_of_le_of_lt hk (lt_of_le_of_lt hk (lt_add_of_pos_right _ Îµ0))))
        (neg_le.2 <| abs_neg (f n) â–¸ le_abs_self _)âŸ©
  let l := Nat.find h
  have hl : âˆ€ n : â„•, n â‰¥ m â†’ f n > a - l â€¢ Îµ := Nat.find_spec h
  have hl0 : l â‰  0 := fun hl0 â†¦
    not_lt_of_ge (ham m le_rfl)
      (lt_of_lt_of_le (by have := hl m (le_refl m); simpa [hl0] using this) (le_abs_self (f m)))
  cases' not_forall.1 (Nat.find_min h (Nat.pred_lt hl0)) with i hi
  rw [Classical.not_imp, not_lt] at hi
  exists i
  intro j hj
  have hfij : f j â‰¤ f i := (Nat.rel_of_forall_rel_succ_of_le_of_le (Â· â‰¥ Â·) hnm hi.1 hj).le
  rw [abs_of_nonpos (sub_nonpos.2 hfij), neg_sub, sub_lt_iff_lt_add']
  calc
    f i â‰¤ a - Nat.pred l â€¢ Îµ := hi.2
    _ = a - l â€¢ Îµ + Îµ := by
      conv =>
        rhs
        rw [â† Nat.succ_pred_eq_of_pos (Nat.pos_of_ne_zero hl0), succ_nsmul, sub_add,
          add_sub_cancel_right]
    _ < f j + Îµ := add_lt_add_right (hl j (le_trans hi.1 hj)) _"
Mathlib/RingTheory/PowerSeries/WellKnown.lean,PowerSeries.mk_one_mul_one_sub_eq_one,mk_one_mul_one_sub_eq_one,2ea14b79e1f7e6978b1265a8d41f7a305925875c,":= by
  rw [mul_comm, ext_iff]
  intro n
  cases n with
  | zero => simp [â† coeff_zero_eq_constantCoeff]
  | succ n => simp [sub_mul]","error:  unsolved goals
case zero
S : Type u_1
instâœ : CommRing S
d : â„•
âŠ¢ (coeff S 0) ((1 - X) * mk 1) = 1
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated",theorem mk_one_mul_one_sub_eq_one : (mk 1 : SâŸ¦XâŸ§) * (1 - X) = 1 ,":= by
  rw [mul_comm, ext_iff]
  intro n
  cases n with
  | zero => simp
  | succ n => simp [sub_mul]"
Mathlib/Topology/Algebra/Module/FiniteDimension.lean,LinearMap.continuous_of_isClosed_ker,LinearMap.continuous_of_isClosed_ker,738b1a97e85d528d395f215b4057bad4704e2ceb,":= by
  by_cases H : finrank ğ•œ (LinearMap.range l) = 0
  Â· rw [finrank_eq_zero, LinearMap.range_eq_bot] at H
    rw [H]
    exact continuous_zero
  Â· 
    have : finrank ğ•œ (LinearMap.range l) = 1 :=
      le_antisymm (finrank_self ğ•œ â–¸ l.range.finrank_le) (zero_lt_iff.mpr H)
    have hi : Function.Injective ((LinearMap.ker l).liftQ l (le_refl _)) := by
      rw [â† LinearMap.ker_eq_bot]
      exact Submodule.ker_liftQ_eq_bot _ _ _ (le_refl _)
    have hs : Function.Surjective ((LinearMap.ker l).liftQ l (le_refl _)) := by
      rw [â† LinearMap.range_eq_top, Submodule.range_liftQ]
      exact Submodule.eq_top_of_finrank_eq ((finrank_self ğ•œ).symm â–¸ this)
    let Ï† : (E â§¸ LinearMap.ker l) â‰ƒâ‚—[ğ•œ] ğ•œ :=
      LinearEquiv.ofBijective ((LinearMap.ker l).liftQ l (le_refl _)) âŸ¨hi, hsâŸ©
    have hlÏ† : (l : E â†’ ğ•œ) = Ï† âˆ˜ (LinearMap.ker l).mkQ := by ext; rfl
    suffices Continuous Ï†.toEquiv by
      rw [hlÏ†]
      exact this.comp continuous_quot_mk
    have : induced Ï†.toEquiv.symm inferInstance = hnorm.toUniformSpace.toTopologicalSpace := by
      refine'
        unique_topology_of_t2 (topologicalAddGroup_induced Ï†.symm.toLinearMap)
          (continuousSMul_induced Ï†.symm.toLinearMap) _
      refine (@t2Space_iff ğ•œ (induced (â†‘(LinearEquiv.toEquiv Ï†).symm) inferInstance)).mpr ?_
      exact fun x y hxy =>
        @separated_by_continuous _ _ (induced _ _) _ _ _ continuous_induced_dom _ _
          (Ï†.toEquiv.symm.injective.ne hxy)
    rw [this.symm, Equiv.induced_symm]
    exact continuous_coinduced_rng","error:  unknown identifier 'finrank_eq_zero'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.53282
case pos
ğ•œ : Type u
hnorm : NontriviallyNormedField ğ•œ
E : Type v
instâœÂ¹â´ : AddCommGroup E
instâœÂ¹Â³ : Module ğ•œ E
instâœÂ¹Â² : TopologicalSpace E
instâœÂ¹Â¹ : TopologicalAddGroup E
instâœÂ¹â° : ContinuousSMul ğ•œ E
F : Type w
instâœâ¹ : AddCommGroup F
instâœâ¸ : Module ğ•œ F
instâœâ· : TopologicalSpace F
instâœâ¶ : TopologicalAddGroup F
instâœâµ : ContinuousSMul ğ•œ F
F' : Type x
instâœâ´ : AddCommGroup F'
instâœÂ³ : Module ğ•œ F'
instâœÂ² : TopologicalSpace F'
instâœÂ¹ : TopologicalAddGroup F'
instâœ : ContinuousSMul ğ•œ F'
l : E â†’â‚—[ğ•œ] ğ•œ
hl : IsClosed â†‘(ker l)
H : finrank ğ•œ â†¥(range l) = 0
âŠ¢ Continuous â‡‘l","theorem LinearMap.continuous_of_isClosed_ker (l : E â†’â‚—[ğ•œ] ğ•œ)
    (hl : IsClosed (LinearMap.ker l : Set E)) :
    Continuous l ",":= by
  by_cases H : finrank ğ•œ (LinearMap.range l) = 0
  Â· rw [Submodule.finrank_eq_zero, LinearMap.range_eq_bot] at H
    rw [H]
    exact continuous_zero
  Â· 
    have : finrank ğ•œ (LinearMap.range l) = 1 :=
      le_antisymm (finrank_self ğ•œ â–¸ l.range.finrank_le) (zero_lt_iff.mpr H)
    have hi : Function.Injective ((LinearMap.ker l).liftQ l (le_refl _)) := by
      rw [â† LinearMap.ker_eq_bot]
      exact Submodule.ker_liftQ_eq_bot _ _ _ (le_refl _)
    have hs : Function.Surjective ((LinearMap.ker l).liftQ l (le_refl _)) := by
      rw [â† LinearMap.range_eq_top, Submodule.range_liftQ]
      exact Submodule.eq_top_of_finrank_eq ((finrank_self ğ•œ).symm â–¸ this)
    let Ï† : (E â§¸ LinearMap.ker l) â‰ƒâ‚—[ğ•œ] ğ•œ :=
      LinearEquiv.ofBijective ((LinearMap.ker l).liftQ l (le_refl _)) âŸ¨hi, hsâŸ©
    have hlÏ† : (l : E â†’ ğ•œ) = Ï† âˆ˜ (LinearMap.ker l).mkQ := by ext; rfl
    suffices Continuous Ï†.toEquiv by
      rw [hlÏ†]
      exact this.comp continuous_quot_mk
    have : induced Ï†.toEquiv.symm inferInstance = hnorm.toUniformSpace.toTopologicalSpace := by
      refine unique_topology_of_t2 (topologicalAddGroup_induced Ï†.symm.toLinearMap)
        (continuousSMul_induced Ï†.symm.toLinearMap) ?_
      refine (@t2Space_iff ğ•œ (induced (â†‘(LinearEquiv.toEquiv Ï†).symm) inferInstance)).mpr ?_
      exact fun x y hxy =>
        @separated_by_continuous _ _ (induced _ _) _ _ _ continuous_induced_dom _ _
          (Ï†.toEquiv.symm.injective.ne hxy)
    rw [this.symm, Equiv.induced_symm]
    exact continuous_coinduced_rng"
Mathlib/Topology/Algebra/Order/Compact.lean,ContinuousOn.exists_isMinOn',ContinuousOn.exists_isMinOn',6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  rcases (hasBasis_cocompact.inf_principal _).eventually_iff.1 hc with âŸ¨K, hK, hKfâŸ©
  have hsub : insert xâ‚€ (K âˆ© s) âŠ† s := insert_subset_iff.2 âŸ¨hâ‚€, inter_subset_right _ _âŸ©
  obtain âŸ¨x, hx, hxfâŸ© : âˆƒ x âˆˆ insert xâ‚€ (K âˆ© s), âˆ€ y âˆˆ insert xâ‚€ (K âˆ© s), f x â‰¤ f y :=
    ((hK.inter_right hsc).insert xâ‚€).exists_forall_le (insert_nonempty _ _) (hf.mono hsub)
  refine âŸ¨x, hsub hx, fun y hy => ?_âŸ©
  by_cases hyK : y âˆˆ K
  exacts [hxf _ (Or.inr âŸ¨hyK, hyâŸ©), (hxf _ (Or.inl rfl)).trans (hKf âŸ¨hyK, hyâŸ©)]","error:  function expected at
  inter_subset_right ?m.55165
term has type
  ?m.55164 âˆˆ ?m.55163
warning:  `IsCompact.exists_forall_le` has been deprecated, use `IsCompact.exists_isMinOn` instead","theorem ContinuousOn.exists_isMinOn' [ClosedIicTopology Î±] {s : Set Î²} {f : Î² â†’ Î±}
    (hf : ContinuousOn f s) (hsc : IsClosed s) {xâ‚€ : Î²} (hâ‚€ : xâ‚€ âˆˆ s)
    (hc : âˆ€á¶  x in cocompact Î² âŠ“ ğ“Ÿ s, f xâ‚€ â‰¤ f x) : âˆƒ x âˆˆ s, IsMinOn f s x ",":= by
  rcases (hasBasis_cocompact.inf_principal _).eventually_iff.1 hc with âŸ¨K, hK, hKfâŸ©
  have hsub : insert xâ‚€ (K âˆ© s) âŠ† s := insert_subset_iff.2 âŸ¨hâ‚€, inter_subset_rightâŸ©
  obtain âŸ¨x, hx, hxfâŸ© : âˆƒ x âˆˆ insert xâ‚€ (K âˆ© s), âˆ€ y âˆˆ insert xâ‚€ (K âˆ© s), f x â‰¤ f y :=
    ((hK.inter_right hsc).insert xâ‚€).exists_isMinOn (insert_nonempty _ _) (hf.mono hsub)
  refine âŸ¨x, hsub hx, fun y hy => ?_âŸ©
  by_cases hyK : y âˆˆ K
  exacts [hxf _ (Or.inr âŸ¨hyK, hyâŸ©), (hxf _ (Or.inl rfl)).trans (hKf âŸ¨hyK, hyâŸ©)]"
Mathlib/Data/Nat/Cast/Basic.lean,ext_nat'',ext_nat'',01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  apply FunLike.ext
  rintro (_ | n)
  Â· simp [map_zero f, map_zero g]
  Â· exact h_pos n.succ_pos",error:  unknown constant 'FunLike.ext',"theorem ext_nat'' [MonoidWithZeroHomClass F â„• A] (f g : F) (h_pos : âˆ€ {n : â„•}, 0 < n â†’ f n = g n) :
    f = g ",":= by
  apply DFunLike.ext
  rintro (_ | n)
  Â· simp [map_zero f, map_zero g]
  Â· exact h_pos n.succ_pos"
Mathlib/NumberTheory/LegendreSymbol/Basic.lean,legendreSym.eq_one_of_sq_sub_mul_sq_eq_zero',eq_one_of_sq_sub_mul_sq_eq_zero',37813bde7720a69944099756f73c55d1905172d0,":= by
  haveI hy : y â‰  0 := by
    rintro rfl
    rw [zero_pow' 2 (by norm_num), MulZeroClass.mul_zero, sub_zero, pow_eq_zero_iff
        (by norm_num : 0 < 2)] at hxy
    exact hx hxy
  exact eq_one_of_sq_sub_mul_sq_eq_zero ha hy hxy","error:  unknown identifier 'zero_pow''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.39709
p : â„•
instâœ : Fact (Nat.Prime p)
a : â„¤
ha : â†‘a â‰  0
x : ZMod p
hx : x â‰  0
hxy : x ^ 2 - â†‘a * 0 ^ 2 = 0
âŠ¢ False","theorem eq_one_of_sq_sub_mul_sq_eq_zero' {p : â„•} [Fact p.Prime] {a : â„¤} (ha : (a : ZMod p) â‰  0)
    {x y : ZMod p} (hx : x â‰  0) (hxy : x ^ 2 - a * y ^ 2 = 0) : legendreSym p a = 1 ",":= by
  haveI hy : y â‰  0 := by
    rintro rfl
    rw [zero_pow two_ne_zero, mul_zero, sub_zero, sq_eq_zero_iff] at hxy
    exact hx hxy
  exact eq_one_of_sq_sub_mul_sq_eq_zero ha hy hxy"
Mathlib/Combinatorics/SetFamily/CauchyDavenport.lean,Finset.min_le_card_mul,Finset.min_le_card_mul,75d413be2ff5a21f77a63ca465194c5159bb22d2,":= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain âŸ¨rfl, rflâŸ© := hx
  refine' wellFoundedOn_devosMulRel.induction (P := fun x : Finset Î± Ã— Finset Î± â†¦
    min (minOrder Î±) â†‘(card x.1 + card x.2 - 1) â‰¤ card (x.1 * x.2)) âŸ¨hs, htâŸ© _
  clear! x
  rintro âŸ¨s, tâŸ© âŸ¨hs, htâŸ© ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  Â· simpa only [â† mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [â† mul_inv_rev, add_comm, card_inv, true_and])
  obtain âŸ¨a, rflâŸ© | âŸ¨a, ha, b, hb, habâŸ© := hs.exists_eq_singleton_or_nontrivial
  Â· simp [add_comm]
  obtain âŸ¨g, hg, hgsâŸ© : âˆƒ g : Î±, g â‰  1 âˆ§ (s âˆ© op g â€¢ s).Nonempty :=
    âŸ¨bâ»Â¹ * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 âŸ¨ha, mem_smul_finset.2 âŸ¨_, hb, by simpâŸ©âŸ©âŸ©
  obtain hsg | hsg := eq_or_ne (op g â€¢ s) s
  Â· have hS : (zpowers g : Set Î±) âŠ† aâ»Â¹ â€¢ (s : Set Î±) := by
      refine forall_mem_zpowers.2 $ @zpow_induction_right _ _ _ (Â· âˆˆ aâ»Â¹ â€¢ (s : Set Î±))
        âŸ¨_, ha, inv_mul_self _âŸ© (fun c hc â†¦ ?_) fun c hc â†¦ ?_
      Â· rw [â† hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      Â· simp only
        rwa [â† op_smul_eq_mul, op_inv, â† Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          â† coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [â† coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s âˆ© op g â€¢ s).card < s.card := card_lt_card âŸ¨inter_subset_left _ _, fun h â†¦
    hsg <| eq_of_superset_of_card_ge (h.trans <| inter_subset_right _ _) (card_smul_finset _ _).leâŸ©
  replace aux1 := card_mono $ mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono $ mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (gâ»Â¹ â€¢ t)
  Â· rw [â† card_smul_finset gâ»Â¹ t]
    refine' Or.inr ((add_le_add_right hst _).trans _)
    rw [â† card_union_eq hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  Â· exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h â†¦ hstg.trans <| h.trans <| add_le_add_right aux1 _
  Â· exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h â†¦
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _","error:  function expected at
  inter_subset_left ?m.46803
term has type
  ?m.46802 âˆˆ ?m.46800
error:  function expected at
  inter_subset_right ?m.46987
term has type
  ?m.46986 âˆˆ ?m.46985
warning:  `Finset.card_union_eq` has been deprecated, use `Finset.card_union_of_disjoint` instead","lemma Finset.min_le_card_mul (hs : s.Nonempty) (ht : t.Nonempty) :
    min (minOrder Î±) â†‘(s.card + t.card - 1) â‰¤ (s * t).card ",":= by
  set x := (s, t) with hx
  clear_value x
  simp only [Prod.ext_iff] at hx
  obtain âŸ¨rfl, rflâŸ© := hx
  refine wellFoundedOn_devosMulRel.induction (P := fun x : Finset Î± Ã— Finset Î± â†¦
    min (minOrder Î±) â†‘(card x.1 + card x.2 - 1) â‰¤ card (x.1 * x.2)) âŸ¨hs, htâŸ© ?_
  clear! x
  rintro âŸ¨s, tâŸ© âŸ¨hs, htâŸ© ih
  simp only [min_le_iff, tsub_le_iff_right, Prod.forall, Set.mem_setOf_eq, and_imp,
    Nat.cast_le] at *
  obtain hts | hst := lt_or_le t.card s.card
  Â· simpa only [â† mul_inv_rev, add_comm, card_inv] using
      ih _ _ ht.inv hs.inv
        (devosMulRel_iff.2 <| Or.inr <| Or.inr <| by
          simpa only [â† mul_inv_rev, add_comm, card_inv, true_and])
  obtain âŸ¨a, rflâŸ© | âŸ¨a, ha, b, hb, habâŸ© := hs.exists_eq_singleton_or_nontrivial
  Â· simp [add_comm]
  obtain âŸ¨g, hg, hgsâŸ© : âˆƒ g : Î±, g â‰  1 âˆ§ (s âˆ© op g â€¢ s).Nonempty :=
    âŸ¨bâ»Â¹ * a, inv_mul_eq_one.not.2 hab.symm, _,
      mem_inter.2 âŸ¨ha, mem_smul_finset.2 âŸ¨_, hb, by simpâŸ©âŸ©âŸ©
  obtain hsg | hsg := eq_or_ne (op g â€¢ s) s
  Â· have hS : (zpowers g : Set Î±) âŠ† aâ»Â¹ â€¢ (s : Set Î±) := by
      refine forall_mem_zpowers.2 <| @zpow_induction_right _ _ _ (Â· âˆˆ aâ»Â¹ â€¢ (s : Set Î±))
        âŸ¨_, ha, inv_mul_self _âŸ© (fun c hc â†¦ ?_) fun c hc â†¦ ?_
      Â· rw [â† hsg, coe_smul_finset, smul_comm]
        exact Set.smul_mem_smul_set hc
      Â· simp only
        rwa [â† op_smul_eq_mul, op_inv, â† Set.mem_smul_set_iff_inv_smul_mem, smul_comm,
          â† coe_smul_finset, hsg]
    refine Or.inl ((minOrder_le_natCard (zpowers_ne_bot.2 hg) <|
      s.finite_toSet.smul_set.subset hS).trans <| WithTop.coe_le_coe.2 <|
        ((Nat.card_mono s.finite_toSet.smul_set hS).trans_eq <| ?_).trans <|
          card_le_card_mul_right _ ht)
    rw [â† coe_smul_finset]
    simp [-coe_smul_finset]
  replace hsg : (s âˆ© op g â€¢ s).card < s.card := card_lt_card âŸ¨inter_subset_left, fun h â†¦
    hsg <| eq_of_superset_of_card_ge (h.trans inter_subset_right) (card_smul_finset _ _).leâŸ©
  replace aux1 := card_mono <| mulETransformLeft.fst_mul_snd_subset g (s, t)
  replace aux2 := card_mono <| mulETransformRight.fst_mul_snd_subset g (s, t)
  obtain hgt | hgt := disjoint_or_nonempty_inter t (gâ»Â¹ â€¢ t)
  Â· rw [â† card_smul_finset gâ»Â¹ t]
    refine Or.inr ((add_le_add_right hst _).trans ?_)
    rw [â† card_union_of_disjoint hgt]
    exact (card_le_card_mul_left _ hgs).trans (le_add_of_le_left aux1)
  obtain hstg | hstg := le_or_lt_of_add_le_add (MulETransform.card g (s, t)).ge
  Â· exact (ih _ _ hgs (hgt.mono inter_subset_union) <| devosMulRel_of_le_of_le aux1 hstg hsg).imp
      (WithTop.coe_le_coe.2 aux1).trans' fun h â†¦ hstg.trans <| h.trans <| add_le_add_right aux1 _
  Â· exact (ih _ _ (hgs.mono inter_subset_union) hgt <| devosMulRel_of_le aux2 hstg).imp
      (WithTop.coe_le_coe.2 aux2).trans' fun h â†¦
        hstg.le.trans <| h.trans <| add_le_add_right aux2 _"
Mathlib/Data/String/Lemmas.lean,String.length_eq_list_length,length_eq_list_length,8bc80c91e30d0701ed46f88c2c850cdb47868ec0,:=,error:  unexpected token '@['; expected term,lemma length_eq_list_length (l : List Char) : (String.mk l).length = l.length ,":= by
  simp only [String.length]"
Mathlib/FieldTheory/Finite/Basic.lean,FiniteField.sum_pow_units,sum_pow_units,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  let Ï† : KË£ â†’* K :=
    { toFun := fun x => x ^ i
      map_one' := by simp
      map_mul' := by intros; simp [mul_pow] }
  have : Decidable (Ï† = 1) := by classical infer_instance
  calc (âˆ‘ x : KË£, Ï† x) = if Ï† = 1 then Fintype.card KË£ else 0 := sum_hom_units Ï†
      _ = if q - 1 âˆ£ i then -1 else 0 := by
        suffices q - 1 âˆ£ i â†” Ï† = 1 by
          simp only [this]
          split_ifs; swap
          Â· exact Nat.cast_zero
          Â· rw [Fintype.card_units, Nat.cast_sub,
              cast_card_eq_zero, Nat.cast_one, zero_sub]
            show 1 â‰¤ q; exact Fintype.card_pos_iff.mpr âŸ¨0âŸ©
        rw [â† forall_pow_eq_one_iff, FunLike.ext_iff]
        apply forall_congr'; intro x; simp [Units.ext_iff]","error:  unknown constant 'FunLike.ext_iff'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.99619
K : Type u_1
R : Type u_2
instâœÂ² : Field K
instâœÂ¹ : Fintype K
instâœ : DecidableEq K
i : â„•
Ï† : KË£ â†’* K := { toFun := fun x â†¦ â†‘x ^ i, map_one' := â‹¯, map_mul' := â‹¯ }
this : Decidable (Ï† = 1)
âŠ¢ (âˆ€ (x : KË£), x ^ i = 1) â†” Ï† = 1","theorem sum_pow_units [DecidableEq K] (i : â„•) :
    (âˆ‘ x : KË£, (x ^ i : K)) = if q - 1 âˆ£ i then -1 else 0 ",":= by
  let Ï† : KË£ â†’* K :=
    { toFun := fun x => x ^ i
      map_one' := by simp
      map_mul' := by intros; simp [mul_pow] }
  have : Decidable (Ï† = 1) := by classical infer_instance
  calc (âˆ‘ x : KË£, Ï† x) = if Ï† = 1 then Fintype.card KË£ else 0 := sum_hom_units Ï†
      _ = if q - 1 âˆ£ i then -1 else 0 := by
        suffices q - 1 âˆ£ i â†” Ï† = 1 by
          simp only [this]
          split_ifs; swap
          Â· exact Nat.cast_zero
          Â· rw [Fintype.card_units, Nat.cast_sub,
              cast_card_eq_zero, Nat.cast_one, zero_sub]
            show 1 â‰¤ q; exact Fintype.card_pos_iff.mpr âŸ¨0âŸ©
        rw [â† forall_pow_eq_one_iff, DFunLike.ext_iff]
        apply forall_congr'; intro x; simp [Ï†, Units.ext_iff]"
Mathlib/Algebra/Order/Group/Abs.lean,abs_add,abs_add,26c28adfd0e2ebe738b1e9e210e7e6f3ad53b9e9,":=
  abs_le.2
    âŸ¨(neg_add |a| |b|).symm â–¸
        add_le_add ((@neg_le Î± ..).2 <| neg_le_abs_self _) ((@neg_le Î± ..).2 <| neg_le_abs_self _),
      add_le_add (le_abs_self _) (le_abs_self _)âŸ©","warning:  @mabs does not have a doc string
error:  unknown identifier 'neg_le_abs_self'
error:  unknown identifier 'neg_le_abs_self'",theorem abs_add (a b : Î±) : |a + b| â‰¤ |a| + |b| ,":=
  abs_le.2
    âŸ¨(neg_add |a| |b|).symm â–¸
        add_le_add ((@neg_le Î± ..).2 <| neg_le_abs _) ((@neg_le Î± ..).2 <| neg_le_abs _),
      add_le_add (le_abs_self _) (le_abs_self _)âŸ©"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.Gamma_eq_GammaAux,Gamma_eq_GammaAux,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have u : âˆ€ k : â„•, GammaAux (âŒŠ1 - s.reâŒ‹â‚Š + k) s = Gamma s := by
    intro k; induction' k with k hk
    Â· simp [Gamma]
    Â· rw [â† hk, Nat.succ_eq_add_one, â† add_assoc]
      refine' (GammaAux_recurrence2 s (âŒŠ1 - s.reâŒ‹â‚Š + k) _).symm
      rw [Nat.cast_add]
      have i0 := Nat.sub_one_lt_floor (1 - s.re)
      simp only [sub_sub_cancel_left] at i0
      refine' lt_add_of_lt_of_nonneg i0 _
      rw [â† Nat.cast_zero, Nat.cast_le]; exact Nat.zero_le k
  convert (u <| n - âŒŠ1 - s.reâŒ‹â‚Š).symm; rw [Nat.add_sub_of_le]
  by_cases h : 0 â‰¤ 1 - s.re
  Â· apply Nat.le_of_lt_succ
    exact_mod_cast lt_of_le_of_lt (Nat.floor_le h) (by linarith : 1 - s.re < n + 1)
  Â· rw [Nat.floor_of_nonpos]
    Â· omega
    Â· linarith","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ
s : â„‚
n : â„•
h1 : -s.re < â†‘n
k : â„•
hk : GammaAux (âŒŠ1 - s.reâŒ‹â‚Š + k) s = Gamma s
âŠ¢ GammaAux (âŒŠ1 - s.reâŒ‹â‚Š + (k + 1)) s = GammaAux (âŒŠ1 - s.reâŒ‹â‚Š + k) s",theorem Gamma_eq_GammaAux (s : â„‚) (n : â„•) (h1 : -s.re < â†‘n) : Gamma s = GammaAux n s ,":= by
  have u : âˆ€ k : â„•, GammaAux (âŒŠ1 - s.reâŒ‹â‚Š + k) s = Gamma s := by
    intro k; induction' k with k hk
    Â· simp [Gamma]
    Â· rw [â† hk, â† add_assoc]
      refine (GammaAux_recurrence2 s (âŒŠ1 - s.reâŒ‹â‚Š + k) ?_).symm
      rw [Nat.cast_add]
      have i0 := Nat.sub_one_lt_floor (1 - s.re)
      simp only [sub_sub_cancel_left] at i0
      refine lt_add_of_lt_of_nonneg i0 ?_
      rw [â† Nat.cast_zero, Nat.cast_le]; exact Nat.zero_le k
  convert (u <| n - âŒŠ1 - s.reâŒ‹â‚Š).symm; rw [Nat.add_sub_of_le]
  by_cases h : 0 â‰¤ 1 - s.re
  Â· apply Nat.le_of_lt_succ
    exact_mod_cast lt_of_le_of_lt (Nat.floor_le h) (by linarith : 1 - s.re < n + 1)
  Â· rw [Nat.floor_of_nonpos]
    Â· omega
    Â· linarith"
Mathlib/Topology/MetricSpace/CantorScheme.lean,CantorScheme.Disjoint.map_injective,Disjoint.map_injective,67a30f55cabb8ddd087043d4900eb7947be27d10,":= by
  rintro âŸ¨x, hxâŸ© âŸ¨y, hyâŸ© hxy
  refine' Subtype.coe_injective (res_injective _)
  dsimp
  ext n : 1
  induction' n with n ih; Â· simp
  simp only [res_succ, cons.injEq]
  refine' âŸ¨_, ihâŸ©
  contrapose hA
  simp only [CantorScheme.Disjoint, _root_.Pairwise, Ne.def, not_forall, exists_prop]
  refine' âŸ¨res x n, _, _, hA, _âŸ©
  rw [not_disjoint_iff]
  refine' âŸ¨(inducedMap A).2 âŸ¨x, hxâŸ©, _, _âŸ©
  Â· rw [â† res_succ]
    apply map_mem
  rw [hxy, ih, â† res_succ]
  apply map_mem","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.3547 â†’ ?m.3547 â†’ Prop",theorem Disjoint.map_injective (hA : CantorScheme.Disjoint A) : Injective (inducedMap A).2 ,":= by
  rintro âŸ¨x, hxâŸ© âŸ¨y, hyâŸ© hxy
  refine Subtype.coe_injective (res_injective ?_)
  dsimp
  ext n : 1
  induction' n with n ih; Â· simp
  simp only [res_succ, cons.injEq]
  refine âŸ¨?_, ihâŸ©
  contrapose hA
  simp only [CantorScheme.Disjoint, _root_.Pairwise, Ne, not_forall, exists_prop]
  refine âŸ¨res x n, _, _, hA, ?_âŸ©
  rw [not_disjoint_iff]
  refine âŸ¨(inducedMap A).2 âŸ¨x, hxâŸ©, ?_, ?_âŸ©
  Â· rw [â† res_succ]
    apply map_mem
  rw [hxy, ih, â† res_succ]
  apply map_mem"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exist_disjoint_covering_families,exist_disjoint_covering_families,ad88a031b67d9f51d39379f0e5f82a31c1929202,":= by
  cases isEmpty_or_nonempty Î²
  Â· refine' âŸ¨fun _ => âˆ…, fun _ => pairwiseDisjoint_empty, _âŸ©
    rw [â† image_univ, eq_empty_of_isEmpty (univ : Set Î²)]
    simp
  let p : TauPackage Î² Î± :=
    { q with
      Ï„
      one_lt_tau := hÏ„ }
  let s := fun i : Fin N =>
    â‹ƒ (k : Ordinal.{u}) (_ : k < p.lastStep) (_ : p.color k = i), ({p.index k} : Set Î²)
  refine' âŸ¨s, fun i => _, _âŸ©
  Â· 
    intro x hx y hy x_ne_y
    obtain âŸ¨jx, jx_lt, jxi, rflâŸ© :
      âˆƒ jx : Ordinal, jx < p.lastStep âˆ§ p.color jx = i âˆ§ x = p.index jx := by
      simpa only [exists_prop, mem_iUnion, mem_singleton_iff] using hx
    obtain âŸ¨jy, jy_lt, jyi, rflâŸ© :
      âˆƒ jy : Ordinal, jy < p.lastStep âˆ§ p.color jy = i âˆ§ y = p.index jy := by
      simpa only [exists_prop, mem_iUnion, mem_singleton_iff] using hy
    wlog jxy : jx â‰¤ jy generalizing jx jy
    Â· exact (this jy jy_lt jyi hy jx jx_lt jxi hx x_ne_y.symm (le_of_not_le jxy)).symm
    replace jxy : jx < jy
    Â· rcases lt_or_eq_of_le jxy with (H | rfl); Â· { exact H }; Â· { exact (x_ne_y rfl).elim }
    let A : Set â„• :=
      â‹ƒ (j : { j // j < jy })
        (_ : (closedBall (p.c (p.index j)) (p.r (p.index j)) âˆ©
          closedBall (p.c (p.index jy)) (p.r (p.index jy))).Nonempty),
        {p.color j}
    have color_j : p.color jy = sInf (univ \ A) := by rw [TauPackage.color]
    have h : p.color jy âˆˆ univ \ A := by
      rw [color_j]
      apply csInf_mem
      refine' âŸ¨N, _âŸ©
      simp only [not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff, not_and,
        mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]
      intro k hk _
      exact (p.color_lt (hk.trans jy_lt) hN).ne'
    simp only [not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff, not_and,
      mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk] at h
    specialize h jx jxy
    contrapose! h
    simpa only [jxi, jyi, and_true_iff, eq_self_iff_true, â† not_disjoint_iff_nonempty_inter] using h
  Â· 
    refine' range_subset_iff.2 fun b => _
    obtain âŸ¨a, haâŸ© :
      âˆƒ a : Ordinal, a < p.lastStep âˆ§ dist (p.c b) (p.c (p.index a)) < p.r (p.index a) := by
      simpa only [iUnionUpTo, exists_prop, mem_iUnion, mem_ball, Subtype.exists,
        Subtype.coe_mk] using p.mem_iUnionUpTo_lastStep b
    simp only [exists_prop, mem_iUnion, mem_ball, mem_singleton_iff, biUnion_and', exists_eq_left,
      iUnion_exists, exists_and_left]
    exact âŸ¨âŸ¨p.color a, p.color_lt ha.1 hNâŸ©, a, rfl, haâŸ©","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
Î± : Type u_1
instâœ : MetricSpace Î±
Î² : Type u
N : â„•
Ï„ : â„
hÏ„ : 1 < Ï„
hN : IsEmpty (SatelliteConfig Î± N Ï„)
q : BallPackage Î² Î±
hâœ : Nonempty Î²
p : TauPackage Î² Î± := { toBallPackage := q, Ï„ := Ï„, one_lt_tau := hÏ„ }
s : Fin N â†’ Set Î² := fun i â†¦ â‹ƒ k, â‹ƒ (_ : k < p.lastStep), â‹ƒ (_ : p.color k = â†‘i), {p.index k}
i : Fin N
jx : Ordinal.{u}
jx_lt : jx < p.lastStep
jxi : p.color jx = â†‘i
hx : p.index jx âˆˆ s i
jy : Ordinal.{u}
jy_lt : jy < p.lastStep
jyi : p.color jy = â†‘i
hy : p.index jy âˆˆ s i
x_ne_y : p.index jx â‰  p.index jy
jxy : jx < jy
âŠ¢ (Disjoint on fun j â†¦ closedBall (q.c j) (q.r j)) (p.index jx) (p.index jy)
error:  unsolved goals
case inr.refine'_2
Î± : Type u_1
instâœ : MetricSpace Î±
Î² : Type u
N : â„•
Ï„ : â„
hÏ„ : 1 < Ï„
hN : IsEmpty (SatelliteConfig Î± N Ï„)
q : BallPackage Î² Î±
hâœ : Nonempty Î²
p : TauPackage Î² Î± := { toBallPackage := q, Ï„ := Ï„, one_lt_tau := hÏ„ }
s : Fin N â†’ Set Î² := fun i â†¦ â‹ƒ k, â‹ƒ (_ : k < p.lastStep), â‹ƒ (_ : p.color k = â†‘i), {p.index k}
âŠ¢ range q.c âŠ† â‹ƒ i, â‹ƒ j âˆˆ s i, ball (q.c j) (q.r j)","theorem exist_disjoint_covering_families {N : â„•} {Ï„ : â„} (hÏ„ : 1 < Ï„)
    (hN : IsEmpty (SatelliteConfig Î± N Ï„)) (q : BallPackage Î² Î±) :
    âˆƒ s : Fin N â†’ Set Î²,
      (âˆ€ i : Fin N, (s i).PairwiseDisjoint fun j => closedBall (q.c j) (q.r j)) âˆ§
        range q.c âŠ† â‹ƒ i : Fin N, â‹ƒ j âˆˆ s i, ball (q.c j) (q.r j) ",":= by
  cases isEmpty_or_nonempty Î²
  Â· refine âŸ¨fun _ => âˆ…, fun _ => pairwiseDisjoint_empty, ?_âŸ©
    rw [â† image_univ, eq_empty_of_isEmpty (univ : Set Î²)]
    simp
  let p : TauPackage Î² Î± :=
    { q with
      Ï„
      one_lt_tau := hÏ„ }
  let s := fun i : Fin N =>
    â‹ƒ (k : Ordinal.{u}) (_ : k < p.lastStep) (_ : p.color k = i), ({p.index k} : Set Î²)
  refine âŸ¨s, fun i => ?_, ?_âŸ©
  Â· 
    intro x hx y hy x_ne_y
    obtain âŸ¨jx, jx_lt, jxi, rflâŸ© :
      âˆƒ jx : Ordinal, jx < p.lastStep âˆ§ p.color jx = i âˆ§ x = p.index jx := by
      simpa only [s, exists_prop, mem_iUnion, mem_singleton_iff] using hx
    obtain âŸ¨jy, jy_lt, jyi, rflâŸ© :
      âˆƒ jy : Ordinal, jy < p.lastStep âˆ§ p.color jy = i âˆ§ y = p.index jy := by
      simpa only [s, exists_prop, mem_iUnion, mem_singleton_iff] using hy
    wlog jxy : jx â‰¤ jy generalizing jx jy
    Â· exact (this jy jy_lt jyi hy jx jx_lt jxi hx x_ne_y.symm (le_of_not_le jxy)).symm
    replace jxy : jx < jy := by
      rcases lt_or_eq_of_le jxy with (H | rfl); Â· { exact H }; Â· { exact (x_ne_y rfl).elim }
    let A : Set â„• :=
      â‹ƒ (j : { j // j < jy })
        (_ : (closedBall (p.c (p.index j)) (p.r (p.index j)) âˆ©
          closedBall (p.c (p.index jy)) (p.r (p.index jy))).Nonempty),
        {p.color j}
    have color_j : p.color jy = sInf (univ \ A) := by rw [TauPackage.color]
    have h : p.color jy âˆˆ univ \ A := by
      rw [color_j]
      apply csInf_mem
      refine âŸ¨N, ?_âŸ©
      simp only [A, not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff, not_and,
        mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]
      intro k hk _
      exact (p.color_lt (hk.trans jy_lt) hN).ne'
    simp only [A, not_exists, true_and_iff, exists_prop, mem_iUnion, mem_singleton_iff, not_and,
      mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk] at h
    specialize h jx jxy
    contrapose! h
    simpa only [jxi, jyi, and_true_iff, eq_self_iff_true, â† not_disjoint_iff_nonempty_inter] using h
  Â· 
    refine range_subset_iff.2 fun b => ?_
    obtain âŸ¨a, haâŸ© :
      âˆƒ a : Ordinal, a < p.lastStep âˆ§ dist (p.c b) (p.c (p.index a)) < p.r (p.index a) := by
      simpa only [iUnionUpTo, exists_prop, mem_iUnion, mem_ball, Subtype.exists,
        Subtype.coe_mk] using p.mem_iUnionUpTo_lastStep b
    simp only [s, exists_prop, mem_iUnion, mem_ball, mem_singleton_iff, biUnion_and',
      exists_eq_left, iUnion_exists, exists_and_left]
    exact âŸ¨âŸ¨p.color a, p.color_lt ha.1 hNâŸ©, a, rfl, haâŸ©"
Mathlib/Data/Int/Cast/Lemmas.lean,RingHom.ext_int,ext_int,01d739c14a27d96463129c57bbb1982309f33ea6,":=
  have : f.comp (Int.ofNatHom : â„• â†’+ â„¤) = g.comp (Int.ofNatHom : â„• â†’+ â„¤) := ext_nat' _ _ h1
  have this' : âˆ€ n : â„•, f n = g n := FunLike.ext_iff.1 this
  ext fun n => match n with
  | (n : â„•) => this' n
  | .negSucc n => eq_on_neg _ _ (this' <| n + 1)",error:  unknown constant 'FunLike.ext_iff',theorem ext_int [AddMonoid A] {f g : â„¤ â†’+ A} (h1 : f 1 = g 1) : f = g ,":=
  have : f.comp (Int.ofNatHom : â„• â†’+ â„¤) = g.comp (Int.ofNatHom : â„• â†’+ â„¤) := ext_nat' _ _ h1
  have this' : âˆ€ n : â„•, f n = g n := DFunLike.ext_iff.1 this
  ext fun n => match n with
  | (n : â„•) => this' n
  | .negSucc n => eq_on_neg _ _ (this' <| n + 1)"
Mathlib/GroupTheory/PGroup.lean,IsPGroup.index,index,8c7e2497d6b5ded2cb20ad30538ebffa5560f7a2,":= by
  obtain âŸ¨n, hnâŸ© := iff_card.mp (hG.to_quotient H.normalCore)
  obtain âŸ¨k, _, hk2âŸ© := (Nat.dvd_prime_pow hp.out).mp
    ((congr_arg _ hn).mp (Subgroup.index_dvd_of_le H.normalCore_le))
  exact âŸ¨k, hk2âŸ©","error:  failed to synthesize
  Fintype (G â§¸ H.normalCore)
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  Eq.mp (congr_arg (Dvd.dvd H.index) hn) (Subgroup.index_dvd_of_le (Subgroup.normalCore_le H))
argument
  Subgroup.index_dvd_of_le (Subgroup.normalCore_le H)
has type
  H.index âˆ£ H.normalCore.index : Prop
but is expected to have type
  H.index âˆ£ card (G â§¸ H.normalCore) : Prop","theorem index (H : Subgroup G) [H.FiniteIndex] : âˆƒ n : â„•, H.index = p ^ n ",":= by
  haveI := H.normalCore.fintypeQuotientOfFiniteIndex
  obtain âŸ¨n, hnâŸ© := iff_card.mp (hG.to_quotient H.normalCore)
  obtain âŸ¨k, _, hk2âŸ© :=
    (Nat.dvd_prime_pow hp.out).mp
      ((congr_arg _ (H.normalCore.index_eq_card.trans hn)).mp
        (Subgroup.index_dvd_of_le H.normalCore_le))
  exact âŸ¨k, hk2âŸ©"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.join_nil,join_nil,938069ac7c83a4980c46ca108d9947ab788c12ee,":=
  Seq'.join_nil",error:  unknown identifier 'Seq'.join_nil',theorem join_nil : join nil = (nil : WSeq Î±) ,":=
  Seq.join_nil"
Mathlib/Topology/Algebra/Nonarchimedean/Basic.lean,NonarchimedeanRing.mul_subset,mul_subset,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  let âŸ¨V, HâŸ© :=
    prod_self_subset
      (IsOpen.mem_nhds (IsOpen.preimage continuous_mul U.isOpen)
        (by simpa only [Set.mem_preimage, SetLike.mem_coe, Prod.snd_zero,
            mul_zero] using U.zero_mem))
  use V
  rintro v âŸ¨a, b, ha, hb, hvâŸ©
  have hy := H (Set.mk_mem_prod ha hb)
  simp only [Set.mem_preimage, SetLike.mem_coe, hv] at hy
  rw [SetLike.mem_coe]
  exact hy","error:  application type mismatch
  Set.mk_mem_prod ha
argument
  ha
has type
  R : Type u_1
but is expected to have type
  ?m.15120 âˆˆ â†‘V : Prop
error:  unsolved goals
case h.intro.intro.intro.intro
R : Type u_1
S : Type u_2
instâœâµ : Ring R
instâœâ´ : TopologicalSpace R
instâœÂ³ : NonarchimedeanRing R
instâœÂ² : Ring S
instâœÂ¹ : TopologicalSpace S
instâœ : NonarchimedeanRing S
U V : OpenAddSubgroup R
H : â†‘V Ã—Ë¢ â†‘V âŠ† (fun p â†¦ p.1 * p.2) â»Â¹' â†‘U
v a : R
b : a âˆˆ â†‘V
ha : R
hb : ha âˆˆ â†‘V
hv : (fun x x_1 â†¦ x * x_1) a ha = v
âŠ¢ v âˆˆ â†‘U","theorem mul_subset (U : OpenAddSubgroup R) : âˆƒ V : OpenAddSubgroup R, (V : Set R) * V âŠ† U ",":= by
  let âŸ¨V, HâŸ© := prod_self_subset <| (U.isOpen.preimage continuous_mul).mem_nhds <| by
    simpa only [Set.mem_preimage, Prod.snd_zero, mul_zero] using U.zero_mem
  use V
  rintro v âŸ¨a, ha, b, hb, hvâŸ©
  have hy := H (Set.mk_mem_prod ha hb)
  simp only [Set.mem_preimage, SetLike.mem_coe, hv] at hy
  rw [SetLike.mem_coe]
  exact hy"
Mathlib/Geometry/Euclidean/Angle/Sphere.lean,Affine.Triangle.dist_div_sin_oangle_eq_two_mul_circumradius,dist_div_sin_oangle_eq_two_mul_circumradius,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  Sphere.dist_div_sin_oangle_eq_two_mul_radius (t.mem_circumsphere _) (t.mem_circumsphere _)
    (t.mem_circumsphere _) (t.Independent.injective.ne hâ‚â‚‚) (t.Independent.injective.ne hâ‚â‚ƒ)
    (t.Independent.injective.ne hâ‚‚â‚ƒ)","error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Triangle â„ P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Simplex â„ P 2
error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Triangle â„ P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Simplex â„ P 2
error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Triangle â„ P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Simplex â„ P 2","theorem dist_div_sin_oangle_eq_two_mul_circumradius (t : Triangle â„ P) {iâ‚ iâ‚‚ iâ‚ƒ : Fin 3}
    (hâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ) (hâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ) : dist (t.points iâ‚) (t.points iâ‚ƒ) /
      |Real.Angle.sin (âˆ¡ (t.points iâ‚) (t.points iâ‚‚) (t.points iâ‚ƒ))| = 2 * t.circumradius ",":=
  Sphere.dist_div_sin_oangle_eq_two_mul_radius (t.mem_circumsphere _) (t.mem_circumsphere _)
    (t.mem_circumsphere _) (t.independent.injective.ne hâ‚â‚‚) (t.independent.injective.ne hâ‚â‚ƒ)
    (t.independent.injective.ne hâ‚‚â‚ƒ)"
Mathlib/SetTheory/Ordinal/Topology.lean,Ordinal.mem_closure_tfae,mem_closure_tfae,62c2d6a1d2ffdbe5bcaa653b84d3602a209e4c8c,":= by
  tfae_have : 1 â†’ 2
  Â· simp only [mem_closure_iff_nhdsWithin_neBot, inter_comm s, nhdsWithin_inter', nhds_left_eq_nhds]
    exact id
  tfae_have : 2 â†’ 3
  Â· intro h
    rcases (s âˆ© Iic a).eq_empty_or_nonempty with he | hne
    Â· simp [he] at h
    Â· refine âŸ¨hne, (isLUB_of_mem_closure ?_ h).csSup_eq hneâŸ©
      exact fun x hx => hx.2
  tfae_have : 3 â†’ 4 :=
    fun h => âŸ¨_, inter_subset_left _ _, h.1, bddAbove_Iic.mono (inter_subset_right _ _), h.2âŸ©
  tfae_have : 4 â†’ 5
  Â· rintro âŸ¨t, hts, hne, hbdd, rflâŸ©
    have hlub : IsLUB t (sSup t) := isLUB_csSup hne hbdd
    let âŸ¨y, hytâŸ© := hne
    classical
      refine âŸ¨succ (sSup t), succ_ne_zero _, fun x _ => if x âˆˆ t then x else y, fun x _ => ?_, ?_âŸ©
      Â· simp only
        split_ifs with h <;> exact hts â€¹_â€º
      Â· refine le_antisymm (bsup_le fun x _ => ?_) (csSup_le hne fun x hx => ?_)
        Â· split_ifs <;> exact hlub.1 â€¹_â€º
        Â· refine (if_pos hx).symm.trans_le (le_bsup _ _ <| (hlub.1 hx).trans_lt (lt_succ _))
  tfae_have : 5 â†’ 6
  Â· rintro âŸ¨o, hâ‚€, f, hfs, rflâŸ©
    exact âŸ¨_, out_nonempty_iff_ne_zero.2 hâ‚€, familyOfBFamily o f, fun _ => hfs _ _, rflâŸ©
  tfae_have : 6 â†’ 1
  Â· rintro âŸ¨Î¹, hne, f, hfs, rflâŸ©
    rw [sup, iSup]
    exact closure_mono (range_subset_iff.2 hfs) <| csSup_mem_closure (range_nonempty f)
      (bddAbove_range.{u, u} f)
  tfae_finish",error:  unexpected token ':'; expected numeral,"theorem mem_closure_tfae (a : Ordinal.{u}) (s : Set Ordinal) :
    TFAE [a âˆˆ closure s,
      a âˆˆ closure (s âˆ© Iic a),
      (s âˆ© Iic a).Nonempty âˆ§ sSup (s âˆ© Iic a) = a,
      âˆƒ t, t âŠ† s âˆ§ t.Nonempty âˆ§ BddAbove t âˆ§ sSup t = a,
      âˆƒ (o : Ordinal.{u}), o â‰  0 âˆ§ âˆƒ (f : âˆ€ x < o, Ordinal),
        (âˆ€ x hx, f x hx âˆˆ s) âˆ§ bsup.{u, u} o f = a,
      âˆƒ (Î¹ : Type u), Nonempty Î¹ âˆ§ âˆƒ f : Î¹ â†’ Ordinal, (âˆ€ i, f i âˆˆ s) âˆ§ sup.{u, u} f = a] ",":= by
  tfae_have 1 â†’ 2
  Â· simp only [mem_closure_iff_nhdsWithin_neBot, inter_comm s, nhdsWithin_inter', nhds_left_eq_nhds]
    exact id
  tfae_have 2 â†’ 3
  Â· intro h
    rcases (s âˆ© Iic a).eq_empty_or_nonempty with he | hne
    Â· simp [he] at h
    Â· refine âŸ¨hne, (isLUB_of_mem_closure ?_ h).csSup_eq hneâŸ©
      exact fun x hx => hx.2
  tfae_have 3 â†’ 4
  Â· exact fun h => âŸ¨_, inter_subset_left, h.1, bddAbove_Iic.mono inter_subset_right, h.2âŸ©
  tfae_have 4 â†’ 5
  Â· rintro âŸ¨t, hts, hne, hbdd, rflâŸ©
    have hlub : IsLUB t (sSup t) := isLUB_csSup hne hbdd
    let âŸ¨y, hytâŸ© := hne
    classical
      refine âŸ¨succ (sSup t), succ_ne_zero _, fun x _ => if x âˆˆ t then x else y, fun x _ => ?_, ?_âŸ©
      Â· simp only
        split_ifs with h <;> exact hts â€¹_â€º
      Â· refine le_antisymm (bsup_le fun x _ => ?_) (csSup_le hne fun x hx => ?_)
        Â· split_ifs <;> exact hlub.1 â€¹_â€º
        Â· refine (if_pos hx).symm.trans_le (le_bsup _ _ <| (hlub.1 hx).trans_lt (lt_succ _))
  tfae_have 5 â†’ 6
  Â· rintro âŸ¨o, hâ‚€, f, hfs, rflâŸ©
    exact âŸ¨_, out_nonempty_iff_ne_zero.2 hâ‚€, familyOfBFamily o f, fun _ => hfs _ _, rflâŸ©
  tfae_have 6 â†’ 1
  Â· rintro âŸ¨Î¹, hne, f, hfs, rflâŸ©
    rw [sup, iSup]
    exact closure_mono (range_subset_iff.2 hfs) <| csSup_mem_closure (range_nonempty f)
      (bddAbove_range.{u, u} f)
  tfae_finish"
Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean,isLittleO_zpow_exp_pos_mul_atTop,isLittleO_zpow_exp_pos_mul_atTop,e24d0042f0fd176848590f8a296e5c675237f634,":= by
  simpa only [rpow_int_cast] using isLittleO_rpow_exp_pos_mul_atTop k hb","error:  ambiguous, possible interpretations 
  ENNReal.rpow_int_cast : âˆ€ (x : â„â‰¥0âˆ) (n : â„¤), x ^ â†‘n = x ^ n
  
  Real.rpow_int_cast : âˆ€ (x : â„) (n : â„¤), x ^ â†‘n = x ^ n
error:  type mismatch
  hâœ
has type
  (fun x â†¦ x ^ â†‘k) =o[atTop] fun x â†¦ rexp (b * x) : Prop
but is expected to have type
  (fun x â†¦ x ^ k) =o[atTop] fun x â†¦ rexp (b * x) : Prop","theorem isLittleO_zpow_exp_pos_mul_atTop (k : â„¤) {b : â„} (hb : 0 < b) :
    (fun x : â„ => x ^ k) =o[atTop] fun x => exp (b * x) ",":= by
  simpa only [Real.rpow_intCast] using isLittleO_rpow_exp_pos_mul_atTop k hb"
Mathlib/Computability/PartrecCode.lean,Nat.Partrec.Code.evaln_complete,evaln_complete,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine âŸ¨fun h => ?_, fun âŸ¨k, hâŸ© => evaln_sound hâŸ©
  rsuffices âŸ¨k, hâŸ© : âˆƒ k, x âˆˆ evaln (k + 1) c n
  Â· exact âŸ¨k + 1, hâŸ©
  induction c generalizing n x with simp [eval, evaln, pure, PFun.pure, Seq.seq, Bind.bind] at h âŠ¢
  | pair cf cg hf hg =>
    rcases h with âŸ¨x, hx, y, hy, rflâŸ©
    rcases hf hx with âŸ¨kâ‚, hkâ‚âŸ©; rcases hg hy with âŸ¨kâ‚‚, hkâ‚‚âŸ©
    refine âŸ¨max kâ‚ kâ‚‚, ?_âŸ©
    refine'
      âŸ¨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚, rflâŸ©
  | comp cf cg hf hg =>
    rcases h with âŸ¨y, hy, hxâŸ©
    rcases hg hy with âŸ¨kâ‚, hkâ‚âŸ©; rcases hf hx with âŸ¨kâ‚‚, hkâ‚‚âŸ©
    refine âŸ¨max kâ‚ kâ‚‚, ?_âŸ©
    exact
      âŸ¨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hkâ‚,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚âŸ©
  | prec cf cg hf hg =>
    revert h
    generalize n.unpair.1 = nâ‚; generalize n.unpair.2 = nâ‚‚
    induction' nâ‚‚ with m IH generalizing x n <;> simp
    Â· intro h
      rcases hf h with âŸ¨k, hkâŸ©
      exact âŸ¨_, le_max_left _ _, evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâŸ©
    Â· intro y hy hx
      rcases IH hy with âŸ¨kâ‚, nkâ‚, hkâ‚âŸ©
      rcases hg hx with âŸ¨kâ‚‚, hkâ‚‚âŸ©
      refine
        âŸ¨(max kâ‚ kâ‚‚).succ,
          Nat.le_succ_of_le <| le_max_of_le_left <|
            le_trans (le_max_left _ (Nat.pair nâ‚ m)) nkâ‚, y,
          evaln_mono (Nat.succ_le_succ <| le_max_left _ _) ?_,
          evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_right _ _) hkâ‚‚âŸ©
      simp only [evaln.eq_8, bind, unpaired, unpair_pair, Option.mem_def, Option.bind_eq_some,
        Option.guard_eq_some', exists_and_left, exists_const]
      exact âŸ¨le_trans (le_max_right _ _) nkâ‚, hkâ‚âŸ©
  | rfind' cf hf =>
    rcases h with âŸ¨y, âŸ¨hyâ‚, hyâ‚‚âŸ©, rflâŸ©
    suffices âˆƒ k, y + n.unpair.2 âˆˆ evaln (k + 1) (rfind' cf) (Nat.pair n.unpair.1 n.unpair.2) by
      simpa [evaln, Bind.bind]
    revert hyâ‚ hyâ‚‚
    generalize n.unpair.2 = m
    intro hyâ‚ hyâ‚‚
    induction' y with y IH generalizing m <;> simp [evaln, Bind.bind]
    Â· simp at hyâ‚
      rcases hf hyâ‚ with âŸ¨k, hkâŸ©
      exact âŸ¨_, Nat.le_of_lt_succ <| evaln_bound hk, _, hk, by simpâŸ©
    Â· rcases hyâ‚‚ (Nat.succ_pos _) with âŸ¨a, ha, a0âŸ©
      rcases hf ha with âŸ¨kâ‚, hkâ‚âŸ©
      rcases IH m.succ (by simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using hyâ‚)
          fun {i} hi => by
          simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using
            hyâ‚‚ (Nat.succ_lt_succ hi) with
        âŸ¨kâ‚‚, hkâ‚‚âŸ©
      use (max kâ‚ kâ‚‚).succ
      rw [zero_add] at hkâ‚
      use Nat.le_succ_of_le <| le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚
      use a
      use evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_left _ _) hkâ‚
      simpa [Nat.succ_eq_add_one, a0, -max_eq_left, -max_eq_right, add_comm, add_left_comm] using
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚
  | _ => exact âŸ¨âŸ¨_, le_rflâŸ©, h.symmâŸ©","error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #6 provided
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #4 provided
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #2 provided
error:  tactic 'cases' failed, nested error:
dependent elimination failed, failed to solve equation
  some y =
    match guard (?m.364435 â‰¤ kâ‚), fun a â†¦
      Nat.rec (evaln (kâ‚ + 1) cf nâ‚)
        (fun n n_ih â†¦
          (evaln kâ‚ (cf.prec cg) (Nat.pair nâ‚ n)).bind fun i â†¦ evaln (kâ‚ + 1) cg (Nat.pair nâ‚ (Nat.pair n i)))
        m with
    | Option.none, x => Option.none
    | some a, f => f a
at case Eq.refl
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #4 provided
error:  type mismatch
  le_succ_of_le (le_max_of_le_left (le_of_lt_succ (evaln_bound hkâ‚)))
has type
  Nat.pair (unpair n).1 m â‰¤ (max kâ‚ ?m.381477).succ : Prop
but is expected to have type
  ((guard (Nat.pair (unpair n).1 m â‰¤ (max kâ‚ kâ‚‚).succ)).bind fun a â†¦
      (evaln ((max kâ‚ kâ‚‚).succ + 1) cf (Nat.pair (unpair n).1 m)).bind fun a â†¦
        if a = 0 then some m else evaln (max kâ‚ kâ‚‚).succ cf.rfind' (Nat.pair (unpair n).1 (m + 1))) =
    some (y + 1 + m) : Prop
error:  no goals to be solved
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type with only one constructor 
  â„•
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type with only one constructor 
  â„•
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type with only one constructor 
  â„•
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type with only one constructor 
  â„•","theorem evaln_complete {c n x} : x âˆˆ eval c n â†” âˆƒ k, x âˆˆ evaln k c n ",":= by
  refine âŸ¨fun h => ?_, fun âŸ¨k, hâŸ© => evaln_sound hâŸ©
  rsuffices âŸ¨k, hâŸ© : âˆƒ k, x âˆˆ evaln (k + 1) c n
  Â· exact âŸ¨k + 1, hâŸ©
  induction c generalizing n x with
      simp [eval, evaln, pure, PFun.pure, Seq.seq, Option.bind_eq_some] at h âŠ¢
  | pair cf cg hf hg =>
    rcases h with âŸ¨x, hx, y, hy, rflâŸ©
    rcases hf hx with âŸ¨kâ‚, hkâ‚âŸ©; rcases hg hy with âŸ¨kâ‚‚, hkâ‚‚âŸ©
    refine âŸ¨max kâ‚ kâ‚‚, ?_âŸ©
    refine
      âŸ¨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚, rflâŸ©
  | comp cf cg hf hg =>
    rcases h with âŸ¨y, hy, hxâŸ©
    rcases hg hy with âŸ¨kâ‚, hkâ‚âŸ©; rcases hf hx with âŸ¨kâ‚‚, hkâ‚‚âŸ©
    refine âŸ¨max kâ‚ kâ‚‚, ?_âŸ©
    exact
      âŸ¨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hkâ‚,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚âŸ©
  | prec cf cg hf hg =>
    revert h
    generalize n.unpair.1 = nâ‚; generalize n.unpair.2 = nâ‚‚
    induction' nâ‚‚ with m IH generalizing x n <;> simp [Option.bind_eq_some]
    Â· intro h
      rcases hf h with âŸ¨k, hkâŸ©
      exact âŸ¨_, le_max_left _ _, evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâŸ©
    Â· intro y hy hx
      rcases IH hy with âŸ¨kâ‚, nkâ‚, hkâ‚âŸ©
      rcases hg hx with âŸ¨kâ‚‚, hkâ‚‚âŸ©
      refine
        âŸ¨(max kâ‚ kâ‚‚).succ,
          Nat.le_succ_of_le <| le_max_of_le_left <|
            le_trans (le_max_left _ (Nat.pair nâ‚ m)) nkâ‚, y,
          evaln_mono (Nat.succ_le_succ <| le_max_left _ _) ?_,
          evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_right _ _) hkâ‚‚âŸ©
      simp only [evaln.eq_8, bind, unpaired, unpair_pair, Option.mem_def, Option.bind_eq_some,
        Option.guard_eq_some', exists_and_left, exists_const]
      exact âŸ¨le_trans (le_max_right _ _) nkâ‚, hkâ‚âŸ©
  | rfind' cf hf =>
    rcases h with âŸ¨y, âŸ¨hyâ‚, hyâ‚‚âŸ©, rflâŸ©
    suffices âˆƒ k, y + n.unpair.2 âˆˆ evaln (k + 1) (rfind' cf) (Nat.pair n.unpair.1 n.unpair.2) by
      simpa [evaln, Option.bind_eq_some]
    revert hyâ‚ hyâ‚‚
    generalize n.unpair.2 = m
    intro hyâ‚ hyâ‚‚
    induction' y with y IH generalizing m <;> simp [evaln, Option.bind_eq_some]
    Â· simp at hyâ‚
      rcases hf hyâ‚ with âŸ¨k, hkâŸ©
      exact âŸ¨_, Nat.le_of_lt_succ <| evaln_bound hk, _, hk, by simpâŸ©
    Â· rcases hyâ‚‚ (Nat.succ_pos _) with âŸ¨a, ha, a0âŸ©
      rcases hf ha with âŸ¨kâ‚, hkâ‚âŸ©
      rcases IH m.succ (by simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using hyâ‚)
          fun {i} hi => by
          simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using
            hyâ‚‚ (Nat.succ_lt_succ hi) with
        âŸ¨kâ‚‚, hkâ‚‚âŸ©
      use (max kâ‚ kâ‚‚).succ
      rw [zero_add] at hkâ‚
      use Nat.le_succ_of_le <| le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚
      use a
      use evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_left _ _) hkâ‚
      simpa [Nat.succ_eq_add_one, a0, -max_eq_left, -max_eq_right, add_comm, add_left_comm] using
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚
  | _ => exact âŸ¨âŸ¨_, le_rflâŸ©, h.symmâŸ©"
Mathlib/Analysis/SpecialFunctions/Pow/Real.lean,Complex.norm_natCast_cpow_of_re_ne_zero,norm_natCast_cpow_of_re_ne_zero,5972f1186b2ca6a1d047e1c045628b6e94c2181b,":= by
  rw [norm_eq_abs, â† ofReal_nat_cast, abs_cpow_eq_rpow_re_of_nonneg n.cast_nonneg hs]","error:  unknown identifier 'ofReal_nat_cast'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.64805
n : â„•
s : â„‚
hs : s.re â‰  0
âŠ¢ abs (â†‘n ^ s) = â†‘n ^ s.re","lemma norm_natCast_cpow_of_re_ne_zero (n : â„•) {s : â„‚} (hs : s.re â‰  0) :
    â€–(n : â„‚) ^ sâ€– = (n : â„) ^ (s.re) ",":= by
  rw [norm_eq_abs, â† ofReal_natCast, abs_cpow_eq_rpow_re_of_nonneg n.cast_nonneg hs]"
Mathlib/Analysis/Convex/StoneSeparation.lean,exists_convex_convex_compl_subset,exists_convex_convex_compl_subset,6d1b77e97159c51b0084f053ab93299f39b3a009,":= by
  let S : Set (Set E) := { C | Convex ğ•œ C âˆ§ Disjoint C t }
  obtain âŸ¨C, hC, hsC, hCmaxâŸ© :=
    zorn_subset_nonempty S
      (fun c hcS hc âŸ¨_, _âŸ© =>
        âŸ¨â‹ƒâ‚€ c,
          âŸ¨hc.directedOn.convex_sUnion  fun s hs => (hcS hs).1,
            disjoint_sUnion_left.2 fun c hc => (hcS hc).2âŸ©,
          fun s => subset_sUnion_of_memâŸ©)
      s âŸ¨hs, hstâŸ©
  refine'
    âŸ¨C, hC.1, convex_iff_segment_subset.2 fun x hx y hy z hz hzC => _, hsC, hC.2.subset_compl_leftâŸ©
  suffices h : âˆ€ c âˆˆ Cá¶œ, âˆƒ a âˆˆ C, (segment ğ•œ c a âˆ© t).Nonempty
  Â· obtain âŸ¨p, hp, u, hu, hutâŸ© := h x hx
    obtain âŸ¨q, hq, v, hv, hvtâŸ© := h y hy
    refine'
      not_disjoint_segment_convexHull_triple hz hu hv
        (hC.2.symm.mono (ht.segment_subset hut hvt) <| convexHull_min _ hC.1)
    simpa [insert_subset_iff, hp, hq, singleton_subset_iff.2 hzC]
  rintro c hc
  by_contra' h
  suffices h : Disjoint (convexHull ğ•œ (insert c C)) t
  Â· rw [â†
      hCmax _ âŸ¨convex_convexHull _ _, hâŸ© ((subset_insert _ _).trans <| subset_convexHull _ _)] at hc
    exact hc (subset_convexHull _ _ <| mem_insert _ _)
  rw [convexHull_insert âŸ¨z, hzCâŸ©, convexJoin_singleton_left]
  refine' disjoint_iUnionâ‚‚_left.2 fun a ha => disjoint_iff_inf_le.mpr fun b hb => h a _ âŸ¨b, hbâŸ©
  rwa [â† hC.1.convexHull_eq]",error:  unexpected token 'Â·'; expected 'by' or 'from',"theorem exists_convex_convex_compl_subset (hs : Convex ğ•œ s) (ht : Convex ğ•œ t) (hst : Disjoint s t) :
    âˆƒ C : Set E, Convex ğ•œ C âˆ§ Convex ğ•œ Cá¶œ âˆ§ s âŠ† C âˆ§ t âŠ† Cá¶œ ",":= by
  let S : Set (Set E) := { C | Convex ğ•œ C âˆ§ Disjoint C t }
  obtain âŸ¨C, hC, hsC, hCmaxâŸ© :=
    zorn_subset_nonempty S
      (fun c hcS hc âŸ¨_, _âŸ© =>
        âŸ¨â‹ƒâ‚€ c,
          âŸ¨hc.directedOn.convex_sUnion fun s hs => (hcS hs).1,
            disjoint_sUnion_left.2 fun c hc => (hcS hc).2âŸ©,
          fun s => subset_sUnion_of_memâŸ©)
      s âŸ¨hs, hstâŸ©
  refine
    âŸ¨C, hC.1, convex_iff_segment_subset.2 fun x hx y hy z hz hzC => ?_, hsC, hC.2.subset_compl_leftâŸ©
  suffices h : âˆ€ c âˆˆ Cá¶œ, âˆƒ a âˆˆ C, (segment ğ•œ c a âˆ© t).Nonempty by
    obtain âŸ¨p, hp, u, hu, hutâŸ© := h x hx
    obtain âŸ¨q, hq, v, hv, hvtâŸ© := h y hy
    refine
      not_disjoint_segment_convexHull_triple hz hu hv
        (hC.2.symm.mono (ht.segment_subset hut hvt) <| convexHull_min ?_ hC.1)
    simp [insert_subset_iff, hp, hq, singleton_subset_iff.2 hzC]
  rintro c hc
  by_contra! h
  suffices h : Disjoint (convexHull ğ•œ (insert c C)) t by
    rw [â†
      hCmax _ âŸ¨convex_convexHull _ _, hâŸ© ((subset_insert _ _).trans <| subset_convexHull _ _)] at hc
    exact hc (subset_convexHull _ _ <| mem_insert _ _)
  rw [convexHull_insert âŸ¨z, hzCâŸ©, convexJoin_singleton_left]
  refine disjoint_iUnionâ‚‚_left.2 fun a ha => disjoint_iff_inter_eq_empty.2 (h a ?_)
  rwa [â† hC.1.convexHull_eq]"
Mathlib/Probability/Martingale/Upcrossing.lean,MeasureTheory.Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part,Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part,82ddb54f6cb64f727e412a60ecaa99a9dafaec2a,":= by
  by_cases hab : a < b
  Â· simp_rw [upcrossings]
    have : âˆ€ N, âˆ«â» Ï‰, ENNReal.ofReal ((f N Ï‰ - a)âº) âˆ‚Î¼ = ENNReal.ofReal (âˆ« Ï‰, (f N Ï‰ - a)âº âˆ‚Î¼) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      Â· exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      Â· exact eventually_of_forall fun Ï‰ => LatticeOrderedGroup.pos_nonneg _
    rw [lintegral_iSup']
    Â· simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          âˆ«â» Ï‰, upcrossingsBefore a b f N Ï‰ âˆ‚Î¼ = âˆ«â» Ï‰, â†‘(upcrossingsBefore a b f N Ï‰ : â„â‰¥0) âˆ‚Î¼),
        lintegral_coe_eq_integral, â† ENNReal.ofReal_mul (sub_pos.2 hab).le]
      Â· simp_rw [NNReal.coe_nat_cast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (Î± := â„â‰¥0âˆ) _ N)
      Â· simp only [NNReal.coe_nat_cast, hf.adapted.integrable_upcrossingsBefore hab]
    Â· exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    Â· refine' eventually_of_forall fun Ï‰ N M hNM => _
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM Ï‰
  Â· rw [not_lt, â† sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, zero_mul]
    exact zero_le _","error:  unknown identifier 'LatticeOrderedGroup.pos_nonneg'
warning:  `NNReal.coe_nat_cast` has been deprecated, use `NNReal.coe_natCast` instead
warning:  `NNReal.coe_nat_cast` has been deprecated, use `NNReal.coe_natCast` instead","theorem Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part [IsFiniteMeasure Î¼] (a b : â„)
    (hf : Submartingale f â„± Î¼) : ENNReal.ofReal (b - a) * âˆ«â» Ï‰, upcrossings a b f Ï‰ âˆ‚Î¼ â‰¤
      â¨† N, âˆ«â» Ï‰, ENNReal.ofReal ((f N Ï‰ - a)âº) âˆ‚Î¼ ",":= by
  by_cases hab : a < b
  Â· simp_rw [upcrossings]
    have : âˆ€ N, âˆ«â» Ï‰, ENNReal.ofReal ((f N Ï‰ - a)âº) âˆ‚Î¼ = ENNReal.ofReal (âˆ« Ï‰, (f N Ï‰ - a)âº âˆ‚Î¼) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      Â· exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      Â· exact eventually_of_forall fun Ï‰ => posPart_nonneg _
    rw [lintegral_iSup']
    Â· simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          âˆ«â» Ï‰, upcrossingsBefore a b f N Ï‰ âˆ‚Î¼ = âˆ«â» Ï‰, â†‘(upcrossingsBefore a b f N Ï‰ : â„â‰¥0) âˆ‚Î¼),
        lintegral_coe_eq_integral, â† ENNReal.ofReal_mul (sub_pos.2 hab).le]
      Â· simp_rw [NNReal.coe_natCast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (Î± := â„â‰¥0âˆ) _ N)
      Â· simp only [NNReal.coe_natCast, hf.adapted.integrable_upcrossingsBefore hab]
    Â· exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    Â· filter_upwards with Ï‰ N M hNM
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM Ï‰
  Â· rw [not_lt, â† sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, zero_mul]
    exact zero_le _"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.GammaAux_recurrence1,GammaAux_recurrence1,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' n with n hn generalizing s
  Â· simp only [Nat.zero_eq, CharP.cast_eq_zero, Left.neg_neg_iff] at h1
    dsimp only [GammaAux]; rw [GammaIntegral_add_one h1]
    rw [mul_comm, mul_div_cancel_rightâ‚€]; contrapose! h1; rw [h1]
    simp
  Â· dsimp only [GammaAux]
    have hh1 : -(s + 1).re < n := by
      rw [Nat.succ_eq_add_one, Nat.cast_add, Nat.cast_one] at h1
      rw [add_re, one_re]; linarith
    rw [â† hn (s + 1) hh1]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
n : â„•
hn : âˆ€ (s : â„‚), -s.re < â†‘n â†’ GammaAux n s = GammaAux n (s + 1) / s
s : â„‚
h1 : -s.re < â†‘(n + 1)
âŠ¢ -(s + 1).re < â†‘n","theorem GammaAux_recurrence1 (s : â„‚) (n : â„•) (h1 : -s.re < â†‘n) :
    GammaAux n s = GammaAux n (s + 1) / s ",":= by
  induction' n with n hn generalizing s
  Â· simp only [Nat.zero_eq, CharP.cast_eq_zero, Left.neg_neg_iff] at h1
    dsimp only [GammaAux]; rw [GammaIntegral_add_one h1]
    rw [mul_comm, mul_div_cancel_rightâ‚€]; contrapose! h1; rw [h1]
    simp
  Â· dsimp only [GammaAux]
    have hh1 : -(s + 1).re < n := by
      rw [Nat.cast_add, Nat.cast_one] at h1
      rw [add_re, one_re]; linarith
    rw [â† hn (s + 1) hh1]"
Mathlib/Analysis/Seminorm.lean,Seminorm.closedBall_finset_sup',closedBall_finset_sup',dee5d9343d596781e8ec7749927ce52e2d12df27,":= by
  induction H using Finset.Nonempty.cons_induction with
  | singleton => simp
  | cons _ _ hs ih =>
    rw [Finset.sup'_cons hs, Finset.inf'_cons hs, closedBall_sup]
    simp only [inf_eq_inter, ih]","error:  application type mismatch
  Finset.sup'_cons hs
argument
  hs
has type
  aâœÂ¹ âˆ‰ sâœ : Prop
but is expected to have type
  ?m.581016.Nonempty : Prop
error:  application type mismatch
  Finset.inf'_cons hs
argument
  hs
has type
  aâœÂ¹ âˆ‰ sâœ : Prop
but is expected to have type
  ?m.581364.Nonempty : Prop
error:  unsolved goals
case cons
R : Type u_1
R' : Type u_2
ğ•œ : Type u_3
ğ•œâ‚‚ : Type u_4
ğ•œâ‚ƒ : Type u_5
ğ• : Type u_6
E : Type u_7
Eâ‚‚ : Type u_8
Eâ‚ƒ : Type u_9
F : Type u_10
G : Type u_11
Î¹ : Type u_12
instâœÂ² : SeminormedRing ğ•œ
instâœÂ¹ : AddCommGroup E
instâœ : SMul ğ•œ E
pâœ : Seminorm ğ•œ E
x y : E
râœ : â„
p : Î¹ â†’ Seminorm ğ•œ E
s : Finset Î¹
e : E
r : â„
aâœÂ¹ : Î¹
sâœ : Finset Î¹
hs : aâœÂ¹ âˆ‰ sâœ
ih : sâœ.Nonempty
aâœ : (sâœ.sup' ih p).closedBall e r = sâœ.inf' ih fun i â†¦ (p i).closedBall e r
âŠ¢ (p aâœÂ¹).closedBall e r âˆ© (sâœ.sup' â‹¯ p).closedBall e r =
    (p aâœÂ¹).closedBall e r âˆ© sâœ.inf' â‹¯ fun i â†¦ (p i).closedBall e r","theorem closedBall_finset_sup' (p : Î¹ â†’ Seminorm ğ•œ E) (s : Finset Î¹) (H : s.Nonempty) (e : E)
    (r : â„) : closedBall (s.sup' H p) e r = s.inf' H fun i => closedBall (p i) e r ",":= by
  induction H using Finset.Nonempty.cons_induction with
  | singleton => simp
  | cons _ _ _ hs ih =>
    rw [Finset.sup'_cons hs, Finset.inf'_cons hs, closedBall_sup]
    simp only [inf_eq_inter, ih]"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Complex.partialGamma_add_one,partialGamma_add_one,8eee072d70c12314075443642860b2be6c1b3660,":= by
  rw [partialGamma, partialGamma, add_sub_cancel]
  have F_der_I : âˆ€ x : â„, x âˆˆ Ioo 0 X â†’ HasDerivAt (fun x => (-x).exp * x ^ s : â„ â†’ â„‚)
      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by
    intro x hx
    have d1 : HasDerivAt (fun y : â„ => (-y).exp) (-(-x).exp) x := by
      simpa using (hasDerivAt_neg x).exp
    have d2 : HasDerivAt (fun y : â„ => â†‘y ^ s) (s * x ^ (s - 1)) x := by
      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id â†‘x) ?_
      simpa only [mul_one] using t.comp_ofReal
      simpa only [id.def, ofReal_re, ofReal_im, Ne.def, eq_self_iff_true, not_true, or_false_iff,
        mul_one] using hx.1
    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2
  have cont := (continuous_ofReal.comp continuous_neg.exp).mul (continuous_ofReal_cpow_const hs)
  have der_ible :=
    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)
  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible
  apply_fun fun x : â„‚ => -x at int_eval
  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)
      (Gamma_integrand_deriv_integrable_B hs hX),
    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval
  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]
  simp only [sub_left_inj, add_left_inj]
  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : â„ â†’ â„‚) =
      (fun x => s * (-x).exp * x ^ (s - 1) : â„ â†’ â„‚) := by ext1; ring
  rw [this]
  have t := @integral_const_mul 0 X volume _ _ s fun x : â„ => (-x).exp * x ^ (s - 1)
  dsimp at t ; rw [â† t, ofReal_zero, zero_cpow]
  Â· rw [MulZeroClass.mul_zero, add_zero]; congr 2; ext1; ring
  Â· contrapose! hs; rw [hs, zero_re]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + (?b - ?a)
s : â„‚
hs : 0 < s.re
X : â„
hX : 0 â‰¤ X
âŠ¢ âˆ« (x : â„) in 0 ..X, â†‘(rexp (-x)) * â†‘x ^ (s + 1 - 1) =
    (s * âˆ« (x : â„) in 0 ..X, â†‘(rexp (-x)) * â†‘x ^ (s - 1)) - â†‘(rexp (-X)) * â†‘X ^ s","theorem partialGamma_add_one {s : â„‚} (hs : 0 < s.re) {X : â„} (hX : 0 â‰¤ X) :
    partialGamma (s + 1) X = s * partialGamma s X - (-X).exp * X ^ s ",":= by
  rw [partialGamma, partialGamma, add_sub_cancel_right]
  have F_der_I : âˆ€ x : â„, x âˆˆ Ioo 0 X â†’ HasDerivAt (fun x => (-x).exp * x ^ s : â„ â†’ â„‚)
      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by
    intro x hx
    have d1 : HasDerivAt (fun y : â„ => (-y).exp) (-(-x).exp) x := by
      simpa using (hasDerivAt_neg x).exp
    have d2 : HasDerivAt (fun y : â„ => (y : â„‚) ^ s) (s * x ^ (s - 1)) x := by
      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id â†‘x) ?_
      Â· simpa only [mul_one] using t.comp_ofReal
      Â· exact ofReal_mem_slitPlane.2 hx.1
    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2
  have cont := (continuous_ofReal.comp continuous_neg.rexp).mul (continuous_ofReal_cpow_const hs)
  have der_ible :=
    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)
  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible
  apply_fun fun x : â„‚ => -x at int_eval
  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)
      (Gamma_integrand_deriv_integrable_B hs hX),
    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval
  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]
  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : â„ â†’ â„‚) =
      (fun x => s * (-x).exp * x ^ (s - 1) : â„ â†’ â„‚) := by ext1; ring
  rw [this]
  have t := @integral_const_mul 0 X volume _ _ s fun x : â„ => (-x).exp * x ^ (s - 1)
  rw [â† t, ofReal_zero, zero_cpow]
  Â· rw [mul_zero, add_zero]; congr 2; ext1; ring
  Â· contrapose! hs; rw [hs, zero_re]"
Mathlib/Analysis/Seminorm.lean,Seminorm.balanced_closedBall_zero,balanced_closedBall_zero,0bc9e28b50593c968afd9e45b23586cbdd0008e0,":= by
  rintro a ha x âŸ¨y, hy, hxâŸ©
  rw [mem_closedBall_zero, â† hx, map_smul_eq_mul]
  calc
    _ â‰¤ p y := mul_le_of_le_one_left (map_nonneg p _) ha
    _ â‰¤ r := by rwa [mem_closedBall_zero] at hy","error:  failed to synthesize
  Preorder E
use `set_option diagnostics true` to get diagnostic information",theorem balanced_closedBall_zero (r : â„) : Balanced ğ•œ (closedBall p 0 r) ,":= by
  rintro a ha x âŸ¨y, hy, hxâŸ©
  rw [mem_closedBall_zero, â† hx, map_smul_eq_mul]
  calc
    _ â‰¤ p y := mul_le_of_le_one_left (apply_nonneg p _) ha
    _ â‰¤ r := by rwa [mem_closedBall_zero] at hy"
Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean,Complex.betaIntegral_convergent_left,betaIntegral_convergent_left,051aa73462329fa6f7421c7112a573d135b828c1,":= by
  apply IntervalIntegrable.mul_continuousOn
  Â· refine' intervalIntegral.intervalIntegrable_cpow' _
    rwa [sub_re, one_re, â† zero_sub, sub_lt_sub_iff_right]
  Â· apply ContinuousAt.continuousOn
    intro x hx
    rw [uIcc_of_le (by positivity : (0 : â„) â‰¤ 1 / 2)] at hx
    apply ContinuousAt.cpow
    Â· exact (continuous_const.sub continuous_ofReal).continuousAt
    Â· exact continuousAt_const
    Â· rw [sub_re, one_re, ofReal_re, sub_pos]
      exact Or.inl (hx.2.trans_lt (by norm_num : (1 / 2 : â„) < 1))","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?z - ?w).re
case hg.hcont.h0
u : â„‚
hu : 0 < u.re
v : â„‚
x : â„
hx : x âˆˆ Icc 0 (1 / 2)
âŠ¢ 1 - â†‘x âˆˆ slitPlane","theorem betaIntegral_convergent_left {u : â„‚} (hu : 0 < re u) (v : â„‚) :
    IntervalIntegrable (fun x =>
      (x : â„‚) ^ (u - 1) * (1 - (x : â„‚)) ^ (v - 1) : â„ â†’ â„‚) volume 0 (1 / 2) ",":= by
  apply IntervalIntegrable.mul_continuousOn
  Â· refine intervalIntegral.intervalIntegrable_cpow' ?_
    rwa [sub_re, one_re, â† zero_sub, sub_lt_sub_iff_right]
  Â· apply ContinuousAt.continuousOn
    intro x hx
    rw [uIcc_of_le (by positivity : (0 : â„) â‰¤ 1 / 2)] at hx
    apply ContinuousAt.cpow
    Â· exact (continuous_const.sub continuous_ofReal).continuousAt
    Â· exact continuousAt_const
    Â· norm_cast
      exact ofReal_mem_slitPlane.2 <| by linarith only [hx.2]"
Mathlib/Data/Finset/Prod.lean,Finset.diag_union,diag_union,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  conv_rhs => rw [â† filter_union_filter_neg_eq (fun a => a.1 = a.2) (s Ã—Ë¢ s)]","error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
instâœ : DecidableEq Î±
s t : Finset Î±
x : Î± Ã— Î±
âŠ¢ s.diag âˆª s.offDiag = filter (fun a â†¦ a.1 = a.2) (s Ã—Ë¢ s) âˆª filter (fun a â†¦ Â¬a.1 = a.2) (s Ã—Ë¢ s)",theorem diag_union_offDiag : s.diag âˆª s.offDiag = s Ã—Ë¢ s ,":= by
  conv_rhs => rw [â† filter_union_filter_neg_eq (fun a => a.1 = a.2) (s Ã—Ë¢ s)]
  rfl"
Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean,MvPolynomial.weightedHomogeneousComponent_zero,weightedHomogeneousComponent_zero,b271affacf1fa368c4e879d75cd5aaf54b75b7ed,":= by
  classical
  ext1 d
  rcases Classical.em (d = 0) with (rfl | hd)
  Â· simp only [coeff_weightedHomogeneousComponent, if_pos, map_zero, coeff_zero_C]
  Â· rw [coeff_weightedHomogeneousComponent, if_neg, coeff_C, if_neg (Ne.symm hd)]
    simp only [weightedDegree', LinearMap.toAddMonoidHom_coe, Finsupp.total_apply, Finsupp.sum,
      sum_eq_zero_iff, Finsupp.mem_support_iff, Ne, smul_eq_zero, not_forall, not_or,
      and_self_left, exists_prop]
    simp only [DFunLike.ext_iff, Finsupp.coe_zero, Pi.zero_apply, not_forall] at hd
    obtain âŸ¨i, hiâŸ© := hd
    exact âŸ¨i, hi, hw iâŸ©","error:  unknown identifier 'weightedDegree''
error:  simp made no progress","theorem weightedHomogeneousComponent_zero [NoZeroSMulDivisors â„• M] (hw : âˆ€ i : Ïƒ, w i â‰  0) :
    weightedHomogeneousComponent w 0 Ï† = C (coeff 0 Ï†) ",":= by
  classical
  ext1 d
  rcases Classical.em (d = 0) with (rfl | hd)
  Â· simp only [coeff_weightedHomogeneousComponent, if_pos, map_zero, coeff_zero_C]
  Â· rw [coeff_weightedHomogeneousComponent, if_neg, coeff_C, if_neg (Ne.symm hd)]
    simp only [weightedDegree, LinearMap.toAddMonoidHom_coe, Finsupp.total_apply, Finsupp.sum,
      sum_eq_zero_iff, Finsupp.mem_support_iff, Ne, smul_eq_zero, not_forall, not_or,
      and_self_left, exists_prop]
    simp only [DFunLike.ext_iff, Finsupp.coe_zero, Pi.zero_apply, not_forall] at hd
    obtain âŸ¨i, hiâŸ© := hd
    exact âŸ¨i, hi, hw iâŸ©"
Mathlib/NumberTheory/Pell.lean,Pell.Solutionâ‚.exists_pos_of_not_isSquare,exists_pos_of_not_isSquare,a71231735e55fa1fc4000a42658641f766fde88b,":= by
  obtain âŸ¨x, y, h, hyâŸ© := exists_of_not_isSquare hâ‚€ hd
  refine' âŸ¨mk |x| |y| (by rwa [sq_abs, sq_abs]), _, abs_pos.mpr hyâŸ©
  rw [x_mk, â† one_lt_sq_iff_one_lt_abs, eq_add_of_sub_eq h, lt_add_iff_pos_right]
  exact mul_pos hâ‚€ (sq_pos_of_ne_zero y hy)","error:  application type mismatch
  sq_pos_of_ne_zero y
argument
  y
has type
  â„¤ : Type
but is expected to have type
  ?m.135767 â‰  0 : Prop","theorem exists_pos_of_not_isSquare (hâ‚€ : 0 < d) (hd : Â¬IsSquare d) :
    âˆƒ a : Solutionâ‚ d, 1 < a.x âˆ§ 0 < a.y ",":= by
  obtain âŸ¨x, y, h, hyâŸ© := exists_of_not_isSquare hâ‚€ hd
  refine âŸ¨mk |x| |y| (by rwa [sq_abs, sq_abs]), ?_, abs_pos.mpr hyâŸ©
  rw [x_mk, â† one_lt_sq_iff_one_lt_abs, eq_add_of_sub_eq h, lt_add_iff_pos_right]
  exact mul_pos hâ‚€ (sq_pos_of_ne_zero hy)"
Mathlib/Data/Finsupp/Basic.lean,Finsupp.mapRange.addMonoidHom_id,mapRange.addMonoidHom_id,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.mapRange.addMonoidHom_id",error:  unknown identifier 'DFinsupp.mapRange.addMonoidHom_id',"theorem mapRange.addMonoidHom_id :
    mapRange.addMonoidHom (AddMonoidHom.id M) = AddMonoidHom.id (Î± â†’â‚€ M) ",":=
  AddMonoidHom.ext mapRange_id"
Mathlib/Analysis/SpecificLimits/Normed.lean,Real.summable_pow_div_factorial,Real.summable_pow_div_factorial,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  have A : (0 : â„) < âŒŠâ€–xâ€–âŒ‹â‚Š + 1 := zero_lt_one.trans_le (by simp)
  have B : â€–xâ€– / (âŒŠâ€–xâ€–âŒ‹â‚Š + 1) < 1 := (div_lt_one A).2 (Nat.lt_floor_add_one _)
  suffices âˆ€ n â‰¥ âŒŠâ€–xâ€–âŒ‹â‚Š, â€–x ^ (n + 1) / (n + 1)!â€– â‰¤ â€–xâ€– / (âŒŠâ€–xâ€–âŒ‹â‚Š + 1) * â€–x ^ n / â†‘n !â€– from
    summable_of_ratio_norm_eventually_le B (eventually_atTop.2 âŸ¨âŒŠâ€–xâ€–âŒ‹â‚Š, thisâŸ©)
  intro n hn
  calc
    â€–x ^ (n + 1) / (n + 1)!â€– = â€–xâ€– / (n + 1) * â€–x ^ n / (n !)â€– := by
      rw [_root_.pow_succ, Nat.factorial_succ, Nat.cast_mul, â† _root_.div_mul_div_comm, norm_mul,
        norm_div, Real.norm_coe_nat, Nat.cast_succ]
    _ â‰¤ â€–xâ€– / (âŒŠâ€–xâ€–âŒ‹â‚Š + 1) * â€–x ^ n / (n !)â€– :=
      mul_le_mul_of_nonneg_right
        (div_le_div (norm_nonneg x) (le_refl â€–xâ€–) A (add_le_add (mono_cast hn) (le_refl 1)))
        (norm_nonneg (x ^ n / n !))","warning:  `Real.norm_coe_nat` has been deprecated, use `Real.norm_natCast` instead
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î¹ : Type u_3
x : â„
A : 0 < â†‘âŒŠâ€–xâ€–âŒ‹â‚Š + 1
B : â€–xâ€– / (â†‘âŒŠâ€–xâ€–âŒ‹â‚Š + 1) < 1
n : â„•
hn : n â‰¥ âŒŠâ€–xâ€–âŒ‹â‚Š
âŠ¢ â€–x ^ nâ€– / (â†‘n + 1) * â€–x / â†‘n !â€– = â€–xâ€– / (â†‘n + 1) * â€–x ^ n / â†‘n !â€–",theorem Real.summable_pow_div_factorial (x : â„) : Summable (fun n â†¦ x ^ n / n ! : â„• â†’ â„) ,":= by
  have A : (0 : â„) < âŒŠâ€–xâ€–âŒ‹â‚Š + 1 := zero_lt_one.trans_le (by simp)
  have B : â€–xâ€– / (âŒŠâ€–xâ€–âŒ‹â‚Š + 1) < 1 := (div_lt_one A).2 (Nat.lt_floor_add_one _)
  suffices âˆ€ n â‰¥ âŒŠâ€–xâ€–âŒ‹â‚Š, â€–x ^ (n + 1) / (n + 1)!â€– â‰¤ â€–xâ€– / (âŒŠâ€–xâ€–âŒ‹â‚Š + 1) * â€–x ^ n / â†‘n !â€– from
    summable_of_ratio_norm_eventually_le B (eventually_atTop.2 âŸ¨âŒŠâ€–xâ€–âŒ‹â‚Š, thisâŸ©)
  intro n hn
  calc
    â€–x ^ (n + 1) / (n + 1)!â€– = â€–xâ€– / (n + 1) * â€–x ^ n / (n !)â€– := by
      rw [_root_.pow_succ', Nat.factorial_succ, Nat.cast_mul, â† _root_.div_mul_div_comm, norm_mul,
        norm_div, Real.norm_natCast, Nat.cast_succ]
    _ â‰¤ â€–xâ€– / (âŒŠâ€–xâ€–âŒ‹â‚Š + 1) * â€–x ^ n / (n !)â€– := by gcongr"
Mathlib/Geometry/Manifold/Instances/Sphere.lean,stereoInvFun_ne_north_pole,stereoInvFun_ne_north_pole,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine Subtype.coe_ne_coe.1 ?_
  rw [â† inner_lt_one_iff_real_of_norm_one _ hv]
  Â· have hw : âŸªv, wâŸ«_â„ = 0 := Submodule.mem_orthogonal_singleton_iff_inner_right.mp w.2
    have hw' : (â€–(w : E)â€– ^ 2 + 4)â»Â¹ * (â€–(w : E)â€– ^ 2 - 4) < 1 := by
      refine (inv_mul_lt_iff' ?_).mpr? _
      Â· nlinarith
      linarith
    simpa [real_inner_comm, inner_add_right, inner_smul_right, real_inner_self_eq_norm_mul_norm, hw,
      hv] using hw'
  Â· simpa using stereoInvFunAux_mem hv w.2","error:  invalid field 'mpr?', the environment does not contain 'Iff.mpr?'
  inv_mul_lt_iff' ?m.163258
has type
  ?m.163256â»Â¹ * ?m.163255 < ?m.163257 â†” ?m.163255 < ?m.163257 * ?m.163256
error:  no goals to be solved","theorem stereoInvFun_ne_north_pole (hv : â€–vâ€– = 1) (w : (â„ âˆ™ v)á—®) :
    stereoInvFun hv w â‰  (âŸ¨v, by simp [hv]âŸ© : sphere (0 : E) 1) ",":= by
  refine Subtype.coe_ne_coe.1 ?_
  rw [â† inner_lt_one_iff_real_of_norm_one _ hv]
  Â· have hw : âŸªv, wâŸ«_â„ = 0 := Submodule.mem_orthogonal_singleton_iff_inner_right.mp w.2
    have hw' : (â€–(w : E)â€– ^ 2 + 4)â»Â¹ * (â€–(w : E)â€– ^ 2 - 4) < 1 := by
      refine (inv_mul_lt_iff' ?_).mpr ?_
      Â· nlinarith
      linarith
    simpa [real_inner_comm, inner_add_right, inner_smul_right, real_inner_self_eq_norm_mul_norm, hw,
      hv] using hw'
  Â· simpa using stereoInvFunAux_mem hv w.2"
Mathlib/Analysis/SpecialFunctions/Gaussian/FourierTransform.lean,GaussianFourier.verticalIntegral_norm_le,verticalIntegral_norm_le,10294a2e3306ccd731ec7cbd6a95830a83a9ff94,":= by
  have vert_norm_bound :
    âˆ€ {T : â„},
      0 â‰¤ T â†’
        âˆ€ {c y : â„},
          |y| â‰¤ |c| â†’
            â€–cexp (-b * (T + y * I) ^ 2)â€– â‰¤
              exp (-(b.re * T ^ 2 - (2 : â„) * |b.im| * |c| * T - b.re * c ^ 2)) := by
    intro T hT c y hy
    rw [norm_cexp_neg_mul_sq_add_mul_I b]
    gcongr exp (- (_ - ?_ * _ - _ * ?_))
    Â· (conv_lhs => rw [mul_assoc]); (conv_rhs => rw [mul_assoc])
      gcongr _ * ?_
      refine (le_abs_self _).trans ?_
      rw [abs_mul]
      gcongr
    Â· rwa [sq_le_sq]
  apply (intervalIntegral.norm_integral_le_of_norm_le_const _).trans
  pick_goal 1
  Â· rw [sub_zero]
    conv_lhs => simp only [mul_comm _ |c|]
    conv_rhs =>
      conv =>
        congr
        rw [mul_comm]
      rw [mul_assoc]
  Â· intro y hy
    have absy : |y| â‰¤ |c| := by
      rcases le_or_lt 0 c with (h | h)
      Â· rw [uIoc_of_le h] at hy
        rw [abs_of_nonneg h, abs_of_pos hy.1]
        exact hy.2
      Â· rw [uIoc_of_lt h] at hy
        rw [abs_of_neg h, abs_of_nonpos hy.2, neg_le_neg_iff]
        exact hy.1.le
    rw [norm_mul, Complex.norm_eq_abs, abs_I, one_mul, two_mul]
    refine (norm_sub_le _ _).trans (add_le_add (vert_norm_bound hT absy) ?_)
    rw [â† abs_neg y] at absy
    simpa only [neg_mul, ofReal_neg] using vert_norm_bound hT absy","error:  unknown identifier 'uIoc_of_lt'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.34322
case inr
b : â„‚
hb : 0 < b.re
c T : â„
hT : 0 â‰¤ T
vert_norm_bound :
  âˆ€ {T : â„},
    0 â‰¤ T â†’
      âˆ€ {c y : â„},
        |y| â‰¤ |c| â†’ â€–cexp (-b * (â†‘T + â†‘y * I) ^ 2)â€– â‰¤ rexp (-(b.re * T ^ 2 - 2 * |b.im| * |c| * T - b.re * c ^ 2))
y : â„
hy : y âˆˆ Î™ 0 c
h : c < 0
âŠ¢ |y| â‰¤ |c|","theorem verticalIntegral_norm_le (hb : 0 < b.re) (c : â„) {T : â„} (hT : 0 â‰¤ T) :
    â€–verticalIntegral b c Tâ€– â‰¤
      (2 : â„) * |c| * exp (-(b.re * T ^ 2 - (2 : â„) * |b.im| * |c| * T - b.re * c ^ 2)) ",":= by
  have vert_norm_bound :
    âˆ€ {T : â„},
      0 â‰¤ T â†’
        âˆ€ {c y : â„},
          |y| â‰¤ |c| â†’
            â€–cexp (-b * (T + y * I) ^ 2)â€– â‰¤
              exp (-(b.re * T ^ 2 - (2 : â„) * |b.im| * |c| * T - b.re * c ^ 2)) := by
    intro T hT c y hy
    rw [norm_cexp_neg_mul_sq_add_mul_I b]
    gcongr exp (- (_ - ?_ * _ - _ * ?_))
    Â· (conv_lhs => rw [mul_assoc]); (conv_rhs => rw [mul_assoc])
      gcongr _ * ?_
      refine (le_abs_self _).trans ?_
      rw [abs_mul]
      gcongr
    Â· rwa [sq_le_sq]
  apply (intervalIntegral.norm_integral_le_of_norm_le_const _).trans
  Â· rw [sub_zero]
    conv_lhs => simp only [mul_comm _ |c|]
    conv_rhs =>
      conv =>
        congr
        rw [mul_comm]
      rw [mul_assoc]
  Â· intro y hy
    have absy : |y| â‰¤ |c| := by
      rcases le_or_lt 0 c with (h | h)
      Â· rw [uIoc_of_le h] at hy
        rw [abs_of_nonneg h, abs_of_pos hy.1]
        exact hy.2
      Â· rw [uIoc_of_ge h.le] at hy
        rw [abs_of_neg h, abs_of_nonpos hy.2, neg_le_neg_iff]
        exact hy.1.le
    rw [norm_mul, Complex.norm_eq_abs, abs_I, one_mul, two_mul]
    refine (norm_sub_le _ _).trans (add_le_add (vert_norm_bound hT absy) ?_)
    rw [â† abs_neg y] at absy
    simpa only [neg_mul, ofReal_neg] using vert_norm_bound hT absy"
Mathlib/Topology/ContinuousFunction/FunctionalCalculus.lean,cfcHom_predicate,cfcHom_predicate,f06d21a104fddb864fd2796ab8681a6ff5f9629b,":=
  (ContinuousFunctionalCalculus.exists_cfc_of_predicate.2 a ha).choose_spec.2.2.2 f","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  ContinuousFunctionalCalculus.exists_cfc_of_predicate
has type
  âˆ€ (a : ?m.40142),
    ?m.40143 a â†’
      âˆƒ Ï†,
        ClosedEmbedding â‡‘Ï† âˆ§
          Ï† (ContinuousMap.restrict (spectrum ?m.40141 a) (ContinuousMap.id ?m.40141)) = a âˆ§
            (âˆ€ (f : C(â†‘(spectrum ?m.40141 a), ?m.40141)), spectrum ?m.40141 (Ï† f) = Set.range â‡‘f) âˆ§
              âˆ€ (f : C(â†‘(spectrum ?m.40141 a), ?m.40141)), ?m.40143 (Ï† f)","lemma cfcHom_predicate (f : C(spectrum R a, R)) :
    p (cfcHom ha f) ",":=
  (ContinuousFunctionalCalculus.exists_cfc_of_predicate a ha).choose_spec.2.2.2 f"
Mathlib/GroupTheory/GroupAction/Period.lean,MulAction.period_le_of_fixed,period_le_of_fixed,cef8a766d74101e505f17c2cc18209448b2f6a44,":= by
  rw [period_eq_minimalPeriod]
  rw [fixed_iff_isPeriodicPt] at fixed
  exact Function.IsPeriodicPt.minimalPeriod_le n_pos fixed","error:  unknown identifier 'fixed_iff_isPeriodicPt'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.4071
Î± : Type v
G : Type u
instâœÂ³ : Group G
instâœÂ² : MulAction G Î±
M : Type u
instâœÂ¹ : Monoid M
instâœ : MulAction M Î±
m : M
a : Î±
n : â„•
n_pos : 0 < n
fixed : m ^ n â€¢ a = a
âŠ¢ Function.minimalPeriod (fun x â†¦ m â€¢ x) a â‰¤ n","theorem period_le_of_fixed {m : M} {a : Î±} {n : â„•} (n_pos : 0 < n) (fixed : m ^ n â€¢ a = a) :
    period m a â‰¤ n ",":=
  (isPeriodicPt_smul_iff.mpr fixed).minimalPeriod_le n_pos"
Mathlib/Data/Nat/Factorization/Basic.lean,Nat.factors_count_eq,factors_count_eq,19886c8a65d45c7c65705b7482580bc5741c87a8,":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  Â· simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization, coe_mk, pp, if_true]
  rw [â† PartENat.natCast_inj, padicValNat_def' pp.ne_one hn0,
    UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors pp hn0.ne']
  simp [factors_eq]","error:  unknown identifier 'UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.7120
case inr
a b m nâœ pâœ n p : â„•
hn0 : n > 0
pp : Prime p
âŠ¢ â†‘(count p n.factors) = multiplicity p n",theorem factors_count_eq {n p : â„•} : n.factors.count p = n.factorization p ,":= by
  rcases n.eq_zero_or_pos with (rfl | hn0)
  Â· simp [factorization, count]
  if pp : p.Prime then ?_ else
    rw [count_eq_zero_of_not_mem (mt prime_of_mem_factors pp)]
    simp [factorization, pp]
  simp only [factorization_def _ pp]
  apply _root_.le_antisymm
  Â· rw [le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    exact List.le_count_iff_replicate_sublist.mp le_rfl |>.subperm
  Â· rw [â† Nat.lt_add_one_iff, lt_iff_not_ge, ge_iff_le,
      le_padicValNat_iff_replicate_subperm_factors pp hn0.ne']
    intro h
    have := h.count_le p
    simp at this"
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.Î´_comp_Î´,Î´_comp_Î´,7472132820a806816d92180a5476e45b47a8d68b,":=
  Hom.ext _ _ (OrderHom.ext _ _
  (Fin.succAbove_comp_succ_succAbove_eq_succAbove_castSucc_succAbove_of_le H))",error:  unknown constant 'Fin.succAbove_comp_succ_succAbove_eq_succAbove_castSucc_succAbove_of_le',"theorem Î´_comp_Î´ {n} {i j : Fin (n + 2)} (H : i â‰¤ j) :
    Î´ i â‰« Î´ j.succ = Î´ j â‰« Î´ (Fin.castSucc i) ",":= by
  ext k
  dsimp [Î´, Fin.succAbove]
  rcases i with âŸ¨i, _âŸ©
  rcases j with âŸ¨j, _âŸ©
  rcases k with âŸ¨k, _âŸ©
  split_ifs <;> Â· simp at * <;> omega"
Mathlib/GroupTheory/Archimedean.lean,AddSubgroup.exists_isLeast_pos,AddSubgroup.exists_isLeast_pos,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  have hex : âˆ€ g > 0, âˆƒ n : â„•, g âˆˆ Ioc (n â€¢ a) ((n + 1) â€¢ a) := fun g hg => by
    rcases existsUnique_add_zsmul_mem_Ico hâ‚€ 0 (g - a) with âŸ¨m, âŸ¨hm, hm'âŸ©, -âŸ©
    simp only [zero_add, sub_le_iff_le_add, sub_add_cancel, â† add_one_zsmul] at hm hm'
    lift m to â„•
    Â· rw [â† Int.lt_add_one_iff, â† zsmul_lt_zsmul_iff hâ‚€, zero_zsmul]
      exact hg.trans_le hm
    Â· simp only [â† Nat.cast_succ, coe_nat_zsmul] at hm hm'
      exact âŸ¨m, hm', hmâŸ©
  have : âˆƒ n : â„•, Set.Nonempty (H âˆ© Ioc (n â€¢ a) ((n + 1) â€¢ a))
  Â· rcases (bot_or_exists_ne_zero H).resolve_left hbot with âŸ¨g, hgH, hgâ‚€âŸ©
    rcases hex |g| (abs_pos.2 hgâ‚€) with âŸ¨n, hnâŸ©
    exact âŸ¨n, _, (@abs_mem_iff (AddSubgroup G) G _ _).2 hgH, hnâŸ©
  classical rcases Nat.findX this with âŸ¨n, âŸ¨x, hxH, hnx, hxnâŸ©, hminâŸ©
  by_contra hxmin
  simp only [IsLeast, not_and, mem_setOf_eq, mem_lowerBounds, not_exists, not_forall,
    not_le] at hxmin
  rcases hxmin x âŸ¨hxH, (nsmul_nonneg hâ‚€.le _).trans_lt hnxâŸ© with âŸ¨y, âŸ¨hyH, hyâ‚€âŸ©, hxyâŸ©
  rcases hex y hyâ‚€ with âŸ¨m, hmâŸ©
  cases' lt_or_le m n with hmn hnm
  Â· exact hmin m hmn âŸ¨y, hyH, hmâŸ©
  Â· refine disjoint_left.1 hd (sub_mem hxH hyH) âŸ¨sub_pos.2 hxy, sub_lt_iff_lt_add'.2 ?_âŸ©
    calc x â‰¤ (n + 1) â€¢ a := hxn
    _ â‰¤ (m + 1) â€¢ a := nsmul_le_nsmul hâ‚€.le (add_le_add_right hnm _)
    _ = m â€¢ a + a := succ_nsmul' _ _
    _ < y + a := add_lt_add_right hm.1 _","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
G : Type u_1
instâœÂ¹ : LinearOrderedAddCommGroup G
instâœ : Archimedean G
H : AddSubgroup G
hbot : H â‰  âŠ¥
a : G
hâ‚€ : 0 < a
hd : Disjoint (â†‘H) (Ioo 0 a)
hex : âˆ€ g > 0, âˆƒ n, g âˆˆ Ioc (n â€¢ a) ((n + 1) â€¢ a)
this : âˆƒ n, (â†‘H âˆ© Ioc (n â€¢ a) ((n + 1) â€¢ a)).Nonempty
âŠ¢ âˆƒ b, IsLeast {g | g âˆˆ H âˆ§ 0 < g} b","theorem AddSubgroup.exists_isLeast_pos {H : AddSubgroup G} (hbot : H â‰  âŠ¥) {a : G} (hâ‚€ : 0 < a)
    (hd : Disjoint (H : Set G) (Ioo 0 a)) : âˆƒ b, IsLeast { g : G | g âˆˆ H âˆ§ 0 < g } b ",":= by
  have hex : âˆ€ g > 0, âˆƒ n : â„•, g âˆˆ Ioc (n â€¢ a) ((n + 1) â€¢ a) := fun g hg => by
    rcases existsUnique_add_zsmul_mem_Ico hâ‚€ 0 (g - a) with âŸ¨m, âŸ¨hm, hm'âŸ©, -âŸ©
    simp only [zero_add, sub_le_iff_le_add, sub_add_cancel, â† add_one_zsmul] at hm hm'
    lift m to â„•
    Â· rw [â† Int.lt_add_one_iff, â† zsmul_lt_zsmul_iff hâ‚€, zero_zsmul]
      exact hg.trans_le hm
    Â· simp only [â† Nat.cast_succ, natCast_zsmul] at hm hm'
      exact âŸ¨m, hm', hmâŸ©
  have : âˆƒ n : â„•, Set.Nonempty (H âˆ© Ioc (n â€¢ a) ((n + 1) â€¢ a)) := by
    rcases (bot_or_exists_ne_zero H).resolve_left hbot with âŸ¨g, hgH, hgâ‚€âŸ©
    rcases hex |g| (abs_pos.2 hgâ‚€) with âŸ¨n, hnâŸ©
    exact âŸ¨n, _, (@abs_mem_iff (AddSubgroup G) G _ _).2 hgH, hnâŸ©
  classical rcases Nat.findX this with âŸ¨n, âŸ¨x, hxH, hnx, hxnâŸ©, hminâŸ©
  by_contra hxmin
  simp only [IsLeast, not_and, mem_setOf_eq, mem_lowerBounds, not_exists, not_forall,
    not_le] at hxmin
  rcases hxmin x âŸ¨hxH, (nsmul_nonneg hâ‚€.le _).trans_lt hnxâŸ© with âŸ¨y, âŸ¨hyH, hyâ‚€âŸ©, hxyâŸ©
  rcases hex y hyâ‚€ with âŸ¨m, hmâŸ©
  cases' lt_or_le m n with hmn hnm
  Â· exact hmin m hmn âŸ¨y, hyH, hmâŸ©
  Â· refine disjoint_left.1 hd (sub_mem hxH hyH) âŸ¨sub_pos.2 hxy, sub_lt_iff_lt_add'.2 ?_âŸ©
    calc x â‰¤ (n + 1) â€¢ a := hxn
    _ â‰¤ (m + 1) â€¢ a := nsmul_le_nsmul_left hâ‚€.le (add_le_add_right hnm _)
    _ = m â€¢ a + a := succ_nsmul _ _
    _ < y + a := add_lt_add_right hm.1 _"
Mathlib/CategoryTheory/Elements.lean,CategoryTheory.CategoryOfElements.to_fromCostructuredArrow_eq,to_fromCostructuredArrow_eq,de2321d01fed2b8dfa8db6d498ef79d0a9faadfc,":= by
  refine' Functor.ext _ _
  Â· intro X
    cases' X with X_left X_right X_hom
    cases X_right
    simp only [Functor.id_obj, Functor.rightOp_obj, toCostructuredArrow_obj, Functor.comp_obj,
      CostructuredArrow.mk]
    congr
    ext x
    funext f
    convert congr_fun (X_hom.naturality f.op).symm (ğŸ™ X_left)
    simp
  . intro X Y f
    ext
    simp [CostructuredArrow.eqToHom_left]
  CategoryTheory.CategoryOfElements.to_fromCostructuredArrow_eq",error:  unknown tactic,"theorem to_fromCostructuredArrow_eq (F : Cáµ’áµ– â¥¤ Type v) :
    (fromCostructuredArrow F).rightOp â‹™ toCostructuredArrow F = ğŸ­ _ ",":= by
  refine Functor.ext ?_ ?_
  Â· intro X
    cases' X with X_left X_right X_hom
    cases X_right
    simp only [Functor.id_obj, Functor.rightOp_obj, toCostructuredArrow_obj, Functor.comp_obj,
      CostructuredArrow.mk]
    congr
    ext x f
    convert congr_fun (X_hom.naturality f.op).symm (ğŸ™ X_left)
    simp
  Â· aesop"
Mathlib/LinearAlgebra/Projectivization/Independence.lean,Projectivization.dependent_pair_iff_eq,dependent_pair_iff_eq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [dependent_iff_not_independent, independent_iff, linearIndependent_fin2,
    Function.comp_apply, Matrix.cons_val_one, Matrix.head_cons, Ne]
  simp only [Matrix.cons_val_zero, not_and, not_forall, Classical.not_not, Function.comp_apply,
    â† mk_eq_mk_iff' K _ _ (rep_nonzero u) (rep_nonzero v), mk_rep, imp_iff_right_iff]
  exact Or.inl (rep_nonzero v)","error:  ambiguous, possible interpretations 
  _root_.imp_iff_right_iff : (?m.29189 â†’ ?m.29190 â†” ?m.29190) â†” ?m.29189 âˆ¨ ?m.29190
  
  Classical.imp_iff_right_iff : (?m.29191 â†’ ?m.29192 â†” ?m.29192) â†” ?m.29191 âˆ¨ ?m.29192
error:  type mismatch
  Or.inl (rep_nonzero v)
has type
  v.rep â‰  0 âˆ¨ ?m.29563 : Prop
but is expected to have type
  Â¬v.rep = 0 â†’ u = v â†” u = v : Prop","theorem dependent_pair_iff_eq (u v : â„™ K V) : Dependent ![u, v] â†” u = v ",":= by
  rw [dependent_iff_not_independent, independent_iff, linearIndependent_fin2,
    Function.comp_apply, Matrix.cons_val_one, Matrix.head_cons, Ne]
  simp only [Matrix.cons_val_zero, not_and, not_forall, Classical.not_not, Function.comp_apply,
    â† mk_eq_mk_iff' K _ _ (rep_nonzero u) (rep_nonzero v), mk_rep, Classical.imp_iff_right_iff]
  exact Or.inl (rep_nonzero v)"
Mathlib/MeasureTheory/Measure/Regular.lean,MeasureTheory.Measure.OuterRegular.of_restrict,of_restrict,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  refine' âŸ¨fun A hA r hr => _âŸ©
  have HA : Î¼ A < âˆ := lt_of_lt_of_le hr le_top
  have hm : âˆ€ n, MeasurableSet (s n) := fun n => (h' n).measurableSet
  obtain âŸ¨A, hAm, hAs, hAd, rflâŸ© :
    âˆƒ A' : â„• â†’ Set Î±,
      (âˆ€ n, MeasurableSet (A' n)) âˆ§
        (âˆ€ n, A' n âŠ† s n) âˆ§ Pairwise (Disjoint on A') âˆ§ A = â‹ƒ n, A' n := by
    refine'
      âŸ¨fun n => A âˆ© disjointed s n, fun n => hA.inter (MeasurableSet.disjointed hm _), fun n =>
        (inter_subset_right _ _).trans (disjointed_subset _ _),
        (disjoint_disjointed s).mono fun k l hkl => hkl.mono inf_le_right inf_le_right, _âŸ©
    rw [â† inter_iUnion, iUnion_disjointed, univ_subset_iff.mp h'', inter_univ]
  rcases ENNReal.exists_pos_sum_of_countable' (tsub_pos_iff_lt.2 hr).ne' â„• with âŸ¨Î´, Î´0, hÎ´ÎµâŸ©
  rw [lt_tsub_iff_right, add_comm] at hÎ´Îµ
  have : âˆ€ n, âˆƒ (U : _) (_ : U âŠ‡ A n), IsOpen U âˆ§ Î¼ U < Î¼ (A n) + Î´ n := by
    intro n
    have Hâ‚ : âˆ€ t, Î¼.restrict (s n) t = Î¼ (t âˆ© s n) := fun t => restrict_apply' (hm n)
    have Ht : Î¼.restrict (s n) (A n) â‰  âŠ¤ := by
      rw [Hâ‚]
      exact ((measure_mono ((inter_subset_left _ _).trans (subset_iUnion A n))).trans_lt HA).ne
    rcases (A n).exists_isOpen_lt_add Ht (Î´0 n).ne' with âŸ¨U, hAU, hUo, hUâŸ©
    rw [Hâ‚, Hâ‚, inter_eq_self_of_subset_left (hAs _)] at hU
    exact âŸ¨U âˆ© s n, subset_inter hAU (hAs _), hUo.inter (h' n), hUâŸ©
  choose U hAU hUo hU using this
  refine' âŸ¨â‹ƒ n, U n, iUnion_mono hAU, isOpen_iUnion hUo, _âŸ©
  calc
    Î¼ (â‹ƒ n, U n) â‰¤ âˆ‘' n, Î¼ (U n) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Î¼ (A n) + Î´ n) := (ENNReal.tsum_le_tsum fun n => (hU n).le)
    _ = âˆ‘' n, Î¼ (A n) + âˆ‘' n, Î´ n := ENNReal.tsum_add
    _ = Î¼ (â‹ƒ n, A n) + âˆ‘' n, Î´ n := (congr_argâ‚‚ (Â· + Â·) (measure_iUnion hAd hAm).symm rfl)
    _ < r := hÎ´Îµ","error:  function expected at
  inter_subset_right ?m.25404
term has type
  ?m.25403 âˆˆ ?m.25402
error:  function expected at
  inter_subset_left ?m.28253
term has type
  ?m.28252 âˆˆ ?m.28250","lemma of_restrict [OpensMeasurableSpace Î±] {Î¼ : Measure Î±} {s : â„• â†’ Set Î±}
    (h : âˆ€ n, OuterRegular (Î¼.restrict (s n))) (h' : âˆ€ n, IsOpen (s n)) (h'' : univ âŠ† â‹ƒ n, s n) :
    OuterRegular Î¼ ",":= by
  refine âŸ¨fun A hA r hr => ?_âŸ©
  have HA : Î¼ A < âˆ := lt_of_lt_of_le hr le_top
  have hm : âˆ€ n, MeasurableSet (s n) := fun n => (h' n).measurableSet
  obtain âŸ¨A, hAm, hAs, hAd, rflâŸ© :
    âˆƒ A' : â„• â†’ Set Î±,
      (âˆ€ n, MeasurableSet (A' n)) âˆ§
        (âˆ€ n, A' n âŠ† s n) âˆ§ Pairwise (Disjoint on A') âˆ§ A = â‹ƒ n, A' n := by
    refine
      âŸ¨fun n => A âˆ© disjointed s n, fun n => hA.inter (MeasurableSet.disjointed hm _), fun n =>
        inter_subset_right.trans (disjointed_subset _ _),
        (disjoint_disjointed s).mono fun k l hkl => hkl.mono inf_le_right inf_le_right, ?_âŸ©
    rw [â† inter_iUnion, iUnion_disjointed, univ_subset_iff.mp h'', inter_univ]
  rcases ENNReal.exists_pos_sum_of_countable' (tsub_pos_iff_lt.2 hr).ne' â„• with âŸ¨Î´, Î´0, hÎ´ÎµâŸ©
  rw [lt_tsub_iff_right, add_comm] at hÎ´Îµ
  have : âˆ€ n, âˆƒ U âŠ‡ A n, IsOpen U âˆ§ Î¼ U < Î¼ (A n) + Î´ n := by
    intro n
    have Hâ‚ : âˆ€ t, Î¼.restrict (s n) t = Î¼ (t âˆ© s n) := fun t => restrict_apply' (hm n)
    have Ht : Î¼.restrict (s n) (A n) â‰  âˆ := by
      rw [Hâ‚]
      exact ((measure_mono (inter_subset_left.trans (subset_iUnion A n))).trans_lt HA).ne
    rcases (A n).exists_isOpen_lt_add Ht (Î´0 n).ne' with âŸ¨U, hAU, hUo, hUâŸ©
    rw [Hâ‚, Hâ‚, inter_eq_self_of_subset_left (hAs _)] at hU
    exact âŸ¨U âˆ© s n, subset_inter hAU (hAs _), hUo.inter (h' n), hUâŸ©
  choose U hAU hUo hU using this
  refine âŸ¨â‹ƒ n, U n, iUnion_mono hAU, isOpen_iUnion hUo, ?_âŸ©
  calc
    Î¼ (â‹ƒ n, U n) â‰¤ âˆ‘' n, Î¼ (U n) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Î¼ (A n) + Î´ n) := ENNReal.tsum_le_tsum fun n => (hU n).le
    _ = âˆ‘' n, Î¼ (A n) + âˆ‘' n, Î´ n := ENNReal.tsum_add
    _ = Î¼ (â‹ƒ n, A n) + âˆ‘' n, Î´ n := (congr_argâ‚‚ (Â· + Â·) (measure_iUnion hAd hAm).symm rfl)
    _ < r := hÎ´Îµ"
Mathlib/RingTheory/IntegralClosure.lean,isField_of_isIntegral_of_isField',isField_of_isIntegral_of_isField',839db8a30a61a26af4adfa36f65db472a27dd4f0,"  exists_pair_ne := âŸ¨0, 1, zero_ne_oneâŸ©
  mul_comm := mul_comm
  mul_inv_cancel {x} hx := by
    letI := hR.toField
    obtain âŸ¨y, rflâŸ© := (Algebra.IsIntegral.isIntegral (R := R) x).isUnit hx
    exact âŸ¨y.inv, y.val_invâŸ©","error:  function expected at
  IsField S
term has type
  Prop
error:  invalid constructor âŸ¨...âŸ©, expected type must be known
error:  unexpected token ':='; expected command
error:  unknown identifier 'isField_of_isIntegral_of_isField''","theorem isField_of_isIntegral_of_isField' {R S : Type*} [CommRing R] [CommRing S] [IsDomain S]
    [Algebra R S] [Algebra.IsIntegral R S] (hR : IsField R) : IsField S ",":= by
  refine âŸ¨âŸ¨0, 1, zero_ne_oneâŸ©, mul_comm, fun {x} hx â†¦ ?_âŸ©
  have : Module.Finite R (adjoin R {x}) := âŸ¨(Submodule.fg_top _).mpr
    (Algebra.IsIntegral.isIntegral x).fg_adjoin_singletonâŸ©
  letI := hR.toField
  obtain âŸ¨y, hyâŸ© := FiniteDimensional.exists_mul_eq_one R
    (K := adjoin R {x}) (x := âŸ¨x, subset_adjoin rflâŸ©) (mt Subtype.ext_iff.mp hx)
  exact âŸ¨y, Subtype.ext_iff.mp hyâŸ©"
Mathlib/Data/Finsupp/Indicator.lean,Finsupp.single_eq_indicator,single_eq_indicator,67e80fd089fe45abea632652c43b78eba72d60e3,":= by
  ext j
  simp [single_apply, indicator_apply, @eq_comm _ j]",error:  simp made no progress,lemma single_eq_indicator (b : Î±) : single i b = indicator {i} (fun _ _ => b) ,":= by
  classical
  ext j
  simp [single_apply, indicator_apply, @eq_comm _ j]"
Mathlib/Geometry/Euclidean/Angle/Sphere.lean,Affine.Triangle.dist_div_sin_oangle_div_two_eq_circumradius,dist_div_sin_oangle_div_two_eq_circumradius,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  Sphere.dist_div_sin_oangle_div_two_eq_radius (t.mem_circumsphere _) (t.mem_circumsphere _)
    (t.mem_circumsphere _) (t.Independent.injective.ne hâ‚â‚‚) (t.Independent.injective.ne hâ‚â‚ƒ)
    (t.Independent.injective.ne hâ‚‚â‚ƒ)","error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Triangle â„ P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Simplex â„ P 2
error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Triangle â„ P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Simplex â„ P 2
error:  invalid field 'Independent', the environment does not contain 'Affine.Triangle.Independent'
  t
has type
  Triangle â„ P
error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  t
has type
  Simplex â„ P 2","theorem dist_div_sin_oangle_div_two_eq_circumradius (t : Triangle â„ P) {iâ‚ iâ‚‚ iâ‚ƒ : Fin 3}
    (hâ‚â‚‚ : iâ‚ â‰  iâ‚‚) (hâ‚â‚ƒ : iâ‚ â‰  iâ‚ƒ) (hâ‚‚â‚ƒ : iâ‚‚ â‰  iâ‚ƒ) : dist (t.points iâ‚) (t.points iâ‚ƒ) /
      |Real.Angle.sin (âˆ¡ (t.points iâ‚) (t.points iâ‚‚) (t.points iâ‚ƒ))| / 2 = t.circumradius ",":=
  Sphere.dist_div_sin_oangle_div_two_eq_radius (t.mem_circumsphere _) (t.mem_circumsphere _)
    (t.mem_circumsphere _) (t.independent.injective.ne hâ‚â‚‚) (t.independent.injective.ne hâ‚â‚ƒ)
    (t.independent.injective.ne hâ‚‚â‚ƒ)"
Mathlib/CategoryTheory/Shift/Localization.lean,CategoryTheory.MorphismProperty.IsCompatibleWithShift.iff,iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  conv_rhs => rw [â† @IsCompatibleWithShift.condition _ _ W A _ _ _ a]","error:  unsolved goals
C : Type uâ‚
D : Type uâ‚‚
instâœâµ : Category.{vâ‚, uâ‚} C
instâœâ´ : Category.{vâ‚‚, uâ‚‚} D
L : C â¥¤ D
W : MorphismProperty C
instâœÂ³ : L.IsLocalization W
A : Type w
instâœÂ² : AddMonoid A
instâœÂ¹ : HasShift C A
instâœ : W.IsCompatibleWithShift A
X Y : C
f : X âŸ¶ Y
a : A
âŠ¢ W ((shiftFunctor C a).map f) â†” W.inverseImage (shiftFunctor C a) f",lemma iff {X Y : C} (f : X âŸ¶ Y) (a : A) : W (fâŸ¦aâŸ§') â†” W f ,":= by
  conv_rhs => rw [â† @IsCompatibleWithShift.condition _ _ W A _ _ _ a]
  rfl"
Mathlib/CategoryTheory/Preadditive/Yoneda/Projective.lean,CategoryTheory.Projective.projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj',projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj',fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  rw [projective_iff_preservesEpimorphisms_coyoneda_obj]
  refine âŸ¨fun h : (preadditiveCoyoneda.obj (op P) â‹™
      forget AddCommGroupCat).PreservesEpimorphisms => ?_,? _âŸ©
  Â· exact Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveCoyoneda.obj (op P))
        (forget _)
  Â· intro
    exact (inferInstance : (preadditiveCoyoneda.obj (op P) â‹™ forget _).PreservesEpimorphisms)","error:  unknown identifier 'AddCommGroupCat'
error:  failed to synthesize
  (preadditiveCoyoneda.obj { unop := P } â‹™ forget AddCommGrp).PreservesEpimorphisms
use `set_option diagnostics true` to get diagnostic information
error:  no goals to be solved","theorem projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj' (P : C) :
    Projective P â†” (preadditiveCoyoneda.obj (op P)).PreservesEpimorphisms ",":= by
  rw [projective_iff_preservesEpimorphisms_coyoneda_obj]
  refine âŸ¨fun h : (preadditiveCoyoneda.obj (op P) â‹™
      forget AddCommGrp).PreservesEpimorphisms => ?_, ?_âŸ©
  Â· exact Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveCoyoneda.obj (op P))
        (forget _)
  Â· intro
    exact (inferInstance : (preadditiveCoyoneda.obj (op P) â‹™ forget _).PreservesEpimorphisms)"
Mathlib/Data/Real/Irrational.lean,irrational_nrt_of_notint_nrt,irrational_nrt_of_notint_nrt,b50a8b2e9760b6f582390d3948a953c553480df1,":= by
  rintro âŸ¨âŸ¨N, D, P, CâŸ©, rflâŸ©
  rw [â† cast_pow] at hxr
  have c1 : ((D : â„¤) : â„) â‰  0 := by
    rw [Int.cast_ne_zero, Int.coe_nat_ne_zero]
    exact P
  have c2 : ((D : â„¤) : â„) ^ n â‰  0 := pow_ne_zero _ c1
  rw [num_den', cast_pow, cast_mk, div_pow, div_eq_iff_mul_eq c2, â† Int.cast_pow, â† Int.cast_pow,
    â† Int.cast_mul, Int.cast_inj] at hxr
  have hdivn : (D : â„¤) ^ n âˆ£ N ^ n := Dvd.intro_left m hxr
  rw [â† Int.dvd_natAbs, â† Int.coe_nat_pow, Int.coe_nat_dvd, Int.natAbs_pow,
    Nat.pow_dvd_pow_iff hnpos] at hdivn
  obtain rfl : D = 1 := by rw [â† Nat.gcd_eq_right hdivn, C.gcd_eq_one]
  refine' hv âŸ¨N, _âŸ©
  rw [num_den', Int.ofNat_one, divInt_one, cast_intCast]","warning:  `Int.coe_nat_ne_zero` has been deprecated, use `Int.natCast_ne_zero` instead
error:  unknown identifier 'num_den''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.2076
case intro.mk'
n : â„•
m : â„¤
hnpos : 0 < n
N : â„¤
D : â„•
P : D â‰  0
C : N.natAbs.Coprime D
hxr : â†‘({ num := N, den := D, den_nz := P, reduced := C } ^ n) = â†‘m
hv : Â¬âˆƒ y, â†‘{ num := N, den := D, den_nz := P, reduced := C } = â†‘y
c1 : â†‘â†‘D â‰  0
c2 : â†‘â†‘D ^ n â‰  0
âŠ¢ False","theorem irrational_nrt_of_notint_nrt {x : â„} (n : â„•) (m : â„¤) (hxr : x ^ n = m)
    (hv : Â¬âˆƒ y : â„¤, x = y) (hnpos : 0 < n) : Irrational x ",":= by
  rintro âŸ¨âŸ¨N, D, P, CâŸ©, rflâŸ©
  rw [â† cast_pow] at hxr
  have c1 : ((D : â„¤) : â„) â‰  0 := by
    rw [Int.cast_ne_zero, Int.natCast_ne_zero]
    exact P
  have c2 : ((D : â„¤) : â„) ^ n â‰  0 := pow_ne_zero _ c1
  rw [mk'_eq_divInt, cast_pow, cast_mk, div_pow, div_eq_iff_mul_eq c2, â† Int.cast_pow,
    â† Int.cast_pow, â† Int.cast_mul, Int.cast_inj] at hxr
  have hdivn : (D : â„¤) ^ n âˆ£ N ^ n := Dvd.intro_left m hxr
  rw [â† Int.dvd_natAbs, â† Int.natCast_pow, Int.natCast_dvd_natCast, Int.natAbs_pow,
    Nat.pow_dvd_pow_iff hnpos.ne'] at hdivn
  obtain rfl : D = 1 := by rw [â† Nat.gcd_eq_right hdivn, C.gcd_eq_one]
  refine hv âŸ¨N, ?_âŸ©
  rw [mk'_eq_divInt, Int.ofNat_one, divInt_one, cast_intCast]"
Mathlib/MeasureTheory/Function/SimpleFunc.lean,MeasureTheory.SimpleFunc.lintegral_mono,lintegral_mono,4b292e8968c43193b3dbd022dfbc7ddc03b3a7a8,":=
  calc
    f.lintegral Î¼ â‰¤ f.lintegral Î¼ âŠ” g.lintegral Î¼ := le_sup_left
    _ â‰¤ (f âŠ” g).lintegral Î¼ := (le_sup_lintegral _ _)
    _ = g.lintegral Î¼ := by rw [sup_of_le_right hfg]
    _ â‰¤ g.lintegral Î½ :=
      Finset.sum_le_sum fun y _ => ENNReal.mul_left_mono <| hÎ¼Î½ _ (g.measurableSet_preimage _)","error:  application type mismatch
  hÎ¼Î½ ?m.196028 (measurableSet_preimage g ?m.196039)
argument
  measurableSet_preimage g ?m.196039
has type
  MeasurableSet (â†‘g â»Â¹' ?m.196039) : Prop
but is expected to have type
  â„â‰¥0 : Type","theorem lintegral_mono {f g : Î± â†’â‚› â„â‰¥0âˆ} (hfg : f â‰¤ g) (hÎ¼Î½ : Î¼ â‰¤ Î½) :
    f.lintegral Î¼ â‰¤ g.lintegral Î½ ",":=
  calc
    f.lintegral Î¼ â‰¤ f.lintegral Î¼ âŠ” g.lintegral Î¼ := le_sup_left
    _ â‰¤ (f âŠ” g).lintegral Î¼ := le_sup_lintegral _ _
    _ = g.lintegral Î¼ := by rw [sup_of_le_right hfg]
    _ â‰¤ g.lintegral Î½ := Finset.sum_le_sum fun y _ => ENNReal.mul_left_mono <| hÎ¼Î½ _"
Mathlib/Data/List/Rotate.lean,List.get_eq_get_rotate,get_eq_get_rotate,5de5d3201b338977df0e677ce686fb2a0924639d,":= by
  rw [get_rotate]
  refine congr_arg l.get (Fin.eq_of_val_eq ?_)
  simp only [mod_add_mod]
  rw [â† add_mod_mod, add_right_comm, tsub_add_cancel_of_le (Î± := â„•), add_mod_left, mod_eq_of_lt]
  exacts [k.2, (mod_lt _ (k.1.zero_le.trans_lt k.2)).le]","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_rotate` has been deprecated, use `List.get_rotate` instead
error:  unknown identifier 'add_right_comm'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.16238
Î± : Type u
l : List Î±
n : â„•
k : Fin l.length
âŠ¢ â†‘k = (l.length - n % l.length + â†‘k + n % l.length) % l.length
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  @IsRotated does not have a doc string","theorem get_eq_get_rotate (l : List Î±) (n : â„•) (k : Fin l.length) :
    l.get k = (l.rotate n).get âŸ¨(l.length - n % l.length + k) % l.length,
      (Nat.mod_lt _ (k.1.zero_le.trans_lt k.2)).trans_eq (length_rotate _ _).symmâŸ© ",":= by
  rw [get_rotate]
  refine congr_arg l.get (Fin.eq_of_val_eq ?_)
  simp only [mod_add_mod]
  rw [â† add_mod_mod, Nat.add_right_comm, Nat.sub_add_cancel, add_mod_left, mod_eq_of_lt]
  exacts [k.2, (mod_lt _ (k.1.zero_le.trans_lt k.2)).le]"
Mathlib/LinearAlgebra/FiniteDimensional.lean,Submodule.eq_top_of_finrank_eq,_root_.Submodule.eq_top_of_finrank_eq,fb6ba072b0a93cf43e39a87367072a958d7be9cf,":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((â†‘) : ((â†‘) '' Basis.ofVectorSpaceIndex K S : Set V) â†’ V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (finite_of_linearIndependent (by simpa using b.linearIndependent)).fintype
  letI i2 : Fintype (((â†‘) : S â†’ V) '' Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (finite_of_linearIndependent (by simpa using bS.linearIndependent)).fintype
  have : (â†‘) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, â† finrank_eq_card_basis bS, â†
            finrank_eq_card_basis b, h])
  rw [â† b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, â† this, â† Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, map_top (Submodule.subtype S), range_subtype]","error:  type mismatch
  hâœ
has type
  LinearIndependent (Î¹ := â†‘(Basis.ofVectorSpaceIndex K â†¥S)) K â‡‘bS : Prop
but is expected to have type
  LinearIndependent K fun (x : â†‘(Basis.ofVectorSpaceIndex K â†¥S)) â†¦ â†‘x : Prop
warning:  `finite_of_linearIndependent` has been deprecated, use `LinearIndependent.set_finite_of_isNoetherian` instead
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  unknown identifier 'eq_top_of_finrank_eq'
error:  no goals to be solved
error:  unknown identifier 'eq_top_of_finrank_eq'","theorem _root_.Submodule.eq_top_of_finrank_eq [FiniteDimensional K V] {S : Submodule K V}
    (h : finrank K S = finrank K V) : S = âŠ¤ ",":= by
  haveI : IsNoetherian K V := iff_fg.2 inferInstance
  set bS := Basis.ofVectorSpace K S with bS_eq
  have : LinearIndependent K ((â†‘) : ((â†‘) '' Basis.ofVectorSpaceIndex K S : Set V) â†’ V) :=
    LinearIndependent.image_subtype (f := Submodule.subtype S)
      (by simpa [bS] using bS.linearIndependent) (by simp)
  set b := Basis.extend this with b_eq
  letI i1 : Fintype (this.extend _) :=
    (LinearIndependent.set_finite_of_isNoetherian (by simpa [b] using b.linearIndependent)).fintype
  letI i2 : Fintype (((â†‘) : S â†’ V) '' Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian this).fintype
  letI i3 : Fintype (Basis.ofVectorSpaceIndex K S) :=
    (LinearIndependent.set_finite_of_isNoetherian
      (by simpa [bS] using bS.linearIndependent)).fintype
  have : (â†‘) '' Basis.ofVectorSpaceIndex K S = this.extend (Set.subset_univ _) :=
    Set.eq_of_subset_of_card_le (this.subset_extend _)
      (by
        rw [Set.card_image_of_injective _ Subtype.coe_injective, â† finrank_eq_card_basis bS, â†
            finrank_eq_card_basis b, h])
  rw [â† b.span_eq, b_eq, Basis.coe_extend, Subtype.range_coe, â† this, â† Submodule.coeSubtype,
    span_image]
  have := bS.span_eq
  rw [bS_eq, Basis.coe_ofVectorSpace, Subtype.range_coe] at this
  rw [this, Submodule.map_top (Submodule.subtype S), range_subtype]"
Mathlib/Data/Finset/Sups.lean,Finset.subset_infs_self,subset_infs_self,1faa648b0b1359dec61956304fa51ac01bdbb219,":= fun _a ha â†¦ mem_infs.2 âŸ¨_, ha, _, ha, inf_idemâŸ©","error:  application type mismatch
  âŸ¨ha, inf_idemâŸ©
argument
  inf_idem
has type
  âˆ€ (a : ?m.58275), a âŠ“ a = a : Prop
but is expected to have type
  _a âŠ“ _a = _a : Prop
warning:  @Finset.disjSups does not have a doc string
warning:  @Finset.diffs does not have a doc string
warning:  @Finset.compls does not have a doc string",lemma subset_infs_self : s âŠ† s âŠ¼ s ,":= fun _a ha â†¦ mem_infs.2 âŸ¨_, ha, _, ha, inf_idem _âŸ©"
Mathlib/LinearAlgebra/FiniteDimensional.lean,is_simple_module_of_finrank_eq_one,is_simple_module_of_finrank_eq_one,719a21701d48cc284d79469cd45ad8d9a4ff3ec9,":= by
  haveI := nontrivial_of_finrank_eq_succ h
  refine' âŸ¨fun S => or_iff_not_imp_left.2 fun hn => _âŸ©
  rw [â† restrictScalars_inj K] at hnâŠ¢
  haveI : FiniteDimensional _ _ := finiteDimensional_of_finrank_eq_succ h
  refine' Submodule.eq_top_of_finrank_eq ((Submodule.finrank_le _).antisymm _)
  simpa only [h, finrank_bot] using Submodule.finrank_strictMono (Ne.bot_lt hn)","error:  unknown identifier 'finiteDimensional_of_finrank_eq_succ'
error:  unsolved goals
K : Type u
V : Type v
instâœâ¶ : DivisionRing K
instâœâµ : AddCommGroup V
instâœâ´ : Module K V
A : Type u_1
instâœÂ³ : Semiring A
instâœÂ² : Module A V
instâœÂ¹ : SMul K A
instâœ : IsScalarTower K A V
h : finrank K V = 1
this : Nontrivial V
S : Submodule A V
hn : Â¬restrictScalars K S = restrictScalars K âŠ¥
âŠ¢ restrictScalars K S = restrictScalars K âŠ¤","theorem is_simple_module_of_finrank_eq_one {A} [Semiring A] [Module A V] [SMul K A]
    [IsScalarTower K A V] (h : finrank K V = 1) : IsSimpleOrder (Submodule A V) ",":= by
  haveI := nontrivial_of_finrank_eq_succ h
  refine âŸ¨fun S => or_iff_not_imp_left.2 fun hn => ?_âŸ©
  rw [â† restrictScalars_inj K] at hn âŠ¢
  haveI : FiniteDimensional _ _ := .of_finrank_eq_succ h
  refine eq_top_of_finrank_eq ((Submodule.finrank_le _).antisymm ?_)
  simpa only [h, finrank_bot] using Submodule.finrank_strictMono (Ne.bot_lt hn)"
Mathlib/Data/Finsupp/Basic.lean,Finsupp.mem_frange,mem_frange,67e80fd089fe45abea632652c43b78eba72d60e3,":= by
  cases' f with f s
  induction' s using Trunc.induction_on with s
  simp [frange, Trunc.lift_mk]
  constructor
  case mp  => rintro âŸ¨a, âŸ¨_, haâŸ©, rflâŸ©; exact âŸ¨ha, a, rflâŸ©
  case mpr => rintro âŸ¨ha, a, rflâŸ©; exact âŸ¨a, âŸ¨(s.prop a).resolve_right ha, haâŸ©, rflâŸ©","error:  target
  s
has type
  Î± â†’ M : Type (max u_5 u_1)
but is expected to have type
  Trunc ?m.239428 : Sort ?u.239422","theorem mem_frange {f : Î± â†’â‚€ M} {y : M} : y âˆˆ f.frange â†” y â‰  0 âˆ§ âˆƒ x, f x = y ",":= by
  rw [frange, @Finset.mem_image _ _ (Classical.decEq _) _ f.support]
  exact âŸ¨fun âŸ¨x, hx1, hx2âŸ© => âŸ¨hx2 â–¸ mem_support_iff.1 hx1, x, hx2âŸ©, fun âŸ¨hy, x, hxâŸ© =>
    âŸ¨x, mem_support_iff.2 (hx.symm â–¸ hy), hxâŸ©âŸ©"
Mathlib/MeasureTheory/PiSystem.lean,isPiSystem_piiUnionInter,isPiSystem_piiUnionInter,92f5c622103f0c81143145b8c00c1b88256de70e,":= by
  rintro t1 âŸ¨p1, hp1S, f1, hf1m, ht1_eqâŸ© t2 âŸ¨p2, hp2S, f2, hf2m, ht2_eqâŸ© h_nonempty
  simp_rw [piiUnionInter, Set.mem_setOf_eq]
  let g n := ite (n âˆˆ p1) (f1 n) Set.univ âˆ© ite (n âˆˆ p2) (f2 n) Set.univ
  have hp_union_ss : â†‘(p1 âˆª p2) âŠ† S := by
    simp only [hp1S, hp2S, Finset.coe_union, union_subset_iff, and_self_iff]
  use p1 âˆª p2, hp_union_ss, g
  have h_inter_eq : t1 âˆ© t2 = â‹‚ i âˆˆ p1 âˆª p2, g i := by
    rw [ht1_eq, ht2_eq]
    simp_rw [â† Set.inf_eq_inter]
    ext1 x
    simp only [inf_eq_inter, mem_inter_iff, mem_iInter, Finset.mem_union]
    refine' âŸ¨fun h i _ => _, fun h => âŸ¨fun i hi1 => _, fun i hi2 => _âŸ©âŸ©
    Â· split_ifs with h_1 h_2 h_2
      exacts[âŸ¨h.1 i h_1, h.2 i h_2âŸ©, âŸ¨h.1 i h_1, Set.mem_univ _âŸ©, âŸ¨Set.mem_univ _, h.2 i h_2âŸ©,
        âŸ¨Set.mem_univ _, Set.mem_univ _âŸ©]
    Â· specialize h i (Or.inl hi1)
      rw [if_pos hi1] at h
      exact h.1
    Â· specialize h i (Or.inr hi2)
      rw [if_pos hi2] at h
      exact h.2
  refine' âŸ¨fun n hn => _, h_inter_eqâŸ©
  simp only []
  split_ifs with hn1 hn2 h
  Â· refine' hpi n (f1 n) (hf1m n hn1) (f2 n) (hf2m n hn2) (Set.nonempty_iff_ne_empty.2 fun h => _)
    rw [h_inter_eq] at h_nonempty
    suffices h_empty : (â‹‚ i âˆˆ p1 âˆª p2, g i) = âˆ…
    exact (Set.not_nonempty_iff_eq_empty.mpr h_empty) h_nonempty
    refine' le_antisymm (Set.iInter_subset_of_subset n _) (Set.empty_subset _)
    refine' Set.iInter_subset_of_subset hn _
    simp_rw [if_pos hn1, if_pos hn2]
    exact h.subset
  Â· simp [hf1m n hn1]
  Â· simp [hf2m n h]
  Â· exact absurd hn (by simp [hn1, h])",error:  unexpected identifier; expected 'by' or 'from',"theorem isPiSystem_piiUnionInter (Ï€ : Î¹ â†’ Set (Set Î±)) (hpi : âˆ€ x, IsPiSystem (Ï€ x)) (S : Set Î¹) :
    IsPiSystem (piiUnionInter Ï€ S) ",":= by
  rintro t1 âŸ¨p1, hp1S, f1, hf1m, ht1_eqâŸ© t2 âŸ¨p2, hp2S, f2, hf2m, ht2_eqâŸ© h_nonempty
  simp_rw [piiUnionInter, Set.mem_setOf_eq]
  let g n := ite (n âˆˆ p1) (f1 n) Set.univ âˆ© ite (n âˆˆ p2) (f2 n) Set.univ
  have hp_union_ss : â†‘(p1 âˆª p2) âŠ† S := by
    simp only [hp1S, hp2S, Finset.coe_union, union_subset_iff, and_self_iff]
  use p1 âˆª p2, hp_union_ss, g
  have h_inter_eq : t1 âˆ© t2 = â‹‚ i âˆˆ p1 âˆª p2, g i := by
    rw [ht1_eq, ht2_eq]
    simp_rw [â† Set.inf_eq_inter]
    ext1 x
    simp only [g, inf_eq_inter, mem_inter_iff, mem_iInter, Finset.mem_union]
    refine âŸ¨fun h i _ => ?_, fun h => âŸ¨fun i hi1 => ?_, fun i hi2 => ?_âŸ©âŸ©
    Â· split_ifs with h_1 h_2 h_2
      exacts [âŸ¨h.1 i h_1, h.2 i h_2âŸ©, âŸ¨h.1 i h_1, Set.mem_univ _âŸ©, âŸ¨Set.mem_univ _, h.2 i h_2âŸ©,
        âŸ¨Set.mem_univ _, Set.mem_univ _âŸ©]
    Â· specialize h i (Or.inl hi1)
      rw [if_pos hi1] at h
      exact h.1
    Â· specialize h i (Or.inr hi2)
      rw [if_pos hi2] at h
      exact h.2
  refine âŸ¨fun n hn => ?_, h_inter_eqâŸ©
  simp only [g]
  split_ifs with hn1 hn2 h
  Â· refine hpi n (f1 n) (hf1m n hn1) (f2 n) (hf2m n hn2) (Set.nonempty_iff_ne_empty.2 fun h => ?_)
    rw [h_inter_eq] at h_nonempty
    suffices h_empty : â‹‚ i âˆˆ p1 âˆª p2, g i = âˆ… from
      (Set.not_nonempty_iff_eq_empty.mpr h_empty) h_nonempty
    refine le_antisymm (Set.iInter_subset_of_subset n ?_) (Set.empty_subset _)
    refine Set.iInter_subset_of_subset hn ?_
    simp_rw [g, if_pos hn1, if_pos hn2]
    exact h.subset
  Â· simp [hf1m n hn1]
  Â· simp [hf2m n h]
  Â· exact absurd hn (by simp [hn1, h])"
Mathlib/CategoryTheory/Limits/HasLimits.lean,CategoryTheory.Limits.colimit.pre_map',colimit.pre_map',596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  ext1; simp [â† Category.assoc]","error:  unsolved goals
case w
J : Type uâ‚
instâœâ´ : Category.{vâ‚, uâ‚} J
K : Type uâ‚‚
instâœÂ³ : Category.{vâ‚‚, uâ‚‚} K
C : Type u
instâœÂ² : Category.{v, u} C
Fâœ : J â¥¤ C
instâœÂ¹ : HasColimitsOfShape J C
G : J â¥¤ C
Î±âœ : Fâœ âŸ¶ G
instâœ : HasColimitsOfShape K C
F : J â¥¤ C
Eâ‚ Eâ‚‚ : K â¥¤ J
Î± : Eâ‚ âŸ¶ Eâ‚‚
jâœ : K
âŠ¢ Î¹ F (Eâ‚.obj jâœ) = (F.map (Î±.app jâœ) â‰« Î¹ (Eâ‚‚ â‹™ F) jâœ) â‰« pre F Eâ‚‚","theorem colimit.pre_map' [HasColimitsOfShape K C] (F : J â¥¤ C) {Eâ‚ Eâ‚‚ : K â¥¤ J} (Î± : Eâ‚ âŸ¶ Eâ‚‚) :
    colimit.pre F Eâ‚ = colim.map (whiskerRight Î± F) â‰« colimit.pre F Eâ‚‚ ",":= by
  ext1
  simp [â† assoc, assoc]"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime_pow,isIntegralClosure_adjoin_singleton_of_prime_pow,672f5f5cb82ed7f2e260348bba07f84ada7a8172,":= by
  refine âŸ¨Subtype.val_injective, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©, ?_âŸ©âŸ©
  swap
  Â· rintro âŸ¨y, rflâŸ©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hÎ¶.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hÎ¶.subOnePowerBasis â„š
  have hint : IsIntegral â„¤ B.gen := (hÎ¶.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} â„š K
  have H := discr_mul_isIntegral_mem_adjoin â„š hint h
  obtain âŸ¨u, n, hunâŸ© := discr_prime_pow_eq_unit_mul_pow' hÎ¶
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [â† smul_assoc, â† smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, â† Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  Â· haveI : IsCyclotomicExtension {1} â„š K := by simpa using hcycl
    have : x âˆˆ (âŠ¥ : Subalgebra â„š K) := by
      rw [singleton_one â„š K]
      exact mem_top
    obtain âŸ¨y, rflâŸ© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap â„š K).injective).1 h
    obtain âŸ¨z, hzâŸ© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [â† hz, â† IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  Â· have hmin : (minpoly â„¤ B.gen).IsEisensteinAt (Submodule.span â„¤ {((p : â„•) : â„¤)}) := by
      have hâ‚ := minpoly.isIntegrallyClosed_eq_field_fractions' â„š hint
      have hâ‚‚ := hÎ¶.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at hâ‚
      rw [hâ‚, â† map_cyclotomic_int, show Int.castRingHom â„š = algebraMap â„¤ â„š by rfl,
        show X + 1 = map (algebraMap â„¤ â„š) (X + 1) by simp, â† map_comp] at hâ‚‚
      haveI : CharZero â„š := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap â„¤ â„š) (algebraMap â„¤ â„š).injective_int hâ‚‚]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton â„¤ _) (Subalgebra.one_mem _)",error:  unknown constant 'StrictOrderedSemiring.to_charZero',"theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} â„š K]
    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)) : IsIntegralClosure (adjoin â„¤ ({Î¶} : Set K)) â„¤ K ",":= by
  refine âŸ¨Subtype.val_injective, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©, ?_âŸ©âŸ©
  swap
  Â· rintro âŸ¨y, rflâŸ©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hÎ¶.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hÎ¶.subOnePowerBasis â„š
  have hint : IsIntegral â„¤ B.gen := (hÎ¶.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} â„š K
  have H := discr_mul_isIntegral_mem_adjoin â„š hint h
  obtain âŸ¨u, n, hunâŸ© := discr_prime_pow_eq_unit_mul_pow' hÎ¶
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [â† smul_assoc, â† smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, â† Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  Â· haveI : IsCyclotomicExtension {1} â„š K := by simpa using hcycl
    have : x âˆˆ (âŠ¥ : Subalgebra â„š K) := by
      rw [singleton_one â„š K]
      exact mem_top
    obtain âŸ¨y, rflâŸ© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap â„š K).injective).1 h
    obtain âŸ¨z, hzâŸ© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [â† hz, â† IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  Â· have hmin : (minpoly â„¤ B.gen).IsEisensteinAt (Submodule.span â„¤ {((p : â„•) : â„¤)}) := by
      have hâ‚ := minpoly.isIntegrallyClosed_eq_field_fractions' â„š hint
      have hâ‚‚ := hÎ¶.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at hâ‚
      rw [hâ‚, â† map_cyclotomic_int, show Int.castRingHom â„š = algebraMap â„¤ â„š by rfl,
        show X + 1 = map (algebraMap â„¤ â„š) (X + 1) by simp, â† map_comp] at hâ‚‚
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap â„¤ â„š) (algebraMap â„¤ â„š).injective_int hâ‚‚]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton â„¤ _) (Subalgebra.one_mem _)"
Mathlib/RingTheory/Adjoin/PowerBasis.lean,PowerBasis.repr_gen_pow_isIntegral,repr_gen_pow_isIntegral,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  intro i
  let Q := X ^ n %â‚˜ minpoly R B.gen
  have : B.gen ^ n = aeval B.gen Q := by
    rw [â† @aeval_X_pow R _ _ _ _ B.gen, â† modByMonic_add_div (X ^ n) (minpoly.monic hB)]
    simp
  by_cases hQ : Q = 0
  Â· simp [this, hQ, isIntegral_zero]
  have hlt : Q.natDegree < B.dim := by
    rw [â† B.natDegree_minpoly, hmin, (minpoly.monic hB).natDegree_map,
      natDegree_lt_natDegree_iff hQ]
    letI : Nontrivial R := Nontrivial.of_polynomial_ne hQ
    exact degree_modByMonic_lt _ (minpoly.monic hB)
  rw [this, aeval_eq_sum_range' hlt]
  simp only [LinearEquiv.map_sum, LinearEquiv.map_smulâ‚›â‚—, RingHom.id_apply, Finset.sum_apply']
  refine' IsIntegral.sum _ fun j hj => _
  replace hj := Finset.mem_range.1 hj
  rw [â† Fin.val_mk hj, â† B.basis_eq_pow, Algebra.smul_def, IsScalarTower.algebraMap_apply R S A, â†
    Algebra.smul_def, LinearEquiv.map_smul]
  simp only [algebraMap_smul, Finsupp.coe_smul, Pi.smul_apply, B.basis.repr_self_apply]
  by_cases hij : (âŸ¨j, hjâŸ© : Fin _) = i
  Â· simp only [hij, eq_self_iff_true, if_true]
    rw [Algebra.smul_def, mul_one]
    exact isIntegral_algebraMap
  Â· simp [hij, isIntegral_zero]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearEquiv
has type
  (Ïƒ : ?m.45856 â†’+* ?m.45857) â†’
    {Ïƒ' : ?m.45857 â†’+* ?m.45856} â†’
      [inst : RingHomInvPair Ïƒ Ïƒ'] â†’
        [inst : RingHomInvPair Ïƒ' Ïƒ] â†’
          (M : Type ?u.45853) â†’
            (Mâ‚‚ : Type ?u.45852) â†’
              [inst : AddCommMonoid M] â†’
                [inst_1 : AddCommMonoid Mâ‚‚] â†’
                  [inst : Module ?m.45856 M] â†’ [inst : Module ?m.45857 Mâ‚‚] â†’ Type (max ?u.45853 ?u.45852)
error:  simp made no progress","theorem repr_gen_pow_isIntegral [IsDomain S]
    (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) (n : â„•) :
    âˆ€ i, IsIntegral R (B.basis.repr (B.gen ^ n) i) ",":= by
  intro i
  let Q := X ^ n %â‚˜ minpoly R B.gen
  have : B.gen ^ n = aeval B.gen Q := by
    rw [â† @aeval_X_pow R _ _ _ _ B.gen, â† modByMonic_add_div (X ^ n) (minpoly.monic hB)]
    simp
  by_cases hQ : Q = 0
  Â· simp [this, hQ, isIntegral_zero]
  have hlt : Q.natDegree < B.dim := by
    rw [â† B.natDegree_minpoly, hmin, (minpoly.monic hB).natDegree_map,
      natDegree_lt_natDegree_iff hQ]
    letI : Nontrivial R := Nontrivial.of_polynomial_ne hQ
    exact degree_modByMonic_lt _ (minpoly.monic hB)
  rw [this, aeval_eq_sum_range' hlt]
  simp only [map_sum, LinearEquiv.map_smulâ‚›â‚—, RingHom.id_apply, Finset.sum_apply']
  refine IsIntegral.sum _ fun j hj => ?_
  replace hj := Finset.mem_range.1 hj
  rw [â† Fin.val_mk hj, â† B.basis_eq_pow, Algebra.smul_def, IsScalarTower.algebraMap_apply R S A, â†
    Algebra.smul_def, LinearEquiv.map_smul]
  simp only [algebraMap_smul, Finsupp.coe_smul, Pi.smul_apply, B.basis.repr_self_apply]
  by_cases hij : (âŸ¨j, hjâŸ© : Fin _) = i
  Â· simp only [hij, eq_self_iff_true, if_true]
    rw [Algebra.smul_def, mul_one]
    exact isIntegral_algebraMap
  Â· simp [hij, isIntegral_zero]"
Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean,CategoryTheory.Pretriangulated.Triangle.coyoneda_exactâ‚,coyoneda_exactâ‚,8535b08ef59bcdb8a9d09a473f4b6c583f54aef0,":=
  coyoneda_exactâ‚‚ _ (rot_of_dist_triangle _ (rot_of_dist_triangle _ hT)) f (by aesop_cat)","error:  unknown identifier 'rot_of_dist_triangle'
error:  tactic 'aesop' failed, failed to prove the goal after exhaustive search.
Initial goal:
  C : Type u
  instâœâ´ : Category.{v, u} C
  instâœÂ³ : HasZeroObject C
  instâœÂ² : HasShift C â„¤
  instâœÂ¹ : Preadditive C
  instâœ : âˆ€ (n : â„¤), (CategoryTheory.shiftFunctor C n).Additive
  hC : Pretriangulated C
  T : Triangle C
  hT : T âˆˆ distinguishedTriangles
  X : C
  f : X âŸ¶ (CategoryTheory.shiftFunctor C 1).obj T.objâ‚
  hf : f â‰« (CategoryTheory.shiftFunctor C 1).map T.morâ‚ = 0
  âŠ¢ sorryAx (X âŸ¶ ?m.78560.objâ‚‚) true â‰« ?m.78560.morâ‚‚ = 0
Remaining goals after safe rules:
  C : Type u
  inst : Category.{v, u} C
  inst_1 : HasZeroObject C
  inst_2 : HasShift C â„¤
  inst_3 : Preadditive C
  inst_4 : âˆ€ (n : â„¤), (CategoryTheory.shiftFunctor C n).Additive
  hC : Pretriangulated C
  T : Triangle C
  hT : T âˆˆ distinguishedTriangles
  X : C
  f : X âŸ¶ (CategoryTheory.shiftFunctor C 1).obj T.objâ‚
  hf : f â‰« (CategoryTheory.shiftFunctor C 1).map T.morâ‚ = 0
  âŠ¢ sorryAx (X âŸ¶ ?m.78560.objâ‚‚) true â‰« ?m.78560.morâ‚‚ = 0
error:  application type mismatch
  Triangle.coyoneda_exactâ‚ T' hT'
argument
  hT'
has type
  T' âˆˆ distinguishedTriangles : Prop
but is expected to have type
  ?m.211590 âŸ¶ (shiftFunctor C 1).obj T'.objâ‚ : Type v
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  ?m.212615
error:  no goals to be solved","lemma coyoneda_exactâ‚ {X : C} (f : X âŸ¶ T.objâ‚âŸ¦(1 : â„¤)âŸ§) (hf : f â‰« T.morâ‚âŸ¦1âŸ§' = 0) :
    âˆƒ (g : X âŸ¶ T.objâ‚ƒ), f = g â‰« T.morâ‚ƒ ",":=
  coyoneda_exactâ‚‚ _ (rot_of_distTriang _ (rot_of_distTriang _ hT)) f (by aesop_cat)"
Mathlib/SetTheory/Cardinal/SchroederBernstein.lean,Function.Embedding.schroeder_bernstein,schroeder_bernstein,2714dce065bad0ddf3bede6acabcadb21606d65b,":=
  by
  cases' isEmpty_or_nonempty Î² with hÎ² hÎ²
  Â· have : IsEmpty Î± := Function.isEmpty f
    exact âŸ¨_, ((Equiv.equivEmpty Î±).trans (Equiv.equivEmpty Î²).symm).bijectiveâŸ©
  set F : Set Î± â†’o Set Î± :=
    { toFun := fun s => (g '' (f '' s)á¶œ)á¶œ
      monotone' := fun s t hst =>
        compl_subset_compl.mpr <| image_subset _ <| compl_subset_compl.mpr <| image_subset _ hst }
  set s : Set Î± := OrderHom.lfp F
  have hs : (g '' (f '' s)á¶œ)á¶œ = s := F.map_lfp
  have hns : g '' (f '' s)á¶œ = sá¶œ := compl_injective (by simp [hs])
  set g' := invFun g
  have g'g : LeftInverse g' g := leftInverse_invFun hg
  have hg'ns : g' '' sá¶œ = (f '' s)á¶œ := by rw [â† hns, g'g.image_image]
  set h : Î± â†’ Î² := s.piecewise f g'
  have : Surjective h := by rw [â† range_iff_surjective, range_piecewise, hg'ns, union_compl_self]
  have : Injective h :=
    by
    refine' (injective_piecewise_iff _).2 âŸ¨hf.injOn _, _, _âŸ©
    Â· intro x hx y hy hxy
      obtain âŸ¨x', _, rflâŸ© : x âˆˆ g '' (f '' s)á¶œ := by rwa [hns]
      obtain âŸ¨y', _, rflâŸ© : y âˆˆ g '' (f '' s)á¶œ := by rwa [hns]
      rw [g'g _, g'g _] at hxy
      rw [hxy]
    Â· intro x hx y hy hxy
      obtain âŸ¨y', hy', rflâŸ© : y âˆˆ g '' (f '' s)á¶œ := by rwa [hns]
      rw [g'g _] at hxy
      exact hy' âŸ¨x, hx, hxyâŸ©
  exact âŸ¨h, â€¹Injective hâ€º, â€¹Surjective hâ€ºâŸ©","error:  application type mismatch
  And.intro (Injective.injOn hf ?m.1813)
argument
  Injective.injOn hf ?m.1813
has type
  âˆ€ â¦ƒxâ‚‚ : Î±â¦„, xâ‚‚ âˆˆ ?m.1811 â†’ f ?m.1812 = f xâ‚‚ â†’ ?m.1812 = xâ‚‚ : Prop
but is expected to have type
  InjOn f s : Prop","theorem schroeder_bernstein {f : Î± â†’ Î²} {g : Î² â†’ Î±} (hf : Function.Injective f)
    (hg : Function.Injective g) : âˆƒ h : Î± â†’ Î², Bijective h ",":= by
  cases' isEmpty_or_nonempty Î² with hÎ² hÎ²
  Â· have : IsEmpty Î± := Function.isEmpty f
    exact âŸ¨_, ((Equiv.equivEmpty Î±).trans (Equiv.equivEmpty Î²).symm).bijectiveâŸ©
  set F : Set Î± â†’o Set Î± :=
    { toFun := fun s => (g '' (f '' s)á¶œ)á¶œ
      monotone' := fun s t hst =>
        compl_subset_compl.mpr <| image_subset _ <| compl_subset_compl.mpr <| image_subset _ hst }
  set s : Set Î± := OrderHom.lfp F
  have hs : (g '' (f '' s)á¶œ)á¶œ = s := F.map_lfp
  have hns : g '' (f '' s)á¶œ = sá¶œ := compl_injective (by simp [hs])
  set g' := invFun g
  have g'g : LeftInverse g' g := leftInverse_invFun hg
  have hg'ns : g' '' sá¶œ = (f '' s)á¶œ := by rw [â† hns, g'g.image_image]
  set h : Î± â†’ Î² := s.piecewise f g'
  have : Surjective h := by rw [â† range_iff_surjective, range_piecewise, hg'ns, union_compl_self]
  have : Injective h := by
    refine (injective_piecewise_iff _).2 âŸ¨hf.injOn, ?_, ?_âŸ©
    Â· intro x hx y hy hxy
      obtain âŸ¨x', _, rflâŸ© : x âˆˆ g '' (f '' s)á¶œ := by rwa [hns]
      obtain âŸ¨y', _, rflâŸ© : y âˆˆ g '' (f '' s)á¶œ := by rwa [hns]
      rw [g'g _, g'g _] at hxy
      rw [hxy]
    Â· intro x hx y hy hxy
      obtain âŸ¨y', hy', rflâŸ© : y âˆˆ g '' (f '' s)á¶œ := by rwa [hns]
      rw [g'g _] at hxy
      exact hy' âŸ¨x, hx, hxyâŸ©
  exact âŸ¨h, â€¹Injective hâ€º, â€¹Surjective hâ€ºâŸ©"
Mathlib/MeasureTheory/Measure/Haar/Disintegration.lean,LinearMap.exists_map_addHaar_eq_smul_addHaar,LinearMap.exists_map_addHaar_eq_smul_addHaar,33a0a8d1e50659d291588035cb9d613ec3998630,":= by
  have : ProperSpace E := properSpace_of_locallyCompactSpace ğ•œ
  have : FiniteDimensional ğ•œ E := finiteDimensional_of_locallyCompactSpace ğ•œ
  have : ProperSpace F := by
    rcases subsingleton_or_nontrivial E with hE|hE
    Â· have : Subsingleton F := Function.Surjective.subsingleton h
      infer_instance
    Â· have : ProperSpace ğ•œ := properSpace_of_locallyCompact_module ğ•œ E
      have : FiniteDimensional ğ•œ F := Module.Finite.of_surjective L h
      exact FiniteDimensional.proper ğ•œ F
  let S : Submodule ğ•œ E := LinearMap.ker L
  obtain âŸ¨T, hTâŸ© : âˆƒ T : Submodule ğ•œ E, IsCompl S T := Submodule.exists_isCompl S
  let M : (S Ã— T) â‰ƒâ‚—[ğ•œ] E := Submodule.prodEquivOfIsCompl S T hT
  have M_cont : Continuous M.symm := LinearMap.continuous_of_finiteDimensional _
  let P : S Ã— T â†’â‚—[ğ•œ] T := LinearMap.snd ğ•œ S T
  have P_cont : Continuous P := LinearMap.continuous_of_finiteDimensional _
  have I : Function.Bijective (LinearMap.domRestrict L T) :=
    âŸ¨LinearMap.injective_domRestrict_iff.2 (IsCompl.inf_eq_bot hT.symm),
    (LinearMap.surjective_domRestrict_iff h).2 hT.symm.sup_eq_topâŸ©
  let L' : T â‰ƒâ‚—[ğ•œ] F := LinearEquiv.ofBijective (LinearMap.domRestrict L T) I
  have L'_cont : Continuous L' := LinearMap.continuous_of_finiteDimensional _
  have A : L = (L' : T â†’â‚—[ğ•œ] F).comp (P.comp (M.symm : E â†’â‚—[ğ•œ] (S Ã— T))) := by
    ext x
    obtain âŸ¨y, z, hyzâŸ© : âˆƒ (y : S) (z : T), M.symm x = (y, z) := âŸ¨_, _, rflâŸ©
    have : x = M (y, z) := by
      rw [â† hyz]; simp only [LinearEquiv.apply_symm_apply]
    simp [this]
  have I : Î¼.map L = ((Î¼.map M.symm).map P).map L' := by
    rw [Measure.map_map, Measure.map_map, A]
    Â· rfl
    Â· exact L'_cont.measurable.comp P_cont.measurable
    Â· exact M_cont.measurable
    Â· exact L'_cont.measurable
    Â· exact P_cont.measurable
  let Î¼S : Measure S := addHaar
  let Î¼T : Measure T := addHaar
  obtain âŸ¨câ‚€, câ‚€_pos, câ‚€_fin, hâ‚€âŸ© :
      âˆƒ câ‚€ : â„â‰¥0âˆ, câ‚€ â‰  0 âˆ§ câ‚€ â‰  âˆ âˆ§ Î¼.map M.symm = câ‚€ â€¢ Î¼S.prod Î¼T := by
    have : IsAddHaarMeasure (Î¼.map M.symm) :=
      M.toContinuousLinearEquiv.symm.isAddHaarMeasure_map Î¼
    refine âŸ¨addHaarScalarFactor (Î¼.map M.symm) (Î¼S.prod Î¼T), ?_, ENNReal.coe_ne_top,
      isAddHaarMeasure_eq_smul _ _âŸ©
    simpa only [ne_eq, ENNReal.coe_eq_zero] using
      (addHaarScalarFactor_pos_of_isOpenPosMeasure (Î¼.map M.symm) (Î¼S.prod Î¼T)).ne'
  have J : (Î¼S.prod Î¼T).map P = (Î¼S univ) â€¢ Î¼T := map_snd_prod
  obtain âŸ¨câ‚, câ‚_pos, câ‚_fin, hâ‚âŸ© : âˆƒ câ‚ : â„â‰¥0âˆ, câ‚ â‰  0 âˆ§ câ‚ â‰  âˆ âˆ§ Î¼T.map L' = câ‚ â€¢ Î½ := by
    have : IsAddHaarMeasure (Î¼T.map L') :=
      L'.toContinuousLinearEquiv.isAddHaarMeasure_map Î¼T
    refine âŸ¨addHaarScalarFactor (Î¼T.map L') Î½, ?_, ENNReal.coe_ne_top,
      isAddHaarMeasure_eq_smul _ _âŸ©
    simpa only [ne_eq, ENNReal.coe_eq_zero] using
      (addHaarScalarFactor_pos_of_isOpenPosMeasure (Î¼T.map L') Î½).ne'
  refine âŸ¨câ‚€ * câ‚, by simp [pos_iff_ne_zero, câ‚€_pos, câ‚_pos], ENNReal.mul_lt_top câ‚€_fin câ‚_fin, ?_âŸ©
  simp only [I, hâ‚€, Measure.map_smul, J, smul_smul, hâ‚]
  rw [mul_assoc, mul_comm _ câ‚, â† mul_assoc]","warning:  `properSpace_of_locallyCompactSpace` has been deprecated, use `ProperSpace.of_locallyCompactSpace` instead
warning:  `finiteDimensional_of_locallyCompactSpace` has been deprecated, use `FiniteDimensional.of_locallyCompactSpace` instead
warning:  `properSpace_of_locallyCompact_module` has been deprecated, use `ProperSpace.of_locallyCompact_module` instead
error:  unsolved goals
case h.intro.intro
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœÂ¹Â² : NontriviallyNormedField ğ•œ
instâœÂ¹Â¹ : CompleteSpace ğ•œ
instâœÂ¹â° : NormedAddCommGroup E
instâœâ¹ : MeasurableSpace E
instâœâ¸ : BorelSpace E
instâœâ· : NormedSpace ğ•œ E
instâœâ¶ : NormedAddCommGroup F
instâœâµ : MeasurableSpace F
instâœâ´ : BorelSpace F
instâœÂ³ : NormedSpace ğ•œ F
L : E â†’â‚—[ğ•œ] F
Î¼ : Measure E
Î½ : Measure F
instâœÂ² : Î¼.IsAddHaarMeasure
instâœÂ¹ : Î½.IsAddHaarMeasure
instâœ : LocallyCompactSpace E
h : Function.Surjective â‡‘L
thisâœÂ² : ProperSpace E
thisâœÂ¹ : FiniteDimensional ğ•œ E
thisâœ : ProperSpace F
S : Submodule ğ•œ E := ker L
T : Submodule ğ•œ E
hT : IsCompl S T
M : (â†¥S Ã— â†¥T) â‰ƒâ‚—[ğ•œ] E := S.prodEquivOfIsCompl T hT
M_cont : Continuous â‡‘M.symm
P : â†¥S Ã— â†¥T â†’â‚—[ğ•œ] â†¥T := snd ğ•œ â†¥S â†¥T
P_cont : Continuous â‡‘P
I : Function.Bijective â‡‘(L.domRestrict T)
L' : â†¥T â‰ƒâ‚—[ğ•œ] F := LinearEquiv.ofBijective (L.domRestrict T) I
L'_cont : Continuous â‡‘L'
x : E
y : â†¥S
z : â†¥T
hyz : M.symm x = (y, z)
this : x = M (y, z)
âŠ¢ L (M (y, z)) = L' (P (y, z))
warning:  `MeasureTheory.Measure.isAddHaarMeasure_eq_smul` has been deprecated, use `MeasureTheory.Measure.isAddLeftInvariant_eq_smul` instead
warning:  `MeasureTheory.Measure.addHaarScalarFactor_pos_of_isOpenPosMeasure` has been deprecated, use `MeasureTheory.Measure.addHaarScalarFactor_pos_of_isAddHaarMeasure` instead
warning:  `MeasureTheory.Measure.isAddHaarMeasure_eq_smul` has been deprecated, use `MeasureTheory.Measure.isAddLeftInvariant_eq_smul` instead
warning:  `MeasureTheory.Measure.addHaarScalarFactor_pos_of_isOpenPosMeasure` has been deprecated, use `MeasureTheory.Measure.addHaarScalarFactor_pos_of_isAddHaarMeasure` instead","theorem LinearMap.exists_map_addHaar_eq_smul_addHaar' (h : Function.Surjective L) :
    âˆƒ (c : â„â‰¥0âˆ), 0 < c âˆ§ c < âˆ âˆ§ Î¼.map L = (c * addHaar (univ : Set (LinearMap.ker L))) â€¢ Î½ ",":= by
  have : ProperSpace E := .of_locallyCompactSpace ğ•œ
  have : FiniteDimensional ğ•œ E := .of_locallyCompactSpace ğ•œ
  have : ProperSpace F := by
    rcases subsingleton_or_nontrivial E with hE|hE
    Â· have : Subsingleton F := Function.Surjective.subsingleton h
      infer_instance
    Â· have : ProperSpace ğ•œ := .of_locallyCompact_module ğ•œ E
      have : FiniteDimensional ğ•œ F := Module.Finite.of_surjective L h
      exact FiniteDimensional.proper ğ•œ F
  let S : Submodule ğ•œ E := LinearMap.ker L
  obtain âŸ¨T, hTâŸ© : âˆƒ T : Submodule ğ•œ E, IsCompl S T := Submodule.exists_isCompl S
  let M : (S Ã— T) â‰ƒâ‚—[ğ•œ] E := Submodule.prodEquivOfIsCompl S T hT
  have M_cont : Continuous M.symm := LinearMap.continuous_of_finiteDimensional _
  let P : S Ã— T â†’â‚—[ğ•œ] T := LinearMap.snd ğ•œ S T
  have P_cont : Continuous P := LinearMap.continuous_of_finiteDimensional _
  have I : Function.Bijective (LinearMap.domRestrict L T) :=
    âŸ¨LinearMap.injective_domRestrict_iff.2 (IsCompl.inf_eq_bot hT.symm),
    (LinearMap.surjective_domRestrict_iff h).2 hT.symm.sup_eq_topâŸ©
  let L' : T â‰ƒâ‚—[ğ•œ] F := LinearEquiv.ofBijective (LinearMap.domRestrict L T) I
  have L'_cont : Continuous L' := LinearMap.continuous_of_finiteDimensional _
  have A : L = (L' : T â†’â‚—[ğ•œ] F).comp (P.comp (M.symm : E â†’â‚—[ğ•œ] (S Ã— T))) := by
    ext x
    obtain âŸ¨y, z, hyzâŸ© : âˆƒ (y : S) (z : T), M.symm x = (y, z) := âŸ¨_, _, rflâŸ©
    have : x = M (y, z) := by
      rw [â† hyz]; simp only [LinearEquiv.apply_symm_apply]
    simp [L', P, M, this]
  have I : Î¼.map L = ((Î¼.map M.symm).map P).map L' := by
    rw [Measure.map_map, Measure.map_map, A]
    Â· rfl
    Â· exact L'_cont.measurable.comp P_cont.measurable
    Â· exact M_cont.measurable
    Â· exact L'_cont.measurable
    Â· exact P_cont.measurable
  let Î¼S : Measure S := addHaar
  let Î¼T : Measure T := addHaar
  obtain âŸ¨câ‚€, câ‚€_pos, câ‚€_fin, hâ‚€âŸ© :
      âˆƒ câ‚€ : â„â‰¥0âˆ, câ‚€ â‰  0 âˆ§ câ‚€ â‰  âˆ âˆ§ Î¼.map M.symm = câ‚€ â€¢ Î¼S.prod Î¼T := by
    have : IsAddHaarMeasure (Î¼.map M.symm) :=
      M.toContinuousLinearEquiv.symm.isAddHaarMeasure_map Î¼
    refine âŸ¨addHaarScalarFactor (Î¼.map M.symm) (Î¼S.prod Î¼T), ?_, ENNReal.coe_ne_top,
      isAddLeftInvariant_eq_smul _ _âŸ©
    simpa only [ne_eq, ENNReal.coe_eq_zero] using
      (addHaarScalarFactor_pos_of_isAddHaarMeasure (Î¼.map M.symm) (Î¼S.prod Î¼T)).ne'
  have J : (Î¼S.prod Î¼T).map P = (Î¼S univ) â€¢ Î¼T := map_snd_prod
  obtain âŸ¨câ‚, câ‚_pos, câ‚_fin, hâ‚âŸ© : âˆƒ câ‚ : â„â‰¥0âˆ, câ‚ â‰  0 âˆ§ câ‚ â‰  âˆ âˆ§ Î¼T.map L' = câ‚ â€¢ Î½ := by
    have : IsAddHaarMeasure (Î¼T.map L') :=
      L'.toContinuousLinearEquiv.isAddHaarMeasure_map Î¼T
    refine âŸ¨addHaarScalarFactor (Î¼T.map L') Î½, ?_, ENNReal.coe_ne_top,
      isAddLeftInvariant_eq_smul _ _âŸ©
    simpa only [ne_eq, ENNReal.coe_eq_zero] using
      (addHaarScalarFactor_pos_of_isAddHaarMeasure (Î¼T.map L') Î½).ne'
  refine âŸ¨câ‚€ * câ‚, by simp [pos_iff_ne_zero, câ‚€_pos, câ‚_pos], ENNReal.mul_lt_top câ‚€_fin câ‚_fin, ?_âŸ©
  simp only [I, hâ‚€, Measure.map_smul, J, smul_smul, hâ‚]
  rw [mul_assoc, mul_comm _ câ‚, â† mul_assoc]"
Mathlib/Topology/ClopenBox.lean,TopologicalSpace.Clopens.countable_iff_second_countable,TopologicalSpace.Clopens.countable_iff_second_countable,42e26ad0ad3b8af4218c37c36e545a8214eee836,":= by
  refine âŸ¨fun h â†¦ âŸ¨{s : Set X | IsClopen s}, ?_, ?_âŸ©, fun h â†¦ ?_âŸ©
  Â· let f : {s : Set X | IsClopen s} â†’ Clopens X := fun s â†¦ âŸ¨s.1, s.2âŸ©
    exact (injective_of_le_imp_le f fun a â†¦ a).countable
  Â· apply IsTopologicalBasis.eq_generateFrom
    exact loc_compact_Haus_tot_disc_of_zero_dim
  Â· have : âˆ€ (s : Clopens X), âˆƒ (t : Finset (countableBasis X)), s.1 = t.toSet.sUnion :=
      fun s â†¦ eq_sUnion_finset_of_isTopologicalBasis__of_isCompact_open _
        (isBasis_countableBasis X) s.1 s.2.1.isCompact s.2.2
    let f : Clopens X â†’ Finset (countableBasis X) := fun s â†¦ (this s).choose
    have hf : f.Injective := by
      intro s t (h : Exists.choose _ = Exists.choose _)
      ext1; change s.carrier = t.carrier
      rw [(this s).choose_spec, (this t).choose_spec, h]
    exact hf.countable",error:  unknown identifier 'eq_sUnion_finset_of_isTopologicalBasis__of_isCompact_open',"lemma TopologicalSpace.Clopens.countable_iff_second_countable [T2Space X]
    [TotallyDisconnectedSpace X] : Countable (Clopens X) â†” SecondCountableTopology X ",":= by
  refine âŸ¨fun h â†¦ âŸ¨{s : Set X | IsClopen s}, ?_, ?_âŸ©, fun h â†¦ ?_âŸ©
  Â· let f : {s : Set X | IsClopen s} â†’ Clopens X := fun s â†¦ âŸ¨s.1, s.2âŸ©
    exact (injective_of_le_imp_le f fun a â†¦ a).countable
  Â· apply IsTopologicalBasis.eq_generateFrom
    exact loc_compact_Haus_tot_disc_of_zero_dim
  Â· have : âˆ€ (s : Clopens X), âˆƒ (t : Finset (countableBasis X)), s.1 = t.toSet.sUnion :=
      fun s â†¦ eq_sUnion_finset_of_isTopologicalBasis_of_isCompact_open _
        (isBasis_countableBasis X) s.1 s.2.1.isCompact s.2.2
    let f : Clopens X â†’ Finset (countableBasis X) := fun s â†¦ (this s).choose
    have hf : f.Injective := by
      intro s t (h : Exists.choose _ = Exists.choose _)
      ext1; change s.carrier = t.carrier
      rw [(this s).choose_spec, (this t).choose_spec, h]
    exact hf.countable"
Mathlib/RingTheory/DedekindDomain/IntegralClosure.lean,IsIntegralClosure.isNoetherian,IsIntegralClosure.isNoetherian,8dba065d4a693e23ed06348923cd5effc765cb75,":= by
  haveI := Classical.decEq L
  obtain âŸ¨s, b, hb_intâŸ© := FiniteDimensional.exists_is_basis_integral A K L
  let b' := (traceForm K L).dualBasis (traceForm_nondegenerate K L) b
  letI := isNoetherian_span_of_finite A (Set.finite_range b')
  let f : C â†’â‚—[A] Submodule.span A (Set.range b') :=
    (Submodule.ofLe (IsIntegralClosure.range_le_span_dualBasis C b hb_int)).comp
      ((Algebra.linearMap C L).restrictScalars A).rangeRestrict
  refine' isNoetherian_of_ker_bot f _
  rw [LinearMap.ker_comp, Submodule.ker_ofLe, Submodule.comap_bot, LinearMap.ker_codRestrict]
  exact LinearMap.ker_eq_bot_of_injective (IsIntegralClosure.algebraMap_injective C A L)","error:  unknown constant 'Submodule.ofLe'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  LinearMap.ker (?g.comp ?f)
case intro.intro
R : Type u_1
A : Type u_2
K : Type u_3
instâœÂ¹â¸ : CommRing R
instâœÂ¹â· : CommRing A
instâœÂ¹â¶ : Field K
instâœÂ¹âµ : IsDomain A
instâœÂ¹â´ : Algebra A K
instâœÂ¹Â³ : IsFractionRing A K
L : Type u_4
instâœÂ¹Â² : Field L
C : Type u_5
instâœÂ¹Â¹ : CommRing C
instâœÂ¹â° : Algebra K L
instâœâ¹ : Algebra A L
instâœâ¸ : IsScalarTower A K L
instâœâ· : Algebra C L
instâœâ¶ : IsIntegralClosure C A L
instâœâµ : Algebra A C
instâœâ´ : IsScalarTower A C L
instâœÂ³ : FiniteDimensional K L
instâœÂ² : IsSeparable K L
instâœÂ¹ : IsIntegrallyClosed A
instâœ : IsNoetherianRing A
thisâœ : DecidableEq L
s : Finset L
b : Basis { x // x âˆˆ s } K L
hb_int : âˆ€ (x : { x // x âˆˆ s }), IsIntegral A (b x)
b' : Basis { x // x âˆˆ s } K L := (traceForm K L).dualBasis â‹¯ b
this : IsNoetherian A â†¥(Submodule.span A (Set.range â‡‘b')) := isNoetherian_span_of_finite A (Set.finite_range â‡‘b')
f : C â†’â‚—[A] â†¥(Submodule.span A (Set.range â‡‘b')) := sorryAx (C â†’â‚—[A] â†¥(Submodule.span A (Set.range â‡‘b'))) true
âŠ¢ LinearMap.ker f = âŠ¥","theorem IsIntegralClosure.isNoetherian [IsIntegrallyClosed A] [IsNoetherianRing A] :
    IsNoetherian A C ",":= by
  haveI := Classical.decEq L
  obtain âŸ¨s, b, hb_intâŸ© := FiniteDimensional.exists_is_basis_integral A K L
  let b' := (traceForm K L).dualBasis (traceForm_nondegenerate K L) b
  letI := isNoetherian_span_of_finite A (Set.finite_range b')
  let f : C â†’â‚—[A] Submodule.span A (Set.range b') :=
    (Submodule.inclusion (IsIntegralClosure.range_le_span_dualBasis C b hb_int)).comp
      ((Algebra.linearMap C L).restrictScalars A).rangeRestrict
  refine isNoetherian_of_ker_bot f ?_
  rw [LinearMap.ker_comp, Submodule.ker_inclusion, Submodule.comap_bot, LinearMap.ker_codRestrict]
  exact LinearMap.ker_eq_bot_of_injective (IsIntegralClosure.algebraMap_injective C A L)"
Mathlib/NumberTheory/Pell.lean,Pell.IsFundamental.exists_of_not_isSquare,exists_of_not_isSquare,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  let Î¾ : â„ := sqrt d
  have hÎ¾ : Irrational Î¾ := by
    refine' irrational_nrt_of_notint_nrt 2 d (sq_sqrt <| Int.cast_nonneg.mpr hâ‚€.le) _ two_pos
    rintro âŸ¨x, hxâŸ©
    refine' hd âŸ¨x, @Int.cast_injective â„ _ _ d (x * x) _âŸ©
    rw [â† sq_sqrt <| Int.cast_nonneg.mpr hâ‚€.le, Int.cast_mul, â† hx, sq]
  obtain âŸ¨M, hMâ‚âŸ© := exists_int_gt (2 * |Î¾| + 1)
  have hM : {q : â„š | |q.1 ^ 2 - d * (q.2 : â„¤) ^ 2| < M}.Infinite := by
    refine' Infinite.mono (fun q h => _) (infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational hÎ¾)
    have h0 : 0 < (q.2 : â„) ^ 2 := pow_pos (Nat.cast_pos.mpr q.pos) 2
    have h1 : (q.num : â„) / (q.den : â„) = q := mod_cast q.num_div_den
    rw [mem_setOf, abs_sub_comm, â† @Int.cast_lt â„, â† div_lt_div_right (abs_pos_of_pos h0)]
    push_cast
    rw [â† abs_div, abs_sq, sub_div, mul_div_cancel_rightâ‚€ _ h0.ne', â† div_pow, h1, â†
      sq_sqrt (Int.cast_pos.mpr hâ‚€).le, sq_sub_sq, abs_mul, â† mul_one_div]
    refine' mul_lt_mul'' (((abs_add Î¾ q).trans _).trans_lt hMâ‚) h (abs_nonneg _) (abs_nonneg _)
    rw [two_mul, add_assoc, add_le_add_iff_left, â† sub_le_iff_le_add']
    rw [mem_setOf, abs_sub_comm] at h
    refine' (abs_sub_abs_le_abs_sub (q : â„) Î¾).trans (h.le.trans _)
    rw [div_le_one h0, one_le_sq_iff_one_le_abs, Nat.abs_cast, Nat.one_le_cast]
    exact q.pos
  obtain âŸ¨m, hmâŸ© : âˆƒ m : â„¤, {q : â„š | q.1 ^ 2 - d * (q.den : â„¤) ^ 2 = m}.Infinite := by
    contrapose! hM
    simp only [not_infinite] at hM âŠ¢
    refine' (congr_arg _ (ext fun x => _)).mp (Finite.biUnion (finite_Ioo (-M) M) fun m _ => hM m)
    simp only [abs_lt, mem_setOf, mem_Ioo, mem_iUnion, exists_prop, exists_eq_right']
  have hmâ‚€ : m â‰  0 := by
    rintro rfl
    obtain âŸ¨q, hqâŸ© := hm.nonempty
    rw [mem_setOf, sub_eq_zero, mul_comm] at hq
    obtain âŸ¨a, haâŸ© := (Int.pow_dvd_pow_iff two_pos).mp âŸ¨d, hqâŸ©
    rw [ha, mul_pow, mul_right_inj' (pow_pos (Int.coe_nat_pos.mpr q.pos) 2).ne'] at hq
    exact hd âŸ¨a, sq a â–¸ hq.symmâŸ©
  haveI := neZero_iff.mpr (Int.natAbs_ne_zero.mpr hmâ‚€)
  let f : â„š â†’ ZMod m.natAbs Ã— ZMod m.natAbs := fun q => (q.num, q.den)
  obtain âŸ¨qâ‚, hâ‚ : qâ‚.num ^ 2 - d * (qâ‚.den : â„¤) ^ 2 = m,
      qâ‚‚, hâ‚‚ : qâ‚‚.num ^ 2 - d * (qâ‚‚.den : â„¤) ^ 2 = m, hne, hqfâŸ© :=
    hm.exists_ne_map_eq_of_mapsTo (mapsTo_univ f _) finite_univ
  obtain âŸ¨hq1 : (qâ‚.num : ZMod m.natAbs) = qâ‚‚.num, hq2 : (qâ‚.den : ZMod m.natAbs) = qâ‚‚.denâŸ© :=
    Prod.ext_iff.mp hqf
  have hdâ‚ : m âˆ£ qâ‚.num * qâ‚‚.num - d * (qâ‚.den * qâ‚‚.den) := by
    rw [â† Int.natAbs_dvd, â† ZMod.int_cast_zmod_eq_zero_iff_dvd]
    push_cast
    rw [hq1, hq2, â† sq, â† sq]
    norm_cast
    rw [ZMod.int_cast_zmod_eq_zero_iff_dvd, Int.natAbs_dvd, Nat.cast_pow, â† hâ‚‚]
  have hdâ‚‚ : m âˆ£ qâ‚.num * qâ‚‚.den - qâ‚‚.num * qâ‚.den := by
    rw [â† Int.natAbs_dvd, â† ZMod.int_cast_eq_int_cast_iff_dvd_sub]
    push_cast
    rw [hq1, hq2]
  replace hmâ‚€ : (m : â„š) â‰  0 := Int.cast_ne_zero.mpr hmâ‚€
  refine' âŸ¨(qâ‚.num * qâ‚‚.num - d * (qâ‚.den * qâ‚‚.den)) / m, (qâ‚.num * qâ‚‚.den - qâ‚‚.num * qâ‚.den) / m,
      _, _âŸ©
  Â· qify [hdâ‚, hdâ‚‚]
    field_simp [hmâ‚€]
    norm_cast
    conv_rhs =>
      rw [sq]
      congr
      Â· rw [â† hâ‚]
      Â· rw [â† hâ‚‚]
    push_cast
    ring
  Â· qify [hdâ‚‚]
    refine' div_ne_zero_iff.mpr âŸ¨_, hmâ‚€âŸ©
    exact mod_cast mt sub_eq_zero.mp (mt Rat.eq_iff_mul_eq_mul.mpr hne)","error:  application type mismatch
  Int.pow_dvd_pow_iff two_pos
argument
  two_pos
has type
  0 < 2 : Prop
but is expected to have type
  ?m.82608 â‰  0 : Prop
warning:  `Int.coe_nat_pos` has been deprecated, use `Int.natCast_pos` instead
warning:  `ZMod.int_cast_zmod_eq_zero_iff_dvd` has been deprecated, use `ZMod.intCast_zmod_eq_zero_iff_dvd` instead
warning:  `ZMod.int_cast_zmod_eq_zero_iff_dvd` has been deprecated, use `ZMod.intCast_zmod_eq_zero_iff_dvd` instead
warning:  `ZMod.int_cast_eq_int_cast_iff_dvd_sub` has been deprecated, use `ZMod.intCast_eq_intCast_iff_dvd_sub` instead","theorem exists_of_not_isSquare (hâ‚€ : 0 < d) (hd : Â¬IsSquare d) :
    âˆƒ x y : â„¤, x ^ 2 - d * y ^ 2 = 1 âˆ§ y â‰  0 ",":= by
  let Î¾ : â„ := âˆšd
  have hÎ¾ : Irrational Î¾ := by
    refine irrational_nrt_of_notint_nrt 2 d (sq_sqrt <| Int.cast_nonneg.mpr hâ‚€.le) ?_ two_pos
    rintro âŸ¨x, hxâŸ©
    refine hd âŸ¨x, @Int.cast_injective â„ _ _ d (x * x) ?_âŸ©
    rw [â† sq_sqrt <| Int.cast_nonneg.mpr hâ‚€.le, Int.cast_mul, â† hx, sq]
  obtain âŸ¨M, hMâ‚âŸ© := exists_int_gt (2 * |Î¾| + 1)
  have hM : {q : â„š | |q.1 ^ 2 - d * (q.2 : â„¤) ^ 2| < M}.Infinite := by
    refine Infinite.mono (fun q h => ?_) (infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational hÎ¾)
    have h0 : 0 < (q.2 : â„) ^ 2 := pow_pos (Nat.cast_pos.mpr q.pos) 2
    have h1 : (q.num : â„) / (q.den : â„) = q := mod_cast q.num_div_den
    rw [mem_setOf, abs_sub_comm, â† @Int.cast_lt â„, â† div_lt_div_right (abs_pos_of_pos h0)]
    push_cast
    rw [â† abs_div, abs_sq, sub_div, mul_div_cancel_rightâ‚€ _ h0.ne', â† div_pow, h1, â†
      sq_sqrt (Int.cast_pos.mpr hâ‚€).le, sq_sub_sq, abs_mul, â† mul_one_div]
    refine mul_lt_mul'' (((abs_add Î¾ q).trans ?_).trans_lt hMâ‚) h (abs_nonneg _) (abs_nonneg _)
    rw [two_mul, add_assoc, add_le_add_iff_left, â† sub_le_iff_le_add']
    rw [mem_setOf, abs_sub_comm] at h
    refine (abs_sub_abs_le_abs_sub (q : â„) Î¾).trans (h.le.trans ?_)
    rw [div_le_one h0, one_le_sq_iff_one_le_abs, Nat.abs_cast, Nat.one_le_cast]
    exact q.pos
  obtain âŸ¨m, hmâŸ© : âˆƒ m : â„¤, {q : â„š | q.1 ^ 2 - d * (q.den : â„¤) ^ 2 = m}.Infinite := by
    contrapose! hM
    simp only [not_infinite] at hM âŠ¢
    refine (congr_arg _ (ext fun x => ?_)).mp (Finite.biUnion (finite_Ioo (-M) M) fun m _ => hM m)
    simp only [abs_lt, mem_setOf, mem_Ioo, mem_iUnion, exists_prop, exists_eq_right']
  have hmâ‚€ : m â‰  0 := by
    rintro rfl
    obtain âŸ¨q, hqâŸ© := hm.nonempty
    rw [mem_setOf, sub_eq_zero, mul_comm] at hq
    obtain âŸ¨a, haâŸ© := (Int.pow_dvd_pow_iff two_ne_zero).mp âŸ¨d, hqâŸ©
    rw [ha, mul_pow, mul_right_inj' (pow_pos (Int.natCast_pos.mpr q.pos) 2).ne'] at hq
    exact hd âŸ¨a, sq a â–¸ hq.symmâŸ©
  haveI := neZero_iff.mpr (Int.natAbs_ne_zero.mpr hmâ‚€)
  let f : â„š â†’ ZMod m.natAbs Ã— ZMod m.natAbs := fun q => (q.num, q.den)
  obtain âŸ¨qâ‚, hâ‚ : qâ‚.num ^ 2 - d * (qâ‚.den : â„¤) ^ 2 = m,
      qâ‚‚, hâ‚‚ : qâ‚‚.num ^ 2 - d * (qâ‚‚.den : â„¤) ^ 2 = m, hne, hqfâŸ© :=
    hm.exists_ne_map_eq_of_mapsTo (mapsTo_univ f _) finite_univ
  obtain âŸ¨hq1 : (qâ‚.num : ZMod m.natAbs) = qâ‚‚.num, hq2 : (qâ‚.den : ZMod m.natAbs) = qâ‚‚.denâŸ© :=
    Prod.ext_iff.mp hqf
  have hdâ‚ : m âˆ£ qâ‚.num * qâ‚‚.num - d * (qâ‚.den * qâ‚‚.den) := by
    rw [â† Int.natAbs_dvd, â† ZMod.intCast_zmod_eq_zero_iff_dvd]
    push_cast
    rw [hq1, hq2, â† sq, â† sq]
    norm_cast
    rw [ZMod.intCast_zmod_eq_zero_iff_dvd, Int.natAbs_dvd, Nat.cast_pow, â† hâ‚‚]
  have hdâ‚‚ : m âˆ£ qâ‚.num * qâ‚‚.den - qâ‚‚.num * qâ‚.den := by
    rw [â† Int.natAbs_dvd, â† ZMod.intCast_eq_intCast_iff_dvd_sub]
    push_cast
    rw [hq1, hq2]
  replace hmâ‚€ : (m : â„š) â‰  0 := Int.cast_ne_zero.mpr hmâ‚€
  refine âŸ¨(qâ‚.num * qâ‚‚.num - d * (qâ‚.den * qâ‚‚.den)) / m, (qâ‚.num * qâ‚‚.den - qâ‚‚.num * qâ‚.den) / m,
      ?_, ?_âŸ©
  Â· qify [hdâ‚, hdâ‚‚]
    field_simp [hmâ‚€]
    norm_cast
    conv_rhs =>
      rw [sq]
      congr
      Â· rw [â† hâ‚]
      Â· rw [â† hâ‚‚]
    push_cast
    ring
  Â· qify [hdâ‚‚]
    refine div_ne_zero_iff.mpr âŸ¨?_, hmâ‚€âŸ©
    exact mod_cast mt sub_eq_zero.mp (mt Rat.eq_iff_mul_eq_mul.mpr hne)"
Mathlib/Order/UpperLower/Basic.lean,LowerSet.sdiff_le_left,sdiff_le_left,596865180ecc63dcd1d95809202e31027ac3ae38,:= diff_subset _ _,"error:  function expected at
  diff_subset ?m.701184
term has type
  ?m.701183 âˆˆ ?m.701181",lemma sdiff_le_left : s.sdiff t â‰¤ s ,:= diff_subset
Mathlib/Order/JordanHolder.lean,CompositionSeries.ext,ext,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  cases sâ‚; cases sâ‚‚
  dsimp at hl h
  subst hl
  simpa [Function.funext_iff] using h",error:  unknown identifier 'hl',"theorem ext {sâ‚ sâ‚‚ : CompositionSeries X} (h : âˆ€ x, x âˆˆ sâ‚ â†” x âˆˆ sâ‚‚) : sâ‚ = sâ‚‚ ",":=
  toList_injective <|
    List.eq_of_perm_of_sorted
      (by
        classical
        exact List.perm_of_nodup_nodup_toFinset_eq sâ‚.toList_nodup sâ‚‚.toList_nodup
          (Finset.ext <| by simpa only [List.mem_toFinset, RelSeries.mem_toList]))
      sâ‚.toList_sorted sâ‚‚.toList_sorted"
Mathlib/Analysis/Normed/Field/Basic.lean,nnnorm_pow_le,nnnorm_pow_le,bb57ebcc4194eb527dec55e15644d8e9cbdf30ca,"  | 1, _ => by simp only [pow_one]; rfl
  | n + 2, _ => by
    simpa only [pow_succ _ (n + 1)] using
      le_trans (nnnorm_mul_le _ _) (mul_le_mul_left' (nnnorm_pow_le' a n.succ_pos) _)","error:  type mismatch
  hâœ
has type
  â€–a ^ (n + 1) * a ^ n.succâ€–â‚Š â‰¤ â€–a ^ (n + 1)â€–â‚Š * â€–aâ€–â‚Š ^ n.succ : Prop
but is expected to have type
  â€–a ^ (n + 1) * aâ€–â‚Š â‰¤ â€–aâ€–â‚Š ^ (n + 1) * â€–aâ€–â‚Š : Prop","theorem nnnorm_pow_le' (a : Î±) : âˆ€ {n : â„•}, 0 < n â†’ â€–a ^ nâ€–â‚Š â‰¤ â€–aâ€–â‚Š ^ n
","  | 1, _ => by simp only [pow_one, le_rfl]
  | n + 2, _ => by
    simpa only [pow_succ' _ (n + 1)] using
      le_trans (nnnorm_mul_le _ _) (mul_le_mul_left' (nnnorm_pow_le' a n.succ_pos) _)"
Mathlib/Data/Finset/Fold.lean,Finset.fold_ite,fold_ite,c959b2f950b9c44268e36bcedef976356855e6fb,":= by
  classical
    induction' s with x s hx IH
    Â· simp [hb]
    Â· simp only [Finset.fold_insert hx]
      split_ifs with h
      Â· have : x âˆ‰ Finset.filter p s := by simp [hx]
        simp [Finset.filter_insert, h, Finset.fold_insert this, ha.assoc, IH]
      Â· have : x âˆ‰ Finset.filter (fun i => Â¬ p i) s := by simp [hx]
        simp [Finset.filter_insert, h, Finset.fold_insert this, IH, â† ha.assoc, hc.comm]","error:  simp made no progress
error:  no goals to be solved","theorem fold_ite' {g : Î± â†’ Î²} (hb : op b b = b) (p : Î± â†’ Prop) [DecidablePred p] :
    Finset.fold op b (fun i => ite (p i) (f i) (g i)) s =
      op (Finset.fold op b f (s.filter p)) (Finset.fold op b g (s.filter fun i => Â¬p i)) ",":= by
  classical
    induction' s using Finset.induction_on with x s hx IH
    Â· simp [hb]
    Â· simp only [Finset.fold_insert hx]
      split_ifs with h
      Â· have : x âˆ‰ Finset.filter p s := by simp [hx]
        simp [Finset.filter_insert, h, Finset.fold_insert this, ha.assoc, IH]
      Â· have : x âˆ‰ Finset.filter (fun i => Â¬ p i) s := by simp [hx]
        simp [Finset.filter_insert, h, Finset.fold_insert this, IH, â† ha.assoc, hc.comm]"
Mathlib/MeasureTheory/Function/LocallyIntegrable.lean,MeasureTheory.LocallyIntegrableOn.exists_nat_integrableOn,LocallyIntegrableOn.exists_nat_integrableOn,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  rcases hf.exists_countable_integrableOn with âŸ¨T, T_count, T_open, sT, hTâŸ©
  let T' : Set (Set X) := insert âˆ… T
  have T'_count : T'.Countable := Countable.insert âˆ… T_count
  have T'_ne : T'.Nonempty := by simp only [insert_nonempty]
  rcases T'_count.exists_eq_range T'_ne with âŸ¨u, huâŸ©
  refine' âŸ¨u, _, _, _âŸ©
  Â· intro n
    have : u n âˆˆ T' := by rw [hu]; exact mem_range_self n
    rcases mem_insert_iff.1 this with h|h
    Â· rw [h]
      exact isOpen_empty
    Â· exact T_open _ h
  Â· intro x hx
    obtain âŸ¨v, hv, h'vâŸ© : âˆƒ v, v âˆˆ T âˆ§ x âˆˆ v := by simpa only [mem_iUnion, exists_prop] using sT hx
    have : v âˆˆ range u := by rw [â† hu]; exact subset_insert âˆ… T hv
    obtain âŸ¨n, rflâŸ© : âˆƒ n, u n = v := by simpa only [mem_range] using this
    exact mem_iUnion_of_mem _ h'v
  Â· intro n
    have : u n âˆˆ T' := by rw [hu]; exact mem_range_self n
    rcases mem_insert_iff.1 this with h|h
    Â· simp only [h, empty_inter, integrableOn_empty]
    Â· exact hT _ h",error:  simp made no progress,"theorem LocallyIntegrableOn.exists_nat_integrableOn [SecondCountableTopology X]
    (hf : LocallyIntegrableOn f s Î¼) : âˆƒ u : â„• â†’ Set X,
    (âˆ€ n, IsOpen (u n)) âˆ§ (s âŠ† â‹ƒ n, u n) âˆ§ (âˆ€ n, IntegrableOn f (u n âˆ© s) Î¼) ",":= by
  rcases hf.exists_countable_integrableOn with âŸ¨T, T_count, T_open, sT, hTâŸ©
  let T' : Set (Set X) := insert âˆ… T
  have T'_count : T'.Countable := Countable.insert âˆ… T_count
  have T'_ne : T'.Nonempty := by simp only [T', insert_nonempty]
  rcases T'_count.exists_eq_range T'_ne with âŸ¨u, huâŸ©
  refine âŸ¨u, ?_, ?_, ?_âŸ©
  Â· intro n
    have : u n âˆˆ T' := by rw [hu]; exact mem_range_self n
    rcases mem_insert_iff.1 this with h|h
    Â· rw [h]
      exact isOpen_empty
    Â· exact T_open _ h
  Â· intro x hx
    obtain âŸ¨v, hv, h'vâŸ© : âˆƒ v, v âˆˆ T âˆ§ x âˆˆ v := by simpa only [mem_iUnion, exists_prop] using sT hx
    have : v âˆˆ range u := by rw [â† hu]; exact subset_insert âˆ… T hv
    obtain âŸ¨n, rflâŸ© : âˆƒ n, u n = v := by simpa only [mem_range] using this
    exact mem_iUnion_of_mem _ h'v
  Â· intro n
    have : u n âˆˆ T' := by rw [hu]; exact mem_range_self n
    rcases mem_insert_iff.1 this with h|h
    Â· simp only [h, empty_inter, integrableOn_empty]
    Â· exact hT _ h"
Mathlib/Algebra/DirectLimit.lean,Ring.DirectLimit.map_comp,map_comp,f9a92ed3d67873862051aaeedcedfa1472745048,":=
  DFunLike.ext _ _ fun x â†¦ (isEmpty_or_nonempty Î¹).elim (by subsingleton) fun _ â†¦
    x.induction_on fun i g â†¦ by simp","error:  unknown tactic
error:  unsolved goals
R : Type u
instâœÂ¹Â¹ : Ring R
Î¹ : Type v
instâœÂ¹â° : Preorder Î¹
G : Î¹ â†’ Type w
instâœâ¹ : (i : Î¹) â†’ AddCommGroup (G i)
instâœâ¸ : (i : Î¹) â†’ Module R (G i)
f : (i j : Î¹) â†’ i â‰¤ j â†’ G i â†’â‚—[R] G j
instâœâ· : DecidableEq Î¹
P : Type uâ‚
instâœâ¶ : AddCommGroup P
instâœâµ : Module R P
g : (i : Î¹) â†’ G i â†’â‚—[R] P
Hg : âˆ€ (i j : Î¹) (hij : i â‰¤ j) (x : G i), (g j) ((f i j hij) x) = (g i) x
G' : Î¹ â†’ Type v'
instâœâ´ : (i : Î¹) â†’ AddCommGroup (G' i)
instâœÂ³ : (i : Î¹) â†’ Module R (G' i)
f' : (i j : Î¹) â†’ i â‰¤ j â†’ G' i â†’â‚—[R] G' j
G'' : Î¹ â†’ Type v''
instâœÂ² : (i : Î¹) â†’ AddCommGroup (G'' i)
instâœÂ¹ : (i : Î¹) â†’ Module R (G'' i)
f'' : (i j : Î¹) â†’ i â‰¤ j â†’ G'' i â†’â‚—[R] G'' j
instâœ : IsDirected Î¹ fun x x_1 â†¦ x â‰¤ x_1
gâ‚ : (i : Î¹) â†’ G i â†’â‚—[R] G' i
gâ‚‚ : (i : Î¹) â†’ G' i â†’â‚—[R] G'' i
hgâ‚ : âˆ€ (i j : Î¹) (h : i â‰¤ j), gâ‚ j âˆ˜â‚— f i j h = f' i j h âˆ˜â‚— gâ‚ i
hgâ‚‚ : âˆ€ (i j : Î¹) (h : i â‰¤ j), gâ‚‚ j âˆ˜â‚— f' i j h = f'' i j h âˆ˜â‚— gâ‚‚ i
x : DirectLimit G f
âŠ¢ IsEmpty Î¹ â†’ ?m.223200","lemma map_comp [IsDirected Î¹ (Â· â‰¤ Â·)]
    (gâ‚ : (i : Î¹) â†’ G i â†’â‚—[R] G' i) (gâ‚‚ : (i : Î¹) â†’ G' i â†’â‚—[R] G'' i)
    (hgâ‚ : âˆ€ i j h, gâ‚ j âˆ˜â‚— f i j h = f' i j h âˆ˜â‚— gâ‚ i)
    (hgâ‚‚ : âˆ€ i j h, gâ‚‚ j âˆ˜â‚— f' i j h = f'' i j h âˆ˜â‚— gâ‚‚ i) :
    (map gâ‚‚ hgâ‚‚ âˆ˜â‚— map gâ‚ hgâ‚ :
      DirectLimit G f â†’â‚—[R] DirectLimit G'' f'') =
    (map (fun i â†¦ gâ‚‚ i âˆ˜â‚— gâ‚ i) fun i j h â†¦ by
        rw [LinearMap.comp_assoc, hgâ‚ i, â† LinearMap.comp_assoc, hgâ‚‚ i, LinearMap.comp_assoc] :
      DirectLimit G f â†’â‚—[R] DirectLimit G'' f'') ",":=
  DFunLike.ext _ _ fun x â†¦ (isEmpty_or_nonempty Î¹).elim (fun _ â†¦ Subsingleton.elim _ _) fun _ â†¦
    x.induction_on fun i g â†¦ by simp"
Mathlib/Geometry/Euclidean/Inversion/Calculus.lean,EuclideanGeometry.hasFDerivAt_inversion,hasFDerivAt_inversion,229bb6cbcc9a67aabf677431de0faf2f1866dbf7,":= by
  rcases add_left_surjective c x with âŸ¨x, rflâŸ©
  have : HasFDerivAt (inversion c R) (_ : F â†’L[â„] F) (c + x)
  Â· simp_rw [inversion, dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ğ•œ := â„) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := â„ âˆ™ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy â†¦ ?_)
  Â· have : ((â€–xâ€– ^ 2) ^ 2)â»Â¹ * (â€–xâ€– ^ 2) = (â€–xâ€– ^ 2)â»Â¹
    Â· rw [â† div_eq_inv_mul, sq (â€–xâ€– ^ 2), div_self_mul_self']
    dsimp
    simp only [add_sub_cancel', ContinuousLinearMap.comp_id, neg_smul, smul_neg,
      dist_self_add_left, div_eq_mul_inv, mul_pow, inv_pow, eqOn_singleton,
      ContinuousLinearMap.add_apply, ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_id', Pi.smul_apply, id_eq, ContinuousLinearMap.smulRight_apply,
      ContinuousLinearMap.neg_apply, innerSL_apply_coe, nsmul_eq_mul, Nat.cast_ofNat,
      two_mul, smul_add, Pi.add_apply, neg_add_rev, add_smul,
      reflection_orthogonalComplement_singleton_eq_neg]
    rw [Pi.smul_apply, Pi.smul_apply, real_inner_self_eq_norm_sq]
    simp only [smul_eq_mul, this, add_neg_cancel_comm_assoc]
  Â· simp only [id_eq, Function.comp_apply, add_sub_cancel', ContinuousLinearMap.comp_id,
      neg_smul, smul_neg, ContinuousLinearMap.add_apply, ContinuousLinearMap.coe_smul',
      ContinuousLinearMap.coe_id', Pi.smul_apply, ContinuousLinearMap.smulRight_apply,
      ContinuousLinearMap.neg_apply, innerSL_apply_coe, nsmul_eq_mul, Nat.cast_ofNat,
      dist_self_add_left, div_eq_mul_inv, mul_pow, inv_pow, ContinuousLinearEquiv.coe_coe,
      LinearIsometryEquiv.coe_coe, reflection_mem_subspace_eq_self hy, add_right_eq_self,
      neg_eq_zero, smul_eq_zero]
    rw [Pi.smul_apply, Pi.smul_apply]
    simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]","error:  unexpected token 'Â·'; expected '|'
error:  don't know how to synthesize placeholder for argument 'f''
context:
E : Type u_1
F : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace â„ E
instâœÂ¹ : NormedAddCommGroup F
instâœ : InnerProductSpace â„ F
a b c d y z : F
r R : â„
x : F
hx : (fun x â†¦ c + x) x â‰  c
âŠ¢ F â†’L[â„] F
error:  unsolved goals
case intro
E : Type u_1
F : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace â„ E
instâœÂ¹ : NormedAddCommGroup F
instâœ : InnerProductSpace â„ F
a b c d y z : F
r R : â„
x : F
hx : (fun x â†¦ c + x) x â‰  c
âŠ¢ HasFDerivAt (inversion c R)
    ((R / dist ((fun x â†¦ c + x) x) c) ^ 2 â€¢
      â†‘{ toLinearEquiv := (reflection (Submodule.span â„ {(fun x â†¦ c + x) x - c})á—®).toLinearEquiv, continuous_toFun := â‹¯,
          continuous_invFun := â‹¯ })
    ((fun x â†¦ c + x) x)","theorem hasFDerivAt_inversion (hx : x â‰  c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 â€¢ (reflection (â„ âˆ™ (x - c))á—® : F â†’L[â„] F)) x ",":= by
  rcases add_left_surjective c x with âŸ¨x, rflâŸ©
  have : HasFDerivAt (inversion c R) (?_ : F â†’L[â„] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ğ•œ := â„) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := â„ âˆ™ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy â†¦ ?_)
  Â· have : ((â€–xâ€– ^ 2) ^ 2)â»Â¹ * (â€–xâ€– ^ 2) = (â€–xâ€– ^ 2)â»Â¹ := by
      rw [â† div_eq_inv_mul, sq (â€–xâ€– ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  Â· simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]"
Mathlib/GroupTheory/Schreier.lean,Subgroup.card_commutator_le_of_finite_commutatorSet,card_commutator_le_of_finite_commutatorSet,a2d4b97db742cef33d7ce3404f92ab85330707e5,":= by
  have h1 := index_center_le_pow (closureCommutatorRepresentatives G)
  have h2 := card_commutator_dvd_index_center_pow (closureCommutatorRepresentatives G)
  rw [card_commutatorSet_closureCommutatorRepresentatives] at h1 h2
  rw [card_commutator_closureCommutatorRepresentatives] at h2
  replace h1 :=
    h1.trans
      (Nat.pow_le_pow_of_le_right Finite.card_pos (rank_closureCommutatorRepresentatives_le G))
  replace h2 := h2.trans (pow_dvd_pow _ (add_le_add_right (mul_le_mul_right' h1 _) 1))
  rw [â† pow_succ'] at h2
  refine' (Nat.le_of_dvd _ h2).trans (Nat.pow_le_pow_left h1 _)
  exact pow_pos (Nat.pos_of_ne_zero FiniteIndex.finiteIndex) _","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * ?a ^ ?n
G : Type u_1
instâœÂ¹ : Group G
H : Subgroup G
R S : Set G
instâœ : Finite â†‘(commutatorSet G)
h1 :
  (center â†¥(closureCommutatorRepresentatives G)).index â‰¤ Nat.card â†‘(commutatorSet G) ^ (2 * Nat.card â†‘(commutatorSet G))
h2 :
  Nat.card â†¥(_root_.commutator G) âˆ£
    (center â†¥(closureCommutatorRepresentatives G)).index ^
      (Nat.card â†‘(commutatorSet G) ^ (2 * Nat.card â†‘(commutatorSet G)) * Nat.card â†‘(commutatorSet G) + 1)
âŠ¢ Nat.card â†¥(_root_.commutator G) â‰¤ cardCommutatorBound (Nat.card â†‘(commutatorSet G))","theorem card_commutator_le_of_finite_commutatorSet [Finite (commutatorSet G)] :
    Nat.card (_root_.commutator G) â‰¤ cardCommutatorBound (Nat.card (commutatorSet G)) ",":= by
  have h1 := index_center_le_pow (closureCommutatorRepresentatives G)
  have h2 := card_commutator_dvd_index_center_pow (closureCommutatorRepresentatives G)
  rw [card_commutatorSet_closureCommutatorRepresentatives] at h1 h2
  rw [card_commutator_closureCommutatorRepresentatives] at h2
  replace h1 :=
    h1.trans
      (Nat.pow_le_pow_of_le_right Finite.card_pos (rank_closureCommutatorRepresentatives_le G))
  replace h2 := h2.trans (pow_dvd_pow _ (add_le_add_right (mul_le_mul_right' h1 _) 1))
  rw [â† pow_succ] at h2
  refine (Nat.le_of_dvd ?_ h2).trans (Nat.pow_le_pow_left h1 _)
  exact pow_pos (Nat.pos_of_ne_zero FiniteIndex.finiteIndex) _"
Mathlib/FieldTheory/PrimitiveElement.lean,Field.exists_primitive_element_of_finite_top,exists_primitive_element_of_finite_top,4e8bae583b52e0844d277a19d99ae61e70771989,":= by
  obtain âŸ¨Î±, hÎ±âŸ© := @IsCyclic.exists_generator EË£ _ _
  use Î±
  rw [eq_top_iff]
  rintro x -
  by_cases hx : x = 0
  Â· rw [hx]
    exact FâŸ®Î±.valâŸ¯.zero_mem
  Â· obtain âŸ¨n, hnâŸ© := Set.mem_range.mp (hÎ± (Units.mk0 x hx))
    simp only at hn
    rw [show x = Î± ^ n by norm_cast; rw [hn, Units.val_mk0]]
    exact zpow_mem (mem_adjoin_simple_self F (E := E) â†‘Î±) n",error:  simp made no progress,"theorem exists_primitive_element_of_finite_top [Finite E] : âˆƒ Î± : E, FâŸ®Î±âŸ¯ = âŠ¤ ",":= by
  obtain âŸ¨Î±, hÎ±âŸ© := @IsCyclic.exists_generator EË£ _ _
  use Î±
  rw [eq_top_iff]
  rintro x -
  by_cases hx : x = 0
  Â· rw [hx]
    exact FâŸ®Î±.valâŸ¯.zero_mem
  Â· obtain âŸ¨n, hnâŸ© := Set.mem_range.mp (hÎ± (Units.mk0 x hx))
    rw [show x = Î± ^ n by norm_cast; rw [hn, Units.val_mk0]]
    exact zpow_mem (mem_adjoin_simple_self F (E := E) â†‘Î±) n"
Mathlib/Analysis/InnerProductSpace/Positive.lean,ContinuousLinearMap.isPositive_zero,isPositive_zero,1c643aca968064296312bf5328c84d0c50cfe5ae,":= by
  refine âŸ¨.zero _, fun x => ?_âŸ©
  change 0 â‰¤ re âŸª_, _âŸ«
  rw [zero_apply, inner_zero_left, ZeroHomClass.map_zero]","error:  invalid dotted identifier notation, unknown identifier `IsSelfAdjoint.zero` from expected type
  IsSelfAdjoint 0
error:  invalid dotted identifier notation, unknown identifier `Eq.zero` from expected type
  IsSelfAdjoint 0",theorem isPositive_zero : IsPositive (0 : E â†’L[ğ•œ] E) ,":= by
  refine âŸ¨isSelfAdjoint_zero _, fun x => ?_âŸ©
  change 0 â‰¤ re âŸª_, _âŸ«
  rw [zero_apply, inner_zero_left, ZeroHomClass.map_zero]"
Mathlib/Data/Finset/Sort.lean,Finset.orderEmbOfFin_eq_orderEmbOfFin_iff,orderEmbOfFin_eq_orderEmbOfFin_iff,10dd3d5e04c8f66f1a4b067901ed215d4e57101b,":= by
  substs k l
  exact (s.orderEmbOfFin rfl).eq_iff_eq.trans Fin.ext_iff
  finset.order_emb_of_fin_eq_order_emb_of_fin_iff Finset.orderEmbOfFin_eq_orderEmbOfFin_iff",error:  unknown tactic,"theorem orderEmbOfFin_eq_orderEmbOfFin_iff {k l : â„•} {s : Finset Î±} {i : Fin k} {j : Fin l}
    {h : s.card = k} {h' : s.card = l} :
    s.orderEmbOfFin h i = s.orderEmbOfFin h' j â†” (i : â„•) = (j : â„•) ",":= by
  substs k l
  exact (s.orderEmbOfFin rfl).eq_iff_eq.trans Fin.ext_iff"
Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean,WeierstrassCurve.Jacobian.equiv_of_Z_eq_zero,equiv_of_Z_eq_zero,fa01869a99ed2fbab2a8018d7b90f0b21bff1372,":= by
  rw [â† fin3_def P, hPz] at hP âŠ¢
  rw [â† fin3_def Q, hQz] at hQ âŠ¢
  simp [nonsingular_iff, equation_iff] at hP hQ
  have hPx : P x â‰  0 := fun h => by simp [h] at hP; simp [hP] at hP
  have hQx : Q x â‰  0 := fun h => by simp [h] at hQ; simp [hQ] at hQ
  have hPy : P y â‰  0 := fun h => by simp [h] at hP; exact hPx <| pow_eq_zero hP.left.symm
  have hQy : Q y â‰  0 := fun h => by simp [h] at hQ; exact hQx <| pow_eq_zero hQ.left.symm
  use Units.mk0 _ <| mul_ne_zero (div_ne_zero hPy hPx) (div_ne_zero hQx hQy)
  simp [smul_fin3, mul_pow, div_pow]
  congr! 2
  Â· field_simp [hP.left, hQ.left]
    ring1
  Â· field_simp [â† hP.left, â† hQ.left]
    ring1","error:  application type mismatch
  pow_eq_zero (Eq.symm hP.left)
argument
  Eq.symm hP.left
has type
  0 = P x : Prop
but is expected to have type
  P x ^ ?m.312435 = 0 : Prop
error:  unsolved goals
R : Type u
instâœÂ¹ : CommRing R
W' : Jacobian R
F : Type v
instâœ : Field F
W : Jacobian F
P Q : Fin 3 â†’ F
hPz : P z = 0
hQz : Q z = 0
hQ : Q y ^ 2 - Q x ^ 3 = 0 âˆ§ (Â¬3 = 0 âˆ§ Â¬Q x = 0 âˆ¨ Â¬2 = 0 âˆ§ Â¬Q y = 0 âˆ¨ (Â¬W.aâ‚ = 0 âˆ§ Â¬Q x = 0) âˆ§ Â¬Q y = 0)
hPx : P x â‰  0
hQx : Q x â‰  0
h : P y = 0
hP : P x = 0 âˆ§ Â¬3 = 0 âˆ§ Â¬P x = 0
âŠ¢ False
error:  application type mismatch
  pow_eq_zero (Eq.symm hQ.left)
argument
  Eq.symm hQ.left
has type
  0 = Q x : Prop
but is expected to have type
  Q x ^ ?m.313674 = 0 : Prop
error:  unsolved goals
R : Type u
instâœÂ¹ : CommRing R
W' : Jacobian R
F : Type v
instâœ : Field F
W : Jacobian F
P Q : Fin 3 â†’ F
hPz : P z = 0
hQz : Q z = 0
hP : P y ^ 2 - P x ^ 3 = 0 âˆ§ (Â¬3 = 0 âˆ§ Â¬P x = 0 âˆ¨ Â¬2 = 0 âˆ§ Â¬P y = 0 âˆ¨ (Â¬W.aâ‚ = 0 âˆ§ Â¬P x = 0) âˆ§ Â¬P y = 0)
hPx : P x â‰  0
hQx : Q x â‰  0
hPy : P y â‰  0
h : Q y = 0
hQ : Q x = 0 âˆ§ Â¬3 = 0 âˆ§ Â¬Q x = 0
âŠ¢ False
error:  simp made no progress
error:  no goals to be solved","lemma equiv_of_Z_eq_zero {P Q : Fin 3 â†’ F} (hP : W.Nonsingular P) (hQ : W.Nonsingular Q)
    (hPz : P z = 0) (hQz : Q z = 0) : P â‰ˆ Q ",":= by
  have hPx : IsUnit <| P x := isUnit_X_of_Z_eq_zero hP hPz
  have hPy : IsUnit <| P y := isUnit_Y_of_Z_eq_zero hP hPz
  have hQx : IsUnit <| Q x := isUnit_X_of_Z_eq_zero hQ hQz
  have hQy : IsUnit <| Q y := isUnit_Y_of_Z_eq_zero hQ hQz
  simp only [nonsingular_of_Z_eq_zero, equation_of_Z_eq_zero, hPz, hQz] at hP hQ
  use (hPy.unit / hPx.unit) * (hQx.unit / hQy.unit)
  simp only [Units.smul_def, smul_fin3, Units.val_mul, Units.val_div_eq_div_val, IsUnit.unit_spec,
    mul_pow, div_pow, hQz, mul_zero]
  conv_rhs => rw [â† fin3_def P, hPz]
  congr! 2
  Â· rw [hP.left, pow_succ, (hPx.pow 2).mul_div_cancel_left, hQ.left, pow_succ _ 2,
      (hQx.pow 2).div_mul_cancel_left, hQx.inv_mul_cancel_right]
  Â· rw [â† hP.left, pow_succ, (hPy.pow 2).mul_div_cancel_left, â† hQ.left, pow_succ _ 2,
      (hQy.pow 2).div_mul_cancel_left, hQy.inv_mul_cancel_right]"
Mathlib/RingTheory/LocalProperties.lean,localization_finite,localization_finite,40b64f797572a7615ba4553a28d3d6ee5049aa3b,":= by
  introv R hf
  letI := f.toAlgebra
  letI := ((algebraMap S S').comp f).toAlgebra
  let f' : R' â†’+* S' := IsLocalization.map S' f (Submonoid.le_comap_map M)
  letI := f'.toAlgebra
  haveI : IsScalarTower R R' S' := IsScalarTower.of_algebraMap_eq'
    (IsLocalization.map_comp M.le_comap_map).symm
  let fâ‚ : S â†’â‚[R] S' := AlgHom.mk' (algebraMap S S') fun c x => RingHom.map_mul _ _ _
  obtain âŸ¨T, hTâŸ© := hf
  use T.image (algebraMap S S')
  rw [eq_top_iff]
  rintro x -
  obtain âŸ¨y, âŸ¨_, âŸ¨r, hr, rflâŸ©âŸ©, rflâŸ© := IsLocalization.mk'_surjective (M.map f) x
  rw [IsLocalization.mk'_eq_mul_mk'_one, mul_comm, Finset.coe_image]
  have hy : y âˆˆ Submodule.span R â†‘T := by rw [hT]; trivial
  replace hy : algebraMap S S' y âˆˆ Submodule.map fâ‚.toLinearMap (Submodule.span R (T : Set S)) :=
    Submodule.mem_map_of_mem hy
  rw [Submodule.map_span fâ‚.toLinearMap T] at hy
  have H : Submodule.span R (algebraMap S S' '' T) â‰¤
      (Submodule.span R' (algebraMap S S' '' T)).restrictScalars R := by
    rw [Submodule.span_le]; exact Submodule.subset_span
  convert (Submodule.span R' (algebraMap S S' '' T)).smul_mem
    (IsLocalization.mk' R' (1 : R) âŸ¨r, hrâŸ©) (H hy) using 1
  rw [Algebra.smul_def]
  erw [IsLocalization.map_mk' M.le_comap_map]
  rw [map_one]","error:  failed to synthesize
  SemilinearMapClass (S â†’+* S') ?m.180136 S S'
use `set_option diagnostics true` to get diagnostic information",theorem localization_finite : RingHom.LocalizationPreserves @RingHom.Finite ,":= by
  introv R hf
  letI := f.toAlgebra
  letI := ((algebraMap S S').comp f).toAlgebra
  let f' : R' â†’+* S' := IsLocalization.map S' f (Submonoid.le_comap_map M)
  letI := f'.toAlgebra
  have : IsScalarTower R R' S' := IsScalarTower.of_algebraMap_eq'
    (IsLocalization.map_comp M.le_comap_map).symm
  have : IsScalarTower R S S' := IsScalarTower.of_algebraMap_eq' rfl
  have : IsLocalization (Algebra.algebraMapSubmonoid S M) S' := by
    rwa [Algebra.algebraMapSubmonoid, RingHom.algebraMap_toAlgebra]
  have : Module.Finite R S := hf
  apply Module.Finite_of_isLocalization R S R' S' M"
Mathlib/RingTheory/Adjoin/PowerBasis.lean,PowerBasis.repr_mul_isIntegral,repr_mul_isIntegral,a76dc22f3a90e5ab96e9284d30276a87a4324a5d,":= by
  intro i
  rw [â† B.basis.sum_repr x, â† B.basis.sum_repr y, Finset.sum_mul_sum, map_sum, Finset.sum_apply']
  refine' IsIntegral.sum _ fun I _ => _
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smulâ‚›â‚—,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine' IsIntegral.mul (hy _) (IsIntegral.mul (hx _) _)
  simp only [coe_basis, â† pow_add]
  refine' repr_gen_pow_isIntegral hB hmin _ _","error:  type mismatch
  IsIntegral.mul (hy ?m.63129) (IsIntegral.mul (hx ?m.63330) ?m.63331)
has type
  IsIntegral R ((B.basis.repr y) ?m.63129 * ((B.basis.repr x) ?m.63330 * ?m.63147)) : Prop
but is expected to have type
  IsIntegral R
    ((B.basis.repr (âˆ‘ x_1 : Fin B.dim, (B.basis.repr y) x_1 â€¢ (B.basis.repr x) I â€¢ (B.basis I * B.basis x_1))) i) : Prop
error:  application type mismatch
  repr_mul_isIntegral hB
argument
  hB
has type
  IsIntegral R B.gen : Prop
but is expected to have type
  âˆ€ (i : Fin ?m.77814.dim), IsIntegral ?m.77807 ((?m.77814.basis.repr ?m.77816) i) : Prop
error:  application type mismatch
  repr_pow_isIntegral hB
argument
  hB
has type
  IsIntegral R B.gen : Prop
but is expected to have type
  âˆ€ (i : Fin ?m.84086.dim), IsIntegral ?m.84079 ((?m.84086.basis.repr ?m.84088) i) : Prop
error:  no goals to be solved","theorem repr_mul_isIntegral [IsDomain S] {x y : A} (hx : âˆ€ i, IsIntegral R (B.basis.repr x i))
    (hy : âˆ€ i, IsIntegral R (B.basis.repr y i))
    (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) :
    âˆ€ i, IsIntegral R (B.basis.repr (x * y) i) ",":= by
  intro i
  rw [â† B.basis.sum_repr x, â† B.basis.sum_repr y, Finset.sum_mul_sum, â† Finset.sum_product',
    map_sum, Finset.sum_apply']
  refine IsIntegral.sum _ fun I _ => ?_
  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smulâ‚›â‚—,
    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]
  refine (hy _).mul ((hx _).mul ?_)
  simp only [coe_basis, â† pow_add]
  exact repr_gen_pow_isIntegral hB hmin _ _"
Mathlib/NumberTheory/LegendreSymbol/QuadraticChar/GaussSum.lean,FiniteField.isSquare_neg_two_iff,FiniteField.isSquare_neg_two_iff,0829989fb05c0f3d0ef2ff405811515ae4ea6aa2,":= by
  classical
  by_cases hF : ringChar F = 2
  focus
    have h := FiniteField.even_card_of_char_two hF
    simp only [FiniteField.isSquare_of_char_two hF, true_iff_iff]
  rotate_left
  focus
    have h := FiniteField.odd_card_of_char_ne_two hF
    rw [â† quadraticChar_one_iff_isSquare (neg_ne_zero.mpr (Ring.two_ne_zero hF)),
      quadraticChar_neg_two hF, Ï‡â‚ˆ'_nat_eq_if_mod_eight]
    simp only [h, Nat.one_ne_zero, if_false, ite_eq_left_iff, Ne.def, (by decide : (-1 : â„¤) â‰  1),
      imp_false, Classical.not_not]
  all_goals
    rw [â† Nat.mod_mod_of_dvd _ (by decide : 2 âˆ£ 8)] at h
    have hâ‚ := Nat.mod_lt (Fintype.card F) (by decide : 0 < 8)
    revert hâ‚ h
    generalize Fintype.card F % 8 = n
    intros; interval_cases n <;> simp_all ","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.24683 â†’ ?m.24683 â†’ Prop","theorem FiniteField.isSquare_neg_two_iff :
    IsSquare (-2 : F) â†” Fintype.card F % 8 â‰  5 âˆ§ Fintype.card F % 8 â‰  7 ",":= by
  classical
  by_cases hF : ringChar F = 2
  Â· have h := FiniteField.even_card_of_char_two hF
    simp only [FiniteField.isSquare_of_char_two hF, true_iff_iff]
    omega
  Â· have h := FiniteField.odd_card_of_char_ne_two hF
    rw [â† quadraticChar_one_iff_isSquare (neg_ne_zero.mpr (Ring.two_ne_zero hF)),
      quadraticChar_neg_two hF, Ï‡â‚ˆ'_nat_eq_if_mod_eight]
    omega"
Mathlib/MeasureTheory/SetSemiring.lean,MeasureTheory.IsSetSemiring.exists_disjoint_finset_diff_eq,exists_disjoint_finset_diff_eq,399f04bf3c57d43d9f70a32662007a7562003890,":= by
  classical
  induction I using Finset.induction with
  | empty =>
    simp only [coe_empty, sUnion_empty, diff_empty, exists_prop]
    refine âŸ¨{s}, singleton_subset_set_iff.mpr hs, ?_âŸ©
    simp only [coe_singleton, pairwiseDisjoint_singleton, sUnion_singleton, eq_self_iff_true,
      and_self_iff]
  | @insert t I' _ h => ?_

  rw [coe_insert] at hI
  have ht : t âˆˆ C := hI (Set.mem_insert _ _)
  obtain âŸ¨J, h_ss, h_dis, h_eqâŸ© := h ((Set.subset_insert _ _).trans hI)
  let Ju : âˆ€ u âˆˆ C, Finset (Set Î±) := fun u hu â†¦ hC.diffFinset hu ht
  have hJu_subset : âˆ€ (u) (hu : u âˆˆ C), â†‘(Ju u hu) âŠ† C := by
    intro u hu x hx
    exact hC.diffFinset_subset hu ht hx
  have hJu_disj : âˆ€ (u) (hu : u âˆˆ C), (Ju u hu : Set (Set Î±)).PairwiseDisjoint id := fun u hu â†¦
    hC.pairwiseDisjoint_diffFinset hu ht
  have hJu_sUnion : âˆ€ (u) (hu : u âˆˆ C), â‹ƒâ‚€ (Ju u hu : Set (Set Î±)) = u \ t :=
    fun u hu â†¦ hC.sUnion_diffFinset hu ht
  have hJu_disj' : âˆ€ (u) (hu : u âˆˆ C) (v) (hv : v âˆˆ C) (_h_dis : Disjoint u v),
      Disjoint (â‹ƒâ‚€ (Ju u hu : Set (Set Î±))) (â‹ƒâ‚€ â†‘(Ju v hv)) :=by
    intro u hu v hv huv_disj
    rw [hJu_sUnion, hJu_sUnion]
    exact disjoint_of_subset (Set.diff_subset u t) (Set.diff_subset v t) huv_disj
  let J' : Finset (Set Î±) := Finset.biUnion (Finset.univ : Finset J) fun u â†¦ Ju u (h_ss u.prop)
  have hJ'_subset : â†‘J' âŠ† C := by
    intro u
    simp only [Subtype.coe_mk, univ_eq_attach, coe_biUnion, mem_coe, mem_attach, iUnion_true,
      mem_iUnion, Finset.exists_coe, bex_imp]
    intro v hv huvt
    exact hJu_subset v (h_ss hv) huvt
  refine âŸ¨J', hJ'_subset, ?_, ?_âŸ©
  Â· rw [Finset.coe_biUnion]
    refine PairwiseDisjoint.biUnion ?_ ?_
    Â· simp only [univ_eq_attach, mem_coe, id.def, iSup_eq_iUnion]
      simp_rw [PairwiseDisjoint, Set.Pairwise, Function.onFun]
      intro x _ y _ hxy
      have hxy_disj : Disjoint (x : Set Î±) y := by
        by_contra h_contra
        refine hxy ?_
        refine Subtype.ext ?_
        exact h_dis.elim x.prop y.prop h_contra
      convert hJu_disj' (x : Set Î±) (h_ss x.prop) y (h_ss y.prop) hxy_disj
      Â· rw [sUnion_eq_biUnion]
        congr
      Â· rw [sUnion_eq_biUnion]
        congr
    Â· exact fun u _ â†¦ hJu_disj _ _
  Â· rw [coe_insert, sUnion_insert, Set.union_comm, â† Set.diff_diff, h_eq]
    simp_rw [sUnion_eq_biUnion, Set.iUnion_diff]
    simp only [Subtype.coe_mk, mem_coe, Finset.mem_biUnion, Finset.mem_univ, exists_true_left,
      Finset.exists_coe, iUnion_exists, true_and]
    rw [iUnion_comm]
    refine iUnion_congr fun i â†¦ ?_
    by_cases hi : i âˆˆ J
    Â· simp only [hi, iUnion_true, exists_prop]
      rw [â† hJu_sUnion i (h_ss hi), sUnion_eq_biUnion]
      simp only [mem_coe]
    Â· simp only [hi, iUnion_of_empty, iUnion_empty]","error:  application type mismatch
  diff_subset u
argument
  u
has type
  Set Î± : Type u_1
but is expected to have type
  ?m.9837 âˆˆ ?m.9835 \ ?m.9836 : Prop
error:  application type mismatch
  diff_subset v
argument
  v
has type
  Set Î± : Type u_1
but is expected to have type
  ?m.10150 âˆˆ ?m.10148 \ ?m.10149 : Prop
warning:  `bex_imp` has been deprecated, use `existsâ‚‚_imp` instead
error:  tactic 'introN' failed, insufficient number of binders
Î± : Type u_1
C : Set (Set Î±)
s tâœ : Set Î±
I : Finset (Set Î±)
hC : IsSetSemiring C
hs : s âˆˆ C
t : Set Î±
I' : Finset (Set Î±)
aâœ : t âˆ‰ I'
h : â†‘I' âŠ† C â†’ âˆƒ J, â†‘J âŠ† C âˆ§ (â†‘J).PairwiseDisjoint id âˆ§ s \ â‹ƒâ‚€ â†‘I' = â‹ƒâ‚€ â†‘J
hI : insert t â†‘I' âŠ† C
ht : t âˆˆ C
J : Finset (Set Î±)
h_ss : â†‘J âŠ† C
h_dis : (â†‘J).PairwiseDisjoint id
h_eq : s \ â‹ƒâ‚€ â†‘I' = â‹ƒâ‚€ â†‘J
Ju : (u : Set Î±) â†’ u âˆˆ C â†’ Finset (Set Î±) := fun u hu â†¦ hC.diffFinset hu ht
hJu_subset : âˆ€ (u : Set Î±) (hu : u âˆˆ C), â†‘(Ju u hu) âŠ† C
hJu_disj : âˆ€ (u : Set Î±) (hu : u âˆˆ C), (â†‘(Ju u hu)).PairwiseDisjoint id
hJu_sUnion : âˆ€ (u : Set Î±) (hu : u âˆˆ C), â‹ƒâ‚€ â†‘(Ju u hu) = u \ t
hJu_disj' : âˆ€ (u : Set Î±) (hu : u âˆˆ C) (v : Set Î±) (hv : v âˆˆ C), Disjoint u v â†’ Disjoint (â‹ƒâ‚€ â†‘(Ju u hu)) (â‹ƒâ‚€ â†‘(Ju v hv))
J' : Finset (Set Î±) := Finset.univ.biUnion fun u â†¦ Ju â†‘u â‹¯
u : Set Î±
v : u âˆˆ J'
âŠ¢ u âˆˆ C
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.11876 â†’ ?m.11876
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â‹ƒ i, â‹ƒ i', ?s i i'
case insert.intro.intro.intro.refine_2
Î± : Type u_1
C : Set (Set Î±)
s tâœ : Set Î±
I : Finset (Set Î±)
hC : IsSetSemiring C
hs : s âˆˆ C
t : Set Î±
I' : Finset (Set Î±)
aâœ : t âˆ‰ I'
h : â†‘I' âŠ† C â†’ âˆƒ J, â†‘J âŠ† C âˆ§ (â†‘J).PairwiseDisjoint id âˆ§ s \ â‹ƒâ‚€ â†‘I' = â‹ƒâ‚€ â†‘J
hI : insert t â†‘I' âŠ† C
ht : t âˆˆ C
J : Finset (Set Î±)
h_ss : â†‘J âŠ† C
h_dis : (â†‘J).PairwiseDisjoint id
h_eq : s \ â‹ƒâ‚€ â†‘I' = â‹ƒâ‚€ â†‘J
Ju : (u : Set Î±) â†’ u âˆˆ C â†’ Finset (Set Î±) := fun u hu â†¦ hC.diffFinset hu ht
hJu_subset : âˆ€ (u : Set Î±) (hu : u âˆˆ C), â†‘(Ju u hu) âŠ† C
hJu_disj : âˆ€ (u : Set Î±) (hu : u âˆˆ C), (â†‘(Ju u hu)).PairwiseDisjoint id
hJu_sUnion : âˆ€ (u : Set Î±) (hu : u âˆˆ C), â‹ƒâ‚€ â†‘(Ju u hu) = u \ t
hJu_disj' : âˆ€ (u : Set Î±) (hu : u âˆˆ C) (v : Set Î±) (hv : v âˆˆ C), Disjoint u v â†’ Disjoint (â‹ƒâ‚€ â†‘(Ju u hu)) (â‹ƒâ‚€ â†‘(Ju v hv))
J' : Finset (Set Î±) := Finset.univ.biUnion fun u â†¦ Ju â†‘u â‹¯
hJ'_subset : â†‘J' âŠ† C
âŠ¢ â‹ƒ i âˆˆ J, i \ t = â‹ƒ i âˆˆ J', i","lemma exists_disjoint_finset_diff_eq (hC : IsSetSemiring C) (hs : s âˆˆ C) (hI : â†‘I âŠ† C) :
    âˆƒ J : Finset (Set Î±), â†‘J âŠ† C âˆ§ PairwiseDisjoint (J : Set (Set Î±)) id âˆ§
      s \ â‹ƒâ‚€ I = â‹ƒâ‚€ J ",":= by
  classical
  induction I using Finset.induction with
  | empty =>
    simp only [coe_empty, sUnion_empty, diff_empty, exists_prop]
    refine âŸ¨{s}, singleton_subset_set_iff.mpr hs, ?_âŸ©
    simp only [coe_singleton, pairwiseDisjoint_singleton, sUnion_singleton, eq_self_iff_true,
      and_self_iff]
  | @insert t I' _ h => ?_

  rw [coe_insert] at hI
  have ht : t âˆˆ C := hI (Set.mem_insert _ _)
  obtain âŸ¨J, h_ss, h_dis, h_eqâŸ© := h ((Set.subset_insert _ _).trans hI)
  let Ju : âˆ€ u âˆˆ C, Finset (Set Î±) := fun u hu â†¦ hC.diffFinset hu ht
  have hJu_subset : âˆ€ (u) (hu : u âˆˆ C), â†‘(Ju u hu) âŠ† C := by
    intro u hu x hx
    exact hC.diffFinset_subset hu ht hx
  have hJu_disj : âˆ€ (u) (hu : u âˆˆ C), (Ju u hu : Set (Set Î±)).PairwiseDisjoint id := fun u hu â†¦
    hC.pairwiseDisjoint_diffFinset hu ht
  have hJu_sUnion : âˆ€ (u) (hu : u âˆˆ C), â‹ƒâ‚€ (Ju u hu : Set (Set Î±)) = u \ t :=
    fun u hu â†¦ hC.sUnion_diffFinset hu ht
  have hJu_disj' : âˆ€ (u) (hu : u âˆˆ C) (v) (hv : v âˆˆ C) (_h_dis : Disjoint u v),
      Disjoint (â‹ƒâ‚€ (Ju u hu : Set (Set Î±))) (â‹ƒâ‚€ â†‘(Ju v hv)) :=by
    intro u hu v hv huv_disj
    rw [hJu_sUnion, hJu_sUnion]
    exact disjoint_of_subset Set.diff_subset Set.diff_subset huv_disj
  let J' : Finset (Set Î±) := Finset.biUnion (Finset.univ : Finset J) fun u â†¦ Ju u (h_ss u.prop)
  have hJ'_subset : â†‘J' âŠ† C := by
    intro u
    simp only [J' ,Subtype.coe_mk, univ_eq_attach, coe_biUnion, mem_coe, mem_attach, iUnion_true,
      mem_iUnion, Finset.exists_coe, existsâ‚‚_imp]
    intro v hv huvt
    exact hJu_subset v (h_ss hv) huvt
  refine âŸ¨J', hJ'_subset, ?_, ?_âŸ©
  Â· rw [Finset.coe_biUnion]
    refine PairwiseDisjoint.biUnion ?_ ?_
    Â· simp only [univ_eq_attach, mem_coe, id, iSup_eq_iUnion]
      simp_rw [PairwiseDisjoint, Set.Pairwise]
      intro x _ y _ hxy
      have hxy_disj : Disjoint (x : Set Î±) y := by
        by_contra h_contra
        refine hxy ?_
        refine Subtype.ext ?_
        exact h_dis.elim x.prop y.prop h_contra
      convert hJu_disj' (x : Set Î±) (h_ss x.prop) y (h_ss y.prop) hxy_disj
      Â· rw [sUnion_eq_biUnion]
        congr
      Â· rw [sUnion_eq_biUnion]
        congr
    Â· exact fun u _ â†¦ hJu_disj _ _
  Â· rw [coe_insert, sUnion_insert, Set.union_comm, â† Set.diff_diff, h_eq]
    simp_rw [J', sUnion_eq_biUnion, Set.iUnion_diff]
    simp only [Subtype.coe_mk, mem_coe, Finset.mem_biUnion, Finset.mem_univ, exists_true_left,
      Finset.exists_coe, iUnion_exists, true_and]
    rw [iUnion_comm]
    refine iUnion_congr fun i â†¦ ?_
    by_cases hi : i âˆˆ J
    Â· simp only [hi, iUnion_true, exists_prop]
      rw [â† hJu_sUnion i (h_ss hi), sUnion_eq_biUnion]
      simp only [mem_coe]
    Â· simp only [hi, iUnion_of_empty, iUnion_empty]"
Mathlib/Data/List/Infix.lean,List.inits_eq_tails,inits_eq_tails,10294a2e3306ccd731ec7cbd6a95830a83a9ff94,"  | [] => by simp
  | a :: l => by simp [inits_eq_tails l, map_eq_map_iff, reverse_map]","warning:  `List.map_eq_map_iff` has been deprecated, use `List.map_inj_left` instead
warning:  `List.reverse_map` has been deprecated, use `List.map_reverse` instead
error:  tactic 'simp' failed, nested error:
maximum recursion depth has been reached
use `set_option maxRecDepth <num>` to increase limit
use `set_option diagnostics true` to get diagnostic information
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem inits_eq_tails : âˆ€ l : List Î±, l.inits = (reverse <| map reverse <| tails <| reverse l)
","  | [] => by simp
  | a :: l => by simp [inits_eq_tails l, map_inj_left, â† map_reverse]"
Mathlib/LinearAlgebra/Matrix/Spectrum.lean,Matrix.IsHermitian.rank_eq_rank_diagonal,rank_eq_rank_diagonal,5250ed6b5cbd9c34a91206fe413e98dfc25abd1d,":= by
  conv_lhs => rw [hA.spectral_theorem2, â† unitary.coe_star]
  simp [-unitary.coe_star, rank_diagonal]","error:  invalid field 'spectral_theorem2', the environment does not contain 'Matrix.IsHermitian.spectral_theorem2'
  hA
has type
  A.IsHermitian
error:  invalid field 'spectral_theorem2', the environment does not contain 'Eq.spectral_theorem2'
  hA
has type
  Aá´´ = A
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.98289
ğ•œ : Type u_1
instâœÂ² : RCLike ğ•œ
n : Type u_2
instâœÂ¹ : Fintype n
A : Matrix n n ğ•œ
instâœ : DecidableEq n
hA : A.IsHermitian
| A.rank",lemma rank_eq_rank_diagonal : A.rank = (Matrix.diagonal hA.eigenvalues).rank ,":= by
  conv_lhs => rw [hA.spectral_theorem, â† unitary.coe_star]
  simp [-isUnit_iff_ne_zero, -unitary.coe_star, rank_diagonal]"
Mathlib/Analysis/Calculus/BumpFunction/FiniteDimension.lean,IsOpen.exists_smooth_support_eq,IsOpen.exists_smooth_support_eq,544ad04474a9a1395bad0c932141e27ab5ac9aca,":= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  Â· exact
      âŸ¨fun _ => 0, Function.support_zero, contDiff_const, by
        simp only [range_const, singleton_subset_iff, left_mem_Icc, zero_le_one]âŸ©
  let Î¹ := { f : E â†’ â„ // f.support âŠ† s âˆ§ HasCompactSupport f âˆ§ ContDiff â„ âŠ¤ f âˆ§ range f âŠ† Icc 0 1 }
  obtain âŸ¨T, T_count, hTâŸ© : âˆƒ T : Set Î¹, T.Countable âˆ§ â‹ƒ f âˆˆ T, support (f : E â†’ â„) = s := by
    have : â‹ƒ f : Î¹, (f : E â†’ â„).support = s := by
      refine' Subset.antisymm (iUnion_subset fun f => f.2.1) _
      intro x hx
      rcases exists_smooth_tsupport_subset (hs.mem_nhds hx) with âŸ¨f, hfâŸ©
      let g : Î¹ := âŸ¨f, (subset_tsupport f).trans hf.1, hf.2.1, hf.2.2.1, hf.2.2.2.1âŸ©
      have : x âˆˆ support (g : E â†’ â„) := by
        simp only [hf.2.2.2.2, Subtype.coe_mk, mem_support, Ne.def, one_ne_zero, not_false_iff]
      exact mem_iUnion_of_mem _ this
    simp_rw [â† this]
    apply isOpen_iUnion_countable
    rintro âŸ¨f, hfâŸ©
    exact hf.2.2.1.continuous.isOpen_support
  obtain âŸ¨g0, hgâŸ© : âˆƒ g0 : â„• â†’ Î¹, T = range g0 := by
    apply Countable.exists_eq_range T_count
    rcases eq_empty_or_nonempty T with (rfl | hT)
    Â· simp only [iUnion_false, iUnion_empty] at hT
      simp only [â† hT, mem_empty_iff_false, iUnion_of_empty, iUnion_empty, Set.not_nonempty_empty]
          at h's
    Â· exact hT
  let g : â„• â†’ E â†’ â„ := fun n => (g0 n).1
  have g_s : âˆ€ n, support (g n) âŠ† s := fun n => (g0 n).2.1
  have s_g : âˆ€ x âˆˆ s, âˆƒ n, x âˆˆ support (g n) := fun x hx â†¦ by
    rw [â† hT] at hx
    obtain âŸ¨i, iT, hiâŸ© : âˆƒ i âˆˆ T, x âˆˆ support (i : E â†’ â„) := by
      simpa only [mem_iUnion, exists_prop] using hx
    rw [hg, mem_range] at iT
    rcases iT with âŸ¨n, hnâŸ©
    rw [â† hn] at hi
    exact âŸ¨n, hiâŸ©
  have g_smooth : âˆ€ n, ContDiff â„ âŠ¤ (g n) := fun n => (g0 n).2.2.2.1
  have g_comp_supp : âˆ€ n, HasCompactSupport (g n) := fun n => (g0 n).2.2.1
  have g_nonneg : âˆ€ n x, 0 â‰¤ g n x := fun n x => ((g0 n).2.2.2.2 (mem_range_self x)).1
  obtain âŸ¨Î´, Î´pos, c, Î´c, c_ltâŸ© :
    âˆƒ Î´ : â„• â†’ â„â‰¥0, (âˆ€ i : â„•, 0 < Î´ i) âˆ§ âˆƒ c : NNReal, HasSum Î´ c âˆ§ c < 1
  exact NNReal.exists_pos_sum_of_countable one_ne_zero â„•
  have : âˆ€ n : â„•, âˆƒ r : â„, 0 < r âˆ§ âˆ€ i â‰¤ n, âˆ€ x, â€–iteratedFDeriv â„ i (r â€¢ g n) xâ€– â‰¤ Î´ n := by
    intro n
    have : âˆ€ i, âˆƒ R, âˆ€ x, â€–iteratedFDeriv â„ i (fun x => g n x) xâ€– â‰¤ R := by
      intro i
      have : BddAbove (range fun x => â€–iteratedFDeriv â„ i (fun x : E => g n x) xâ€–) := by
        apply
          ((g_smooth n).continuous_iteratedFDeriv le_top).norm.bddAbove_range_of_hasCompactSupport
        apply HasCompactSupport.comp_left _ norm_zero
        apply (g_comp_supp n).iteratedFDeriv
      rcases this with âŸ¨R, hRâŸ©
      exact âŸ¨R, fun x => hR (mem_range_self _)âŸ©
    choose R hR using this
    let M := max (((Finset.range (n + 1)).image R).max' (by simp)) 1
    have Î´npos : 0 < Î´ n := Î´pos n
    have IR : âˆ€ i â‰¤ n, R i â‰¤ M := by
      intro i hi
      refine' le_trans _ (le_max_left _ _)
      apply Finset.le_max'
      apply Finset.mem_image_of_mem
      simpa only [Finset.mem_range, Nat.lt_add_one_iff]
    refine' âŸ¨Mâ»Â¹ * Î´ n, by positivity, fun i hi x => _âŸ©
    calc
      â€–iteratedFDeriv â„ i ((Mâ»Â¹ * Î´ n) â€¢ g n) xâ€– = â€–(Mâ»Â¹ * Î´ n) â€¢ iteratedFDeriv â„ i (g n) xâ€– := by
        rw [iteratedFDeriv_const_smul_apply]; exact (g_smooth n).of_le le_top
      _ = Mâ»Â¹ * Î´ n * â€–iteratedFDeriv â„ i (g n) xâ€– := by
        rw [norm_smul _ (iteratedFDeriv â„ i (g n) x), Real.norm_of_nonneg]; positivity
      _ â‰¤ Mâ»Â¹ * Î´ n * M := (mul_le_mul_of_nonneg_left ((hR i x).trans (IR i hi)) (by positivity))
      _ = Î´ n := by field_simp
  choose r rpos hr using this
  have S : âˆ€ x, Summable fun n => (r n â€¢ g n) x := fun x â†¦ by
    refine' .of_nnnorm_bounded _ Î´c.summable fun n => _
    rw [â† NNReal.coe_le_coe, coe_nnnorm]
    simpa only [norm_iteratedFDeriv_zero] using hr n 0 (zero_le n) x
  refine' âŸ¨fun x => âˆ‘' n, (r n â€¢ g n) x, _, _, _âŸ©
  Â· apply Subset.antisymm
    Â· intro x hx
      simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, mem_support, Ne.def] at hx
      contrapose! hx
      have : âˆ€ n, g n x = 0 := by
        intro n
        contrapose! hx
        exact g_s n hx
      simp only [this, mul_zero, tsum_zero]
    Â· intro x hx
      obtain âŸ¨n, hnâŸ© : âˆƒ n, x âˆˆ support (g n); exact s_g x hx
      have I : 0 < r n * g n x := mul_pos (rpos n) (lt_of_le_of_ne (g_nonneg n x) (Ne.symm hn))
      exact ne_of_gt (tsum_pos (S x) (fun i => mul_nonneg (rpos i).le (g_nonneg i x)) n I)
  Â· refine'
      contDiff_tsum_of_eventually (fun n => (g_smooth n).const_smul (r n))
        (fun k _ => (NNReal.hasSum_coe.2 Î´c).summable) _
    intro i _
    simp only [Nat.cofinite_eq_atTop, Pi.smul_apply, Algebra.id.smul_eq_mul,
      Filter.eventually_atTop, ge_iff_le]
    exact âŸ¨i, fun n hn x => hr _ _ hn _âŸ©
  Â· rintro - âŸ¨y, rflâŸ©
    refine' âŸ¨tsum_nonneg fun n => mul_nonneg (rpos n).le (g_nonneg n y), le_trans _ c_lt.leâŸ©
    have A : HasSum (fun n => (Î´ n : â„)) c := NNReal.hasSum_coe.2 Î´c
    simp only [Pi.smul_apply, smul_eq_mul, NNReal.val_eq_coe, â† A.tsum_eq, ge_iff_le]
    apply tsum_le_tsum _ (S y) A.summable
    intro n
    apply (le_abs_self _).trans
    simpa only [norm_iteratedFDeriv_zero] using hr n 0 (zero_le n) y","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.28299 â†’ ?m.28299 â†’ Prop
error:  unsolved goals
E : Type u_1
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
instâœ : FiniteDimensional â„ E
s : Set E
hs : IsOpen s
h's : s.Nonempty
Î¹ : Type u_1 := { f // support f âŠ† s âˆ§ HasCompactSupport f âˆ§ ContDiff â„ âŠ¤ f âˆ§ range f âŠ† Icc 0 1 }
x : E
hx : x âˆˆ s
f : E â†’ â„
hf : tsupport f âŠ† s âˆ§ HasCompactSupport f âˆ§ ContDiff â„ âŠ¤ f âˆ§ range f âŠ† Icc 0 1 âˆ§ f x = 1
g : Î¹ := âŸ¨f, â‹¯âŸ©
âŠ¢ 1 â‰  0
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.76575 â†’ ?m.76575 â†’ Prop","theorem IsOpen.exists_smooth_support_eq {s : Set E} (hs : IsOpen s) :
    âˆƒ f : E â†’ â„, f.support = s âˆ§ ContDiff â„ âŠ¤ f âˆ§ Set.range f âŠ† Set.Icc 0 1 ",":= by
  rcases eq_empty_or_nonempty s with (rfl | h's)
  Â· exact
      âŸ¨fun _ => 0, Function.support_zero, contDiff_const, by
        simp only [range_const, singleton_subset_iff, left_mem_Icc, zero_le_one]âŸ©
  let Î¹ := { f : E â†’ â„ // f.support âŠ† s âˆ§ HasCompactSupport f âˆ§ ContDiff â„ âŠ¤ f âˆ§ range f âŠ† Icc 0 1 }
  obtain âŸ¨T, T_count, hTâŸ© : âˆƒ T : Set Î¹, T.Countable âˆ§ â‹ƒ f âˆˆ T, support (f : E â†’ â„) = s := by
    have : â‹ƒ f : Î¹, (f : E â†’ â„).support = s := by
      refine Subset.antisymm (iUnion_subset fun f => f.2.1) ?_
      intro x hx
      rcases exists_smooth_tsupport_subset (hs.mem_nhds hx) with âŸ¨f, hfâŸ©
      let g : Î¹ := âŸ¨f, (subset_tsupport f).trans hf.1, hf.2.1, hf.2.2.1, hf.2.2.2.1âŸ©
      have : x âˆˆ support (g : E â†’ â„) := by
        simp only [hf.2.2.2.2, Subtype.coe_mk, mem_support, Ne, one_ne_zero, not_false_iff]
      exact mem_iUnion_of_mem _ this
    simp_rw [â† this]
    apply isOpen_iUnion_countable
    rintro âŸ¨f, hfâŸ©
    exact hf.2.2.1.continuous.isOpen_support
  obtain âŸ¨g0, hgâŸ© : âˆƒ g0 : â„• â†’ Î¹, T = range g0 := by
    apply Countable.exists_eq_range T_count
    rcases eq_empty_or_nonempty T with (rfl | hT)
    Â· simp only [Î¹, iUnion_false, iUnion_empty] at hT
      simp only [â† hT, mem_empty_iff_false, iUnion_of_empty, iUnion_empty, Set.not_nonempty_empty]
          at h's
    Â· exact hT
  let g : â„• â†’ E â†’ â„ := fun n => (g0 n).1
  have g_s : âˆ€ n, support (g n) âŠ† s := fun n => (g0 n).2.1
  have s_g : âˆ€ x âˆˆ s, âˆƒ n, x âˆˆ support (g n) := fun x hx â†¦ by
    rw [â† hT] at hx
    obtain âŸ¨i, iT, hiâŸ© : âˆƒ i âˆˆ T, x âˆˆ support (i : E â†’ â„) := by
      simpa only [mem_iUnion, exists_prop] using hx
    rw [hg, mem_range] at iT
    rcases iT with âŸ¨n, hnâŸ©
    rw [â† hn] at hi
    exact âŸ¨n, hiâŸ©
  have g_smooth : âˆ€ n, ContDiff â„ âŠ¤ (g n) := fun n => (g0 n).2.2.2.1
  have g_comp_supp : âˆ€ n, HasCompactSupport (g n) := fun n => (g0 n).2.2.1
  have g_nonneg : âˆ€ n x, 0 â‰¤ g n x := fun n x => ((g0 n).2.2.2.2 (mem_range_self x)).1
  obtain âŸ¨Î´, Î´pos, c, Î´c, c_ltâŸ© :
      âˆƒ Î´ : â„• â†’ â„â‰¥0, (âˆ€ i : â„•, 0 < Î´ i) âˆ§ âˆƒ c : NNReal, HasSum Î´ c âˆ§ c < 1 :=
    NNReal.exists_pos_sum_of_countable one_ne_zero â„•
  have : âˆ€ n : â„•, âˆƒ r : â„, 0 < r âˆ§ âˆ€ i â‰¤ n, âˆ€ x, â€–iteratedFDeriv â„ i (r â€¢ g n) xâ€– â‰¤ Î´ n := by
    intro n
    have : âˆ€ i, âˆƒ R, âˆ€ x, â€–iteratedFDeriv â„ i (fun x => g n x) xâ€– â‰¤ R := by
      intro i
      have : BddAbove (range fun x => â€–iteratedFDeriv â„ i (fun x : E => g n x) xâ€–) := by
        apply
          ((g_smooth n).continuous_iteratedFDeriv le_top).norm.bddAbove_range_of_hasCompactSupport
        apply HasCompactSupport.comp_left _ norm_zero
        apply (g_comp_supp n).iteratedFDeriv
      rcases this with âŸ¨R, hRâŸ©
      exact âŸ¨R, fun x => hR (mem_range_self _)âŸ©
    choose R hR using this
    let M := max (((Finset.range (n + 1)).image R).max' (by simp)) 1
    have Î´npos : 0 < Î´ n := Î´pos n
    have IR : âˆ€ i â‰¤ n, R i â‰¤ M := by
      intro i hi
      refine le_trans ?_ (le_max_left _ _)
      apply Finset.le_max'
      apply Finset.mem_image_of_mem
      simpa only [Finset.mem_range, Nat.lt_add_one_iff]
    refine âŸ¨Mâ»Â¹ * Î´ n, by positivity, fun i hi x => ?_âŸ©
    calc
      â€–iteratedFDeriv â„ i ((Mâ»Â¹ * Î´ n) â€¢ g n) xâ€– = â€–(Mâ»Â¹ * Î´ n) â€¢ iteratedFDeriv â„ i (g n) xâ€– := by
        rw [iteratedFDeriv_const_smul_apply]; exact (g_smooth n).of_le le_top
      _ = Mâ»Â¹ * Î´ n * â€–iteratedFDeriv â„ i (g n) xâ€– := by
        rw [norm_smul _ (iteratedFDeriv â„ i (g n) x), Real.norm_of_nonneg]; positivity
      _ â‰¤ Mâ»Â¹ * Î´ n * M := (mul_le_mul_of_nonneg_left ((hR i x).trans (IR i hi)) (by positivity))
      _ = Î´ n := by field_simp
  choose r rpos hr using this
  have S : âˆ€ x, Summable fun n => (r n â€¢ g n) x := fun x â†¦ by
    refine .of_nnnorm_bounded _ Î´c.summable fun n => ?_
    rw [â† NNReal.coe_le_coe, coe_nnnorm]
    simpa only [norm_iteratedFDeriv_zero] using hr n 0 (zero_le n) x
  refine âŸ¨fun x => âˆ‘' n, (r n â€¢ g n) x, ?_, ?_, ?_âŸ©
  Â· apply Subset.antisymm
    Â· intro x hx
      simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, mem_support, Ne] at hx
      contrapose! hx
      have : âˆ€ n, g n x = 0 := by
        intro n
        contrapose! hx
        exact g_s n hx
      simp only [this, mul_zero, tsum_zero]
    Â· intro x hx
      obtain âŸ¨n, hnâŸ© : âˆƒ n, x âˆˆ support (g n) := s_g x hx
      have I : 0 < r n * g n x := mul_pos (rpos n) (lt_of_le_of_ne (g_nonneg n x) (Ne.symm hn))
      exact ne_of_gt (tsum_pos (S x) (fun i => mul_nonneg (rpos i).le (g_nonneg i x)) n I)
  Â· refine
      contDiff_tsum_of_eventually (fun n => (g_smooth n).const_smul (r n))
        (fun k _ => (NNReal.hasSum_coe.2 Î´c).summable) ?_
    intro i _
    simp only [Nat.cofinite_eq_atTop, Pi.smul_apply, Algebra.id.smul_eq_mul,
      Filter.eventually_atTop, ge_iff_le]
    exact âŸ¨i, fun n hn x => hr _ _ hn _âŸ©
  Â· rintro - âŸ¨y, rflâŸ©
    refine âŸ¨tsum_nonneg fun n => mul_nonneg (rpos n).le (g_nonneg n y), le_trans ?_ c_lt.leâŸ©
    have A : HasSum (fun n => (Î´ n : â„)) c := NNReal.hasSum_coe.2 Î´c
    simp only [Pi.smul_apply, smul_eq_mul, NNReal.val_eq_coe, â† A.tsum_eq, ge_iff_le]
    apply tsum_le_tsum _ (S y) A.summable
    intro n
    apply (le_abs_self _).trans
    simpa only [norm_iteratedFDeriv_zero] using hr n 0 (zero_le n) y"
Mathlib/RingTheory/RootsOfUnity/Minpoly.lean,IsPrimitiveRoot.minpoly_eq_pow,minpoly_eq_pow,82c813af13556dfd4f1674ca7e80454403652cd8,":= by
  classical
  by_cases hn : n = 0
  Â· simp_all
  have hpos := Nat.pos_of_ne_zero hn
  by_contra hdiff
  set P := minpoly â„¤ Î¼
  set Q := minpoly â„¤ (Î¼ ^ p)
  have Pmonic : P.Monic := minpoly.monic (h.isIntegral hpos)
  have Qmonic : Q.Monic := minpoly.monic ((h.pow_of_prime hprime.1 hdiv).isIntegral hpos)
  have Pirr : Irreducible P := minpoly.irreducible (h.isIntegral hpos)
  have Qirr : Irreducible Q := minpoly.irreducible ((h.pow_of_prime hprime.1 hdiv).isIntegral hpos)
  have PQprim : IsPrimitive (P * Q) := Pmonic.isPrimitive.mul Qmonic.isPrimitive
  have prod : P * Q âˆ£ X ^ n - 1 := by
    rw [IsPrimitive.Int.dvd_iff_map_cast_dvd_map_cast (P * Q) (X ^ n - 1) PQprim
        (monic_X_pow_sub_C (1 : â„¤) (ne_of_gt hpos)).isPrimitive,
      Polynomial.map_mul]
    refine' IsCoprime.mul_dvd _ _ _
    Â· have aux := IsPrimitive.Int.irreducible_iff_irreducible_map_cast Pmonic.isPrimitive
      refine' (dvd_or_coprime _ _ (aux.1 Pirr)).resolve_left _
      rw [map_dvd_map (Int.castRingHom â„š) Int.cast_injective Pmonic]
      intro hdiv
      refine' hdiff (eq_of_monic_of_associated Pmonic Qmonic _)
      exact associated_of_dvd_dvd hdiv (Pirr.dvd_symm Qirr hdiv)
    Â· apply (map_dvd_map (Int.castRingHom â„š) Int.cast_injective Pmonic).2
      exact minpoly_dvd_x_pow_sub_one h
    Â· apply (map_dvd_map (Int.castRingHom â„š) Int.cast_injective Qmonic).2
      exact minpoly_dvd_x_pow_sub_one (pow_of_prime h hprime.1 hdiv)
  replace prod := RingHom.map_dvd (mapRingHom (Int.castRingHom (ZMod p))) prod
  rw [coe_mapRingHom, Polynomial.map_mul, Polynomial.map_sub, Polynomial.map_one,
    Polynomial.map_pow, map_X] at prod
  obtain âŸ¨R, hRâŸ© := minpoly_dvd_mod_p h hdiv
  rw [hR, â† mul_assoc, â† Polynomial.map_mul, â† sq, Polynomial.map_pow] at prod
  have habs : map (Int.castRingHom (ZMod p)) P ^ 2 âˆ£ map (Int.castRingHom (ZMod p)) P ^ 2 * R := by
    use R
  replace habs :=
    lt_of_lt_of_le (PartENat.coe_lt_coe.2 one_lt_two)
      (multiplicity.le_multiplicity_of_pow_dvd (dvd_trans habs prod))
  have hfree : Squarefree (X ^ n - 1 : (ZMod p)[X]) :=
    (separable_X_pow_sub_C 1 (fun h => hdiv <| (ZMod.nat_cast_zmod_eq_zero_iff_dvd n p).1 h)
        one_ne_zero).squarefree
  cases'
    (multiplicity.squarefree_iff_multiplicity_le_one (X ^ n - 1)).1 hfree
      (map (Int.castRingHom (ZMod p)) P) with
    hle hunit
  Â· rw [Nat.cast_one] at habs ; exact hle.not_lt habs
  Â· replace hunit := degree_eq_zero_of_isUnit hunit
    rw [degree_map_eq_of_leadingCoeff_ne_zero (Int.castRingHom (ZMod p)) _] at hunit
    Â· exact (minpoly.degree_pos (isIntegral h hpos)).ne' hunit
    simp only [Pmonic, eq_intCast, Monic.leadingCoeff, Int.cast_one, Ne.def, not_false_iff,
      one_ne_zero]","warning:  `ZMod.nat_cast_zmod_eq_zero_iff_dvd` has been deprecated, use `ZMod.natCast_zmod_eq_zero_iff_dvd` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.46477 â†’ ?m.46477 â†’ Prop
error:  unsolved goals
n : â„•
K : Type u_1
instâœÂ² : CommRing K
Î¼ : K
h : IsPrimitiveRoot Î¼ n
instâœÂ¹ : IsDomain K
instâœ : CharZero K
p : â„•
hprime : Fact (Nat.Prime p)
hdiv : Â¬p âˆ£ n
hn : Â¬n = 0
hpos : 0 < n
P : â„¤[X] := minpoly â„¤ Î¼
Q : â„¤[X] := minpoly â„¤ (Î¼ ^ p)
hdiff : Â¬P = Q
Pmonic : P.Monic
Qmonic : Q.Monic
Pirr : Irreducible P
Qirr : Irreducible Q
PQprim : (P * Q).IsPrimitive
R : (ZMod p)[X]
prod : map (Int.castRingHom (ZMod p)) P ^ 2 * R âˆ£ X ^ n - 1
hR : map (Int.castRingHom (ZMod p)) (minpoly â„¤ (Î¼ ^ p)) = map (Int.castRingHom (ZMod p)) (minpoly â„¤ Î¼) * R
habs : â†‘1 < multiplicity (map (Int.castRingHom (ZMod p)) P) (X ^ n - 1)
hfree : Squarefree (X ^ n - 1)
hunit : (map (Int.castRingHom (ZMod p)) P).degree = 0
âŠ¢ 1 â‰  0","theorem minpoly_eq_pow {p : â„•} [hprime : Fact p.Prime] (hdiv : Â¬p âˆ£ n) :
    minpoly â„¤ Î¼ = minpoly â„¤ (Î¼ ^ p) ",":= by
  classical
  by_cases hn : n = 0
  Â· simp_all
  have hpos := Nat.pos_of_ne_zero hn
  by_contra hdiff
  set P := minpoly â„¤ Î¼
  set Q := minpoly â„¤ (Î¼ ^ p)
  have Pmonic : P.Monic := minpoly.monic (h.isIntegral hpos)
  have Qmonic : Q.Monic := minpoly.monic ((h.pow_of_prime hprime.1 hdiv).isIntegral hpos)
  have Pirr : Irreducible P := minpoly.irreducible (h.isIntegral hpos)
  have Qirr : Irreducible Q := minpoly.irreducible ((h.pow_of_prime hprime.1 hdiv).isIntegral hpos)
  have PQprim : IsPrimitive (P * Q) := Pmonic.isPrimitive.mul Qmonic.isPrimitive
  have prod : P * Q âˆ£ X ^ n - 1 := by
    rw [IsPrimitive.Int.dvd_iff_map_cast_dvd_map_cast (P * Q) (X ^ n - 1) PQprim
        (monic_X_pow_sub_C (1 : â„¤) (ne_of_gt hpos)).isPrimitive,
      Polynomial.map_mul]
    refine IsCoprime.mul_dvd ?_ ?_ ?_
    Â· have aux := IsPrimitive.Int.irreducible_iff_irreducible_map_cast Pmonic.isPrimitive
      refine (dvd_or_coprime _ _ (aux.1 Pirr)).resolve_left ?_
      rw [map_dvd_map (Int.castRingHom â„š) Int.cast_injective Pmonic]
      intro hdiv
      refine hdiff (eq_of_monic_of_associated Pmonic Qmonic ?_)
      exact associated_of_dvd_dvd hdiv (Pirr.dvd_symm Qirr hdiv)
    Â· apply (map_dvd_map (Int.castRingHom â„š) Int.cast_injective Pmonic).2
      exact minpoly_dvd_x_pow_sub_one h
    Â· apply (map_dvd_map (Int.castRingHom â„š) Int.cast_injective Qmonic).2
      exact minpoly_dvd_x_pow_sub_one (pow_of_prime h hprime.1 hdiv)
  replace prod := RingHom.map_dvd (mapRingHom (Int.castRingHom (ZMod p))) prod
  rw [coe_mapRingHom, Polynomial.map_mul, Polynomial.map_sub, Polynomial.map_one,
    Polynomial.map_pow, map_X] at prod
  obtain âŸ¨R, hRâŸ© := minpoly_dvd_mod_p h hdiv
  rw [hR, â† mul_assoc, â† Polynomial.map_mul, â† sq, Polynomial.map_pow] at prod
  have habs : map (Int.castRingHom (ZMod p)) P ^ 2 âˆ£ map (Int.castRingHom (ZMod p)) P ^ 2 * R := by
    use R
  replace habs :=
    lt_of_lt_of_le (PartENat.coe_lt_coe.2 one_lt_two)
      (multiplicity.le_multiplicity_of_pow_dvd (dvd_trans habs prod))
  have hfree : Squarefree (X ^ n - 1 : (ZMod p)[X]) :=
    (separable_X_pow_sub_C 1 (fun h => hdiv <| (ZMod.natCast_zmod_eq_zero_iff_dvd n p).1 h)
        one_ne_zero).squarefree
  cases'
    (multiplicity.squarefree_iff_multiplicity_le_one (X ^ n - 1)).1 hfree
      (map (Int.castRingHom (ZMod p)) P) with
    hle hunit
  Â· rw [Nat.cast_one] at habs; exact hle.not_lt habs
  Â· replace hunit := degree_eq_zero_of_isUnit hunit
    rw [degree_map_eq_of_leadingCoeff_ne_zero (Int.castRingHom (ZMod p)) _] at hunit
    Â· exact (minpoly.degree_pos (isIntegral h hpos)).ne' hunit
    simp only [Pmonic, eq_intCast, Monic.leadingCoeff, Int.cast_one, Ne, not_false_iff,
      one_ne_zero]"
Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean,collinear_iff_of_mem,collinear_iff_of_mem,28f34517ea07a4ecc94b3d55041dd0ca1152a2a8,":= by
  simp_rw [collinear_iff_rank_le_one, rank_submodule_le_one_iff', Submodule.le_span_singleton_iff]
  constructor
  Â· rintro âŸ¨vâ‚€, hvâŸ©
    use vâ‚€
    intro p hp
    obtain âŸ¨r, hrâŸ© := hv (p -áµ¥ pâ‚€) (vsub_mem_vectorSpan k hp h)
    use r
    rw [eq_vadd_iff_vsub_eq]
    exact hr.symm
  Â· rintro âŸ¨v, hpâ‚€vâŸ©
    use v
    intro w hw
    have hs : vectorSpan k s â‰¤ k â€¢ v := by
      rw [vectorSpan_eq_span_vsub_set_right k h, Submodule.span_le, Set.subset_def]
      intro x hx
      rw [SetLike.mem_coe, Submodule.mem_span_singleton]
      rw [Set.mem_image] at hx
      rcases hx with âŸ¨p, hp, rflâŸ©
      rcases hpâ‚€v p hp with âŸ¨r, rflâŸ©
      use r
      simp
    have hw' := SetLike.le_def.1 hs hw
    rwa [Submodule.mem_span_singleton] at hw'","error:  failed to synthesize
  HSMul (Type u_1) V ?m.202447
use `set_option diagnostics true` to get diagnostic information
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  vectorSpan k s
k : Type u_1
V : Type u_2
P : Type u_3
Î¹ : Type u_4
instâœÂ³ : DivisionRing k
instâœÂ² : AddCommGroup V
instâœÂ¹ : Module k V
instâœ : AffineSpace V P
s : Set P
pâ‚€ : P
h : pâ‚€ âˆˆ s
v : V
hpâ‚€v : âˆ€ p âˆˆ s, âˆƒ r, p = r â€¢ v +áµ¥ pâ‚€
w : V
hw : w âˆˆ vectorSpan k s
âŠ¢ sorryAx (Sort ?u.200967) true","theorem collinear_iff_of_mem {s : Set P} {pâ‚€ : P} (h : pâ‚€ âˆˆ s) :
    Collinear k s â†” âˆƒ v : V, âˆ€ p âˆˆ s, âˆƒ r : k, p = r â€¢ v +áµ¥ pâ‚€ ",":= by
  simp_rw [collinear_iff_rank_le_one, rank_submodule_le_one_iff', Submodule.le_span_singleton_iff]
  constructor
  Â· rintro âŸ¨vâ‚€, hvâŸ©
    use vâ‚€
    intro p hp
    obtain âŸ¨r, hrâŸ© := hv (p -áµ¥ pâ‚€) (vsub_mem_vectorSpan k hp h)
    use r
    rw [eq_vadd_iff_vsub_eq]
    exact hr.symm
  Â· rintro âŸ¨v, hpâ‚€vâŸ©
    use v
    intro w hw
    have hs : vectorSpan k s â‰¤ k âˆ™ v := by
      rw [vectorSpan_eq_span_vsub_set_right k h, Submodule.span_le, Set.subset_def]
      intro x hx
      rw [SetLike.mem_coe, Submodule.mem_span_singleton]
      rw [Set.mem_image] at hx
      rcases hx with âŸ¨p, hp, rflâŸ©
      rcases hpâ‚€v p hp with âŸ¨r, rflâŸ©
      use r
      simp
    have hw' := SetLike.le_def.1 hs hw
    rwa [Submodule.mem_span_singleton] at hw'"
Mathlib/Analysis/MellinTransform.lean,mellin_hasDerivAt_of_isBigO_rpow,mellin_hasDerivAt_of_isBigO_rpow,8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85,":= by
  set F : â„‚ â†’ â„ â†’ E := fun (z : â„‚) (t : â„) => (t : â„‚) ^ (z - 1) â€¢ f t
  set F' : â„‚ â†’ â„ â†’ E := fun (z : â„‚) (t : â„) => ((t : â„‚) ^ (z - 1) * log t) â€¢ f t
  obtain âŸ¨v, hv0, hv1, hv2âŸ© : âˆƒ v : â„, 0 < v âˆ§ v < s.re - b âˆ§ v < a - s.re := by
    obtain âŸ¨w, hw1, hw2âŸ© := exists_between (sub_pos.mpr hs_top)
    obtain âŸ¨w', hw1', hw2'âŸ© := exists_between (sub_pos.mpr hs_bot)
    exact
      âŸ¨min w w', lt_min hw1 hw1', (min_le_right _ _).trans_lt hw2', (min_le_left _ _).trans_lt hw2âŸ©
  let bound : â„ â†’ â„ := fun t : â„ => (t ^ (s.re + v - 1) + t ^ (s.re - v - 1)) * |log t| * â€–f tâ€–
  have h1 : âˆ€á¶  z : â„‚ in ğ“ s, AEStronglyMeasurable (F z) (volume.restrict <| Ioi 0) := by
    refine eventually_of_forall fun z => AEStronglyMeasurable.smul ?_ hfc.aestronglyMeasurable
    refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
    refine ContinuousAt.continuousOn fun t ht => ?_
    exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
  have h2 : IntegrableOn (F s) (Ioi (0 : â„)) := by
    exact mellinConvergent_of_isBigO_rpow hfc hf_top hs_top hf_bot hs_bot
  have h3 : AEStronglyMeasurable (F' s) (volume.restrict <| Ioi 0) := by
    apply LocallyIntegrableOn.aestronglyMeasurable
    refine hfc.continuousOn_smul isOpen_Ioi ((ContinuousAt.continuousOn fun t ht => ?_).mul ?_)
    Â· exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
    Â· refine continuous_ofReal.comp_continuousOn ?_
      exact continuousOn_log.mono (subset_compl_singleton_iff.mpr not_mem_Ioi_self)
  have h4 : âˆ€áµ t : â„ âˆ‚volume.restrict (Ioi 0),
      âˆ€ z : â„‚, z âˆˆ Metric.ball s v â†’ â€–F' z tâ€– â‰¤ bound t := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht z hz => ?_
    simp_rw [F', bound, norm_smul, norm_mul, Complex.norm_eq_abs (log _), Complex.abs_ofReal,
      mul_assoc]
    gcongr
    rw [Complex.norm_eq_abs, abs_cpow_eq_rpow_re_of_pos ht]
    rcases le_or_lt 1 t with h | h
    Â· refine le_add_of_le_of_nonneg (rpow_le_rpow_of_exponent_le h ?_)
        (rpow_nonneg (zero_le_one.trans h) _)
      rw [sub_re, one_re, sub_le_sub_iff_right]
      rw [mem_ball_iff_norm, Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add'] at hz'
    Â· refine
        le_add_of_nonneg_of_le (rpow_pos_of_pos ht _).le (rpow_le_rpow_of_exponent_ge ht h.le ?_)
      rw [sub_re, one_re, sub_le_iff_le_add, sub_add_cancel]
      rw [mem_ball_iff_norm', Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add, â† sub_le_iff_le_add'] at hz'
  have h5 : IntegrableOn bound (Ioi 0) := by
    simp_rw [bound, add_mul, mul_assoc]
    suffices âˆ€ {j : â„}, b < j â†’ j < a â†’
        IntegrableOn (fun t : â„ => t ^ (j - 1) * (|log t| * â€–f tâ€–)) (Ioi 0) volume by
      refine Integrable.add (this ?_ ?_) (this ?_ ?_)
      all_goals linarith
    Â· intro j hj hj'
      obtain âŸ¨w, hw1, hw2âŸ© := exists_between hj
      obtain âŸ¨w', hw1', hw2'âŸ© := exists_between hj'
      refine mellin_convergent_of_isBigO_scalar ?_ ?_ hw1?' _ hw2
      Â· simp_rw [mul_comm]
        refine hfc.norm.mul_continuousOn ?_ isOpen_Ioi
        refine Continuous.comp_continuousOn _root_.continuous_abs (continuousOn_log.mono ?_)
        exact subset_compl_singleton_iff.mpr not_mem_Ioi_self
      Â· refine (isBigO_rpow_top_log_smul hw2' hf_top).norm_left.congr_left fun t â†¦ ?_
        simp only [norm_smul, Real.norm_eq_abs]
      Â· refine (isBigO_rpow_zero_log_smul hw1 hf_bot).norm_left.congr_left fun t â†¦ ?_
        simp only [norm_smul, Real.norm_eq_abs]
  have h6 : âˆ€áµ t : â„ âˆ‚volume.restrict (Ioi 0),
      âˆ€ y : â„‚, y âˆˆ Metric.ball s v â†’ HasDerivAt (fun z : â„‚ => F z t) (F' y t) y := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht y _ => ?_
    have ht' : (t : â„‚) â‰  0 := ofReal_ne_zero.mpr (ne_of_gt ht)
    have u1 : HasDerivAt (fun z : â„‚ => (t : â„‚) ^ (z - 1)) (t ^ (y - 1) * log t) y := by
      convert ((hasDerivAt_id' y).sub_const 1).const_cpow (Or.inl ht') using 1
      rw [ofReal_log (le_of_lt ht)]
      ring
    exact u1.smul_const (f t)
  have main := hasDerivAt_integral_of_dominated_loc_of_deriv_le hv0 h1 h2 h3 h4 h5 h6
  simpa only [F', mul_smul] using main",error:  unknown identifier 'hw1?'',"theorem mellin_hasDerivAt_of_isBigO_rpow [NormedSpace â„‚ E] {a b : â„}
    {f : â„ â†’ E} {s : â„‚} (hfc : LocallyIntegrableOn f (Ioi 0)) (hf_top : f =O[atTop] (Â· ^ (-a)))
    (hs_top : s.re < a) (hf_bot : f =O[ğ“[>] 0] (Â· ^ (-b))) (hs_bot : b < s.re) :
    MellinConvergent (fun t => log t â€¢ f t) s âˆ§
      HasDerivAt (mellin f) (mellin (fun t => log t â€¢ f t) s) s ",":= by
  set F : â„‚ â†’ â„ â†’ E := fun (z : â„‚) (t : â„) => (t : â„‚) ^ (z - 1) â€¢ f t
  set F' : â„‚ â†’ â„ â†’ E := fun (z : â„‚) (t : â„) => ((t : â„‚) ^ (z - 1) * log t) â€¢ f t
  obtain âŸ¨v, hv0, hv1, hv2âŸ© : âˆƒ v : â„, 0 < v âˆ§ v < s.re - b âˆ§ v < a - s.re := by
    obtain âŸ¨w, hw1, hw2âŸ© := exists_between (sub_pos.mpr hs_top)
    obtain âŸ¨w', hw1', hw2'âŸ© := exists_between (sub_pos.mpr hs_bot)
    exact
      âŸ¨min w w', lt_min hw1 hw1', (min_le_right _ _).trans_lt hw2', (min_le_left _ _).trans_lt hw2âŸ©
  let bound : â„ â†’ â„ := fun t : â„ => (t ^ (s.re + v - 1) + t ^ (s.re - v - 1)) * |log t| * â€–f tâ€–
  have h1 : âˆ€á¶  z : â„‚ in ğ“ s, AEStronglyMeasurable (F z) (volume.restrict <| Ioi 0) := by
    refine eventually_of_forall fun z => AEStronglyMeasurable.smul ?_ hfc.aestronglyMeasurable
    refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi
    refine ContinuousAt.continuousOn fun t ht => ?_
    exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
  have h2 : IntegrableOn (F s) (Ioi (0 : â„)) := by
    exact mellinConvergent_of_isBigO_rpow hfc hf_top hs_top hf_bot hs_bot
  have h3 : AEStronglyMeasurable (F' s) (volume.restrict <| Ioi 0) := by
    apply LocallyIntegrableOn.aestronglyMeasurable
    refine hfc.continuousOn_smul isOpen_Ioi ((ContinuousAt.continuousOn fun t ht => ?_).mul ?_)
    Â· exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)
    Â· refine continuous_ofReal.comp_continuousOn ?_
      exact continuousOn_log.mono (subset_compl_singleton_iff.mpr not_mem_Ioi_self)
  have h4 : âˆ€áµ t : â„ âˆ‚volume.restrict (Ioi 0),
      âˆ€ z : â„‚, z âˆˆ Metric.ball s v â†’ â€–F' z tâ€– â‰¤ bound t := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht z hz => ?_
    simp_rw [F', bound, norm_smul, norm_mul, Complex.norm_eq_abs (log _), Complex.abs_ofReal,
      mul_assoc]
    gcongr
    rw [Complex.norm_eq_abs, abs_cpow_eq_rpow_re_of_pos ht]
    rcases le_or_lt 1 t with h | h
    Â· refine le_add_of_le_of_nonneg (rpow_le_rpow_of_exponent_le h ?_)
        (rpow_nonneg (zero_le_one.trans h) _)
      rw [sub_re, one_re, sub_le_sub_iff_right]
      rw [mem_ball_iff_norm, Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add'] at hz'
    Â· refine
        le_add_of_nonneg_of_le (rpow_pos_of_pos ht _).le (rpow_le_rpow_of_exponent_ge ht h.le ?_)
      rw [sub_re, one_re, sub_le_iff_le_add, sub_add_cancel]
      rw [mem_ball_iff_norm', Complex.norm_eq_abs] at hz
      have hz' := (re_le_abs _).trans hz.le
      rwa [sub_re, sub_le_iff_le_add, â† sub_le_iff_le_add'] at hz'
  have h5 : IntegrableOn bound (Ioi 0) := by
    simp_rw [bound, add_mul, mul_assoc]
    suffices âˆ€ {j : â„}, b < j â†’ j < a â†’
        IntegrableOn (fun t : â„ => t ^ (j - 1) * (|log t| * â€–f tâ€–)) (Ioi 0) volume by
      refine Integrable.add (this ?_ ?_) (this ?_ ?_)
      all_goals linarith
    Â· intro j hj hj'
      obtain âŸ¨w, hw1, hw2âŸ© := exists_between hj
      obtain âŸ¨w', hw1', hw2'âŸ© := exists_between hj'
      refine mellin_convergent_of_isBigO_scalar ?_ ?_ hw1' ?_ hw2
      Â· simp_rw [mul_comm]
        refine hfc.norm.mul_continuousOn ?_ isOpen_Ioi
        refine Continuous.comp_continuousOn _root_.continuous_abs (continuousOn_log.mono ?_)
        exact subset_compl_singleton_iff.mpr not_mem_Ioi_self
      Â· refine (isBigO_rpow_top_log_smul hw2' hf_top).norm_left.congr_left fun t â†¦ ?_
        simp only [norm_smul, Real.norm_eq_abs]
      Â· refine (isBigO_rpow_zero_log_smul hw1 hf_bot).norm_left.congr_left fun t â†¦ ?_
        simp only [norm_smul, Real.norm_eq_abs]
  have h6 : âˆ€áµ t : â„ âˆ‚volume.restrict (Ioi 0),
      âˆ€ y : â„‚, y âˆˆ Metric.ball s v â†’ HasDerivAt (fun z : â„‚ => F z t) (F' y t) y := by
    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht y _ => ?_
    have ht' : (t : â„‚) â‰  0 := ofReal_ne_zero.mpr (ne_of_gt ht)
    have u1 : HasDerivAt (fun z : â„‚ => (t : â„‚) ^ (z - 1)) (t ^ (y - 1) * log t) y := by
      convert ((hasDerivAt_id' y).sub_const 1).const_cpow (Or.inl ht') using 1
      rw [ofReal_log (le_of_lt ht)]
      ring
    exact u1.smul_const (f t)
  have main := hasDerivAt_integral_of_dominated_loc_of_deriv_le hv0 h1 h2 h3 h4 h5 h6
  simpa only [F', mul_smul] using main"
Mathlib/Topology/ContinuousOn.lean,nhdsWithin_restrict,nhdsWithin_restrict,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  le_antisymm (le_inf inf_le_left (le_principal_iff.mpr (inter_mem self_mem_nhdsWithin h)))
    (inf_le_inf_left _ (principal_mono.mpr (Set.inter_subset_left _ _)))","error:  function expected at
  inter_subset_left ?m.9529
term has type
  ?m.9528 âˆˆ ?m.9526","theorem nhdsWithin_restrict'' {a : Î±} (s : Set Î±) {t : Set Î±} (h : t âˆˆ ğ“[s] a) :
    ğ“[s] a = ğ“[s âˆ© t] a ",":=
  le_antisymm (le_inf inf_le_left (le_principal_iff.mpr (inter_mem self_mem_nhdsWithin h)))
    (inf_le_inf_left _ (principal_mono.mpr Set.inter_subset_left))"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.toList_nil,toList_nil,88f252d9ef6777980e9cb4396094e178f3ed4acb,":=
  dest_eq_pure rfl",error:  unknown identifier 'dest_eq_pure',theorem toList_nil : toList (nil : WSeq Î±) = Computation.pure [] ,":=
  destruct_eq_pure rfl"
Mathlib/Data/Nat/Factorization/PrimePow.lean,isPrimePow_pow_iff,isPrimePow_pow_iff,67ee3b7709353762fdc01cfb00722ee8c27ff6a5,":= by
  simp only [isPrimePow_iff_unique_prime_dvd]
  apply exists_unique_congr
  simp only [and_congr_right_iff]
  intro p hp
  exact âŸ¨hp.dvd_of_dvd_pow, fun t => t.trans (dvd_pow_self _ hk)âŸ©",error:  unknown identifier 'exists_unique_congr',theorem isPrimePow_pow_iff {n k : â„•} (hk : k â‰  0) : IsPrimePow (n ^ k) â†” IsPrimePow n ,":= by
  simp only [isPrimePow_iff_unique_prime_dvd]
  apply existsUnique_congr
  simp only [and_congr_right_iff]
  intro p hp
  exact âŸ¨hp.dvd_of_dvd_pow, fun t => t.trans (dvd_pow_self _ hk)âŸ©"
Mathlib/RingTheory/Adjoin/Basic.lean,Algebra.adjoin_induction,adjoin_induction,ef3c9bcd07782b044027916a64e925f3e4951707,":=
  let S : Subalgebra R A :=
    { carrier := âŸ¨pâŸ©
      mul_mem' := mul _ _
      add_mem' := add _ _
      algebraMap_mem' := algebraMap }
  adjoin_le (show s â‰¤ S from mem) h","error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  A â†’ Prop
error:  type mismatch
  mem
has type
  âˆ€ x âˆˆ s, p x : Prop
but is expected to have type
  s â‰¤ â†‘S : Prop","theorem adjoin_induction {p : A â†’ Prop} {x : A} (h : x âˆˆ adjoin R s) (mem : âˆ€ x âˆˆ s, p x)
    (algebraMap : âˆ€ r, p (algebraMap R A r)) (add : âˆ€ x y, p x â†’ p y â†’ p (x + y))
    (mul : âˆ€ x y, p x â†’ p y â†’ p (x * y)) : p x ",":=
  let S : Subalgebra R A :=
    { carrier := p
      mul_mem' := mul _ _
      add_mem' := add _ _
      algebraMap_mem' := algebraMap }
  adjoin_le (show s â‰¤ S from mem) h"
Mathlib/RingTheory/DiscreteValuationRing/TFAE.lean,tfae_of_isNoetherianRing_of_localRing_of_isDomain,tfae_of_isNoetherianRing_of_localRing_of_isDomain,9973ad6d9c71296bde9b541823189ecbd49322ba,":= by
  tfae_have : 1 â†’ 2 := fun _ â†¦ inferInstance
  tfae_have : 2 â†’ 1 := fun _ â†¦ ((IsBezout.TFAE (R := R)).out 0 1).mp â€¹_â€º
  tfae_have : 1 â†’ 4
  | H => âŸ¨inferInstance, fun P hP hP' â†¦ eq_maximalIdeal (hP'.isMaximal hP)âŸ©
  tfae_have : 4 â†’ 3 :=
    fun âŸ¨hâ‚, hâ‚‚âŸ© â†¦ { hâ‚ with maximalOfPrime := (hâ‚‚ _ Â· Â· â–¸ maximalIdeal.isMaximal R) }
  tfae_have : 3 â†’ 5 := fun h â†¦ maximalIdeal_isPrincipal_of_isDedekindDomain R
  tfae_have : 6 â†” 5 := finrank_cotangentSpace_le_one_iff
  tfae_have : 5 â†’ 7 := exists_maximalIdeal_pow_eq_of_principal R
  tfae_have : 7 â†’ 2 := by
    rw [ValuationRing.iff_ideal_total]
    intro H
    constructor
    intro I J
    let _ := Classical.decEq (Ideal R)
    by_cases hI : I = âŠ¥; Â· subst hI; left; exact bot_le
    by_cases hJ : J = âŠ¥; Â· subst hJ; right; exact bot_le
    obtain âŸ¨n, rflâŸ© := H I hI
    obtain âŸ¨m, rflâŸ© := H J hJ
    exact (le_total m n).imp Ideal.pow_le_pow_right Ideal.pow_le_pow_right
  tfae_finish",error:  unexpected token ':'; expected numeral,"theorem tfae_of_isNoetherianRing_of_localRing_of_isDomain
    [IsNoetherianRing R] [LocalRing R] [IsDomain R] :
    List.TFAE
      [IsPrincipalIdealRing R, ValuationRing R, IsDedekindDomain R,
        IsIntegrallyClosed R âˆ§ âˆ€ P : Ideal R, P â‰  âŠ¥ â†’ P.IsPrime â†’ P = maximalIdeal R,
        (maximalIdeal R).IsPrincipal,
        finrank (ResidueField R) (CotangentSpace R) â‰¤ 1,
        âˆ€ (I) (_ : I â‰  âŠ¥), âˆƒ n : â„•, I = maximalIdeal R ^ n] ",":= by
  tfae_have 1 â†’ 2
  Â· exact fun _ â†¦ inferInstance
  tfae_have 2 â†’ 1
  Â· exact fun _ â†¦ ((IsBezout.TFAE (R := R)).out 0 1).mp â€¹_â€º
  tfae_have 1 â†’ 4
  Â· intro H
    exact âŸ¨inferInstance, fun P hP hP' â†¦ eq_maximalIdeal (hP'.isMaximal hP)âŸ©
  tfae_have 4 â†’ 3
  Â· exact fun âŸ¨hâ‚, hâ‚‚âŸ© â†¦ { hâ‚ with maximalOfPrime := (hâ‚‚ _ Â· Â· â–¸ maximalIdeal.isMaximal R) }
  tfae_have 3 â†’ 5
  Â· exact fun h â†¦ maximalIdeal_isPrincipal_of_isDedekindDomain R
  tfae_have 6 â†” 5
  Â· exact finrank_cotangentSpace_le_one_iff
  tfae_have 5 â†’ 7
  Â· exact exists_maximalIdeal_pow_eq_of_principal R
  tfae_have 7 â†’ 2
  Â· rw [ValuationRing.iff_ideal_total]
    intro H
    constructor
    intro I J
    let _ := Classical.decEq (Ideal R)
    by_cases hI : I = âŠ¥; Â· subst hI; left; exact bot_le
    by_cases hJ : J = âŠ¥; Â· subst hJ; right; exact bot_le
    obtain âŸ¨n, rflâŸ© := H I hI
    obtain âŸ¨m, rflâŸ© := H J hJ
    exact (le_total m n).imp Ideal.pow_le_pow_right Ideal.pow_le_pow_right
  tfae_finish"
Mathlib/Computability/AkraBazzi/AkraBazzi.lean,AkraBazziRecurrence.rpow_p_mul_one_sub_smoothingFn_le,rpow_p_mul_one_sub_smoothingFn_le,e3adc4f0695a3d67fb7d7efd6330f16323f31c79,":= by
  rw [Filter.eventually_all]
  intro i
  let q : â„ â†’ â„ := fun x => x ^ (p a b) * (1 - Îµ x)
  have h_diff_q : DifferentiableOn â„ q (Set.Ioi 1) := by
    refine DifferentiableOn.mul
      (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)
        differentiableOn_one_sub_smoothingFn
    rw [Set.mem_compl_singleton_iff]
    exact ne_of_gt <| zero_lt_one.trans hz
  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc
    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 - Îµ z) x := by rfl
          _ =á¶ [atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 - Îµ x) +
                  x ^ (p a b) * deriv (fun z => 1 - Îµ z) x := by
              filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'
              rw [deriv_mul] <;> aesop
          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by
              refine IsBigO.add ?left ?right
              case left => calc
                (fun x => deriv (fun z => z ^ (p a b)) x * (1 - Îµ x))
                    =O[atTop] fun x => x ^ ((p a b) - 1) * (1 - Îµ x) := by
                      exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)
                  _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 := by
                      refine IsBigO.mul (isBigO_refl _ _)
                        isEquivalent_one_sub_smoothingFn_one.isBigO
                  _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]
              case right => calc
                (fun x => x ^ (p a b) * deriv (fun z => 1 - Îµ z) x)
                    =O[atTop] (fun x => x ^ (p a b) * xâ»Â¹) := by
                      exact IsBigO.mul (isBigO_refl _ _) isLittleO_deriv_one_sub_smoothingFn.isBigO
                  _ =á¶ [atTop] fun x => x ^ ((p a b) - 1) := by
                      filter_upwards [eventually_gt_atTop 0] with x hx
                      rw [â† Real.rpow_neg_one, â† Real.rpow_add hx, â† sub_eq_add_neg]
  have h_main_norm : (fun (n:â„•) => â€–q (r i n) - q (b i * n)â€–)
      â‰¤á¶ [atTop] fun (n:â„•) => â€–(b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)â€– := by
    refine IsLittleO.eventuallyLE ?_
    calc
      (fun (n:â„•) => q (r i n) - q (b i * n))
          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by
              exact R.isBigO_apply_r_sub_b q h_diff_q
                (growsPolynomially_deriv_rpow_p_mul_one_sub_smoothingFn (p a b)) i
        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by
              exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)
        _ =O[atTop] fun n => n^((p a b) - 1) * (n / log n ^ 2) := by
              exact IsBigO.mul (IsBigO.nat_cast_atTop h_deriv_q) (isBigO_refl _ _)
        _ =á¶ [atTop] fun n => n^(p a b) / (log n) ^ 2 := by
              filter_upwards [eventually_ne_atTop 0] with n hn
              have hn' : (n:â„) â‰  0 := by positivity
              simp [â† mul_div_assoc, â† Real.rpow_add_one hn']
        _ = fun (n:â„•) => (n:â„) ^ (p a b) * (1 / (log n)^2)   := by
              simp_rw [mul_div, mul_one]
        _ =Î˜[atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n)^2)   := by
              refine IsTheta.symm ?_
              simp_rw [mul_assoc]
              refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)
              have := R.b_pos i; positivity
        _ =Î˜[atTop] fun (n:â„•) => (b i)^(p a b) * n^(p a b) * (Îµ (b i * n) - Îµ n) := by
              exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)
                <| R.isTheta_smoothingFn_sub_self i
  have h_main : (fun (n:â„•) => q (r i n) - q (b i * n))
      â‰¤á¶ [atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
    calc (fun (n:â„•) => q (r i n) - q (b i * n))
           â‰¤á¶ [atTop] fun (n:â„•) => â€–q (r i n) - q (b i * n)â€–     := by
                filter_upwards with _; exact le_norm_self _
         _ â‰¤á¶ [atTop] fun (n:â„•) => â€–(b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)â€– :=
                h_main_norm
         _ =á¶ [atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
                filter_upwards [eventually_gt_atTop âŒˆ(b i)â»Â¹âŒ‰â‚Š, eventually_gt_atTop 1] with n hn hn'
                refine norm_of_nonneg ?_
                have hâ‚ := R.b_pos i
                have hâ‚‚ : 0 â‰¤ Îµ (b i * n) - Îµ n := by
                  refine sub_nonneg_of_le <|
                    (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le
                  case n_gt_one =>
                    show 1 < (n:â„)
                    rw [Nat.one_lt_cast]
                    exact hn'
                  case bn_gt_one =>
                    calc 1 = b i * (b i)â»Â¹ := by rw [mul_inv_cancel (by positivity)]
                        _ â‰¤ b i * âŒˆ(b i)â»Â¹âŒ‰â‚Š := by gcongr; exact Nat.le_ceil _
                        _ < b i * n := by gcongr; rw [Nat.cast_lt]; exact hn
                  case le => calc b i * n â‰¤ 1 * n := by have := R.b_lt_one i; gcongr
                                          _ = n := by rw [one_mul]
                positivity
  filter_upwards [h_main] with n hn
  have hâ‚ : q (b i * n) + (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)
      = (b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n) := by
    have := R.b_pos i
    simp only [mul_rpow (by positivity : (0:â„) â‰¤ b i) (by positivity : (0:â„) â‰¤ n)]
    ring
  show q (r i n) â‰¤ (b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n)
  rw [â† hâ‚, â† sub_le_iff_le_add']
  exact hn","warning:  `Asymptotics.IsBigO.nat_cast_atTop` has been deprecated, use `Asymptotics.IsBigO.natCast_atTop` instead
error:  simp made no progress","lemma rpow_p_mul_one_sub_smoothingFn_le :
    âˆ€á¶  (n : â„•) in atTop, âˆ€ i, (r i n) ^ (p a b) * (1 - Îµ (r i n))
      â‰¤ (b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n) ",":= by
  rw [Filter.eventually_all]
  intro i
  let q : â„ â†’ â„ := fun x => x ^ (p a b) * (1 - Îµ x)
  have h_diff_q : DifferentiableOn â„ q (Set.Ioi 1) := by
    refine DifferentiableOn.mul
      (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)
        differentiableOn_one_sub_smoothingFn
    rw [Set.mem_compl_singleton_iff]
    rw [Set.mem_Ioi] at hz
    exact ne_of_gt <| zero_lt_one.trans hz
  have h_deriv_q : deriv q =O[atTop] fun x => x ^ ((p a b) - 1) := calc
    deriv q = deriv fun x => (fun z => z ^ (p a b)) x * (fun z => 1 - Îµ z) x := by rfl
          _ =á¶ [atTop] fun x => deriv (fun z => z ^ (p a b)) x * (1 - Îµ x) +
                  x ^ (p a b) * deriv (fun z => 1 - Îµ z) x := by
              filter_upwards [eventually_ne_atTop 0, eventually_gt_atTop 1] with x hx hx'
              rw [deriv_mul] <;> aesop
          _ =O[atTop] fun x => x ^ ((p a b) - 1) := by
              refine IsBigO.add ?left ?right
              case left => calc
                (fun x => deriv (fun z => z ^ (p a b)) x * (1 - Îµ x))
                    =O[atTop] fun x => x ^ ((p a b) - 1) * (1 - Îµ x) := by
                      exact IsBigO.mul (isBigO_deriv_rpow_const_atTop (p a b)) (isBigO_refl _ _)
                  _ =O[atTop] fun x => x ^ ((p a b) - 1) * 1 := by
                      refine IsBigO.mul (isBigO_refl _ _)
                        isEquivalent_one_sub_smoothingFn_one.isBigO
                  _ = fun x => x ^ ((p a b) - 1) := by ext; rw [mul_one]
              case right => calc
                (fun x => x ^ (p a b) * deriv (fun z => 1 - Îµ z) x)
                    =O[atTop] (fun x => x ^ (p a b) * xâ»Â¹) := by
                      exact IsBigO.mul (isBigO_refl _ _) isLittleO_deriv_one_sub_smoothingFn.isBigO
                  _ =á¶ [atTop] fun x => x ^ ((p a b) - 1) := by
                      filter_upwards [eventually_gt_atTop 0] with x hx
                      rw [â† Real.rpow_neg_one, â† Real.rpow_add hx, â† sub_eq_add_neg]
  have h_main_norm : (fun (n:â„•) => â€–q (r i n) - q (b i * n)â€–)
      â‰¤á¶ [atTop] fun (n:â„•) => â€–(b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)â€– := by
    refine IsLittleO.eventuallyLE ?_
    calc
      (fun (n:â„•) => q (r i n) - q (b i * n))
          =O[atTop] fun n => (deriv q n) * (r i n - b i * n) := by
              exact R.isBigO_apply_r_sub_b q h_diff_q
                (growsPolynomially_deriv_rpow_p_mul_one_sub_smoothingFn (p a b)) i
        _ =o[atTop] fun n => (deriv q n) * (n / log n ^ 2) := by
              exact IsBigO.mul_isLittleO (isBigO_refl _ _) (R.dist_r_b i)
        _ =O[atTop] fun n => n^((p a b) - 1) * (n / log n ^ 2) := by
              exact IsBigO.mul (IsBigO.natCast_atTop h_deriv_q) (isBigO_refl _ _)
        _ =á¶ [atTop] fun n => n^(p a b) / (log n) ^ 2 := by
              filter_upwards [eventually_ne_atTop 0] with n hn
              have hn' : (n:â„) â‰  0 := by positivity
              simp [â† mul_div_assoc, â† Real.rpow_add_one hn']
        _ = fun (n:â„•) => (n:â„) ^ (p a b) * (1 / (log n)^2)   := by
              simp_rw [mul_div, mul_one]
        _ =Î˜[atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (1 / (log n)^2)   := by
              refine IsTheta.symm ?_
              simp_rw [mul_assoc]
              refine IsTheta.const_mul_left ?_ (isTheta_refl _ _)
              have := R.b_pos i; positivity
        _ =Î˜[atTop] fun (n:â„•) => (b i)^(p a b) * n^(p a b) * (Îµ (b i * n) - Îµ n) := by
              exact IsTheta.symm <| IsTheta.mul (isTheta_refl _ _)
                <| R.isTheta_smoothingFn_sub_self i
  have h_main : (fun (n:â„•) => q (r i n) - q (b i * n))
      â‰¤á¶ [atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
    calc (fun (n:â„•) => q (r i n) - q (b i * n))
           â‰¤á¶ [atTop] fun (n:â„•) => â€–q (r i n) - q (b i * n)â€–     := by
                filter_upwards with _; exact le_norm_self _
         _ â‰¤á¶ [atTop] fun (n:â„•) => â€–(b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)â€– :=
                h_main_norm
         _ =á¶ [atTop] fun (n:â„•) => (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n) := by
                filter_upwards [eventually_gt_atTop âŒˆ(b i)â»Â¹âŒ‰â‚Š, eventually_gt_atTop 1] with n hn hn'
                refine norm_of_nonneg ?_
                have hâ‚ := R.b_pos i
                have hâ‚‚ : 0 â‰¤ Îµ (b i * n) - Îµ n := by
                  refine sub_nonneg_of_le <|
                    (strictAntiOn_smoothingFn.le_iff_le ?n_gt_one ?bn_gt_one).mpr ?le
                  case n_gt_one =>
                    rwa [Set.mem_Ioi, Nat.one_lt_cast]
                  case bn_gt_one =>
                    calc 1 = b i * (b i)â»Â¹ := by rw [mul_inv_cancel (by positivity)]
                        _ â‰¤ b i * âŒˆ(b i)â»Â¹âŒ‰â‚Š := by gcongr; exact Nat.le_ceil _
                        _ < b i * n := by gcongr; rw [Nat.cast_lt]; exact hn
                  case le => calc b i * n â‰¤ 1 * n := by have := R.b_lt_one i; gcongr
                                          _ = n := by rw [one_mul]
                positivity
  filter_upwards [h_main] with n hn
  have hâ‚ : q (b i * n) + (b i) ^ (p a b) * n ^ (p a b) * (Îµ (b i * n) - Îµ n)
      = (b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n) := by
    have := R.b_pos i
    simp only [q, mul_rpow (by positivity : (0:â„) â‰¤ b i) (by positivity : (0:â„) â‰¤ n)]
    ring
  show q (r i n) â‰¤ (b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n)
  rw [â† hâ‚, â† sub_le_iff_le_add']
  exact hn"
Mathlib/GroupTheory/SpecificGroups/Cyclic.lean,exists_pow_ne_one_of_isCyclic,exists_pow_ne_one_of_isCyclic,23bca4e7b9b89fb9b29c6e54108c10a745f95d0f,":= by
  rcases G_cyclic with âŸ¨a, haâŸ©
  use a
  contrapose! k_lt_card_G
  convert orderOf_le_of_pow_eq_one k_pos.bot_lt k_lt_card_G
  rw [â† Fintype.card_zpowers, eq_comm, Subgroup.card_eq_iff_eq_top, eq_top_iff]
  exact fun x _ â†¦ ha x","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.card â†¥?H = Nat.card ?m.19073
case h.e'_3
Î± : Type u
aâœ : Î±
instâœÂ² : Group Î±
G : Type u_1
instâœÂ¹ : Group G
instâœ : Fintype G
k : â„•
k_pos : k â‰  0
a : G
ha : âˆ€ (x : G), x âˆˆ zpowers a
k_lt_card_G : a ^ k = 1
âŠ¢ Fintype.card â†¥(zpowers a) = Fintype.card G","theorem exists_pow_ne_one_of_isCyclic {G : Type*} [Group G] [Fintype G] [G_cyclic : IsCyclic G]
    {k : â„•} (k_pos : k â‰  0) (k_lt_card_G : k < Fintype.card G) : âˆƒ a : G, a ^ k â‰  1 ",":= by
  rcases G_cyclic with âŸ¨a, haâŸ©
  use a
  contrapose! k_lt_card_G
  convert orderOf_le_of_pow_eq_one k_pos.bot_lt k_lt_card_G
  rw [â† Nat.card_eq_fintype_card, â† Nat.card_zpowers, eq_comm, card_eq_iff_eq_top, eq_top_iff]
  exact fun x _ â†¦ ha x"
Mathlib/NumberTheory/Padics/PadicVal.lean,Nat.log_ne_padicValNat_succ,Nat.log_ne_padicValNat_succ,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [Ne, log_eq_iff (by simp [hn])]
  rintro âŸ¨h1, h2âŸ©
  rw [â† lt_add_one_iff, â† mul_one (2 ^ _)] at h1
  rw [â† add_one_le_iff, Nat.pow_succ] at h2
  refine not_dvd_of_between_consec_multiples h1 (lt_of_le_of_ne' h2 ?_) pow_padicValNat_dvd
  exact pow_succ_padicValNat_not_dvd (p := 2) n.succ_ne_zero âˆ˜ dvd_of_eq","error:  unknown identifier 'lt_add_one_iff'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.65770
case intro
p n : â„•
hn : n â‰  0
h1 : 2 ^ padicValNat 2 (n + 1) â‰¤ n
h2 : n < 2 ^ (padicValNat 2 (n + 1) + 1)
âŠ¢ False",lemma Nat.log_ne_padicValNat_succ {n : â„•} (hn : n â‰  0) : log 2 n â‰  padicValNat 2 (n + 1) ,":= by
  rw [Ne, log_eq_iff (by simp [hn])]
  rintro âŸ¨h1, h2âŸ©
  rw [â† Nat.lt_add_one_iff, â† mul_one (2 ^ _)] at h1
  rw [â† add_one_le_iff, Nat.pow_succ] at h2
  refine not_dvd_of_between_consec_multiples h1 (lt_of_le_of_ne' h2 ?_) pow_padicValNat_dvd
  exact pow_succ_padicValNat_not_dvd (p := 2) n.succ_ne_zero âˆ˜ dvd_of_eq"
Mathlib/RingTheory/Jacobson.lean,Ideal.MvPolynomial.quotient_mk_comp_C_isIntegral_of_jacobson,quotient_mk_comp_C_isIntegral_of_jacobson,6fcb04c231d90eb32c9114ba0540239f9e9ac612,":= by
  refine' (isIntegral_quotientMap_iff _).mp _
  let P' : Ideal R := P.comap C
  obtain âŸ¨pX, hpX, hp0âŸ© :=
    exists_nonzero_mem_of_ne_bot (ne_of_lt (bot_lt_of_maximal P polynomial_not_isField)).symm hP'
  let a : R â§¸ P' := (pX.map (Quotient.mk P')).leadingCoeff
  let M : Submonoid (R â§¸ P') := Submonoid.powers a
  let Ï† : R â§¸ P' â†’+* R[X] â§¸ P := quotientMap P C le_rfl
  haveI hP'_prime : P'.IsPrime := comap_isPrime C P
  have hM : (0 : R â§¸ P') âˆ‰ M := fun âŸ¨n, hnâŸ© => hp0 <| leadingCoeff_eq_zero.mp (pow_eq_zero hn)
  let M' : Submonoid (R[X] â§¸ P) := M.map Ï†
  refine' RingHom.IsIntegral.tower_bot Ï† (algebraMap _ (Localization M')) _ _
  Â· refine' IsLocalization.injective (Localization M')
      (show M' â‰¤ _ from le_nonZeroDivisors_of_noZeroDivisors fun hM' => hM _)
    exact
      let âŸ¨z, zM, z0âŸ© := hM'
      quotientMap_injective (_root_.trans z0 Ï†.map_zero.symm) â–¸ zM
  Â· suffices : RingHom.comp (algebraMap (R[X] â§¸ P) (Localization M')) Ï† =
      (IsLocalization.map (Localization M') Ï† M.le_comap_map).comp
        (algebraMap (R â§¸ P') (Localization M))
    rw [this]
    refine' RingHom.IsIntegral.trans (algebraMap (R â§¸ P') (Localization M))
      (IsLocalization.map (Localization M') Ï† M.le_comap_map) _ _
    Â· exact (algebraMap (R â§¸ P') (Localization M)).isIntegral_of_surjective
        (IsField.localization_map_bijective hM ((Quotient.maximal_ideal_iff_isField_quotient _).mp
          (isMaximal_comap_C_of_isMaximal P hP'))).2
    Â· 
      have isloc : IsLocalization M' (Localization M') := by infer_instance
      exact @isIntegral_isLocalization_polynomial_quotient R _
        (Localization M) (Localization M') _ _ P pX hpX _ _ _ isloc
    rw [IsLocalization.map_comp M.le_comap_map]",error:  unexpected token ':'; expected term,"theorem quotient_mk_comp_C_isIntegral_of_jacobson' [Nontrivial R] (hR : IsJacobson R)
    (hP' : âˆ€ x : R, C x âˆˆ P â†’ x = 0) : ((Quotient.mk P).comp C : R â†’+* R[X] â§¸ P).IsIntegral ",":= by
  refine (isIntegral_quotientMap_iff _).mp ?_
  let P' : Ideal R := P.comap C
  obtain âŸ¨pX, hpX, hp0âŸ© :=
    exists_nonzero_mem_of_ne_bot (ne_of_lt (bot_lt_of_maximal P polynomial_not_isField)).symm hP'
  let a : R â§¸ P' := (pX.map (Quotient.mk P')).leadingCoeff
  let M : Submonoid (R â§¸ P') := Submonoid.powers a
  let Ï† : R â§¸ P' â†’+* R[X] â§¸ P := quotientMap P C le_rfl
  haveI hP'_prime : P'.IsPrime := comap_isPrime C P
  have hM : (0 : R â§¸ P') âˆ‰ M := fun âŸ¨n, hnâŸ© => hp0 <| leadingCoeff_eq_zero.mp (pow_eq_zero hn)
  let M' : Submonoid (R[X] â§¸ P) := M.map Ï†
  refine RingHom.IsIntegral.tower_bot Ï† (algebraMap _ (Localization M')) ?_ ?_
  Â· refine IsLocalization.injective (Localization M')
      (show M' â‰¤ _ from le_nonZeroDivisors_of_noZeroDivisors fun hM' => hM ?_)
    exact
      let âŸ¨z, zM, z0âŸ© := hM'
      quotientMap_injective (_root_.trans z0 Ï†.map_zero.symm) â–¸ zM
  Â· suffices RingHom.comp (algebraMap (R[X] â§¸ P) (Localization M')) Ï† =
      (IsLocalization.map (Localization M') Ï† M.le_comap_map).comp
        (algebraMap (R â§¸ P') (Localization M)) by
      rw [this]
      refine RingHom.IsIntegral.trans (algebraMap (R â§¸ P') (Localization M))
        (IsLocalization.map (Localization M') Ï† M.le_comap_map) ?_ ?_
      Â· exact (algebraMap (R â§¸ P') (Localization M)).isIntegral_of_surjective
          (IsField.localization_map_bijective hM ((Quotient.maximal_ideal_iff_isField_quotient _).mp
            (isMaximal_comap_C_of_isMaximal P hP'))).2
      Â· 
        have isloc : IsLocalization M' (Localization M') := by infer_instance
        exact @isIntegral_isLocalization_polynomial_quotient R _
          (Localization M) (Localization M') _ _ P pX hpX _ _ _ isloc
    rw [IsLocalization.map_comp M.le_comap_map]"
Mathlib/RingTheory/PowerBasis.lean,PowerBasis.constr_pow_aeval,constr_pow_aeval,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  cases subsingleton_or_nontrivial A
  Â· rw [(Subsingleton.elim _ _ : f = 0), aeval_zero, map_zero, aeval_zero]
  rw [â† aeval_modByMonic_eq_self_of_root (minpoly.monic pb.isIntegral_gen) (minpoly.aeval _ _), â†
    @aeval_modByMonic_eq_self_of_root _ _ _ _ _ _ f _ (minpoly.monic pb.isIntegral_gen) y hy]
  by_cases hf : f %â‚˜ minpoly A pb.gen = 0
  Â· simp only [hf, AlgHom.map_zero, LinearMap.map_zero]
  have : (f %â‚˜ minpoly A pb.gen).natDegree < pb.dim := by
    rw [â† pb.natDegree_minpoly]
    apply natDegree_lt_natDegree hf
    exact degree_modByMonic_lt _ (minpoly.monic pb.isIntegral_gen)
  rw [aeval_eq_sum_range' this, aeval_eq_sum_range' this, map_sum]
  refine' Finset.sum_congr rfl fun i (hi : i âˆˆ Finset.range pb.dim) => _
  rw [Finset.mem_range] at hi
  rw [LinearMap.map_smul]
  congr
  rw [â† Fin.val_mk hi, â† pb.basis_eq_pow âŸ¨i, hiâŸ©, Basis.constr_basis]","error:  application type mismatch
  aeval_modByMonic_eq_self_of_root ?m.115892 y
argument
  y
has type
  S' : Type u_7
but is expected to have type
  (aeval ?m.116107) f = 0 : Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.116511
case inr
R : Type u_1
S : Type u_2
T : Type u_3
instâœÂ¹â° : CommRing R
instâœâ¹ : Ring S
instâœâ¸ : Algebra R S
A : Type u_4
B : Type u_5
instâœâ· : CommRing A
instâœâ¶ : CommRing B
instâœâµ : IsDomain B
instâœâ´ : Algebra A B
K : Type u_6
instâœÂ³ : Field K
instâœÂ² : Algebra A S
S' : Type u_7
instâœÂ¹ : Ring S'
instâœ : Algebra A S'
pb : PowerBasis A S
y : S'
hy : (aeval y) (minpoly A pb.gen) = 0
f : A[X]
hâœ : Nontrivial A
âŠ¢ ((pb.basis.constr A) fun i â†¦ y ^ â†‘i) ((aeval pb.gen) (f %â‚˜ minpoly A pb.gen)) = (aeval y) f","theorem constr_pow_aeval (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0)
    (f : A[X]) : pb.basis.constr A (fun i => y ^ (i : â„•)) (aeval pb.gen f) = aeval y f ",":= by
  cases subsingleton_or_nontrivial A
  Â· rw [(Subsingleton.elim _ _ : f = 0), aeval_zero, map_zero, aeval_zero]
  rw [â† aeval_modByMonic_eq_self_of_root (minpoly.monic pb.isIntegral_gen) (minpoly.aeval _ _), â†
    @aeval_modByMonic_eq_self_of_root _ _ _ _ _ f _ (minpoly.monic pb.isIntegral_gen) y hy]
  by_cases hf : f %â‚˜ minpoly A pb.gen = 0
  Â· simp only [hf, AlgHom.map_zero, LinearMap.map_zero]
  have : (f %â‚˜ minpoly A pb.gen).natDegree < pb.dim := by
    rw [â† pb.natDegree_minpoly]
    apply natDegree_lt_natDegree hf
    exact degree_modByMonic_lt _ (minpoly.monic pb.isIntegral_gen)
  rw [aeval_eq_sum_range' this, aeval_eq_sum_range' this, map_sum]
  refine Finset.sum_congr rfl fun i (hi : i âˆˆ Finset.range pb.dim) => ?_
  rw [Finset.mem_range] at hi
  rw [LinearMap.map_smul]
  congr
  rw [â† Fin.val_mk hi, â† pb.basis_eq_pow âŸ¨i, hiâŸ©, Basis.constr_basis]"
Mathlib/Algebra/Lie/Weights/Chain.lean,LieModule.weightSpaceChain_neg,weightSpaceChain_neg,b68386b3912640290abea7957aee34c8fcb3867e,":= by
  let e : â„¤ â‰ƒ â„¤ := âŸ¨(- Â·), (- Â·), neg_neg, neg_negâŸ© 
  simp_rw [weightSpaceChain, â† e.biSup_comp (Ioo p q)]
  simp [-mem_Ioo, neg_mem_Ioo_iff]","error:  unsolved goals
R : Type u_1
L : Type u_2
instâœâ· : CommRing R
instâœâ¶ : LieRing L
instâœâµ : LieAlgebra R L
M : Type u_3
instâœâ´ : AddCommGroup M
instâœÂ³ : Module R M
instâœÂ² : LieRingModule L M
instâœÂ¹ : LieModule R L M
instâœ : LieAlgebra.IsNilpotent R L
Ï‡â‚ Ï‡â‚‚ : L â†’ R
p q : â„¤
e : â„¤ â‰ƒ â„¤ := { toFun := fun x â†¦ -x, invFun := fun x â†¦ -x, left_inv := â‹¯, right_inv := â‹¯ }
âŠ¢ â¨† k âˆˆ Ioo (-q) (-p), weightSpace M (-((fun x â†¦ â†‘k) * Ï‡â‚) + Ï‡â‚‚) =
    â¨† i, â¨† (_ : e i âˆˆ Ioo p q), weightSpace M ((fun x â†¦ â†‘(e i)) * Ï‡â‚ + Ï‡â‚‚)","lemma weightSpaceChain_neg :
    weightSpaceChain M (-Ï‡â‚) Ï‡â‚‚ (-q) (-p) = weightSpaceChain M Ï‡â‚ Ï‡â‚‚ p q ",":= by
  let e : â„¤ â‰ƒ â„¤ := neg_involutive.toPerm
  simp_rw [weightSpaceChain, â† e.biSup_comp (Ioo p q)]
  simp [e, -mem_Ioo, neg_mem_Ioo_iff]"
Mathlib/Geometry/Manifold/PartitionOfUnity.lean,SmoothPartitionOfUnity.exists_isSubordinate,exists_isSubordinate,19e0ba92d515807cd80a1789fabbf5c4355561be,":= by
  haveI : LocallyCompactSpace H := I.locally_compact
  haveI : LocallyCompactSpace M := ChartedSpace.locallyCompact H M
  haveI : NormalSpace M := normal_of_paracompact_t2
  have hB := fun x hx => SmoothBumpFunction.nhds_basis_support I (hU x hx)
  rcases refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set hs hB with
    âŸ¨Î¹, c, f, hf, hsub', hfinâŸ©
  choose hcs hfU using hf
  rcases exists_subset_iUnion_closed_subset hs (fun i => (f i).isOpen_support)
    (fun x _ => hfin.point_finite x) hsub' with âŸ¨V, hsV, hVc, hVfâŸ©
  choose r hrR hr using fun i => (f i).exists_r_pos_lt_subset_ball (hVc i) (hVf i)
  refine' âŸ¨Î¹, âŸ¨c, fun i => (f i).updateRIn (r i) (hrR i), hcs, _, fun x hx => _âŸ©, fun i => _âŸ©
  Â· simpa only [SmoothBumpFunction.support_updateRIn]
  Â· refine' (mem_iUnion.1 <| hsV hx).imp fun i hi => _
    exact ((f i).updateRIn _ _).eventuallyEq_one_of_dist_lt
      ((f i).support_subset_source <| hVf _ hi) (hr i hi).2
  Â· simpa only [SmoothBumpFunction.support_updateRIn, tsupport] using hfU i","error:  invalid field 'locally_compact', the environment does not contain 'ModelWithCorners.locally_compact'
  I
has type
  ModelWithCorners â„ E H
error:  unknown constant 'ChartedSpace.locallyCompact'
error:  unknown identifier 'normal_of_paracompact_t2'","theorem exists_isSubordinate [T2Space M] [SigmaCompactSpace M] (hs : IsClosed s)
    (hU : âˆ€ x âˆˆ s, U x âˆˆ ğ“ x) :
    âˆƒ (Î¹ : Type uM) (f : SmoothBumpCovering Î¹ I M s), f.IsSubordinate U ",":= by
  haveI : LocallyCompactSpace H := I.locallyCompactSpace
  haveI : LocallyCompactSpace M := ChartedSpace.locallyCompactSpace H M
  have hB := fun x hx => SmoothBumpFunction.nhds_basis_support I (hU x hx)
  rcases refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set hs hB with
    âŸ¨Î¹, c, f, hf, hsub', hfinâŸ©
  choose hcs hfU using hf
  rcases exists_subset_iUnion_closed_subset hs (fun i => (f i).isOpen_support)
    (fun x _ => hfin.point_finite x) hsub' with âŸ¨V, hsV, hVc, hVfâŸ©
  choose r hrR hr using fun i => (f i).exists_r_pos_lt_subset_ball (hVc i) (hVf i)
  refine âŸ¨Î¹, âŸ¨c, fun i => (f i).updateRIn (r i) (hrR i), hcs, ?_, fun x hx => ?_âŸ©, fun i => ?_âŸ©
  Â· simpa only [SmoothBumpFunction.support_updateRIn]
  Â· refine (mem_iUnion.1 <| hsV hx).imp fun i hi => ?_
    exact ((f i).updateRIn _ _).eventuallyEq_one_of_dist_lt
      ((f i).support_subset_source <| hVf _ hi) (hr i hi).2
  Â· simpa only [SmoothBumpFunction.support_updateRIn, tsupport] using hfU i"
Mathlib/MeasureTheory/Measure/Typeclasses.lean,MeasureTheory.ite_ae_eq_of_measure_compl_zero,ite_ae_eq_of_measure_compl_zero,0ef23fba776dbe5bb848bbfc3337bedef4a59c82,":= by
  change s âˆˆ Î¼.ae at hs_zero
  filter_upwards [hs_zero]
  intros
  split_ifs
  rfl","error:  invalid field 'ae', the environment does not contain 'MeasureTheory.Measure.ae'
  Î¼
has type
  Measure Î±
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î´ : Type u_3
Î¹ : Type u_4
m0 : MeasurableSpace Î±
instâœÂ¹ : MeasurableSpace Î²
Î¼ Î½ Î½â‚ Î½â‚‚ : Measure Î±
sâœ t : Set Î±
Î³ : Type u_5
f g : Î± â†’ Î³
s : Set Î±
instâœ : DecidablePred fun x â†¦ x âˆˆ s
hs_zero : Î¼ sá¶œ = 0
âŠ¢ (fun x â†¦ if x âˆˆ s then f x else g x) =á¶ [ae Î¼] f","theorem ite_ae_eq_of_measure_compl_zero {Î³} (f : Î± â†’ Î³) (g : Î± â†’ Î³)
    (s : Set Î±) [DecidablePred (Â· âˆˆ s)] (hs_zero : Î¼ sá¶œ = 0) :
    (fun x => ite (x âˆˆ s) (f x) (g x)) =áµ[Î¼] f ",":= by
  rw [â† mem_ae_iff] at hs_zero
  filter_upwards [hs_zero]
  intros
  split_ifs
  rfl"
Mathlib/Order/Filter/Bases.lean,Filter.HasBasis.exists_antitone_subbasis,HasBasis.exists_antitone_subbasis,14167e48d13e9c2d72cbdff0431a8edba6021c34,":= by
  obtain âŸ¨x', hx'âŸ© : âˆƒ x : â„• â†’ Set Î±, f = â¨… i, ğ“Ÿ (x i) := by
    rcases h with âŸ¨s, hsc, rflâŸ©
    rw [generate_eq_binfáµ¢]
    exact countable_binfáµ¢_principal_eq_seq_infáµ¢ hsc
  have : âˆ€ i, x' i âˆˆ f := fun i => hx'.symm â–¸ (infáµ¢_le (fun i => ğ“Ÿ (x' i)) i) (mem_principal_self _)
  let x : â„• â†’ { i : Î¹' // p i } := fun n =>
    Nat.recOn n (hs.index _ <| this 0) fun n xn =>
      hs.index _ <| inter_mem (this <| n + 1) (hs.mem_of_mem xn.2)
  have x_mono : Antitone fun i => s (x i).1 :=
    antitone_nat_of_succ_le fun i => (hs.set_index_subset _).trans (inter_subset_right _ _)
  have x_subset : âˆ€ i, s (x i).1 âŠ† x' i := by
    rintro (_ | i)
    exacts [hs.set_index_subset _, (hs.set_index_subset _).trans (inter_subset_left _ _)]
  refine' âŸ¨fun i => (x i).1, fun i => (x i).2, _âŸ©
  have : (â¨… i, ğ“Ÿ (s (x i).1)).HasAntitoneBasis fun i => s (x i).1 :=
    âŸ¨hasBasis_infáµ¢_principal (directed_of_sup x_mono), x_monoâŸ©
  convert this
  exact
    le_antisymm (le_infáµ¢ fun i => le_principal_iff.2 <| by cases i <;> apply hs.set_index_mem)
      (hx'.symm â–¸
        le_infáµ¢ fun i => le_principal_iff.2 <| this.1.mem_iff.2 âŸ¨i, trivial, x_subset iâŸ©)","error:  unknown identifier 'generate_eq_binfáµ¢'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.87853
case mk.intro.intro
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Î¹ : Type u_4
Î¹' : Sort u_5
p : Î¹' â†’ Prop
sâœ : Î¹' â†’ Set Î±
s : Set (Set Î±)
hsc : s.Countable
hs : (generate s).HasBasis p sâœ
âŠ¢ âˆƒ x, generate s = â¨… i, ğ“Ÿ (x i)
error:  unknown identifier 'infáµ¢_le'
error:  function expected at
  inter_subset_right ?m.88612
term has type
  ?m.88611 âˆˆ ?m.88610
error:  function expected at
  inter_subset_left ?m.88783
term has type
  ?m.88782 âˆˆ ?m.88780
error:  unknown identifier 'hasBasis_infáµ¢_principal'
error:  unknown identifier 'le_infáµ¢'
error:  unknown identifier 'le_infáµ¢'","theorem HasBasis.exists_antitone_subbasis {f : Filter Î±} [h : f.IsCountablyGenerated]
    {p : Î¹' â†’ Prop} {s : Î¹' â†’ Set Î±} (hs : f.HasBasis p s) :
    âˆƒ x : â„• â†’ Î¹', (âˆ€ i, p (x i)) âˆ§ f.HasAntitoneBasis fun i => s (x i) ",":= by
  obtain âŸ¨x', hx'âŸ© : âˆƒ x : â„• â†’ Set Î±, f = â¨… i, ğ“Ÿ (x i) := by
    rcases h with âŸ¨s, hsc, rflâŸ©
    rw [generate_eq_biInf]
    exact countable_biInf_principal_eq_seq_iInf hsc
  have : âˆ€ i, x' i âˆˆ f := fun i => hx'.symm â–¸ (iInf_le (fun i => ğ“Ÿ (x' i)) i) (mem_principal_self _)
  let x : â„• â†’ { i : Î¹' // p i } := fun n =>
    Nat.recOn n (hs.index _ <| this 0) fun n xn =>
      hs.index _ <| inter_mem (this <| n + 1) (hs.mem_of_mem xn.2)
  have x_anti : Antitone fun i => s (x i).1 :=
    antitone_nat_of_succ_le fun i => (hs.set_index_subset _).trans inter_subset_right
  have x_subset : âˆ€ i, s (x i).1 âŠ† x' i := by
    rintro (_ | i)
    exacts [hs.set_index_subset _, (hs.set_index_subset _).trans inter_subset_left]
  refine âŸ¨fun i => (x i).1, fun i => (x i).2, ?_âŸ©
  have : (â¨… i, ğ“Ÿ (s (x i).1)).HasAntitoneBasis fun i => s (x i).1 := .iInf_principal x_anti
  convert this
  exact
    le_antisymm (le_iInf fun i => le_principal_iff.2 <| by cases i <;> apply hs.set_index_mem)
      (hx'.symm â–¸
        le_iInf fun i => le_principal_iff.2 <| this.1.mem_iff.2 âŸ¨i, trivial, x_subset iâŸ©)"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.withDensity_le_mul,withDensity_le_mul,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  have t_ne_zero' : t â‰  0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : â„â‰¥0âˆ) â‰  0 := by simpa only [ENNReal.coe_eq_zero, Ne.def] using t_ne_zero'
  let Î½ := Î¼.withDensity (v.limRatioMeas hÏ)
  let f := v.limRatioMeas hÏ
  have f_meas : Measurable f := v.limRatioMeas_measurable hÏ
  have A : Î½ (s âˆ© f â»Â¹' {0}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) := by
    apply le_trans _ (zero_le _)
    have M : MeasurableSet (s âˆ© f â»Â¹' {0}) := hs.inter (f_meas (measurableSet_singleton _))
    simp only [nonpos_iff_eq_zero, M, withDensity_apply, lintegral_eq_zero_iff f_meas]
    apply (ae_restrict_iff' M).2
    exact eventually_of_forall fun x hx => hx.2
  have B : Î½ (s âˆ© f â»Â¹' {âˆ}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply withDensity_absolutelyContinuous Î¼ _
    rw [â† nonpos_iff_eq_zero]
    exact (measure_mono (inter_subset_right _ _)).trans (v.measure_limRatioMeas_top hÏ).le
  have C :
    âˆ€ n : â„¤,
      Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) â‰¤
        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))
    have M : MeasurableSet (s âˆ© f â»Â¹' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      (âˆ«â» x in s âˆ© f â»Â¹' I, f x âˆ‚Î¼) â‰¤ âˆ«â» _ in s âˆ© f â»Â¹' I, (t : â„â‰¥0âˆ) ^ (n + 1) âˆ‚Î¼ :=
        lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => hx.2.2.le))
      _ = (t : â„â‰¥0âˆ) ^ (n + 1) * Î¼ (s âˆ© f â»Â¹' I) := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ = (t : â„â‰¥0âˆ) ^ (2 : â„¤) * ((t : â„â‰¥0âˆ) ^ (n - 1) * Î¼ (s âˆ© f â»Â¹' I)) := by
        rw [â† mul_assoc, â† ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top]
        congr 2
        abel
      _ â‰¤ (t : â„â‰¥0âˆ) ^ (2 : â„¤) * Ï (s âˆ© f â»Â¹' I) := by
        gcongr
        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne']
        apply v.mul_measure_le_of_subset_lt_limRatioMeas hÏ
        intro x hx
        apply lt_of_lt_of_le _ hx.2.1
        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne', ENNReal.coe_lt_coe, sub_eq_add_neg,
          zpow_addâ‚€ t_ne_zero']
        conv_rhs => rw [â† mul_one (t ^ n)]
        gcongr
        Â· apply NNReal.zpow_pos t_ne_zero' 
        rw [zpow_neg_one]
        exact inv_lt_one ht
  calc
    Î½ s =
      Î½ (s âˆ© f â»Â¹' {0}) + Î½ (s âˆ© f â»Â¹' {âˆ}) +
        âˆ‘' n : â„¤, Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow Î½ f_meas hs ht
    _ â‰¤
        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) + ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) +
          âˆ‘' n : â„¤, ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico (t ^ n) (t ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï) f_meas hs ht).symm","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.192105 â†’ ?m.192105 â†’ Prop
error:  type mismatch
  hâœ
has type
  t â‰  0 : Prop
but is expected to have type
  â†‘t â‰  0 : Prop
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  invalid field 'withDensity_le_mul', the environment does not contain 'VitaliFamily.withDensity_le_mul'
  v
has type
  VitaliFamily Î¼","theorem withDensity_le_mul {s : Set Î±} (hs : MeasurableSet s) {t : â„â‰¥0} (ht : 1 < t) :
    Î¼.withDensity (v.limRatioMeas hÏ) s â‰¤ (t : â„â‰¥0âˆ) ^ 2 * Ï s ",":= by
  have t_ne_zero' : t â‰  0 := (zero_lt_one.trans ht).ne'
  have t_ne_zero : (t : â„â‰¥0âˆ) â‰  0 := by simpa only [ENNReal.coe_eq_zero, Ne] using t_ne_zero'
  let Î½ := Î¼.withDensity (v.limRatioMeas hÏ)
  let f := v.limRatioMeas hÏ
  have f_meas : Measurable f := v.limRatioMeas_measurable hÏ
  have A : Î½ (s âˆ© f â»Â¹' {0}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) := by
    apply le_trans _ (zero_le _)
    have M : MeasurableSet (s âˆ© f â»Â¹' {0}) := hs.inter (f_meas (measurableSet_singleton _))
    simp only [Î½, nonpos_iff_eq_zero, M, withDensity_apply, lintegral_eq_zero_iff f_meas]
    apply (ae_restrict_iff' M).2
    exact eventually_of_forall fun x hx => hx.2
  have B : Î½ (s âˆ© f â»Â¹' {âˆ}) â‰¤ ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) := by
    apply le_trans (le_of_eq _) (zero_le _)
    apply withDensity_absolutelyContinuous Î¼ _
    rw [â† nonpos_iff_eq_zero]
    exact (measure_mono inter_subset_right).trans (v.measure_limRatioMeas_top hÏ).le
  have C :
    âˆ€ n : â„¤,
      Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) â‰¤
        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) := by
    intro n
    let I := Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))
    have M : MeasurableSet (s âˆ© f â»Â¹' I) := hs.inter (f_meas measurableSet_Ico)
    simp only [Î½, M, withDensity_apply, coe_nnreal_smul_apply]
    calc
      (âˆ«â» x in s âˆ© f â»Â¹' I, f x âˆ‚Î¼) â‰¤ âˆ«â» _ in s âˆ© f â»Â¹' I, (t : â„â‰¥0âˆ) ^ (n + 1) âˆ‚Î¼ :=
        lintegral_mono_ae ((ae_restrict_iff' M).2 (eventually_of_forall fun x hx => hx.2.2.le))
      _ = (t : â„â‰¥0âˆ) ^ (n + 1) * Î¼ (s âˆ© f â»Â¹' I) := by
        simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
      _ = (t : â„â‰¥0âˆ) ^ (2 : â„¤) * ((t : â„â‰¥0âˆ) ^ (n - 1) * Î¼ (s âˆ© f â»Â¹' I)) := by
        rw [â† mul_assoc, â† ENNReal.zpow_add t_ne_zero ENNReal.coe_ne_top]
        congr 2
        abel
      _ â‰¤ (t : â„â‰¥0âˆ) ^ (2 : â„¤) * Ï (s âˆ© f â»Â¹' I) := by
        gcongr
        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne']
        apply v.mul_measure_le_of_subset_lt_limRatioMeas hÏ
        intro x hx
        apply lt_of_lt_of_le _ hx.2.1
        rw [â† ENNReal.coe_zpow (zero_lt_one.trans ht).ne', ENNReal.coe_lt_coe, sub_eq_add_neg,
          zpow_addâ‚€ t_ne_zero']
        conv_rhs => rw [â† mul_one (t ^ n)]
        gcongr
        rw [zpow_neg_one]
        exact inv_lt_one ht
  calc
    Î½ s =
      Î½ (s âˆ© f â»Â¹' {0}) + Î½ (s âˆ© f â»Â¹' {âˆ}) +
        âˆ‘' n : â„¤, Î½ (s âˆ© f â»Â¹' Ico ((t : â„â‰¥0âˆ) ^ n) ((t : â„â‰¥0âˆ) ^ (n + 1))) :=
      measure_eq_measure_preimage_add_measure_tsum_Ico_zpow Î½ f_meas hs ht
    _ â‰¤
        ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {0}) + ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' {âˆ}) +
          âˆ‘' n : â„¤, ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) (s âˆ© f â»Â¹' Ico (t ^ n) (t ^ (n + 1))) :=
      (add_le_add (add_le_add A B) (ENNReal.tsum_le_tsum C))
    _ = ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï :) s :=
      (measure_eq_measure_preimage_add_measure_tsum_Ico_zpow ((t : â„â‰¥0âˆ) ^ 2 â€¢ Ï) f_meas hs ht).symm"
Mathlib/Probability/Variance.lean,ProbabilityTheory.evariance_def',evariance_def',453c456b049db19d87dc21aed1a69aaf23bd5e15,"  by_cases hâ„’ : Memâ„’p X 2
  Â· rw [â† hâ„’.ofReal_variance_eq, variance_def' hâ„’, ENNReal.ofReal_sub _ (sq_nonneg _)]
    congr
    rw [lintegral_coe_eq_integral]
    Â· congr 2 with Ï‰
      simp only [Pi.pow_apply, NNReal.coe_pow, coe_nnnorm, Real.norm_eq_abs, Even.pow_abs even_two]
    Â· exact hâ„’.abs.integrable_sq
  Â· symm
    rw [evariance_eq_top hX hâ„’, ENNReal.sub_eq_top_iff]
    refine âŸ¨?_, ENNReal.ofReal_ne_topâŸ©
    rw [Memâ„’p, not_and] at hâ„’
    specialize hâ„’ hX
    simp only [snorm_eq_lintegral_rpow_nnnorm two_ne_zero ENNReal.two_ne_top, not_lt, top_le_iff,
      ENNReal.toReal_ofNat, one_div, ENNReal.rpow_eq_top_iff, inv_lt_zero, inv_pos, and_true_iff,
      or_iff_not_imp_left, not_and_or, zero_lt_two] at hâ„’
    exact mod_cast hâ„’ fun _ => zero_le_two","error:  unexpected token ':'; expected ':=', 'where' or '|'
error:  function expected at
  ENNReal.ofReal ((âˆ« (a : Î©), X a) ^ 2)
term has type
  â„â‰¥0âˆ","theorem evariance_def' [@IsProbabilityMeasure Î© _ â„™] {X : Î© â†’ â„} (hX : AEStronglyMeasurable X â„™) :
    eVar[X] = (âˆ«â» Ï‰, (â€–X Ï‰â€–â‚Š ^ 2 :)) - ENNReal.ofReal (ğ”¼[X] ^ 2) ",":= by
  by_cases hâ„’ : Memâ„’p X 2
  Â· rw [â† hâ„’.ofReal_variance_eq, variance_def' hâ„’, ENNReal.ofReal_sub _ (sq_nonneg _)]
    congr
    rw [lintegral_coe_eq_integral]
    Â· congr 2 with Ï‰
      simp only [Pi.pow_apply, NNReal.coe_pow, coe_nnnorm, Real.norm_eq_abs, Even.pow_abs even_two]
    Â· exact hâ„’.abs.integrable_sq
  Â· symm
    rw [evariance_eq_top hX hâ„’, ENNReal.sub_eq_top_iff]
    refine âŸ¨?_, ENNReal.ofReal_ne_topâŸ©
    rw [Memâ„’p, not_and] at hâ„’
    specialize hâ„’ hX
    simp only [snorm_eq_lintegral_rpow_nnnorm two_ne_zero ENNReal.two_ne_top, not_lt, top_le_iff,
      ENNReal.toReal_ofNat, one_div, ENNReal.rpow_eq_top_iff, inv_lt_zero, inv_pos, and_true_iff,
      or_iff_not_imp_left, not_and_or, zero_lt_two] at hâ„’
    exact mod_cast hâ„’ fun _ => zero_le_two"
Mathlib/Analysis/NormedSpace/Pointwise.lean,infEdist_thickening,infEdist_thickening,0ef23fba776dbe5bb848bbfc3337bedef4a59c82,":= by
  obtain hs | hs := lt_or_le (infEdist x s) (ENNReal.ofReal Î´)
  Â· rw [infEdist_zero_of_mem, tsub_eq_zero_of_le hs.le]
    exact hs
  refine (tsub_le_iff_right.2 infEdist_le_infEdist_thickening_add).antisymm' ?_
  refine le_sub_of_add_le_right ofReal_ne_top ?_
  refine le_infEdist.2 fun z hz => le_of_forall_lt' fun r h => ?_
  cases' r with r
  Â· exact add_lt_top.2 âŸ¨lt_top_iff_ne_top.2 <| infEdist_ne_top âŸ¨z, self_subset_thickening hÎ´ _ hzâŸ©,
      ofReal_lt_topâŸ©
  have hr : 0 < â†‘r - Î´ := by
    refine sub_pos_of_lt ?_
    have := hs.trans_lt ((infEdist_le_edist_of_mem hz).trans_lt h)
    rw [ofReal_eq_coe_nnreal hÎ´.le, some_eq_coe] at this
    exact mod_cast this
  rw [some_eq_coe, edist_lt_coe, â† dist_lt_coe, â† add_sub_cancel Î´ â†‘r] at h
  obtain âŸ¨y, hxy, hyzâŸ© := exists_dist_lt_lt hr hÎ´ h
  refine (ENNReal.add_lt_add_right ofReal_ne_top <|
    infEdist_lt_iff.2 âŸ¨_, mem_thickening_iff.2 âŸ¨_, hz, hyzâŸ©, edist_lt_ofReal.2 hxyâŸ©).trans_le ?_
  rw [â† ofReal_add hr.le hÎ´.le, sub_add_cancel, ofReal_coe_nnreal]
  exact le_rfl","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  some ?a
ğ•œ : Type u_1
E : Type u_2
instâœÂ³ : NormedField ğ•œ
instâœÂ² : SeminormedAddCommGroup E
instâœÂ¹ : NormedSpace ğ•œ E
instâœ : NormedSpace â„ E
xâœ y zâœ : E
Î´ Îµ : â„
hÎ´ : 0 < Î´
s : Set E
x : E
hs : ENNReal.ofReal Î´ â‰¤ infEdist x s
z : E
hz : z âˆˆ s
r : NNReal
h : edist x z < â†‘r
this : â†‘âŸ¨Î´, â‹¯âŸ© < â†‘r
âŠ¢ Î´ < â†‘r
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  some ?a
case inr.coe
ğ•œ : Type u_1
E : Type u_2
instâœÂ³ : NormedField ğ•œ
instâœÂ² : SeminormedAddCommGroup E
instâœÂ¹ : NormedSpace ğ•œ E
instâœ : NormedSpace â„ E
xâœ y zâœ : E
Î´ Îµ : â„
hÎ´ : 0 < Î´
s : Set E
x : E
hs : ENNReal.ofReal Î´ â‰¤ infEdist x s
z : E
hz : z âˆˆ s
r : NNReal
h : edist x z < â†‘r
hr : 0 < â†‘r - Î´
âŠ¢ infEdist x (thickening Î´ s) + ENNReal.ofReal Î´ < â†‘r","theorem infEdist_thickening (hÎ´ : 0 < Î´) (s : Set E) (x : E) :
    infEdist x (thickening Î´ s) = infEdist x s - ENNReal.ofReal Î´ ",":= by
  obtain hs | hs := lt_or_le (infEdist x s) (ENNReal.ofReal Î´)
  Â· rw [infEdist_zero_of_mem, tsub_eq_zero_of_le hs.le]
    exact hs
  refine (tsub_le_iff_right.2 infEdist_le_infEdist_thickening_add).antisymm' ?_
  refine le_sub_of_add_le_right ofReal_ne_top ?_
  refine le_infEdist.2 fun z hz => le_of_forall_lt' fun r h => ?_
  cases' r with r
  Â· exact add_lt_top.2 âŸ¨lt_top_iff_ne_top.2 <| infEdist_ne_top âŸ¨z, self_subset_thickening hÎ´ _ hzâŸ©,
      ofReal_lt_topâŸ©
  have hr : 0 < â†‘r - Î´ := by
    refine sub_pos_of_lt ?_
    have := hs.trans_lt ((infEdist_le_edist_of_mem hz).trans_lt h)
    rw [ofReal_eq_coe_nnreal hÎ´.le] at this
    exact mod_cast this
  rw [edist_lt_coe, â† dist_lt_coe, â† add_sub_cancel Î´ â†‘r] at h
  obtain âŸ¨y, hxy, hyzâŸ© := exists_dist_lt_lt hr hÎ´ h
  refine (ENNReal.add_lt_add_right ofReal_ne_top <|
    infEdist_lt_iff.2 âŸ¨_, mem_thickening_iff.2 âŸ¨_, hz, hyzâŸ©, edist_lt_ofReal.2 hxyâŸ©).trans_le ?_
  rw [â† ofReal_add hr.le hÎ´.le, sub_add_cancel, ofReal_coe_nnreal]"
Mathlib/LinearAlgebra/Matrix/Determinant/Basic.lean,Matrix.det_eq_of_forall_row_eq_smul_add_const_aux,det_eq_of_forall_row_eq_smul_add_const_aux,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction s generalizing B with
  | empty =>
    rintro c hs k - A_eq
    have : âˆ€ i, c i = 0 := by
      intro i
      specialize hs i
      contrapose! hs
      simp [hs]
    congr
    ext i j
    rw [A_eq, this, zero_mul, add_zero]
  | @insert i s _hi ih =>
    intro c hs k hk A_eq
    have hAi : A i = B i + c i â€¢ B k := funext (A_eq i)
    rw [@ih (updateRow B i (A i)) (Function.update c i 0), hAi, det_updateRow_add_smul_self]
    Â· exact mt (fun h => show k âˆˆ insert i s from h â–¸ Finset.mem_insert_self _ _) hk
    Â· intro i' hi'
      rw [Function.update_apply]
      split_ifs with hi'i
      Â· rfl
      Â· exact hs i' fun h => hi' ((Finset.mem_insert.mp h).resolve_left hi'i)
    Â· exact k
    Â· exact fun h => hk (Finset.mem_insert_of_mem h)
    Â· intro i' j'
      rw [updateRow_apply, Function.update_apply]
      split_ifs with hi'i
      Â· simp [hi'i]
      rw [A_eq, updateRow_ne fun h : k = i => hk <| h â–¸ Finset.mem_insert_self k s]",error:  invalid alternative name 'empty',"theorem det_eq_of_forall_row_eq_smul_add_const_aux {A B : Matrix n n R} {s : Finset n} :
    âˆ€ (c : n â†’ R) (_ : âˆ€ i, i âˆ‰ s â†’ c i = 0) (k : n) (_ : k âˆ‰ s)
      (_: âˆ€ i j, A i j = B i j + c i * B k j), det A = det B ",":= by
  induction s using Finset.induction_on generalizing B with
  | empty =>
    rintro c hs k - A_eq
    have : âˆ€ i, c i = 0 := by
      intro i
      specialize hs i
      contrapose! hs
      simp [hs]
    congr
    ext i j
    rw [A_eq, this, zero_mul, add_zero]
  | @insert i s _hi ih =>
    intro c hs k hk A_eq
    have hAi : A i = B i + c i â€¢ B k := funext (A_eq i)
    rw [@ih (updateRow B i (A i)) (Function.update c i 0), hAi, det_updateRow_add_smul_self]
    Â· exact mt (fun h => show k âˆˆ insert i s from h â–¸ Finset.mem_insert_self _ _) hk
    Â· intro i' hi'
      rw [Function.update_apply]
      split_ifs with hi'i
      Â· rfl
      Â· exact hs i' fun h => hi' ((Finset.mem_insert.mp h).resolve_left hi'i)
    Â· exact k
    Â· exact fun h => hk (Finset.mem_insert_of_mem h)
    Â· intro i' j'
      rw [updateRow_apply, Function.update_apply]
      split_ifs with hi'i
      Â· simp [hi'i]
      rw [A_eq, updateRow_ne fun h : k = i => hk <| h â–¸ Finset.mem_insert_self k s]"
Mathlib/Topology/Bornology/Basic.lean,Bornology.le_cofinite,Bornology.le_cofinite,726f5460dab81f791c8bd51519eaca69b3e20a45,":=
  Bornology.le_cofinite'","error:  application type mismatch
  le_cofinite' le_cofinite'
argument
  le_cofinite'
has type
  cobounded' â‰¤ cofinite : Prop
but is expected to have type
  ?m.227 âˆˆ cofinite : Prop",lemma Bornology.le_cofinite (Î± : Type*) [Bornology Î±] : cobounded Î± â‰¤ cofinite ,:=
Mathlib/Algebra/Order/Archimedean.lean,archimedean_iff_int_lt,archimedean_iff_int_lt,03690a4c3252f422184189d0b6a6dd8d1c55d551,":=
  âŸ¨@exists_int_gt Î± _ _, by
    rw [archimedean_iff_nat_lt]
    intro h x
    obtain âŸ¨n, hâŸ© := h x
    refine âŸ¨n.toNat, h.trans_le ?_âŸ©
    exact mod_cast Int.self_le_toNat _âŸ©","error:  failed to synthesize
  Archimedean Î±
use `set_option diagnostics true` to get diagnostic information","theorem archimedean_iff_int_lt : Archimedean Î± â†” âˆ€ x : Î±, âˆƒ n : â„¤, x < n ",":=
  âŸ¨@exists_int_gt Î± _, by
    rw [archimedean_iff_nat_lt]
    intro h x
    obtain âŸ¨n, hâŸ© := h x
    refine âŸ¨n.toNat, h.trans_le ?_âŸ©
    exact mod_cast Int.self_le_toNat _âŸ©"
Mathlib/Analysis/Calculus/FDeriv/Extend.lean,has_deriv_at_interval_right_endpoint_of_tendsto_deriv,has_deriv_at_interval_right_endpoint_of_tendsto_deriv,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  obtain âŸ¨b, ba, sabâŸ© : âˆƒ b âˆˆ Iio a, Ico b a âŠ† s := mem_nhdsWithin_Iio_iff_exists_Ico_subset.1 hs
  let t := Ioo b a
  have ts : t âŠ† s := Subset.trans Ioo_subset_Ico_self sab
  have t_diff : DifferentiableOn â„ f t := f_diff.mono ts
  have t_conv : Convex â„ t := convex_Ioo b a
  have t_open : IsOpen t := isOpen_Ioo
  have t_closure : closure t = Icc b a := closure_Ioo (ne_of_lt ba)
  have t_cont : âˆ€ y âˆˆ closure t, ContinuousWithinAt f t y := by
    rw [t_closure]
    intro y hy
    by_cases h : y = a
    Â· rw [h]; exact f_lim.mono ts
    Â· have : y âˆˆ s := sab âŸ¨hy.1, lt_of_le_of_ne hy.2 hâŸ©
      exact (f_diff.continuousOn y this).mono ts
  have t_diff' : Tendsto (fun x => fderiv â„ f x) (ğ“[t] a) (ğ“ (smulRight 1 e)) := by
    simp only [deriv_fderiv.symm]
    exact Tendsto.comp
      (isBoundedBilinearMap_smulRight : IsBoundedBilinearMap â„ _).continuous_right.continuousAt
      (tendsto_nhdsWithin_mono_left Ioo_subset_Iio_self f_lim')
  have : HasDerivWithinAt f e (Icc b a) a := by
    rw [hasDerivWithinAt_iff_hasFDerivWithinAt, â† t_closure]
    exact has_fderiv_at_boundary_of_tendsto_fderiv t_diff t_conv t_open t_cont t_diff'
  exact this.mono_of_mem (Icc_mem_nhdsWithin_Iic <| right_mem_Ioc.2 ba)","error:  typeclass instance problem is stuck, it is often due to metavariables
  ContinuousSMul ?m.100571 E","theorem has_deriv_at_interval_right_endpoint_of_tendsto_deriv {s : Set â„} {e : E} {a : â„}
    {f : â„ â†’ E} (f_diff : DifferentiableOn â„ f s) (f_lim : ContinuousWithinAt f s a)
    (hs : s âˆˆ ğ“[<] a) (f_lim' : Tendsto (fun x => deriv f x) (ğ“[<] a) (ğ“ e)) :
    HasDerivWithinAt f e (Iic a) a ",":= by
  obtain âŸ¨b, ba, sabâŸ© : âˆƒ b âˆˆ Iio a, Ico b a âŠ† s := mem_nhdsWithin_Iio_iff_exists_Ico_subset.1 hs
  let t := Ioo b a
  have ts : t âŠ† s := Subset.trans Ioo_subset_Ico_self sab
  have t_diff : DifferentiableOn â„ f t := f_diff.mono ts
  have t_conv : Convex â„ t := convex_Ioo b a
  have t_open : IsOpen t := isOpen_Ioo
  have t_closure : closure t = Icc b a := closure_Ioo (ne_of_lt ba)
  have t_cont : âˆ€ y âˆˆ closure t, ContinuousWithinAt f t y := by
    rw [t_closure]
    intro y hy
    by_cases h : y = a
    Â· rw [h]; exact f_lim.mono ts
    Â· have : y âˆˆ s := sab âŸ¨hy.1, lt_of_le_of_ne hy.2 hâŸ©
      exact (f_diff.continuousOn y this).mono ts
  have t_diff' : Tendsto (fun x => fderiv â„ f x) (ğ“[t] a) (ğ“ (smulRight (1 : â„ â†’L[â„] â„) e)) := by
    simp only [deriv_fderiv.symm]
    exact Tendsto.comp
      (isBoundedBilinearMap_smulRight : IsBoundedBilinearMap â„ _).continuous_right.continuousAt
      (tendsto_nhdsWithin_mono_left Ioo_subset_Iio_self f_lim')
  have : HasDerivWithinAt f e (Icc b a) a := by
    rw [hasDerivWithinAt_iff_hasFDerivWithinAt, â† t_closure]
    exact has_fderiv_at_boundary_of_tendsto_fderiv t_diff t_conv t_open t_cont t_diff'
  exact this.mono_of_mem (Icc_mem_nhdsWithin_Iic <| right_mem_Ioc.2 ba)"
Mathlib/RingTheory/DedekindDomain/Ideal.lean,FractionalIdeal.coe_ideal_mul_inv,coe_ideal_mul_inv,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  apply mul_inv_cancel_of_le_one hI0
  by_cases hJ0 : I * (I : FractionalIdeal Aâ° K)â»Â¹ = 0
  Â· rw [hJ0, inv_zero']; exact zero_le _
  intro x hx
  suffices x âˆˆ integralClosure A K by
    rwa [IsIntegrallyClosed.integralClosure_eq_bot, Algebra.mem_bot, Set.mem_range,
      â† mem_one_iff] at this
  rw [mem_integralClosure_iff_mem_FG]
  have x_mul_mem : âˆ€ b âˆˆ (Iâ»Â¹ : FractionalIdeal Aâ° K), x * b âˆˆ (Iâ»Â¹ : FractionalIdeal Aâ° K) := by
    intro b hb
    rw [mem_inv_iff (coeIdeal_ne_zero.mpr hI0)]
    dsimp only at hx
    rw [val_eq_coe, mem_coe, mem_inv_iff hJ0] at hx
    simp only [mul_assoc, mul_comm b] at hx âŠ¢
    intro y hy
    exact hx _ (mul_mem_mul hy hb)
  refine âŸ¨AlgHom.range (Polynomial.aeval x : A[X] â†’â‚[A] K),
    isNoetherian_submodule.mp (isNoetherian (I : FractionalIdeal Aâ° K)â»Â¹) _ fun y hy => ?_,
    âŸ¨Polynomial.X, Polynomial.aeval_X xâŸ©âŸ©
  obtain âŸ¨p, rflâŸ© := (AlgHom.mem_range _).mp hy
  rw [Polynomial.aeval_eq_sum_range]
  refine Submodule.sum_mem _ fun i hi => Submodule.smul_mem _ _ ?_
  clear hi
  induction' i with i ih
  Â· rw [pow_zero]; exact one_mem_inv_coe_ideal hI0
  Â· show x ^ i.succ âˆˆ (Iâ»Â¹ : FractionalIdeal Aâ° K)
    rw [pow_succ]; exact x_mul_mem _ ih","error:  unknown identifier 'mem_integralClosure_iff_mem_FG'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.193769
case neg
R : Type u_1
A : Type u_2
K : Type u_3
instâœâ´ : CommRing R
instâœÂ³ : CommRing A
instâœÂ² : Field K
instâœÂ¹ : Algebra A K
instâœ : IsFractionRing A K
h : IsDedekindDomain A
I : Ideal A
hI0 : I â‰  âŠ¥
hJ0 : Â¬â†‘I * (â†‘I)â»Â¹ = 0
x : K
hx : x âˆˆ (fun a â†¦ â†‘a) (â†‘I * (â†‘I)â»Â¹)â»Â¹
âŠ¢ x âˆˆ integralClosure A K","theorem coe_ideal_mul_inv [h : IsDedekindDomain A] (I : Ideal A) (hI0 : I â‰  âŠ¥) :
    I * (I : FractionalIdeal Aâ° K)â»Â¹ = 1 ",":= by
  apply mul_inv_cancel_of_le_one hI0
  by_cases hJ0 : I * (I : FractionalIdeal Aâ° K)â»Â¹ = 0
  Â· rw [hJ0, inv_zero']; exact zero_le _
  intro x hx
  suffices x âˆˆ integralClosure A K by
    rwa [IsIntegrallyClosed.integralClosure_eq_bot, Algebra.mem_bot, Set.mem_range,
      â† mem_one_iff] at this
  rw [mem_integralClosure_iff_mem_fg]
  have x_mul_mem : âˆ€ b âˆˆ (Iâ»Â¹ : FractionalIdeal Aâ° K), x * b âˆˆ (Iâ»Â¹ : FractionalIdeal Aâ° K) := by
    intro b hb
    rw [mem_inv_iff (coeIdeal_ne_zero.mpr hI0)]
    dsimp only at hx
    rw [val_eq_coe, mem_coe, mem_inv_iff hJ0] at hx
    simp only [mul_assoc, mul_comm b] at hx âŠ¢
    intro y hy
    exact hx _ (mul_mem_mul hy hb)
  refine âŸ¨AlgHom.range (Polynomial.aeval x : A[X] â†’â‚[A] K),
    isNoetherian_submodule.mp (isNoetherian (I : FractionalIdeal Aâ° K)â»Â¹) _ fun y hy => ?_,
    âŸ¨Polynomial.X, Polynomial.aeval_X xâŸ©âŸ©
  obtain âŸ¨p, rflâŸ© := (AlgHom.mem_range _).mp hy
  rw [Polynomial.aeval_eq_sum_range]
  refine Submodule.sum_mem _ fun i hi => Submodule.smul_mem _ _ ?_
  clear hi
  induction' i with i ih
  Â· rw [pow_zero]; exact one_mem_inv_coe_ideal hI0
  Â· show x ^ i.succ âˆˆ (Iâ»Â¹ : FractionalIdeal Aâ° K)
    rw [pow_succ']; exact x_mul_mem _ ih"
Mathlib/GroupTheory/SpecificGroups/Alternating.lean,Equiv.Perm.isThreeCycle_sq_of_three_mem_cycleType_five,isThreeCycle_sq_of_three_mem_cycleType_five,778a5cd9392015a3987cb7185401f8fd8af8c89d,":= by
  obtain âŸ¨c, g', rfl, hd, _, h3âŸ© := mem_cycleType_iff.1 h
  simp only [mul_assoc]
  rw [hd.commute.eq, â† mul_assoc g']
  suffices hg' : orderOf g' âˆ£ 2
  Â· rw [â† pow_two, orderOf_dvd_iff_pow_eq_one.1 hg', one_mul]
    exact (card_support_eq_three_iff.1 h3).isThreeCycle_sq
  rw [â† lcm_cycleType, Multiset.lcm_dvd]
  intro n hn
  rw [le_antisymm (two_le_of_mem_cycleType hn) (le_trans (le_card_support_of_mem_cycleType hn) _)]
  apply le_of_add_le_add_left
  rw [â† hd.card_support_mul, h3]
  exact (c * g').support.card_le_univ","warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
error:  unexpected token 'Â·'; expected 'by' or 'from'","theorem isThreeCycle_sq_of_three_mem_cycleType_five {g : Perm (Fin 5)} (h : 3 âˆˆ cycleType g) :
    IsThreeCycle (g * g) ",":= by
  obtain âŸ¨c, g', rfl, hd, _, h3âŸ© := mem_cycleType_iff.1 h
  simp only [mul_assoc]
  rw [hd.commute.eq, â† mul_assoc g']
  suffices hg' : orderOf g' âˆ£ 2 by
    rw [â† pow_two, orderOf_dvd_iff_pow_eq_one.1 hg', one_mul]
    exact (card_support_eq_three_iff.1 h3).isThreeCycle_sq
  rw [â† lcm_cycleType, Multiset.lcm_dvd]
  intro n hn
  rw [le_antisymm (two_le_of_mem_cycleType hn) (le_trans (le_card_support_of_mem_cycleType hn) _)]
  apply le_of_add_le_add_left
  rw [â† hd.card_support_mul, h3]
  exact (c * g').support.card_le_univ"
Mathlib/Algebra/Order/Monoid/Unbundled/Defs.lean,rel_act_of_act_rel_act_of_rel_act,rel_act_of_act_rel_act_of_rel_act,a9c207c4e1fa09020f6c257c6d7127ce2969efc6,":=
  _root_.trans (contra.rel_of_act_rel_act m ab) rr",error:  unknown identifier 'contra.rel_of_act_rel_act',"theorem rel_act_of_act_rel_act_of_rel_act (ab : r (Î¼ m a) (Î¼ m b)) (rr : r b (Î¼ m c)) :
    r a (Î¼ m c) ",":=
  _root_.trans (rel_of_act_rel_act m ab) rr"
Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean,MeasureTheory.measure_union_eq_top_iff,measure_union_eq_top_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  not_iff_not.1 <| by simp only [â† lt_top_iff_ne_top, â† Ne.def, not_or, measure_union_lt_top_iff]","warning:  `MeasureTheory.OuterMeasure.empty'` has been deprecated, use `MeasureTheory.measure_empty` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.21317 â†’ ?m.21317 â†’ Prop",theorem measure_union_eq_top_iff : Î¼ (s âˆª t) = âˆ â†” Î¼ s = âˆ âˆ¨ Î¼ t = âˆ ,":=
  not_iff_not.1 <| by simp only [â† lt_top_iff_ne_top, â† Ne.eq_def, not_or, measure_union_lt_top_iff]"
Mathlib/Analysis/Calculus/FDeriv/Measurable.lean,FDerivMeasurableAux.D_subset_differentiable_set,D_subset_differentiable_set,750120926720faadde449cc355833afa50c8b30e,":= by
  have P : âˆ€ {n : â„•}, (0 : â„) < (1 / 2) ^ n := fun {n} => pow_pos (by norm_num) n
  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©
  have cpos : 0 < â€–câ€– := lt_trans zero_lt_one hc
  intro x hx
  have :
    âˆ€ e : â„•, âˆƒ n : â„•, âˆ€ p q, n â‰¤ p â†’ n â‰¤ q â†’
      âˆƒ L âˆˆ K, x âˆˆ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) âˆ© A f L ((1 / 2) ^ q) ((1 / 2) ^ e) := by
    intro e
    have := mem_iInter.1 hx e
    rcases mem_iUnion.1 this with âŸ¨n, hnâŸ©
    refine' âŸ¨n, fun p q hp hq => _âŸ©
    simp only [mem_iInter, ge_iff_le] at hn
    rcases mem_iUnion.1 (hn p hp q hq) with âŸ¨L, hLâŸ©
    exact âŸ¨L, exists_prop.mp <| mem_iUnion.1 hLâŸ©
  choose! n L hn using this
  have M :
    âˆ€ e p q e' p' q',
      n e â‰¤ p â†’
        n e â‰¤ q â†’
          n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’ â€–L e p q - L e' p' q'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p q e' p' q' hp hq hp' hq' he'
    let r := max (n e) (n e')
    have I : ((1 : â„) / 2) ^ e' â‰¤ (1 / 2) ^ e :=
      pow_le_pow_of_le_one (by norm_num) (by norm_num) he'
    have J1 : â€–L e p q - L e p râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1
      have I2 : x âˆˆ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1
      exact norm_sub_le_of_mem_A hc P P I1 I2
    have J2 : â€–L e p r - L e' p' râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2
      have I2 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.2
      exact norm_sub_le_of_mem_A hc P P I1 (A_mono _ _ I I2)
    have J3 : â€–L e' p' r - L e' p' q'â€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.1
      have I2 : x âˆˆ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1
      exact norm_sub_le_of_mem_A hc P P (A_mono _ _ I I1) (A_mono _ _ I I2)
    calc
      â€–L e p q - L e' p' q'â€– =
          â€–L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')â€– :=
        by congr 1; abel
      _ â‰¤ â€–L e p q - L e p râ€– + â€–L e p r - L e' p' râ€– + â€–L e' p' r - L e' p' q'â€– :=
        norm_addâ‚ƒ_le _ _ _
      _ â‰¤ 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e := by gcongr
      _ = 12 * â€–câ€– * (1 / 2) ^ e := by ring
  let L0 : â„• â†’ E â†’L[ğ•œ] F := fun e => L e (n e) (n e)
  have : CauchySeq L0 := by
    rw [Metric.cauchySeq_iff']
    intro Îµ Îµpos
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (div_pos Îµpos (mul_pos (by norm_num) cpos)) (by norm_num)
    refine' âŸ¨e, fun e' he' => _âŸ©
    rw [dist_comm, dist_eq_norm]
    calc
      â€–L0 e - L0 e'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'
      _ < 12 * â€–câ€– * (Îµ / (12 * â€–câ€–)) := by gcongr
      _ = Îµ := by field_simp [(by norm_num : (12 : â„) â‰  0), ne_of_gt cpos]; ring
  obtain âŸ¨f', f'K, hf'âŸ© : âˆƒ f' âˆˆ K, Tendsto L0 atTop (ğ“ f') :=
    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this
  have Lf' : âˆ€ e p, n e â‰¤ p â†’ â€–L e (n e) p - f'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p hp
    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm
    rw [eventually_atTop]
    exact âŸ¨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'âŸ©
  have : HasFDerivAt f f' x := by
    simp only [hasFDerivAt_iff_isLittleO_nhds_zero, isLittleO_iff]
    intro Îµ Îµpos
    have pos : 0 < 4 + 12 * â€–câ€– := by positivity
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (4 + 12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (div_pos Îµpos pos) (by norm_num)
    rw [eventually_nhds_iff_ball]
    refine' âŸ¨(1 / 2) ^ (n e + 1), P, fun y hy => _âŸ©
    by_cases y_pos : y = 0;
    Â· simp [y_pos]
    have yzero : 0 < â€–yâ€– := norm_pos_iff.mpr y_pos
    have y_lt : â€–yâ€– < (1 / 2) ^ (n e + 1) := by simpa using mem_ball_iff_norm.1 hy
    have yone : â€–yâ€– â‰¤ 1 := le_trans y_lt.le (pow_le_one _ (by norm_num) (by norm_num))
    obtain âŸ¨k, hk, h'kâŸ© : âˆƒ k : â„•, (1 / 2) ^ (k + 1) < â€–yâ€– âˆ§ â€–yâ€– â‰¤ (1 / 2) ^ k :=
      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : â„) < 1 / 2)
        (by norm_num : (1 : â„) / 2 < 1)
    have k_gt : n e < k := by
      have : ((1 : â„) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_trans hk y_lt
      rw [pow_lt_pow_iff_of_lt_one (by norm_num : (0 : â„) < 1 / 2) (by norm_num)] at this
      linarith
    set m := k - 1
    have m_ge : n e â‰¤ m := Nat.le_pred_of_lt k_gt
    have km : k = m + 1 := (Nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm
    rw [km] at hk h'k
    have J1 : â€–f (x + y) - f x - L e (n e) m (x + y - x)â€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
      apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2
      Â· simp only [mem_closedBall, dist_self]
        exact div_nonneg (le_of_lt P) zero_le_two
      Â· simpa only [dist_eq_norm, add_sub_cancel', mem_closedBall, pow_succ', mul_one_div] using
          h'k
    have J2 : â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– :=
      calc
        â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
          simpa only [add_sub_cancel'] using J1
        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by field_simp; ring
        _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– :=
          mul_le_mul_of_nonneg_left (le_of_lt hk) (mul_nonneg (by norm_num) (le_of_lt P))
    calc
      â€–f (x + y) - f x - f' yâ€– = â€–f (x + y) - f x - L e (n e) m y + (L e (n e) m - f') yâ€– :=
        congr_arg _ (by simp)
      _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– + 12 * â€–câ€– * (1 / 2) ^ e * â€–yâ€– :=
        (norm_add_le_of_le J2
          ((le_op_norm _ _).trans (mul_le_mul_of_nonneg_right (Lf' _ _ m_ge) (norm_nonneg _))))
      _ = (4 + 12 * â€–câ€–) * â€–yâ€– * (1 / 2) ^ e := by ring
      _ â‰¤ (4 + 12 * â€–câ€–) * â€–yâ€– * (Îµ / (4 + 12 * â€–câ€–)) := by gcongr
      _ = Îµ * â€–yâ€– := by field_simp [ne_of_gt pos]; ring
  rw [â† this.fderiv] at f'K
  exact âŸ¨this.differentiableAt, f'KâŸ©","error:  no goals to be solved
warning:  `pow_lt_pow_iff_of_lt_one` has been deprecated, use `pow_lt_pow_iff_right_of_lt_one` instead
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  type mismatch
  hâœ
has type
  â€–yâ€– â‰¤ 1 / 2 * (1 / 2) ^ m : Prop
but is expected to have type
  â€–yâ€– â‰¤ (1 / 2) ^ m / 2 : Prop
warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
warning:  `ContinuousLinearMap.le_op_norm` has been deprecated, use `ContinuousLinearMap.le_opNorm` instead","theorem D_subset_differentiable_set {K : Set (E â†’L[ğ•œ] F)} (hK : IsComplete K) :
    D f K âŠ† { x | DifferentiableAt ğ•œ f x âˆ§ fderiv ğ•œ f x âˆˆ K } ",":= by
  have P : âˆ€ {n : â„•}, (0 : â„) < (1 / 2) ^ n := fun {n} => pow_pos (by norm_num) n
  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©
  intro x hx
  have :
    âˆ€ e : â„•, âˆƒ n : â„•, âˆ€ p q, n â‰¤ p â†’ n â‰¤ q â†’
      âˆƒ L âˆˆ K, x âˆˆ A f L ((1 / 2) ^ p) ((1 / 2) ^ e) âˆ© A f L ((1 / 2) ^ q) ((1 / 2) ^ e) := by
    intro e
    have := mem_iInter.1 hx e
    rcases mem_iUnion.1 this with âŸ¨n, hnâŸ©
    refine âŸ¨n, fun p q hp hq => ?_âŸ©
    simp only [mem_iInter, ge_iff_le] at hn
    rcases mem_iUnion.1 (hn p hp q hq) with âŸ¨L, hLâŸ©
    exact âŸ¨L, exists_prop.mp <| mem_iUnion.1 hLâŸ©
  choose! n L hn using this
  have M :
    âˆ€ e p q e' p' q',
      n e â‰¤ p â†’
        n e â‰¤ q â†’
          n e' â‰¤ p' â†’ n e' â‰¤ q' â†’ e â‰¤ e' â†’ â€–L e p q - L e' p' q'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p q e' p' q' hp hq hp' hq' he'
    let r := max (n e) (n e')
    have I : ((1 : â„) / 2) ^ e' â‰¤ (1 / 2) ^ e :=
      pow_le_pow_of_le_one (by norm_num) (by norm_num) he'
    have J1 : â€–L e p q - L e p râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p q) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p q hp hq).2.1
      have I2 : x âˆˆ A f (L e p r) ((1 / 2) ^ p) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.1
      exact norm_sub_le_of_mem_A hc P P I1 I2
    have J2 : â€–L e p r - L e' p' râ€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e p r) ((1 / 2) ^ r) ((1 / 2) ^ e) := (hn e p r hp (le_max_left _ _)).2.2
      have I2 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ r) ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.2
      exact norm_sub_le_of_mem_A hc P P I1 (A_mono _ _ I I2)
    have J3 : â€–L e' p' r - L e' p' q'â€– â‰¤ 4 * â€–câ€– * (1 / 2) ^ e := by
      have I1 : x âˆˆ A f (L e' p' r) ((1 / 2) ^ p') ((1 / 2) ^ e') :=
        (hn e' p' r hp' (le_max_right _ _)).2.1
      have I2 : x âˆˆ A f (L e' p' q') ((1 / 2) ^ p') ((1 / 2) ^ e') := (hn e' p' q' hp' hq').2.1
      exact norm_sub_le_of_mem_A hc P P (A_mono _ _ I I1) (A_mono _ _ I I2)
    calc
      â€–L e p q - L e' p' q'â€– =
          â€–L e p q - L e p r + (L e p r - L e' p' r) + (L e' p' r - L e' p' q')â€– := by
        congr 1; abel
      _ â‰¤ â€–L e p q - L e p râ€– + â€–L e p r - L e' p' râ€– + â€–L e' p' r - L e' p' q'â€– :=
        norm_addâ‚ƒ_le _ _ _
      _ â‰¤ 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e + 4 * â€–câ€– * (1 / 2) ^ e := by gcongr
      _ = 12 * â€–câ€– * (1 / 2) ^ e := by ring
  let L0 : â„• â†’ E â†’L[ğ•œ] F := fun e => L e (n e) (n e)
  have : CauchySeq L0 := by
    rw [Metric.cauchySeq_iff']
    intro Îµ Îµpos
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (by positivity) (by norm_num)
    refine âŸ¨e, fun e' he' => ?_âŸ©
    rw [dist_comm, dist_eq_norm]
    calc
      â€–L0 e - L0 e'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := M _ _ _ _ _ _ le_rfl le_rfl le_rfl le_rfl he'
      _ < 12 * â€–câ€– * (Îµ / (12 * â€–câ€–)) := by gcongr
      _ = Îµ := by field_simp
  obtain âŸ¨f', f'K, hf'âŸ© : âˆƒ f' âˆˆ K, Tendsto L0 atTop (ğ“ f') :=
    cauchySeq_tendsto_of_isComplete hK (fun e => (hn e (n e) (n e) le_rfl le_rfl).1) this
  have Lf' : âˆ€ e p, n e â‰¤ p â†’ â€–L e (n e) p - f'â€– â‰¤ 12 * â€–câ€– * (1 / 2) ^ e := by
    intro e p hp
    apply le_of_tendsto (tendsto_const_nhds.sub hf').norm
    rw [eventually_atTop]
    exact âŸ¨e, fun e' he' => M _ _ _ _ _ _ le_rfl hp le_rfl le_rfl he'âŸ©
  have : HasFDerivAt f f' x := by
    simp only [hasFDerivAt_iff_isLittleO_nhds_zero, isLittleO_iff]
    intro Îµ Îµpos
    have pos : 0 < 4 + 12 * â€–câ€– := by positivity
    obtain âŸ¨e, heâŸ© : âˆƒ e : â„•, (1 / 2) ^ e < Îµ / (4 + 12 * â€–câ€–) :=
      exists_pow_lt_of_lt_one (div_pos Îµpos pos) (by norm_num)
    rw [eventually_nhds_iff_ball]
    refine âŸ¨(1 / 2) ^ (n e + 1), P, fun y hy => ?_âŸ©
    by_cases y_pos : y = 0;
    Â· simp [y_pos]
    have yzero : 0 < â€–yâ€– := norm_pos_iff.mpr y_pos
    have y_lt : â€–yâ€– < (1 / 2) ^ (n e + 1) := by simpa using mem_ball_iff_norm.1 hy
    have yone : â€–yâ€– â‰¤ 1 := le_trans y_lt.le (pow_le_one _ (by norm_num) (by norm_num))
    obtain âŸ¨k, hk, h'kâŸ© : âˆƒ k : â„•, (1 / 2) ^ (k + 1) < â€–yâ€– âˆ§ â€–yâ€– â‰¤ (1 / 2) ^ k :=
      exists_nat_pow_near_of_lt_one yzero yone (by norm_num : (0 : â„) < 1 / 2)
        (by norm_num : (1 : â„) / 2 < 1)
    have k_gt : n e < k := by
      have : ((1 : â„) / 2) ^ (k + 1) < (1 / 2) ^ (n e + 1) := lt_trans hk y_lt
      rw [pow_lt_pow_iff_right_of_lt_one (by norm_num : (0 : â„) < 1 / 2) (by norm_num)] at this
      omega
    set m := k - 1
    have m_ge : n e â‰¤ m := Nat.le_sub_one_of_lt k_gt
    have km : k = m + 1 := (Nat.succ_pred_eq_of_pos (lt_of_le_of_lt (zero_le _) k_gt)).symm
    rw [km] at hk h'k
    have J1 : â€–f (x + y) - f x - L e (n e) m (x + y - x)â€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
      apply le_of_mem_A (hn e (n e) m le_rfl m_ge).2.2
      Â· simp only [mem_closedBall, dist_self]
        positivity
      Â· simpa only [dist_eq_norm, add_sub_cancel_left, mem_closedBall, pow_succ, mul_one_div] using
          h'k
    have J2 : â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– :=
      calc
        â€–f (x + y) - f x - L e (n e) m yâ€– â‰¤ (1 / 2) ^ e * (1 / 2) ^ m := by
          simpa only [add_sub_cancel_left] using J1
        _ = 4 * (1 / 2) ^ e * (1 / 2) ^ (m + 2) := by field_simp; ring
        _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– := by gcongr
    calc
      â€–f (x + y) - f x - f' yâ€– = â€–f (x + y) - f x - L e (n e) m y + (L e (n e) m - f') yâ€– :=
        congr_arg _ (by simp)
      _ â‰¤ 4 * (1 / 2) ^ e * â€–yâ€– + 12 * â€–câ€– * (1 / 2) ^ e * â€–yâ€– :=
        norm_add_le_of_le J2 <| (le_opNorm _ _).trans <| by gcongr; exact Lf' _ _ m_ge
      _ = (4 + 12 * â€–câ€–) * â€–yâ€– * (1 / 2) ^ e := by ring
      _ â‰¤ (4 + 12 * â€–câ€–) * â€–yâ€– * (Îµ / (4 + 12 * â€–câ€–)) := by gcongr
      _ = Îµ * â€–yâ€– := by field_simp [ne_of_gt pos]; ring
  rw [â† this.fderiv] at f'K
  exact âŸ¨this.differentiableAt, f'KâŸ©"
Mathlib/Geometry/Euclidean/Angle/Sphere.lean,EuclideanGeometry.Sphere.tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_center,tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_center,6b3f3fe208f0cdce581d713270301bed755856ed,":= by
  obtain âŸ¨r, hrâŸ© := (dist_eq_iff_eq_smul_rotation_pi_div_two_vadd_midpoint h).1
    (dist_center_eq_dist_center_of_mem_sphere hpâ‚ hpâ‚‚)
  rw [â† hr, â† oangle_midpoint_rev_left, oangle, vadd_vsub_assoc]
  nth_rw 1 [show pâ‚‚ -áµ¥ pâ‚ = (2 : â„) â€¢ (midpoint â„ pâ‚ pâ‚‚ -áµ¥ pâ‚) by simp]
  rw [map_smul, smul_smul, add_comm, o.tan_oangle_add_right_smul_rotation_pi_div_two,
    mul_div_cancel _ (two_ne_zero' â„)]
  simpa using h.symm","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.77252 * (?m.77320 / ?m.77252)
case intro
V : Type u_1
P : Type u_2
instâœâ´ : NormedAddCommGroup V
instâœÂ³ : InnerProductSpace â„ V
instâœÂ² : MetricSpace P
instâœÂ¹ : NormedAddTorsor V P
hd2 : Fact (finrank â„ V = 2)
instâœ : Module.Oriented â„ V (Fin 2)
s : Sphere P
pâ‚ pâ‚‚ : P
hpâ‚ : pâ‚ âˆˆ s
hpâ‚‚ : pâ‚‚ âˆˆ s
h : pâ‚ â‰  pâ‚‚
r : â„
hr : r â€¢ (o.rotation â†‘(Ï€ / 2)) (pâ‚‚ -áµ¥ pâ‚) +áµ¥ midpoint â„ pâ‚ pâ‚‚ = s.center
âŠ¢ (r * 2 / 2) â€¢ (o.rotation â†‘(Ï€ / 2)) (pâ‚‚ -áµ¥ pâ‚) +áµ¥ midpoint â„ pâ‚ pâ‚‚ =
    r â€¢ (o.rotation â†‘(Ï€ / 2)) (pâ‚‚ -áµ¥ pâ‚) +áµ¥ midpoint â„ pâ‚ pâ‚‚","theorem tan_div_two_smul_rotation_pi_div_two_vadd_midpoint_eq_center {s : Sphere P} {pâ‚ pâ‚‚ : P}
    (hpâ‚ : pâ‚ âˆˆ s) (hpâ‚‚ : pâ‚‚ âˆˆ s) (h : pâ‚ â‰  pâ‚‚) :
    (Real.Angle.tan (âˆ¡ pâ‚‚ pâ‚ s.center) / 2) â€¢ o.rotation (Ï€ / 2 : â„) (pâ‚‚ -áµ¥ pâ‚) +áµ¥
      midpoint â„ pâ‚ pâ‚‚ = s.center ",":= by
  obtain âŸ¨r, hrâŸ© := (dist_eq_iff_eq_smul_rotation_pi_div_two_vadd_midpoint h).1
    (dist_center_eq_dist_center_of_mem_sphere hpâ‚ hpâ‚‚)
  rw [â† hr, â† oangle_midpoint_rev_left, oangle, vadd_vsub_assoc]
  nth_rw 1 [show pâ‚‚ -áµ¥ pâ‚ = (2 : â„) â€¢ (midpoint â„ pâ‚ pâ‚‚ -áµ¥ pâ‚) by simp]
  rw [map_smul, smul_smul, add_comm, o.tan_oangle_add_right_smul_rotation_pi_div_two,
    mul_div_cancel_rightâ‚€ _ (two_ne_zero' â„)]
  simpa using h.symm"
Mathlib/Data/Seq/Computation.lean,Computation.bind_pure',bind_pure',3c930599229893e1b6a931304cf4efff4a01b172,":= by
  apply eq_of_bisim fun câ‚ câ‚‚ => câ‚ = câ‚‚ âˆ¨ âˆƒ s, câ‚ = bind s pure âˆ§ câ‚‚ = s
  Â· intro câ‚ câ‚‚ h
    exact
      match câ‚, câ‚‚, h with
      | _, câ‚‚, Or.inl (Eq.refl _) => by cases' dest câ‚‚ with b cb <;> simp
      | _, _, Or.inr âŸ¨s, rfl, rflâŸ© => by
        induction' s using recOn' with _ s <;> simp
  Â· exact Or.inr âŸ¨s, rfl, rflâŸ©","error:  unknown identifier 'dest'
error:  tactic 'induction' failed, major premise type is not an inductive type 
  ?m.30274
Î± : Type u
Î² : Type v
Î³ : Type w
s câ‚ câ‚‚âœ : Computation Î±
h : câ‚ = câ‚‚âœ âˆ¨ âˆƒ s, câ‚ = s.bind pure âˆ§ câ‚‚âœ = s
câ‚‚ : Computation Î±
xâœ : ?m.30274
âŠ¢ BisimO (fun câ‚ câ‚‚ â†¦ câ‚ = câ‚‚ âˆ¨ âˆƒ s, câ‚ = s.bind pure âˆ§ câ‚‚ = s) câ‚‚.destruct câ‚‚.destruct
error:  unknown identifier 'recOn''",theorem bind_pure' (s : Computation Î±) : bind s pure = s ,":= by
  apply eq_of_bisim fun câ‚ câ‚‚ => câ‚ = câ‚‚ âˆ¨ âˆƒ s, câ‚ = bind s pure âˆ§ câ‚‚ = s
  Â· intro câ‚ câ‚‚ h
    match câ‚, câ‚‚, h with
    | _, câ‚‚, Or.inl (Eq.refl _) => cases' destruct câ‚‚ with b cb <;> simp
    | _, _, Or.inr âŸ¨s, rfl, rflâŸ© =>
      apply recOn s <;> intro s <;> simp
  Â· exact Or.inr âŸ¨s, rfl, rflâŸ©"
Mathlib/LinearAlgebra/AffineSpace/Combination.lean,affineSpan_eq_affineSpan_lineMap_units,affineSpan_eq_affineSpan_lineMap_units,a6e1045fe156c34fddec5661e23432c879c43e5c,":= by
  have : s = Set.range ((â†‘) : s â†’ P) := by simp
  conv_rhs =>
    rw [this]

  apply le_antisymm
    <;> intro q hq
    <;> erw [mem_affineSpan_iff_eq_weightedVSubOfPoint_vadd k V _ (âŸ¨p, hpâŸ© : s) q] at hq âŠ¢
    <;> obtain âŸ¨t, Î¼, rflâŸ© := hq
    <;> use t
    <;> [(use fun x => Î¼ x * â†‘(w x)), (use fun x => Î¼ x * â†‘(w x)â»Â¹)]
    <;> simp [smul_smul]","error:  unexpected token ','; expected ']'","theorem affineSpan_eq_affineSpan_lineMap_units [Nontrivial k] {s : Set P} {p : P} (hp : p âˆˆ s)
    (w : s â†’ Units k) :
    affineSpan k (Set.range fun q : s => AffineMap.lineMap p â†‘q (w q : k)) = affineSpan k s ",":= by
  have : s = Set.range ((â†‘) : s â†’ P) := by simp
  conv_rhs =>
    rw [this]

  apply le_antisymm
    <;> intro q hq
    <;> erw [mem_affineSpan_iff_eq_weightedVSubOfPoint_vadd k V _ (âŸ¨p, hpâŸ© : s) q] at hq âŠ¢
    <;> obtain âŸ¨t, Î¼, rflâŸ© := hq
    <;> use t
    <;> [use fun x => Î¼ x * â†‘(w x); use fun x => Î¼ x * â†‘(w x)â»Â¹]
    <;> simp [smul_smul]"
Mathlib/RingTheory/UniqueFactorizationDomain.lean,UniqueFactorizationMonoid.normalizedFactors_prod_eq,normalizedFactors_prod_eq,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' s with a s ih
  Â· rw [Multiset.prod_zero, normalizedFactors_one, Multiset.map_zero]
  Â· have ia := hs a (Multiset.mem_cons_self a _)
    have ib := fun b h => hs b (Multiset.mem_cons_of_mem h)
    obtain rfl | âŸ¨b, hbâŸ© := s.empty_or_exists_mem
    Â· rw [Multiset.cons_zero, Multiset.prod_singleton, Multiset.map_singleton,
        normalizedFactors_irreducible ia]
    haveI := nontrivial_of_ne b 0 (ib b hb).ne_zero
    rw [Multiset.prod_cons, Multiset.map_cons,
      normalizedFactors_mul ia.ne_zero (Multiset.prod_ne_zero fun h => (ib 0 h).ne_zero rfl),
      normalizedFactors_irreducible ia, ih ib, Multiset.singleton_add]","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Î± : Type u_1
instâœÂ² : CancelCommMonoidWithZero Î±
instâœÂ¹ : NormalizationMonoid Î±
instâœ : UniqueFactorizationMonoid Î±
s : Multiset Î±
hs : âˆ€ a âˆˆ s, Irreducible a
âŠ¢ normalizedFactors s.prod = Multiset.map (â‡‘normalize) s","theorem normalizedFactors_prod_eq (s : Multiset Î±) (hs : âˆ€ a âˆˆ s, Irreducible a) :
    normalizedFactors s.prod = s.map normalize ",":= by
  induction' s using Multiset.induction with a s ih
  Â· rw [Multiset.prod_zero, normalizedFactors_one, Multiset.map_zero]
  Â· have ia := hs a (Multiset.mem_cons_self a _)
    have ib := fun b h => hs b (Multiset.mem_cons_of_mem h)
    obtain rfl | âŸ¨b, hbâŸ© := s.empty_or_exists_mem
    Â· rw [Multiset.cons_zero, Multiset.prod_singleton, Multiset.map_singleton,
        normalizedFactors_irreducible ia]
    haveI := nontrivial_of_ne b 0 (ib b hb).ne_zero
    rw [Multiset.prod_cons, Multiset.map_cons,
      normalizedFactors_mul ia.ne_zero (Multiset.prod_ne_zero fun h => (ib 0 h).ne_zero rfl),
      normalizedFactors_irreducible ia, ih ib, Multiset.singleton_add]"
Mathlib/Data/Multiset/Powerset.lean,Multiset.powersetCard_map,powersetCard_map,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' s with t s ih generalizing n
  Â· cases n <;> simp [powersetCard_zero_left, powersetCard_zero_right]
  Â· cases n <;> simp [ih, map_comp_cons]","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Î± : Type u_1
Î² : Type u_2
f : Î± â†’ Î²
n : â„•
s : Multiset Î±
âŠ¢ powersetCard n (map f s) = map (map f) (powersetCard n s)","theorem powersetCard_map {Î² : Type*} (f : Î± â†’ Î²) (n : â„•) (s : Multiset Î±) :
    powersetCard n (s.map f) = (powersetCard n s).map (map f) ",":= by
  induction' s using Multiset.induction with t s ih generalizing n
  Â· cases n <;> simp [powersetCard_zero_left, powersetCard_zero_right]
  Â· cases n <;> simp [ih, map_comp_cons]"
Mathlib/Analysis/NormedSpace/ProdLp.lean,WithLp.prod_norm_eq_sup,prod_norm_eq_sup,f655aad92f39fa1eff3436b3b0c4a1004e666b53,":= by
  dsimp [Norm.norm]
  exact if_neg ENNReal.top_ne_zero",error:  no goals to be solved,theorem prod_norm_eq_sup (f : WithLp âˆ (Î± Ã— Î²)) : â€–fâ€– = â€–f.fstâ€– âŠ” â€–f.sndâ€– ,:= rfl
Mathlib/Combinatorics/SimpleGraph/Regularity/Increment.lean,SzemerediRegularity.energy_increment,energy_increment,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  calc
    _ = (âˆ‘ x in P.parts.offDiag, (G.edgeDensity x.1 x.2 : â„) ^ 2 +
          P.parts.card ^ 2 * (Îµ ^ 5 / 4) : â„) / P.parts.card ^ 2 := by
        rw [coe_energy, add_div, mul_div_cancel_left]; positivity
    _ â‰¤ (âˆ‘ x in P.parts.offDiag.attach, (âˆ‘ i in distinctPairs G Îµ hP x,
          G.edgeDensity i.1 i.2 ^ 2 : â„) / 16 ^ P.parts.card) / P.parts.card ^ 2 :=
        div_le_div_of_le_of_nonneg ?_ $ by positivity
    _ = (âˆ‘ x in P.parts.offDiag.attach, âˆ‘ i in distinctPairs G Îµ hP x,
          G.edgeDensity i.1 i.2 ^ 2 : â„) / (increment hP G Îµ).parts.card ^ 2 := by
        rw [card_increment hPÎ± hPG, coe_stepBound, mul_pow, pow_right_comm,
          div_mul_eq_div_div_swap, â† sum_div]; norm_num
    _ â‰¤ _ := by
        rw [coe_energy]
        gcongr
        rw [â† sum_biUnion pairwiseDisjoint_distinctPairs]
        exact sum_le_sum_of_subset_of_nonneg distinctPairs_increment fun i _ _ â†¦ sq_nonneg _
  rw [Finpartition.IsUniform, not_le, mul_tsub, mul_one, â† offDiag_card] at hPG
  calc
    _ â‰¤ âˆ‘ x in P.parts.offDiag, (edgeDensity G x.1 x.2 : â„) ^ 2 +
        ((nonUniforms P G Îµ).card * (Îµ ^ 4 / 3) - P.parts.offDiag.card * (Îµ ^ 5 / 25)) :=
        add_le_add_left ?_ _
    _ = âˆ‘ x in P.parts.offDiag, ((G.edgeDensity x.1 x.2 : â„) ^ 2 +
        ((if G.IsUniform Îµ x.1 x.2 then (0 : â„) else Îµ ^ 4 / 3) - Îµ ^ 5 / 25) : â„) := by
        rw [sum_add_distrib, sum_sub_distrib, sum_const, nsmul_eq_mul, sum_ite, sum_const_zero,
          zero_add, sum_const, nsmul_eq_mul, â† Finpartition.nonUniforms, â† add_sub_assoc,
          add_sub_right_comm]
    _ = _ := (sum_attach ..).symm
    _ â‰¤ _ := sum_le_sum fun i _ â†¦ le_sum_distinctPairs_edgeDensity_sq i hÎµâ‚ hPÎ± hPÎµ
  calc
    _ = (6/7 * P.parts.card ^ 2) * Îµ ^ 5 * (7 / 24) := by ring
    _ â‰¤ P.parts.offDiag.card * Îµ ^ 5 * (22 / 75) := by
        gcongr ?_ * _ * ?_
        Â· rw [â† mul_div_right_comm, div_le_iff (by norm_num), offDiag_card]
          norm_cast
          rw [tsub_mul]
          refine le_tsub_of_add_le_left ?_
          nlinarith
        Â· norm_num
    _ = (P.parts.offDiag.card * Îµ * (Îµ ^ 4 / 3) - P.parts.offDiag.card * (Îµ ^ 5 / 25)) := by ring
    _ â‰¤ ((nonUniforms P G Îµ).card * (Îµ ^ 4 / 3) - P.parts.offDiag.card * (Îµ ^ 5 / 25)) := by
        gcongr","error:  application type mismatch
  SzemerediRegularity.distinctPairs G
argument
  G
has type
  SimpleGraph Î± : Type u_1
but is expected to have type
  ?m.44901.IsEquipartition : Prop
warning:  `div_le_div_of_le_of_nonneg` has been deprecated, use `div_le_div_of_nonneg_right` instead
error:  application type mismatch
  SzemerediRegularity.distinctPairs G
argument
  G
has type
  SimpleGraph Î± : Type u_1
but is expected to have type
  ?m.48696.IsEquipartition : Prop
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * ?b / ?a
Î± : Type u_1
instâœÂ³ : Fintype Î±
instâœÂ² : DecidableEq Î±
P : Finpartition univ
hPâœ : P.IsEquipartition
G : SimpleGraph Î±
instâœÂ¹ : DecidableRel G.Adj
Îµ : â„
instâœ : Nonempty Î±
hP : P.IsEquipartition
hPâ‚‡ : 7 â‰¤ P.parts.card
hPÎµ : 100 â‰¤ 4 ^ P.parts.card * Îµ ^ 5
hPÎ± : P.parts.card * 16 ^ P.parts.card â‰¤ Fintype.card Î±
hPG : Â¬P.IsUniform G Îµ
hÎµâ‚€ : 0 â‰¤ Îµ
hÎµâ‚ : Îµ â‰¤ 1
âŠ¢ (âˆ‘ uv âˆˆ P.parts.offDiag, â†‘(G.edgeDensity uv.1 uv.2) ^ 2) / â†‘P.parts.card ^ 2 + Îµ ^ 5 / 4 =
    (âˆ‘ x âˆˆ P.parts.offDiag, â†‘(G.edgeDensity x.1 x.2) ^ 2) / â†‘P.parts.card ^ 2 +
      â†‘P.parts.card ^ 2 * (Îµ ^ 5 / 4) / â†‘P.parts.card ^ 2
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  âˆ‘ x âˆˆ ?m.96955.parts.offDiag.attach, âˆ‘ i âˆˆ SzemerediRegularity.distinctPairs ?m.96956 ?m.96957 ?m.96959 x, ?m.96946 i
case hab
Î± : Type u_1
instâœÂ³ : Fintype Î±
instâœÂ² : DecidableEq Î±
P : Finpartition univ
hPâœ : P.IsEquipartition
G : SimpleGraph Î±
instâœÂ¹ : DecidableRel G.Adj
Îµ : â„
instâœ : Nonempty Î±
hP : P.IsEquipartition
hPâ‚‡ : 7 â‰¤ P.parts.card
hPÎµ : 100 â‰¤ 4 ^ P.parts.card * Îµ ^ 5
hPÎ± : P.parts.card * 16 ^ P.parts.card â‰¤ Fintype.card Î±
hPG : Â¬P.IsUniform G Îµ
hÎµâ‚€ : 0 â‰¤ Îµ
hÎµâ‚ : Îµ â‰¤ 1
âŠ¢ âˆ‘ x âˆˆ P.parts.offDiag.attach, âˆ‘ i âˆˆ sorryAx (Finset (Finset Î± Ã— Finset Î±)) true, â†‘(G.edgeDensity i.1 i.2) ^ 2 â‰¤
    âˆ‘ uv âˆˆ (increment hP G Îµ).parts.offDiag, â†‘(G.edgeDensity uv.1 uv.2) ^ 2
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information","theorem energy_increment (hP : P.IsEquipartition) (hPâ‚‡ : 7 â‰¤ P.parts.card)
    (hPÎµ : 100 â‰¤ 4 ^ P.parts.card * Îµ ^ 5) (hPÎ± : P.parts.card * 16 ^ P.parts.card â‰¤ card Î±)
    (hPG : Â¬P.IsUniform G Îµ) (hÎµâ‚€ : 0 â‰¤ Îµ) (hÎµâ‚ : Îµ â‰¤ 1) :
    â†‘(P.energy G) + Îµ ^ 5 / 4 â‰¤ (increment hP G Îµ).energy G ",":= by
  calc
    _ = (âˆ‘ x âˆˆ P.parts.offDiag, (G.edgeDensity x.1 x.2 : â„) ^ 2 +
          P.parts.card ^ 2 * (Îµ ^ 5 / 4) : â„) / P.parts.card ^ 2 := by
        rw [coe_energy, add_div, mul_div_cancel_leftâ‚€]; positivity
    _ â‰¤ (âˆ‘ x âˆˆ P.parts.offDiag.attach, (âˆ‘ i âˆˆ distinctPairs hP G Îµ x,
          G.edgeDensity i.1 i.2 ^ 2 : â„) / 16 ^ P.parts.card) / P.parts.card ^ 2 := ?_
    _ = (âˆ‘ x âˆˆ P.parts.offDiag.attach, âˆ‘ i âˆˆ distinctPairs hP G Îµ x,
          G.edgeDensity i.1 i.2 ^ 2 : â„) / (increment hP G Îµ).parts.card ^ 2 := by
        rw [card_increment hPÎ± hPG, coe_stepBound, mul_pow, pow_right_comm,
          div_mul_eq_div_div_swap, â† sum_div]; norm_num
    _ â‰¤ _ := by
        rw [coe_energy]
        gcongr
        rw [â† sum_biUnion pairwiseDisjoint_distinctPairs]
        exact sum_le_sum_of_subset_of_nonneg distinctPairs_increment fun i _ _ â†¦ sq_nonneg _
  gcongr
  rw [Finpartition.IsUniform, not_le, mul_tsub, mul_one, â† offDiag_card] at hPG
  calc
    _ â‰¤ âˆ‘ x âˆˆ P.parts.offDiag, (edgeDensity G x.1 x.2 : â„) ^ 2 +
        ((nonUniforms P G Îµ).card * (Îµ ^ 4 / 3) - P.parts.offDiag.card * (Îµ ^ 5 / 25)) :=
        add_le_add_left ?_ _
    _ = âˆ‘ x âˆˆ P.parts.offDiag, ((G.edgeDensity x.1 x.2 : â„) ^ 2 +
        ((if G.IsUniform Îµ x.1 x.2 then (0 : â„) else Îµ ^ 4 / 3) - Îµ ^ 5 / 25) : â„) := by
        rw [sum_add_distrib, sum_sub_distrib, sum_const, nsmul_eq_mul, sum_ite, sum_const_zero,
          zero_add, sum_const, nsmul_eq_mul, â† Finpartition.nonUniforms, â† add_sub_assoc,
          add_sub_right_comm]
    _ = _ := (sum_attach ..).symm
    _ â‰¤ _ := sum_le_sum fun i _ â†¦ le_sum_distinctPairs_edgeDensity_sq i hÎµâ‚ hPÎ± hPÎµ
  calc
    _ = (6/7 * P.parts.card ^ 2) * Îµ ^ 5 * (7 / 24) := by ring
    _ â‰¤ P.parts.offDiag.card * Îµ ^ 5 * (22 / 75) := by
        gcongr ?_ * _ * ?_
        Â· rw [â† mul_div_right_comm, div_le_iff (by norm_num), offDiag_card]
          norm_cast
          rw [tsub_mul]
          refine le_tsub_of_add_le_left ?_
          nlinarith
        Â· norm_num
    _ = (P.parts.offDiag.card * Îµ * (Îµ ^ 4 / 3) - P.parts.offDiag.card * (Îµ ^ 5 / 25)) := by ring
    _ â‰¤ ((nonUniforms P G Îµ).card * (Îµ ^ 4 / 3) - P.parts.offDiag.card * (Îµ ^ 5 / 25)) := by gcongr"
Mathlib/MeasureTheory/Integral/Periodic.lean,Function.Periodic.intervalIntegral_add_eq,intervalIntegral_add_eq,e80793ed2602b66d6dec49d0ef95cdf56a9ea10f,":= by
  simp only [integral_of_le, hT.le, le_add_iff_nonneg_right]
  haveI : VAddInvariantMeasure (AddSubgroup.zmultiples T) â„ volume :=
    âŸ¨fun c s _ => measure_preimage_add _ _ _âŸ©
  apply IsAddFundamentalDomain.set_integral_eq (G := AddSubgroup.zmultiples T)
  exacts [isAddFundamentalDomain_Ioc hT t, isAddFundamentalDomain_Ioc hT s, hf.map_vadd_zmultiples]",error:  unknown constant 'MeasureTheory.IsAddFundamentalDomain.set_integral_eq',"theorem intervalIntegral_add_eq_of_pos (hf : Periodic f T) (hT : 0 < T) (t s : â„) :
    âˆ« x in t..t + T, f x = âˆ« x in s..s + T, f x ",":= by
  simp only [integral_of_le, hT.le, le_add_iff_nonneg_right]
  haveI : VAddInvariantMeasure (AddSubgroup.zmultiples T) â„ volume :=
    âŸ¨fun c s _ => measure_preimage_add _ _ _âŸ©
  apply IsAddFundamentalDomain.setIntegral_eq (G := AddSubgroup.zmultiples T)
  exacts [isAddFundamentalDomain_Ioc hT t, isAddFundamentalDomain_Ioc hT s, hf.map_vadd_zmultiples]"
Mathlib/Algebra/Homology/QuasiIso.lean,HomotopyEquiv.toQuasiIso',toQuasiIso',7701d824cf6aeb07b077571b10ea148d5886bc22,":=
  âŸ¨fun i => by
    refine' âŸ¨âŸ¨(homology'Functor W c i).map e.inv, _âŸ©âŸ©
    simp only [â† Functor.map_comp, â† (homology'Functor W c i).map_id]
    constructor <;> apply homology_map_eq_of_homotopy
    exacts [e.homotopyHomInvId, e.homotopyInvHomId]âŸ©","error:  unknown identifier 'homology_map_eq_of_homotopy'
error:  unknown identifier 'homology_map_eq_of_homotopy'
error:  type mismatch
  e.homotopyHomInvId
has type
  Homotopy (e.hom â‰« e.inv) (ğŸ™ C) : Type (max u_1 u_3)
but is expected to have type
  (homology'Functor W c i).map (e.hom â‰« e.inv) = (homology'Functor W c i).map (ğŸ™ C) : Prop",theorem toQuasiIso' {C D : HomologicalComplex W c} (e : HomotopyEquiv C D) : QuasiIso' e.hom ,":=
  âŸ¨fun i => by
    refine âŸ¨âŸ¨(homology'Functor W c i).map e.inv, ?_âŸ©âŸ©
    simp only [â† Functor.map_comp, â† (homology'Functor W c i).map_id]
    constructor <;> apply homology'_map_eq_of_homotopy
    exacts [e.homotopyHomInvId, e.homotopyInvHomId]âŸ©"
Mathlib/Order/Bounds/Basic.lean,BddBelow.inter_of_right,BddBelow.inter_of_right,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":=
  h.mono <| inter_subset_right s t","error:  application type mismatch
  inter_subset_right s
argument
  s
has type
  Set Î± : Type u
but is expected to have type
  ?m.17299 âˆˆ ?m.17297 âˆ© ?m.17298 : Prop",theorem BddBelow.inter_of_right (h : BddBelow t) : BddBelow (s âˆ© t) ,":=
  h.mono inter_subset_right"
Mathlib/ModelTheory/Satisfiability.lean,FirstOrder.Language.Theory.exists_large_model_of_infinite_model,exists_large_model_of_infinite_model,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  obtain âŸ¨NâŸ© :=
    isSatisfiable_union_distinctConstantsTheory_of_infinite T (Set.univ : Set Îº.out) M
  refine' âŸ¨(N.is_model.mono (Set.subset_union_left _ _)).bundled.reduct _, _âŸ©
  haveI : N âŠ¨ distinctConstantsTheory _ _ := N.is_model.mono (Set.subset_union_right _ _)
  rw [ModelType.reduct_Carrier, coe_of]
  refine' _root_.trans (lift_le.2 (le_of_eq (Cardinal.mk_out Îº).symm)) _
  rw [â† mk_univ]
  refine
    (card_le_of_model_distinctConstantsTheory L Set.univ N).trans (lift_le.{max u v w}.1 ?_)
  rw [lift_lift]","error:  function expected at
  Set.subset_union_left ?m.16906
term has type
  ?m.16905 âˆˆ ?m.16903 âˆª ?m.16904
error:  function expected at
  Set.subset_union_right ?m.17980
term has type
  ?m.17979 âˆˆ ?m.17977 âˆª ?m.17978
error:  unsolved goals
case intro.refine'_1
L : Language
Tâœ : L.Theory
Î± : Type w
n : â„•
T' T : L.Theory
Îº : Cardinal.{w}
M : Type w'
instâœÂ² : L.Structure M
instâœÂ¹ : M âŠ¨ T
instâœ : Infinite M
N : ((L.lhomWithConstants (Quotient.out Îº)).onTheory T âˆª L.distinctConstantsTheory Set.univ).ModelType
âŠ¢ L â†’á´¸ L[[Quotient.out Îº]]
warning:  @ModelsBoundedFormula does not have a doc string","theorem exists_large_model_of_infinite_model (T : L.Theory) (Îº : Cardinal.{w}) (M : Type w')
    [L.Structure M] [M âŠ¨ T] [Infinite M] :
    âˆƒ N : ModelType.{_, _, max u v w} T, Cardinal.lift.{max u v w} Îº â‰¤ #N ",":= by
  obtain âŸ¨NâŸ© :=
    isSatisfiable_union_distinctConstantsTheory_of_infinite T (Set.univ : Set Îº.out) M
  refine âŸ¨(N.is_model.mono Set.subset_union_left).bundled.reduct _, ?_âŸ©
  haveI : N âŠ¨ distinctConstantsTheory _ _ := N.is_model.mono Set.subset_union_right
  rw [ModelType.reduct_Carrier, coe_of]
  refine _root_.trans (lift_le.2 (le_of_eq (Cardinal.mk_out Îº).symm)) ?_
  rw [â† mk_univ]
  refine
    (card_le_of_model_distinctConstantsTheory L Set.univ N).trans (lift_le.{max u v w}.1 ?_)
  rw [lift_lift]"
Mathlib/RingTheory/IntegralDomain.lean,sum_hom_units_eq_zero,sum_hom_units_eq_zero,01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  classical
    obtain âŸ¨x, hxâŸ© :
      âˆƒ x : MonoidHom.range f.toHomUnits,
        âˆ€ y : MonoidHom.range f.toHomUnits, y âˆˆ Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x â‰  1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx âŸ¨f.toHomUnits g, g, rflâŸ© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 â‰  0  
    exact fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      âˆ‘ g : G, f g = âˆ‘ g : G, (f.toHomUnits g : R) := rfl
      _ = âˆ‘ u : RË£ in univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card â€¢ (u : R) :=
        (sum_comp ((â†‘) : RË£ â†’ R) f.toHomUnits)
      _ = âˆ‘ u : RË£ in univ.image f.toHomUnits, c â€¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_argâ‚‚ _ ?_ rfl)
      _ = âˆ‘ b : MonoidHom.range f.toHomUnits, c â€¢ ((b : RË£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c â€¢ âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R) := smul_sum.symm
      _ = c â€¢ (0 : R) := (congr_argâ‚‚ _ rfl ?_)
      _ = (0 : R) := smul_zero _
    Â· 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply card_fiber_eq_of_mem_range f.toHomUnits
      Â· simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      Â· exact âŸ¨1, f.toHomUnits.map_oneâŸ©
    show (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R)) = 0
    calc
      (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R))
        = âˆ‘ n in range (orderOf x), ((x : RË£) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ Â·) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let âŸ¨n, hnâŸ© := hx b
              âŸ¨n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn âŠ¢; rw [pow_mod_orderOf, hn]âŸ©)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [â† mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]","error:  unexpected identifier; expected '|'
error:  unsolved goals
case intro
R : Type u_1
G : Type u_2
instâœÂ³ : CommRing R
instâœÂ² : IsDomain R
instâœÂ¹ : Group G
instâœ : Fintype G
f : G â†’* R
hf : f â‰  1
x : â†¥f.toHomUnits.range
hx : âˆ€ (y : â†¥f.toHomUnits.range), y âˆˆ Submonoid.powers x
hx1 : â†‘â†‘x - 1 â‰  0
âŠ¢ âˆ‘ g : G, f g = 0","theorem sum_hom_units_eq_zero (f : G â†’* R) (hf : f â‰  1) : âˆ‘ g : G, f g = 0 ",":= by
  classical
    obtain âŸ¨x, hxâŸ© : âˆƒ x : MonoidHom.range f.toHomUnits,
        âˆ€ y : MonoidHom.range f.toHomUnits, y âˆˆ Submonoid.powers x :=
      IsCyclic.exists_monoid_generator
    have hx1 : x â‰  1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx âŸ¨f.toHomUnits g, g, rflâŸ© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 â‰  0 := 
      fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      âˆ‘ g : G, f g = âˆ‘ g : G, (f.toHomUnits g : R) := rfl
      _ = âˆ‘ u âˆˆ univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card â€¢ (u : R) :=
        (sum_comp ((â†‘) : RË£ â†’ R) f.toHomUnits)
      _ = âˆ‘ u âˆˆ univ.image f.toHomUnits, c â€¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_argâ‚‚ _ ?_ rfl)
      _ = âˆ‘ b : MonoidHom.range f.toHomUnits, c â€¢ ((b : RË£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c â€¢ âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R) := smul_sum.symm
      _ = c â€¢ (0 : R) := congr_argâ‚‚ _ rfl ?_
      _ = (0 : R) := smul_zero _
    Â· 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply MonoidHom.card_fiber_eq_of_mem_range f.toHomUnits
      Â· simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      Â· exact âŸ¨1, f.toHomUnits.map_oneâŸ©
    show (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R)) = 0
    calc
      (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R))
        = âˆ‘ n âˆˆ range (orderOf x), ((x : RË£) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ Â·) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let âŸ¨n, hnâŸ© := hx b
              âŸ¨n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn âŠ¢; rw [pow_mod_orderOf, hn]âŸ©)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [â† mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]"
Mathlib/AlgebraicTopology/DoldKan/Compatibility.lean,AlgebraicTopology.DoldKan.Compatibility.equivalenceUnitIso_eq,equivalenceUnitIso_eq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  ext1; apply NatTrans.ext; ext X
  dsimp [equivalence, Functor.asEquivalence, Functor.IsEquivalence.ofEquivalence,
    Functor.IsEquivalence.inverse]
  rw [Functor.IsEquivalence.ofIso_counitIso_inv_app]
  dsimp
  erw [id_comp, comp_id]
  simp only [equivalenceâ‚‚UnitIso_eq eB hF, equivalenceâ‚‚UnitIso_hom_app,
    assoc, equivalenceUnitIso_hom_app, â† eA.inverse.map_comp_assoc, â† hÎµ, Ï…_hom_app]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Functor.IsEquivalence
has type
  ?m.84548 â¥¤ ?m.84568 â†’ Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Functor.IsEquivalence
has type
  ?m.84597 â¥¤ ?m.84617 â†’ Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Functor.IsEquivalence
has type
  ?m.86005 â¥¤ ?m.86025 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.86046
case w.app.h
A : Type u_1
A' : Type u_2
B : Type u_3
B' : Type u_4
instâœÂ³ : Category.{u_5, u_1} A
instâœÂ² : Category.{u_7, u_2} A'
instâœÂ¹ : Category.{u_6, u_3} B
instâœ : Category.{u_8, u_4} B'
eA : A â‰Œ A'
eB : B â‰Œ B'
e' : A' â‰Œ B'
F : A â¥¤ B'
hF : eA.functor â‹™ e'.functor â‰… F
G : B â¥¤ A
hG : eB.functor â‹™ e'.inverse â‰… G â‹™ eA.functor
Î· : G â‹™ F â‰… eB.functor
hÎ· : Ï„â‚€ = Ï„â‚ hF hG Î·
Îµ : eA.functor â‰… F â‹™ e'.inverse
hÎµ : Ï… hF = Îµ
X : A
âŠ¢ (equivalenceâ‚‚ eB hF).unitIso.hom.app X â‰«
      ((ğŸ™ (eA.inverse.obj (e'.inverse.obj (eB.functor.obj (eB.inverse.obj (F.obj X))))) â‰«
            eA.inverse.map (hG.hom.app (eB.inverse.obj (F.obj X)))) â‰«
          eA.unitIso.inv.app (G.obj (eB.inverse.obj (F.obj X)))) â‰«
        ğŸ™ (G.obj (eB.inverse.obj (F.obj X))) =
    (equivalenceUnitIso hG Îµ).hom.app X",theorem equivalenceUnitIso_eq : (equivalence hF hG).unitIso = equivalenceUnitIso hG Îµ ,":= by
  ext1; apply NatTrans.ext; ext X
  dsimp [equivalence]
  simp only [assoc, comp_id, equivalenceUnitIso_hom_app]
  erw [id_comp]
  simp only [equivalenceâ‚‚UnitIso_eq eB hF, equivalenceâ‚‚UnitIso_hom_app,
    â† eA.inverse.map_comp_assoc, assoc, â† hÎµ, Ï…_hom_app]"
Mathlib/CategoryTheory/Elements.lean,CategoryTheory.CategoryOfElements.to_fromCostructuredArrow_eq,to_fromCostructuredArrow_eq,bb7d4c761dfb471327d73069c1825f3edd2b6f80,":= by
  refine' Functor.ext _ _
  Â· intro X
    cases' X with X_left X_right X_hom
    cases X_right
    simp only [Functor.id_obj, Functor.rightOp_obj, toCostructuredArrow_obj, Functor.comp_obj,
      CostructuredArrow.mk]
    congr
    ext x
    funext f
    convert congr_fun (X_hom.naturality f.op).symm (ğŸ™ X_left)
    simp
  Â· intro X Y f
    ext
    simp [CostructuredArrow.eqToHom_left]
  CategoryTheory.CategoryOfElements.to_fromCostructuredArrow_eq",error:  unknown tactic,"theorem to_fromCostructuredArrow_eq (F : Cáµ’áµ– â¥¤ Type v) :
    (fromCostructuredArrow F).rightOp â‹™ toCostructuredArrow F = ğŸ­ _ ",":= by
  refine Functor.ext ?_ ?_
  Â· intro X
    cases' X with X_left X_right X_hom
    cases X_right
    simp only [Functor.id_obj, Functor.rightOp_obj, toCostructuredArrow_obj, Functor.comp_obj,
      CostructuredArrow.mk]
    congr
    ext x f
    convert congr_fun (X_hom.naturality f.op).symm (ğŸ™ X_left)
    simp
  Â· aesop"
Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean,GeneralizedContinuedFraction.of_s_head_aux,of_s_head_aux,67bb925387960887a3b36a6aab219b9c613883f7,":= by
  rw [of, IntFractPair.seq1]
  simp only [of, Seq'.map_tail, Seq'.map, Seq'.tail, Seq'.head, Seq'.get?, Stream'.map]
  rw [â† Stream'.get_succ, Stream'.get, Option.map]
  split <;> simp_all only [Option.some_bind, Option.none_bind, Function.comp_apply]","error:  unknown identifier 'Seq'.map_tail'
error:  unknown identifier 'Seq'.map'
error:  unknown identifier 'Seq'.tail'
error:  unknown identifier 'Seq'.head'
error:  unknown identifier 'Seq'.get?'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?s.tail.get ?n
K : Type u_1
instâœÂ¹ : LinearOrderedField K
instâœ : FloorRing K
vâœ : K
n : â„•
v : K
âŠ¢ (Stream'.Seq.map (fun p â†¦ { a := 1, b := â†‘p.b }) (Stream'.Seq.tail âŸ¨IntFractPair.stream v, â‹¯âŸ©)).get? 0 =
    (IntFractPair.stream v 1).bind (some âˆ˜ fun p â†¦ { a := 1, b := â†‘p.b })","theorem of_s_head_aux (v : K) : (of v).s.get? 0 = (IntFractPair.stream v 1).bind (some âˆ˜ fun p =>
    { a := 1
      b := p.b }) ",":= by
  rw [of, IntFractPair.seq1]
  simp only [of, Stream'.Seq.map_tail, Stream'.Seq.map, Stream'.Seq.tail, Stream'.Seq.head,
    Stream'.Seq.get?, Stream'.map]
  rw [â† Stream'.get_succ, Stream'.get, Option.map]
  split <;> simp_all only [Option.some_bind, Option.none_bind, Function.comp_apply]"
Mathlib/MeasureTheory/Function/AEMeasurableOrder.lean,MeasureTheory.aemeasurable_of_exist_almost_disjoint_supersets,MeasureTheory.aemeasurable_of_exist_almost_disjoint_supersets,8184afb5b005f3973962e14cf019c56ec72d9467,":= by
  haveI : Encodable s := s_count.toEncodable
  have h' : âˆ€ p q, âˆƒ u v, MeasurableSet u âˆ§ MeasurableSet v âˆ§
      { x | f x < p } âŠ† u âˆ§ { x | q < f x } âŠ† v âˆ§ (p âˆˆ s â†’ q âˆˆ s â†’ p < q â†’ Î¼ (u âˆ© v) = 0) := by
    intro p q
    by_cases H : p âˆˆ s âˆ§ q âˆˆ s âˆ§ p < q
    Â· rcases h p H.1 q H.2.1 H.2.2 with âŸ¨u, v, hu, hv, h'u, h'v, hÎ¼âŸ©
      exact âŸ¨u, v, hu, hv, h'u, h'v, fun _ _ _ => hÎ¼âŸ©
    Â· refine'
        âŸ¨univ, univ, MeasurableSet.univ, MeasurableSet.univ, subset_univ _, subset_univ _,
          fun ps qs pq => _âŸ©
      simp only [not_and] at H
      exact (H ps qs pq).elim
  choose! u v huv using h'
  let u' : Î² â†’ Set Î± := fun p => â‹‚ q âˆˆ s âˆ© Ioi p, u p q
  have u'_meas : âˆ€ i, MeasurableSet (u' i) := by
    intro i
    exact MeasurableSet.biInter (s_count.mono (inter_subset_left _ _)) fun b _ => (huv i b).1
  let f' : Î± â†’ Î² := fun x => â¨… i : s, piecewise (u' i) (fun _ => (i : Î²)) (fun _ => (âŠ¤ : Î²)) x
  have f'_meas : Measurable f' := by
    apply measurable_iInf
    exact fun i => Measurable.piecewise (u'_meas i) measurable_const measurable_const
  let t := â‹ƒ (p : s) (q : â†¥(s âˆ© Ioi p)), u' p âˆ© v p q
  have Î¼t : Î¼ t â‰¤ 0 :=
    calc
      Î¼ t â‰¤ âˆ‘' (p : s) (q : â†¥(s âˆ© Ioi p)), Î¼ (u' p âˆ© v p q) := by
        refine (measure_iUnion_le _).trans ?_
        refine ENNReal.tsum_le_tsum fun p => ?_
        haveI := (s_count.mono (inter_subset_left _ (Ioi â†‘p))).to_subtype
        apply measure_iUnion_le
      _ â‰¤ âˆ‘' (p : s) (q : â†¥(s âˆ© Ioi p)), Î¼ (u p q âˆ© v p q) := by
        gcongr with p q
        exact biInter_subset_of_mem q.2
      _ = âˆ‘' (p : s) (_ : â†¥(s âˆ© Ioi p)), (0 : â„â‰¥0âˆ) := by
        congr
        ext1 p
        congr
        ext1 q
        exact (huv p q).2.2.2.2 p.2 q.2.1 q.2.2
      _ = 0 := by simp only [tsum_zero]
  have ff' : âˆ€áµ x âˆ‚Î¼, f x = f' x := by
    have : âˆ€áµ x âˆ‚Î¼, x âˆ‰ t := by
      have : Î¼ t = 0 := le_antisymm Î¼t bot_le
      change Î¼ _ = 0
      convert this
      ext y
      simp only [not_exists, exists_prop, mem_setOf_eq, mem_compl_iff, not_not_mem]
    filter_upwards [this] with x hx
    apply (iInf_eq_of_forall_ge_of_forall_gt_exists_lt _ _).symm
    Â· intro i
      by_cases H : x âˆˆ u' i
      swap
      Â· simp only [H, le_top, not_false_iff, piecewise_eq_of_not_mem]
      simp only [H, piecewise_eq_of_mem]
      contrapose! hx
      obtain âŸ¨r, âŸ¨xr, rqâŸ©, rsâŸ© : âˆƒ r, r âˆˆ Ioo (i : Î²) (f x) âˆ© s :=
        dense_iff_inter_open.1 s_dense (Ioo i (f x)) isOpen_Ioo (nonempty_Ioo.2 hx)
      have A : x âˆˆ v i r := (huv i r).2.2.2.1 rq
      refine mem_iUnion.2 âŸ¨i, ?_âŸ©
      refine mem_iUnion.2 âŸ¨âŸ¨r, âŸ¨rs, xrâŸ©âŸ©, ?_âŸ©
      exact âŸ¨H, AâŸ©
    Â· intro q hq
      obtain âŸ¨r, âŸ¨xr, rqâŸ©, rsâŸ© : âˆƒ r, r âˆˆ Ioo (f x) q âˆ© s :=
        dense_iff_inter_open.1 s_dense (Ioo (f x) q) isOpen_Ioo (nonempty_Ioo.2 hq)
      refine' âŸ¨âŸ¨r, rsâŸ©, _âŸ©
      have A : x âˆˆ u' r := mem_biInter fun i _ => (huv r i).2.2.1 xr
      simp only [A, rq, piecewise_eq_of_mem, Subtype.coe_mk]
  exact âŸ¨f', f'_meas, ff'âŸ©","error:  function expected at
  inter_subset_left ?m.2313
term has type
  ?m.2312 âˆˆ ?m.2310
error:  function expected at
  inter_subset_left ?m.5366
term has type
  ?m.5365 âˆˆ ?m.5363
error:  unsolved goals
Î± : Type u_1
m : MeasurableSpace Î±
Î¼ : Measure Î±
Î² : Type u_2
instâœâ¶ : CompleteLinearOrder Î²
instâœâµ : DenselyOrdered Î²
instâœâ´ : TopologicalSpace Î²
instâœÂ³ : OrderTopology Î²
instâœÂ² : SecondCountableTopology Î²
instâœÂ¹ : MeasurableSpace Î²
instâœ : BorelSpace Î²
s : Set Î²
s_count : s.Countable
s_dense : Dense s
f : Î± â†’ Î²
h :
  âˆ€ p âˆˆ s,
    âˆ€ q âˆˆ s, p < q â†’ âˆƒ u v, MeasurableSet u âˆ§ MeasurableSet v âˆ§ {x | f x < p} âŠ† u âˆ§ {x | q < f x} âŠ† v âˆ§ Î¼ (u âˆ© v) = 0
this : Encodable â†‘s
u v : Î² â†’ Î² â†’ Set Î±
huv :
  âˆ€ (p q : Î²),
    MeasurableSet (u p q) âˆ§
      MeasurableSet (v p q) âˆ§
        {x | f x < p} âŠ† u p q âˆ§ {x | q < f x} âŠ† v p q âˆ§ (p âˆˆ s â†’ q âˆˆ s â†’ p < q â†’ Î¼ (u p q âˆ© v p q) = 0)
u' : Î² â†’ Set Î± := fun p â†¦ â‹‚ q âˆˆ s âˆ© Ioi p, u p q
u'_meas : âˆ€ (i : Î²), MeasurableSet (u' i)
f' : Î± â†’ Î² := fun x â†¦ â¨… i, (u' â†‘i).piecewise (fun x â†¦ â†‘i) (fun x â†¦ âŠ¤) x
f'_meas : Measurable f'
t : Set Î± := â‹ƒ p, â‹ƒ q, u' â†‘p âˆ© v â†‘p â†‘q
p : â†‘s
âŠ¢ Î¼ (â‹ƒ q, u' â†‘p âˆ© v â†‘p â†‘q) â‰¤ âˆ‘' (q : â†‘(s âˆ© Ioi â†‘p)), Î¼ (u' â†‘p âˆ© v â†‘p â†‘q)","theorem MeasureTheory.aemeasurable_of_exist_almost_disjoint_supersets {Î± : Type*}
    {m : MeasurableSpace Î±} (Î¼ : Measure Î±) {Î² : Type*} [CompleteLinearOrder Î²] [DenselyOrdered Î²]
    [TopologicalSpace Î²] [OrderTopology Î²] [SecondCountableTopology Î²] [MeasurableSpace Î²]
    [BorelSpace Î²] (s : Set Î²) (s_count : s.Countable) (s_dense : Dense s) (f : Î± â†’ Î²)
    (h : âˆ€ p âˆˆ s, âˆ€ q âˆˆ s, p < q â†’ âˆƒ u v, MeasurableSet u âˆ§ MeasurableSet v âˆ§
      { x | f x < p } âŠ† u âˆ§ { x | q < f x } âŠ† v âˆ§ Î¼ (u âˆ© v) = 0) :
    AEMeasurable f Î¼ ",":= by
  haveI : Encodable s := s_count.toEncodable
  have h' : âˆ€ p q, âˆƒ u v, MeasurableSet u âˆ§ MeasurableSet v âˆ§
      { x | f x < p } âŠ† u âˆ§ { x | q < f x } âŠ† v âˆ§ (p âˆˆ s â†’ q âˆˆ s â†’ p < q â†’ Î¼ (u âˆ© v) = 0) := by
    intro p q
    by_cases H : p âˆˆ s âˆ§ q âˆˆ s âˆ§ p < q
    Â· rcases h p H.1 q H.2.1 H.2.2 with âŸ¨u, v, hu, hv, h'u, h'v, hÎ¼âŸ©
      exact âŸ¨u, v, hu, hv, h'u, h'v, fun _ _ _ => hÎ¼âŸ©
    Â· refine
        âŸ¨univ, univ, MeasurableSet.univ, MeasurableSet.univ, subset_univ _, subset_univ _,
          fun ps qs pq => ?_âŸ©
      simp only [not_and] at H
      exact (H ps qs pq).elim
  choose! u v huv using h'
  let u' : Î² â†’ Set Î± := fun p => â‹‚ q âˆˆ s âˆ© Ioi p, u p q
  have u'_meas : âˆ€ i, MeasurableSet (u' i) := by
    intro i
    exact MeasurableSet.biInter (s_count.mono inter_subset_left) fun b _ => (huv i b).1
  let f' : Î± â†’ Î² := fun x => â¨… i : s, piecewise (u' i) (fun _ => (i : Î²)) (fun _ => (âŠ¤ : Î²)) x
  have f'_meas : Measurable f' := by
    apply measurable_iInf
    exact fun i => Measurable.piecewise (u'_meas i) measurable_const measurable_const
  let t := â‹ƒ (p : s) (q : â†¥(s âˆ© Ioi p)), u' p âˆ© v p q
  have Î¼t : Î¼ t â‰¤ 0 :=
    calc
      Î¼ t â‰¤ âˆ‘' (p : s) (q : â†¥(s âˆ© Ioi p)), Î¼ (u' p âˆ© v p q) := by
        refine (measure_iUnion_le _).trans ?_
        refine ENNReal.tsum_le_tsum fun p => ?_
        haveI := (s_count.mono (s.inter_subset_left (t := Ioi â†‘p))).to_subtype
        apply measure_iUnion_le
      _ â‰¤ âˆ‘' (p : s) (q : â†¥(s âˆ© Ioi p)), Î¼ (u p q âˆ© v p q) := by
        gcongr with p q
        exact biInter_subset_of_mem q.2
      _ = âˆ‘' (p : s) (_ : â†¥(s âˆ© Ioi p)), (0 : â„â‰¥0âˆ) := by
        congr
        ext1 p
        congr
        ext1 q
        exact (huv p q).2.2.2.2 p.2 q.2.1 q.2.2
      _ = 0 := by simp only [tsum_zero]
  have ff' : âˆ€áµ x âˆ‚Î¼, f x = f' x := by
    have : âˆ€áµ x âˆ‚Î¼, x âˆ‰ t := by
      have : Î¼ t = 0 := le_antisymm Î¼t bot_le
      change Î¼ _ = 0
      convert this
      ext y
      simp only [not_exists, exists_prop, mem_setOf_eq, mem_compl_iff, not_not_mem]
    filter_upwards [this] with x hx
    apply (iInf_eq_of_forall_ge_of_forall_gt_exists_lt _ _).symm
    Â· intro i
      by_cases H : x âˆˆ u' i
      swap
      Â· simp only [H, le_top, not_false_iff, piecewise_eq_of_not_mem]
      simp only [H, piecewise_eq_of_mem]
      contrapose! hx
      obtain âŸ¨r, âŸ¨xr, rqâŸ©, rsâŸ© : âˆƒ r, r âˆˆ Ioo (i : Î²) (f x) âˆ© s :=
        dense_iff_inter_open.1 s_dense (Ioo i (f x)) isOpen_Ioo (nonempty_Ioo.2 hx)
      have A : x âˆˆ v i r := (huv i r).2.2.2.1 rq
      refine mem_iUnion.2 âŸ¨i, ?_âŸ©
      refine mem_iUnion.2 âŸ¨âŸ¨r, âŸ¨rs, xrâŸ©âŸ©, ?_âŸ©
      exact âŸ¨H, AâŸ©
    Â· intro q hq
      obtain âŸ¨r, âŸ¨xr, rqâŸ©, rsâŸ© : âˆƒ r, r âˆˆ Ioo (f x) q âˆ© s :=
        dense_iff_inter_open.1 s_dense (Ioo (f x) q) isOpen_Ioo (nonempty_Ioo.2 hq)
      refine âŸ¨âŸ¨r, rsâŸ©, ?_âŸ©
      have A : x âˆˆ u' r := mem_biInter fun i _ => (huv r i).2.2.1 xr
      simp only [A, rq, piecewise_eq_of_mem, Subtype.coe_mk]
  exact âŸ¨f', f'_meas, ff'âŸ©"
Mathlib/RingTheory/IntegralRestrict.lean,Algebra.intTrace_eq_of_isLocalization,Algebra.intTrace_eq_of_isLocalization,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  by_cases hM : 0 âˆˆ M
  Â· have := IsLocalization.uniqueOfZeroMem (S := Aâ‚˜) hM
    exact Subsingleton.elim _ _
  replace hM : M â‰¤ Aâ° := fun x hx â†¦ mem_nonZeroDivisors_iff_ne_zero.mpr (fun e â†¦ hM (e â–¸ hx))
  let K := FractionRing A
  let L := FractionRing B
  have : IsIntegralClosure B A L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (Algebra.IsIntegral.of_finite A B)
  have : IsLocalization (algebraMapSubmonoid B Aâ°) L :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
      (isAlgebraic_of_isFractionRing _ _ (Algebra.IsIntegral.of_finite A B))
  let f : Aâ‚˜ â†’+* K := IsLocalization.map _ (T := Aâ°) (RingHom.id A) hM
  letI := f.toAlgebra
  have : IsScalarTower A Aâ‚˜ K := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aâ‚˜ K
  let g : Bâ‚˜ â†’+* L := IsLocalization.map _
      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B Aâ°)
      (RingHom.id B) (Submonoid.monotone_map hM)
  letI := g.toAlgebra
  have : IsScalarTower B Bâ‚˜ L := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := ((algebraMap K L).comp f).toAlgebra
  have : IsScalarTower Aâ‚˜ K L := IsScalarTower.of_algebraMap_eq' rfl
  have : IsScalarTower Aâ‚˜ Bâ‚˜ L := by
    apply IsScalarTower.of_algebraMap_eq'
    apply IsLocalization.ringHom_ext M
    rw [RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra (R := Bâ‚˜), RingHom.comp_assoc,
      RingHom.comp_assoc, â† IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq A B Bâ‚˜,
      IsLocalization.map_comp, RingHom.comp_id, â† RingHom.comp_assoc, IsLocalization.map_comp,
      RingHom.comp_id, â† IsScalarTower.algebraMap_eq, â† IsScalarTower.algebraMap_eq]
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization
    (algebraMapSubmonoid B M) Bâ‚˜ L
  have : FiniteDimensional K L := Module.Finite_of_isLocalization A B _ _ Aâ°
  have : IsIntegralClosure Bâ‚˜ Aâ‚˜ L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _ (Algebra.IsIntegral.of_finite Aâ‚˜ Bâ‚˜)
  apply IsFractionRing.injective Aâ‚˜ K
  rw [â† IsScalarTower.algebraMap_apply, Algebra.algebraMap_intTrace_fractionRing,
    Algebra.algebraMap_intTrace (L := L), â† IsScalarTower.algebraMap_apply]","error:  function expected at
  IsIntegralClosure.of_isIntegrallyClosed ?m.366306 ?m.366307 ?m.366311
term has type
  IsIntegralClosure ?m.366306 ?m.366307 ?m.366311
error:  function expected at
  IsIntegralClosure.isLocalization ?m.368130 (FractionRing A) ?m.368143 ?m.368145
term has type
  IsLocalization (algebraMapSubmonoid ?m.368145 ?m.368130â°) ?m.368143
error:  function expected at
  IsIntegralClosure.of_isIntegrallyClosed ?m.399845 ?m.399846 ?m.399850
term has type
  IsIntegralClosure ?m.399845 ?m.399846 ?m.399850","lemma Algebra.intTrace_eq_of_isLocalization
    (x : B) :
    algebraMap A Aâ‚˜ (Algebra.intTrace A B x) = Algebra.intTrace Aâ‚˜ Bâ‚˜ (algebraMap B Bâ‚˜ x) ",":= by
  by_cases hM : 0 âˆˆ M
  Â· have := IsLocalization.uniqueOfZeroMem (S := Aâ‚˜) hM
    exact Subsingleton.elim _ _
  replace hM : M â‰¤ Aâ° := fun x hx â†¦ mem_nonZeroDivisors_iff_ne_zero.mpr (fun e â†¦ hM (e â–¸ hx))
  let K := FractionRing A
  let L := FractionRing B
  have : IsIntegralClosure B A L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsLocalization (algebraMapSubmonoid B Aâ°) L :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  let f : Aâ‚˜ â†’+* K := IsLocalization.map _ (T := Aâ°) (RingHom.id A) hM
  letI := f.toAlgebra
  have : IsScalarTower A Aâ‚˜ K := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aâ‚˜ K
  let g : Bâ‚˜ â†’+* L := IsLocalization.map _
      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B Aâ°)
      (RingHom.id B) (Submonoid.monotone_map hM)
  letI := g.toAlgebra
  have : IsScalarTower B Bâ‚˜ L := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := ((algebraMap K L).comp f).toAlgebra
  have : IsScalarTower Aâ‚˜ K L := IsScalarTower.of_algebraMap_eq' rfl
  have : IsScalarTower Aâ‚˜ Bâ‚˜ L := by
    apply IsScalarTower.of_algebraMap_eq'
    apply IsLocalization.ringHom_ext M
    rw [RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra (R := Bâ‚˜), RingHom.comp_assoc,
      RingHom.comp_assoc, â† IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq A B Bâ‚˜,
      IsLocalization.map_comp, RingHom.comp_id, â† RingHom.comp_assoc, IsLocalization.map_comp,
      RingHom.comp_id, â† IsScalarTower.algebraMap_eq, â† IsScalarTower.algebraMap_eq]
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization
    (algebraMapSubmonoid B M) Bâ‚˜ L
  have : FiniteDimensional K L := Module.Finite_of_isLocalization A B _ _ Aâ°
  have : IsIntegralClosure Bâ‚˜ Aâ‚˜ L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  apply IsFractionRing.injective Aâ‚˜ K
  rw [â† IsScalarTower.algebraMap_apply, Algebra.algebraMap_intTrace_fractionRing,
    Algebra.algebraMap_intTrace (L := L), â† IsScalarTower.algebraMap_apply]"
Mathlib/Analysis/MeanInequalities.lean,Real.Lp_add_le_tsum_of_nonneg,Lp_add_le_tsum_of_nonneg,aaa40f08731a6680bdee636aa290c8d59c9968c4,":= by
  lift f to Î¹ â†’ â„â‰¥0 using hf
  lift g to Î¹ â†’ â„â‰¥0 using hg","error:  unsolved goals
case intro.intro
Î¹ : Type u
s : Finset Î¹
p q : â„
hp : 1 â‰¤ p
f : Î¹ â†’ â„â‰¥0
hf_sum : Summable fun i â†¦ (fun i â†¦ â†‘(f i)) i ^ p
g : Î¹ â†’ â„â‰¥0
hg_sum : Summable fun i â†¦ (fun i â†¦ â†‘(g i)) i ^ p
âŠ¢ (Summable fun i â†¦ ((fun i â†¦ â†‘(f i)) i + (fun i â†¦ â†‘(g i)) i) ^ p) âˆ§
    (âˆ‘' (i : Î¹), ((fun i â†¦ â†‘(f i)) i + (fun i â†¦ â†‘(g i)) i) ^ p) ^ (1 / p) â‰¤
      (âˆ‘' (i : Î¹), (fun i â†¦ â†‘(f i)) i ^ p) ^ (1 / p) + (âˆ‘' (i : Î¹), (fun i â†¦ â†‘(g i)) i ^ p) ^ (1 / p)","theorem Lp_add_le_tsum_of_nonneg (hp : 1 â‰¤ p) (hf : âˆ€ i, 0 â‰¤ f i) (hg : âˆ€ i, 0 â‰¤ g i)
    (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ p) :
    (Summable fun i => (f i + g i) ^ p) âˆ§
      (âˆ‘' i, (f i + g i) ^ p) ^ (1 / p) â‰¤
        (âˆ‘' i, f i ^ p) ^ (1 / p) + (âˆ‘' i, g i ^ p) ^ (1 / p) ",":= by
  lift f to Î¹ â†’ â„â‰¥0 using hf
  lift g to Î¹ â†’ â„â‰¥0 using hg
  beta_reduce at *
  norm_cast0 at *
  exact NNReal.Lp_add_le_tsum hp hf_sum hg_sum"
Mathlib/Data/Fin/Basic.lean,Fin.succ_ne_last_of_lt,succ_ne_last_of_lt,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  cases n
  Â· exact i.elim0
  Â· rw [succ_ne_last_iff]
    exact ((le_last _).trans_lt' h).ne","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Fin.val_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  failed to synthesize
  Preorder (Fin (nâœ + 1))
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  Preorder (Fin (nâœ + 1))
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  LE.le.trans_lt' ?m.34716 h
argument
  h
has type
  @LT.lt (Fin (nâœ + 1)) instLTFin i p : Prop
but is expected to have type
  @LT.lt (Fin (nâœ + 1)) Preorder.toLT i p : Prop",theorem succ_ne_last_of_lt {p i : Fin n} (h : i < p) : succ i â‰  last n ,":= by
  cases n
  Â· exact i.elim0
  Â· rw [succ_ne_last_iff, Ne, ext_iff]
    exact ((le_last _).trans_lt' h).ne"
Mathlib/Topology/Algebra/Order/Field.lean,tendsto_pow_neg_atTop,tendsto_pow_neg_atTop,105a48d42f84ef02d78acca07b3565aa1b78ec83,":= by
  simpa only [zpow_neg, zpow_natCast] using (@tendsto_pow_atTop ğ•œ _ _ _ hn).inv_tendsto_atTop","error:  application type mismatch
  @tendsto_pow_atTop ğ•œ ?m.32369 ?m.32370 ?m.32371 hn
argument
  hn
has type
  n â‰  0 : Prop
but is expected to have type
  Set ğ•œ : Type u_1","theorem tendsto_pow_neg_atTop {n : â„•} (hn : n â‰  0) :
    Tendsto (fun x : ğ•œ => x ^ (-(n : â„¤))) atTop (ğ“ 0) ",":= by
  simpa only [zpow_neg, zpow_natCast] using (@tendsto_pow_atTop ğ•œ _ _ hn).inv_tendsto_atTop"
Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean,AlgebraicTopology.AlternatingFaceMapComplex.d_squared,d_squared,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff, Fin.val_succ,
      Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa using hij
  Â· 
    rintro âŸ¨i, jâŸ© âŸ¨i', j'âŸ© hij hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine' âŸ¨(j'.pred <| Fin.vne_of_ne (j := 0) _, Fin.castSucc i'), _, _âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_pred_of_lt hij'
    Â· simp only [Fin.castLT_castSucc, Fin.succ_pred]","error:  simp made no progress
error:  simp made no progress
error:  rcases tactic failed: aâœ : Quot.lift (fun l â†¦ (i, j) âˆˆ l) â‹¯ Sá¶œ.val is not an inductive datatype
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #3 provided
error:  no goals to be solved",theorem d_squared (n : â„•) : objD X (n + 1) â‰« objD X n = 0 ,":= by
  dsimp
  simp only [comp_sum, sum_comp, â† Finset.sum_product']
  let P := Fin (n + 2) Ã— Fin (n + 3)
  let S := Finset.univ.filter fun ij : P => (ij.2 : â„•) â‰¤ (ij.1 : â„•)
  erw [â† Finset.sum_add_sum_compl S, â† eq_neg_iff_add_eq_zero, â† Finset.sum_neg_distrib]
  let Ï† : âˆ€ ij : P, ij âˆˆ S â†’ P := fun ij hij =>
    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)
  apply Finset.sum_bij Ï†
  Â· 
    intro ij hij
    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,
      Fin.val_succ, Fin.coe_castLT] at hij âŠ¢
    linarith
  Â· 
    rintro âŸ¨i, jâŸ© hij âŸ¨i', j'âŸ© hij' h
    rw [Prod.mk.inj_iff]
    exact âŸ¨by simpa using congr_arg Prod.snd h,
      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)âŸ©
  Â· 
    rintro âŸ¨i', j'âŸ© hij'
    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,
      not_le, Finset.mem_filter, true_and] at hij'
    refine âŸ¨(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_âŸ©
    Â· rintro rfl
      simp only [Fin.val_zero, not_lt_zero'] at hij'
    Â· simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,
        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'
    Â· simp only [Ï†, Fin.castLT_castSucc, Fin.succ_pred]
  Â· 
    rintro âŸ¨i, jâŸ© hij
    dsimp
    simp only [zsmul_comp, comp_zsmul, smul_smul, â† neg_smul]
    congr 1
    Â· simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]
      apply mul_comm
    Â· rw [CategoryTheory.SimplicialObject.Î´_comp_Î´'']
      simpa [S] using hij"
Mathlib/MeasureTheory/Decomposition/Lebesgue.lean,MeasureTheory.Measure.exists_positive_of_not_mutuallySingular,exists_positive_of_not_mutuallySingular,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  have :
    âˆ€ n : â„•, âˆƒ i : Set Î±,
      MeasurableSet i âˆ§
        0 â‰¤[i] Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure âˆ§
          Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure â‰¤[iá¶œ] 0 := by
    intro; exact exists_compl_positive_negative _
  choose f hfâ‚ hfâ‚‚ hfâ‚ƒ using this
  set A := â‹‚ n, (f n)á¶œ with hAâ‚
  have hAmeas : MeasurableSet A := MeasurableSet.iInter fun n => (hfâ‚ n).compl
  have hAâ‚‚ : âˆ€ n : â„•, Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure â‰¤[A] 0 := by
    intro n; exact restrict_le_restrict_subset _ _ (hfâ‚ n).compl (hfâ‚ƒ n) (iInter_subset _ _)
  have hAâ‚ƒ : âˆ€ n : â„•, Î¼ A â‰¤ (1 / (n + 1) : â„â‰¥0) * Î½ A := by
    intro n
    have := nonpos_of_restrict_le_zero _ (hAâ‚‚ n)
    rwa [toSignedMeasure_sub_apply hAmeas, sub_nonpos, ENNReal.toReal_le_toReal] at this
    exacts [ne_of_lt (measure_lt_top _ _), ne_of_lt (measure_lt_top _ _)]
  have hÎ¼ : Î¼ A = 0 := by
    lift Î¼ A to â„â‰¥0 using ne_of_lt (measure_lt_top _ _) with Î¼A
    lift Î½ A to â„â‰¥0 using ne_of_lt (measure_lt_top _ _) with Î½A
    rw [ENNReal.coe_eq_zero]
    by_cases hb : 0 < Î½A
    Â· suffices âˆ€ b, 0 < b â†’ Î¼A â‰¤ b by
        by_contra h
        have h' := this (Î¼A / 2) (half_pos (zero_lt_iff.2 h))
        rw [â† @Classical.not_not (Î¼A â‰¤ Î¼A / 2)] at h'
        exact h' (not_le.2 (NNReal.half_lt_self h))
      intro c hc
      have : âˆƒ n : â„•, 1 / (n + 1 : â„) < c * (Î½A : â„)â»Â¹; refine' exists_nat_one_div_lt _
      Â· refine' mul_pos hc _
        rw [_root_.inv_pos]; exact hb
      rcases this with âŸ¨n, hnâŸ©
      have hbâ‚ : (0 : â„) < (Î½A : â„)â»Â¹ := by rw [_root_.inv_pos]; exact hb
      have h' : 1 / (â†‘n + 1) * Î½A < c := by
        rw [â† NNReal.coe_lt_coe, â† mul_lt_mul_right hbâ‚, NNReal.coe_mul, mul_assoc, â†
          NNReal.coe_inv, â† NNReal.coe_mul, _root_.mul_inv_cancel, â† NNReal.coe_mul, mul_one,
          NNReal.coe_inv]
        Â· exact hn
        Â· exact Ne.symm (ne_of_lt hb)
      refine' le_trans _ (le_of_lt h')
      rw [â† ENNReal.coe_le_coe, ENNReal.coe_mul]
      exact hAâ‚ƒ n
    Â· rw [not_lt, le_zero_iff] at hb
      specialize hAâ‚ƒ 0
      simp? [hb, le_zero_iff] at hAâ‚ƒ says
        simp only [CharP.cast_eq_zero, zero_add, ne_eq, one_ne_zero, not_false_eq_true, div_self,
          ENNReal.coe_one, hb, ENNReal.coe_zero, mul_zero, nonpos_iff_eq_zero,
          ENNReal.coe_eq_zero] at hAâ‚ƒ
      assumption
  rw [MutuallySingular] at h; push_neg at h
  have := h _ hAmeas hÎ¼
  simp_rw [compl_iInter, compl_compl] at this
  obtain âŸ¨n, hnâŸ© := exists_measure_pos_of_not_measure_iUnion_null this
  exact âŸ¨1 / (n + 1), by simp, f n, hfâ‚ n, hn, hfâ‚‚ nâŸ©","error:  unexpected token ';'; expected '|'
error:  unsolved goals
case pos
Î± : Type u_1
Î² : Type u_2
m : MeasurableSpace Î±
Î¼âœ Î½âœ Î¼ Î½ : Measure Î±
instâœÂ¹ : IsFiniteMeasure Î¼
instâœ : IsFiniteMeasure Î½
h : Â¬Î¼ âŸ‚â‚˜ Î½
f : â„• â†’ Set Î±
hfâ‚ : âˆ€ (n : â„•), MeasurableSet (f n)
hfâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict 0 (f n) â‰¤
      VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)
hfâ‚ƒ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)á¶œ â‰¤
      VectorMeasure.restrict 0 (f n)á¶œ
A : Set Î± := â‹‚ n, (f n)á¶œ
hAmeas : MeasurableSet A
hAâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) A â‰¤ VectorMeasure.restrict 0 A
Î¼A : â„â‰¥0
hAâ‚âœ hAâ‚ : True
hAâ‚ƒâœÂ¹ : âˆ€ (n : â„•), â†‘Î¼A â‰¤ â†‘(1 / (â†‘n + 1)) * Î½ A
Î½A : â„â‰¥0
hAâ‚ƒâœ hAâ‚ƒ : âˆ€ (n : â„•), â†‘Î¼A â‰¤ â†‘(1 / (â†‘n + 1)) * â†‘Î½A
hb : 0 < Î½A
c : â„â‰¥0
hc : 0 < c
this : âˆƒ n, 1 / (â†‘n + 1) < â†‘c * (â†‘Î½A)â»Â¹
âŠ¢ Î¼A â‰¤ c
error:  unsolved goals
case neg
Î± : Type u_1
Î² : Type u_2
m : MeasurableSpace Î±
Î¼âœ Î½âœ Î¼ Î½ : Measure Î±
instâœÂ¹ : IsFiniteMeasure Î¼
instâœ : IsFiniteMeasure Î½
h : Â¬Î¼ âŸ‚â‚˜ Î½
f : â„• â†’ Set Î±
hfâ‚ : âˆ€ (n : â„•), MeasurableSet (f n)
hfâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict 0 (f n) â‰¤
      VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)
hfâ‚ƒ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)á¶œ â‰¤
      VectorMeasure.restrict 0 (f n)á¶œ
A : Set Î± := â‹‚ n, (f n)á¶œ
hAmeas : MeasurableSet A
hAâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) A â‰¤ VectorMeasure.restrict 0 A
Î¼A : â„â‰¥0
hAâ‚âœ hAâ‚ : True
hAâ‚ƒâœÂ¹ : âˆ€ (n : â„•), â†‘Î¼A â‰¤ â†‘(1 / (â†‘n + 1)) * Î½ A
Î½A : â„â‰¥0
hAâ‚ƒâœ hAâ‚ƒ : âˆ€ (n : â„•), â†‘Î¼A â‰¤ â†‘(1 / (â†‘n + 1)) * â†‘Î½A
hb : Â¬0 < Î½A
âŠ¢ Î¼A = 0
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
m : MeasurableSpace Î±
Î¼âœ Î½âœ Î¼ Î½ : Measure Î±
instâœÂ¹ : IsFiniteMeasure Î¼
instâœ : IsFiniteMeasure Î½
h : Â¬Î¼ âŸ‚â‚˜ Î½
f : â„• â†’ Set Î±
hfâ‚ : âˆ€ (n : â„•), MeasurableSet (f n)
hfâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict 0 (f n) â‰¤
      VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)
hfâ‚ƒ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)á¶œ â‰¤
      VectorMeasure.restrict 0 (f n)á¶œ
A : Set Î± := â‹‚ n, (f n)á¶œ
hAâ‚ : A = â‹‚ n, (f n)á¶œ
hAmeas : MeasurableSet A
hAâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) A â‰¤ VectorMeasure.restrict 0 A
hAâ‚ƒ : âˆ€ (n : â„•), Î¼ A â‰¤ â†‘(1 / (â†‘n + 1)) * Î½ A
hÎ¼ : Î¼ A = 0
âŠ¢ âˆƒ Îµ,
    0 < Îµ âˆ§
      âˆƒ E,
        MeasurableSet E âˆ§
          0 < Î½ E âˆ§ VectorMeasure.restrict 0 E â‰¤ VectorMeasure.restrict (Î¼.toSignedMeasure - (Îµ â€¢ Î½).toSignedMeasure) E","theorem exists_positive_of_not_mutuallySingular (Î¼ Î½ : Measure Î±) [IsFiniteMeasure Î¼]
    [IsFiniteMeasure Î½] (h : Â¬Î¼ âŸ‚â‚˜ Î½) :
    âˆƒ Îµ : â„â‰¥0, 0 < Îµ âˆ§
      âˆƒ E : Set Î±,
        MeasurableSet E âˆ§ 0 < Î½ E âˆ§ 0 â‰¤[E] Î¼.toSignedMeasure - (Îµ â€¢ Î½).toSignedMeasure ",":= by
  have :
    âˆ€ n : â„•, âˆƒ i : Set Î±,
      MeasurableSet i âˆ§
        0 â‰¤[i] Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure âˆ§
          Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure â‰¤[iá¶œ] 0 := by
    intro; exact exists_compl_positive_negative _
  choose f hfâ‚ hfâ‚‚ hfâ‚ƒ using this
  let A := â‹‚ n, (f n)á¶œ
  have hAmeas : MeasurableSet A := MeasurableSet.iInter fun n â†¦ (hfâ‚ n).compl
  have hAâ‚‚ : âˆ€ n : â„•, Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure â‰¤[A] 0 := by
    intro n; exact restrict_le_restrict_subset _ _ (hfâ‚ n).compl (hfâ‚ƒ n) (iInter_subset _ _)
  have hAâ‚ƒ : âˆ€ n : â„•, Î¼ A â‰¤ (1 / (n + 1) : â„â‰¥0) * Î½ A := by
    intro n
    have := nonpos_of_restrict_le_zero _ (hAâ‚‚ n)
    rwa [toSignedMeasure_sub_apply hAmeas, sub_nonpos, ENNReal.toReal_le_toReal] at this
    exacts [measure_ne_top _ _, measure_ne_top _ _]
  have hÎ¼ : Î¼ A = 0 := by
    lift Î¼ A to â„â‰¥0 using measure_ne_top _ _ with Î¼A
    lift Î½ A to â„â‰¥0 using measure_ne_top _ _ with Î½A
    rw [ENNReal.coe_eq_zero]
    by_cases hb : 0 < Î½A
    Â· suffices âˆ€ b, 0 < b â†’ Î¼A â‰¤ b by
        by_contra h
        have h' := this (Î¼A / 2) (half_pos (zero_lt_iff.2 h))
        rw [â† @Classical.not_not (Î¼A â‰¤ Î¼A / 2)] at h'
        exact h' (not_le.2 (NNReal.half_lt_self h))
      intro c hc
      have : âˆƒ n : â„•, 1 / (n + 1 : â„) < c * (Î½A : â„)â»Â¹ := by
        refine exists_nat_one_div_lt ?_
        positivity
      rcases this with âŸ¨n, hnâŸ©
      have hbâ‚ : (0 : â„) < (Î½A : â„)â»Â¹ := by rw [_root_.inv_pos]; exact hb
      have h' : 1 / (â†‘n + 1) * Î½A < c := by
        rw [â† NNReal.coe_lt_coe, â† mul_lt_mul_right hbâ‚, NNReal.coe_mul, mul_assoc, â†
          NNReal.coe_inv, â† NNReal.coe_mul, _root_.mul_inv_cancel, â† NNReal.coe_mul, mul_one,
          NNReal.coe_inv]
        Â· exact hn
        Â· exact hb.ne'
      refine le_trans ?_ h'.le
      rw [â† ENNReal.coe_le_coe, ENNReal.coe_mul]
      exact hAâ‚ƒ n
    Â· rw [not_lt, le_zero_iff] at hb
      specialize hAâ‚ƒ 0
      simp? [hb] at hAâ‚ƒ says
        simp only [CharP.cast_eq_zero, zero_add, ne_eq, one_ne_zero, not_false_eq_true, div_self,
          ENNReal.coe_one, hb, ENNReal.coe_zero, mul_zero, nonpos_iff_eq_zero,
          ENNReal.coe_eq_zero] at hAâ‚ƒ
      assumption
  rw [MutuallySingular] at h; push_neg at h
  have := h _ hAmeas hÎ¼
  simp_rw [A, compl_iInter, compl_compl] at this
  obtain âŸ¨n, hnâŸ© := exists_measure_pos_of_not_measure_iUnion_null this
  exact âŸ¨1 / (n + 1), by simp, f n, hfâ‚ n, hn, hfâ‚‚ nâŸ©"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.ae_tendsto_div,ae_tendsto_div,611a64b31f2f9df551954217d12578133430d2b6,":= by
  obtain âŸ¨w, w_count, w_dense, _, w_topâŸ© :
    âˆƒ w : Set â„â‰¥0âˆ, w.Countable âˆ§ Dense w âˆ§ 0 âˆ‰ w âˆ§ âˆ âˆ‰ w :=
    ENNReal.exists_countable_dense_no_zero_top
  have I : âˆ€ x âˆˆ w, x â‰  âˆ := fun x xs hx => w_top (hx â–¸ xs)
  have A : âˆ€ c âˆˆ w, âˆ€ d âˆˆ w, c < d â†’ âˆ€áµ x âˆ‚Î¼,
      Â¬((âˆƒá¶  a in v.filterAt x, Ï a / Î¼ a < c) âˆ§ âˆƒá¶  a in v.filterAt x, d < Ï a / Î¼ a) := by
    intro c hc d hd hcd
    lift c to â„â‰¥0 using I c hc
    lift d to â„â‰¥0 using I d hd
    apply v.null_of_frequently_le_of_frequently_ge hÏ (ENNReal.coe_lt_coe.1 hcd)
    Â· simp only [and_imp, exists_prop, not_frequently, not_and, not_lt, not_le, not_eventually,
        mem_setOf_eq, mem_compl_iff, not_forall]
      intro x h1x _
      apply h1x.mono fun a ha => ?_
      refine' (ENNReal.div_le_iff_le_mul _ (Or.inr (bot_le.trans_lt ha).ne')).1 ha.le
      simp only [ENNReal.coe_ne_top, Ne.def, or_true_iff, not_false_iff]
    Â· simp only [and_imp, exists_prop, not_frequently, not_and, not_lt, not_le, not_eventually,
        mem_setOf_eq, mem_compl_iff, not_forall]
      intro x _ h2x
      apply h2x.mono fun a ha => ?_
      exact ENNReal.mul_le_of_le_div ha.le
  have B : âˆ€áµ x âˆ‚Î¼, âˆ€ c âˆˆ w, âˆ€ d âˆˆ w, c < d â†’
      Â¬((âˆƒá¶  a in v.filterAt x, Ï a / Î¼ a < c) âˆ§ âˆƒá¶  a in v.filterAt x, d < Ï a / Î¼ a) := by
    simpa only [ae_ball_iff w_count, ae_all_iff]
  filter_upwards [B]
  intro x hx
  exact tendsto_of_no_upcrossings w_dense hx","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.63102 â†’ ?m.63102 â†’ Prop
error:  simp made no progress
error:  tactic 'assumption' failed
Î± : Type u_1
instâœâµ : MetricSpace Î±
m0 : MeasurableSpace Î±
Î¼ : Measure Î±
v : VitaliFamily Î¼
E : Type u_2
instâœâ´ : NormedAddCommGroup E
instâœÂ³ : SecondCountableTopology Î±
instâœÂ² : BorelSpace Î±
instâœÂ¹ : IsLocallyFiniteMeasure Î¼
Ï : Measure Î±
instâœ : IsLocallyFiniteMeasure Ï
hÏ : Ï â‰ª Î¼
w : Set â„â‰¥0âˆ
w_count : w.Countable
w_dense : Dense w
leftâœ : 0 âˆ‰ w
w_top : âŠ¤ âˆ‰ w
I : âˆ€ x âˆˆ w, x â‰  âŠ¤
A :
  âˆ€ c âˆˆ w,
    âˆ€ d âˆˆ w,
      c < d â†’
        âˆ€áµ (x : Î±) âˆ‚Î¼,
          Â¬((âˆƒá¶  (a : Set Î±) in v.filterAt x, Ï a / Î¼ a < c) âˆ§ âˆƒá¶  (a : Set Î±) in v.filterAt x, d < Ï a / Î¼ a)
âŠ¢ âˆ€áµ (x : Î±) âˆ‚Î¼,
    âˆ€ c âˆˆ w,
      âˆ€ d âˆˆ w,
        c < d â†’ Â¬((âˆƒá¶  (a : Set Î±) in v.filterAt x, Ï a / Î¼ a < c) âˆ§ âˆƒá¶  (a : Set Î±) in v.filterAt x, d < Ï a / Î¼ a)","theorem ae_tendsto_div : âˆ€áµ x âˆ‚Î¼, âˆƒ c, Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ c) ",":= by
  obtain âŸ¨w, w_count, w_dense, _, w_topâŸ© :
    âˆƒ w : Set â„â‰¥0âˆ, w.Countable âˆ§ Dense w âˆ§ 0 âˆ‰ w âˆ§ âˆ âˆ‰ w :=
    ENNReal.exists_countable_dense_no_zero_top
  have I : âˆ€ x âˆˆ w, x â‰  âˆ := fun x xs hx => w_top (hx â–¸ xs)
  have A : âˆ€ c âˆˆ w, âˆ€ d âˆˆ w, c < d â†’ âˆ€áµ x âˆ‚Î¼,
      Â¬((âˆƒá¶  a in v.filterAt x, Ï a / Î¼ a < c) âˆ§ âˆƒá¶  a in v.filterAt x, d < Ï a / Î¼ a) := by
    intro c hc d hd hcd
    lift c to â„â‰¥0 using I c hc
    lift d to â„â‰¥0 using I d hd
    apply v.null_of_frequently_le_of_frequently_ge hÏ (ENNReal.coe_lt_coe.1 hcd)
    Â· simp only [and_imp, exists_prop, not_frequently, not_and, not_lt, not_le, not_eventually,
        mem_setOf_eq, mem_compl_iff, not_forall]
      intro x h1x _
      apply h1x.mono fun a ha => ?_
      refine (ENNReal.div_le_iff_le_mul ?_ (Or.inr (bot_le.trans_lt ha).ne')).1 ha.le
      simp only [ENNReal.coe_ne_top, Ne, or_true_iff, not_false_iff]
    Â· simp only [and_imp, exists_prop, not_frequently, not_and, not_lt, not_le, not_eventually,
        mem_setOf_eq, mem_compl_iff, not_forall]
      intro x _ h2x
      apply h2x.mono fun a ha => ?_
      exact ENNReal.mul_le_of_le_div ha.le
  have B : âˆ€áµ x âˆ‚Î¼, âˆ€ c âˆˆ w, âˆ€ d âˆˆ w, c < d â†’
      Â¬((âˆƒá¶  a in v.filterAt x, Ï a / Î¼ a < c) âˆ§ âˆƒá¶  a in v.filterAt x, d < Ï a / Î¼ a) := by
    rw [ae_ball_iff w_count]; intro x hx; rw [ae_ball_iff w_count]; revert x
    simpa only [ae_all_iff]
  filter_upwards [B]
  intro x hx
  exact tendsto_of_no_upcrossings w_dense hx"
Mathlib/Analysis/Convex/Mul.lean,ConvexOn.pow,ConvexOn.pow,b0772359d09d1bb8ac5abff43f4728c85dc365ea,"  | 0 => by simpa using convexOn_const 1 hf.1
  | n + 1 => by rw [pow_succ]; exact hf.mul (hf.pow hfâ‚€ _) hfâ‚€ (fun x hx â†¦ pow_nonneg (hfâ‚€ hx) _) <|
      (monovaryOn_self f s).pow_rightâ‚€ hfâ‚€ n","error:  type mismatch
  mul hf (pow hf hfâ‚€ n) hfâ‚€ (fun x hx â†¦ pow_nonneg (hfâ‚€ hx) n) (MonovaryOn.pow_rightâ‚€ hfâ‚€ (monovaryOn_self f s) n)
has type
  ConvexOn ğ•œ s (f * f ^ n) : Prop
but is expected to have type
  ConvexOn ğ•œ s (f ^ n * f) : Prop","lemma ConvexOn.pow (hf : ConvexOn ğ•œ s f) (hfâ‚€ : âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ 0 â‰¤ f x) :
    âˆ€ n, ConvexOn ğ•œ s (f ^ n)
","  | 0 => by simpa using convexOn_const 1 hf.1
  | n + 1 => by
    rw [pow_succ']
    exact hf.mul (hf.pow hfâ‚€ _) hfâ‚€ (fun x hx â†¦ pow_nonneg (hfâ‚€ hx) _) <|
      (monovaryOn_self f s).pow_rightâ‚€ hfâ‚€ n"
Mathlib/RingTheory/PowerSeries/Basic.lean,PowerSeries.coeff_zero_eq_constantCoeff_apply,coeff_zero_eq_constantCoeff_apply,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":=
  rfl","error:  type mismatch
  rfl
has type
  (coeff R 0) Ï† = (coeff R 0) Ï† : Prop
but is expected to have type
  (coeff R 0) Ï† = (constantCoeff R) Ï† : Prop
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated",theorem coeff_zero_eq_constantCoeff_apply (Ï† : RâŸ¦XâŸ§) : coeff R 0 Ï† = constantCoeff R Ï† ,":= by
  rw [coeff_zero_eq_constantCoeff]"
Mathlib/Data/Fintype/Card.lean,Finite.exists_ne_map_eq_of_infinite,Finite.exists_ne_map_eq_of_infinite,8304f3cd201c027ef023bc166da7f4c8fce94eed,":= by
  simpa only [Injective, not_forall, Classical.not_imp, and_comm] using
    not_injective_infinite_finite f","error:  type mismatch
  hâœ
has type
  âˆƒ x x_1, âˆƒ (_ : f x = f x_1), Â¬x = x_1 : Prop
but is expected to have type
  âˆƒ x y, f x = f y âˆ§ x â‰  y : Prop","theorem Finite.exists_ne_map_eq_of_infinite {Î± Î²} [Infinite Î±] [Finite Î²] (f : Î± â†’ Î²) :
    âˆƒ x y : Î±, x â‰  y âˆ§ f x = f y ",":= by
  simpa [Injective, and_comm] using not_injective_infinite_finite f"
Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean,Real.lt_tan,lt_tan,26dcb0a78bda63252389cd8290cafcd2d953c437,":= by
  let U := Ico 0 (Ï€ / 2)
  have intU : interior U = Ioo 0 (Ï€ / 2) := interior_Ico
  have half_pi_pos : 0 < Ï€ / 2 := div_pos pi_pos two_pos
  have cos_pos : âˆ€ {y : â„}, y âˆˆ U â†’ 0 < cos y := by
    intro y hy
    exact cos_pos_of_mem_Ioo (Ico_subset_Ioo_left (neg_lt_zero.mpr half_pi_pos) hy)
  have sin_pos : âˆ€ {y : â„}, y âˆˆ interior U â†’ 0 < sin y := by
    intro y hy
    rw [intU] at hy
    exact sin_pos_of_mem_Ioo (Ioo_subset_Ioo_right (div_le_self pi_pos.le one_le_two) hy)
  have tan_cts_U : ContinuousOn tan U := by
    apply ContinuousOn.mono continuousOn_tan
    intro z hz
    simp only [mem_setOf_eq]
    exact (cos_pos hz).ne'
  have tan_minus_id_cts : ContinuousOn (fun y : â„ => tan y - y) U := tan_cts_U.sub continuousOn_id
  have deriv_pos : âˆ€ y : â„, y âˆˆ interior U â†’ 0 < deriv (fun y' : â„ => tan y' - y') y := by
    intro y hy
    have := cos_pos (interior_subset hy)
    simp only [deriv_tan_sub_id y this.ne', one_div, gt_iff_lt, sub_pos]
    norm_cast
    have bd2 : cos y ^ 2 < 1 := by
      apply lt_of_le_of_ne y.cos_sq_le_one
      rw [cos_sq']
      simpa only [Ne.def, sub_eq_self, sq_eq_zero_iff] using (sin_pos hy).ne'
    rwa [lt_inv, inv_one]
    Â· exact zero_lt_one
    simpa only [sq, mul_self_pos] using this.ne'
  have mono := Convex.strictMonoOn_of_deriv_pos (convex_Ico 0 (Ï€ / 2)) tan_minus_id_cts deriv_pos
  have zero_in_U : (0 : â„) âˆˆ U := by rwa [left_mem_Ico]
  have x_in_U : x âˆˆ U := âŸ¨h1.le, h2âŸ©
  simpa only [tan_zero, sub_zero, sub_pos] using mono zero_in_U x_in_U h1","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.137779 â†’ ?m.137779 â†’ Prop
error:  type mismatch
  hâœ
has type
  sin y â‰  0 : Prop
but is expected to have type
  1 - sin y ^ 2 â‰  1 : Prop
error:  unknown constant 'Convex.strictMonoOn_of_deriv_pos'
error:  unsolved goals
xâœ x : â„
h1 : 0 < x
h2 : x < Ï€ / 2
U : Set â„ := Ico 0 (Ï€ / 2)
intU : interior U = Ioo 0 (Ï€ / 2)
half_pi_pos : 0 < Ï€ / 2
cos_pos : âˆ€ {y : â„}, y âˆˆ U â†’ 0 < cos y
sin_pos : âˆ€ {y : â„}, y âˆˆ interior U â†’ 0 < sin y
tan_cts_U : ContinuousOn tan U
tan_minus_id_cts : ContinuousOn (fun y â†¦ tan y - y) U
deriv_pos : âˆ€ y âˆˆ interior U, 0 < deriv (fun y' â†¦ tan y' - y') y
âŠ¢ x < tan x",theorem lt_tan {x : â„} (h1 : 0 < x) (h2 : x < Ï€ / 2) : x < tan x ,":= by
  let U := Ico 0 (Ï€ / 2)
  have intU : interior U = Ioo 0 (Ï€ / 2) := interior_Ico
  have half_pi_pos : 0 < Ï€ / 2 := div_pos pi_pos two_pos
  have cos_pos : âˆ€ {y : â„}, y âˆˆ U â†’ 0 < cos y := by
    intro y hy
    exact cos_pos_of_mem_Ioo (Ico_subset_Ioo_left (neg_lt_zero.mpr half_pi_pos) hy)
  have sin_pos : âˆ€ {y : â„}, y âˆˆ interior U â†’ 0 < sin y := by
    intro y hy
    rw [intU] at hy
    exact sin_pos_of_mem_Ioo (Ioo_subset_Ioo_right (div_le_self pi_pos.le one_le_two) hy)
  have tan_cts_U : ContinuousOn tan U := by
    apply ContinuousOn.mono continuousOn_tan
    intro z hz
    simp only [mem_setOf_eq]
    exact (cos_pos hz).ne'
  have tan_minus_id_cts : ContinuousOn (fun y : â„ => tan y - y) U := tan_cts_U.sub continuousOn_id
  have deriv_pos : âˆ€ y : â„, y âˆˆ interior U â†’ 0 < deriv (fun y' : â„ => tan y' - y') y := by
    intro y hy
    have := cos_pos (interior_subset hy)
    simp only [deriv_tan_sub_id y this.ne', one_div, gt_iff_lt, sub_pos]
    norm_cast
    have bd2 : cos y ^ 2 < 1 := by
      apply lt_of_le_of_ne y.cos_sq_le_one
      rw [cos_sq']
      simpa only [Ne, sub_eq_self, sq_eq_zero_iff] using (sin_pos hy).ne'
    rwa [lt_inv, inv_one]
    Â· exact zero_lt_one
    simpa only [sq, mul_self_pos] using this.ne'
  have mono := strictMonoOn_of_deriv_pos (convex_Ico 0 (Ï€ / 2)) tan_minus_id_cts deriv_pos
  have zero_in_U : (0 : â„) âˆˆ U := by rwa [left_mem_Ico]
  have x_in_U : x âˆˆ U := âŸ¨h1.le, h2âŸ©
  simpa only [tan_zero, sub_zero, sub_pos] using mono zero_in_U x_in_U h1"
Mathlib/Analysis/BoundedVariation.lean,eVariationOn.Icc_add_Icc,Icc_add_Icc,1b56b750c6e5f5c04c16ef8e259d5a73b1ccc493,":= by
  have A : IsGreatest (s âˆ© Icc a b) b :=
    âŸ¨âŸ¨hb, hab, le_rflâŸ©, (inter_subset_right _ _).trans Icc_subset_Iic_selfâŸ©
  have B : IsLeast (s âˆ© Icc b c) b :=
    âŸ¨âŸ¨hb, le_rfl, hbcâŸ©, (inter_subset_right _ _).trans Icc_subset_Ici_selfâŸ©
  rw [â† eVariationOn.union f A B, â† inter_union_distrib_left, Icc_union_Icc_eq_Icc hab hbc]","error:  function expected at
  inter_subset_right ?m.142179
term has type
  ?m.142178 âˆˆ ?m.142177
error:  function expected at
  inter_subset_right ?m.142538
term has type
  ?m.142537 âˆˆ ?m.142536","theorem Icc_add_Icc (f : Î± â†’ E) {s : Set Î±} {a b c : Î±} (hab : a â‰¤ b) (hbc : b â‰¤ c) (hb : b âˆˆ s) :
    eVariationOn f (s âˆ© Icc a b) + eVariationOn f (s âˆ© Icc b c) = eVariationOn f (s âˆ© Icc a c) ",":= by
  have A : IsGreatest (s âˆ© Icc a b) b :=
    âŸ¨âŸ¨hb, hab, le_rflâŸ©, inter_subset_right.trans Icc_subset_Iic_selfâŸ©
  have B : IsLeast (s âˆ© Icc b c) b :=
    âŸ¨âŸ¨hb, le_rfl, hbcâŸ©, inter_subset_right.trans Icc_subset_Ici_selfâŸ©
  rw [â† eVariationOn.union f A B, â† inter_union_distrib_left, Icc_union_Icc_eq_Icc hab hbc]"
Mathlib/NumberTheory/Padics/PadicNorm.lean,padicNorm.int_eq_one_iff,int_eq_one_iff,c47ebbbece0d449dca95c589513159cdc2bab40d,":= by
  nth_rw 2 [â† pow_one p]
  simp only [dvd_iff_norm_le, Int.cast_ofNat, Nat.cast_one, zpow_neg, zpow_one, not_le]
  constructor
  Â· intro h
    rw [h, inv_lt_one_iff_of_pos] <;> norm_cast
    Â· exact Nat.Prime.one_lt Fact.out
    Â· exact Nat.Prime.pos Fact.out
  Â· simp only [padicNorm]
    split_ifs
    Â· rw [inv_lt_zero, â† Nat.cast_zero, Nat.cast_lt]
      intro h
      exact (Nat.not_lt_zero p h).elim
    Â· have : 1 < (p : â„š) := by norm_cast; exact Nat.Prime.one_lt (Fact.out : Nat.Prime p)
      rw [â† zpow_neg_one, zpow_lt_iff_lt this]
      have : 0 â‰¤ padicValRat p m
      simp only [of_int, Nat.cast_nonneg]
      intro h
      rw [â† zpow_zero (p : â„š), zpow_inj] <;> linarith","error:  unexpected identifier; expected '|'
error:  unsolved goals
case neg
p : â„•
hp : Fact (Nat.Prime p)
m : â„¤
hâœ : Â¬â†‘m = 0
thisâœ : 1 < â†‘p
this : 0 â‰¤ padicValRat p â†‘m
âŠ¢ -1 < -padicValRat p â†‘m â†’ â†‘p ^ (-padicValRat p â†‘m) = 1",theorem int_eq_one_iff (m : â„¤) : padicNorm p m = 1 â†” Â¬(p : â„¤) âˆ£ m ,":= by
  nth_rw 2 [â† pow_one p]
  simp only [dvd_iff_norm_le, Int.cast_natCast, Nat.cast_one, zpow_neg, zpow_one, not_le]
  constructor
  Â· intro h
    rw [h, inv_lt_one_iff_of_pos] <;> norm_cast
    Â· exact Nat.Prime.one_lt Fact.out
    Â· exact Nat.Prime.pos Fact.out
  Â· simp only [padicNorm]
    split_ifs
    Â· rw [inv_lt_zero, â† Nat.cast_zero, Nat.cast_lt]
      intro h
      exact (Nat.not_lt_zero p h).elim
    Â· have : 1 < (p : â„š) := by norm_cast; exact Nat.Prime.one_lt (Fact.out : Nat.Prime p)
      rw [â† zpow_neg_one, zpow_lt_iff_lt this]
      have : 0 â‰¤ padicValRat p m := by simp only [of_int, Nat.cast_nonneg]
      intro h
      rw [â† zpow_zero (p : â„š), zpow_inj] <;> linarith"
Mathlib/Analysis/BoxIntegral/Integrability.lean,BoxIntegral.hasIntegralIndicatorConst,hasIntegralIndicatorConst,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  refine' HasIntegral.of_mul â€–yâ€– fun Îµ Îµ0 => _
  lift Îµ to â„â‰¥0 using Îµ0.le; rw [NNReal.coe_pos] at Îµ0
  have A : Î¼ (s âˆ© Box.Icc I) â‰  âˆ :=
    ((measure_mono <| Set.inter_subset_right _ _).trans_lt (I.measure_Icc_lt_top Î¼)).ne
  have B : Î¼ (s âˆ© I) â‰  âˆ :=
    ((measure_mono <| Set.inter_subset_right _ _).trans_lt (I.measure_coe_lt_top Î¼)).ne
  obtain âŸ¨F, hFs, hFc, hÎ¼FâŸ© : âˆƒ F, F âŠ† s âˆ© Box.Icc I âˆ§ IsClosed F âˆ§ Î¼ ((s âˆ© Box.Icc I) \ F) < Îµ :=
    (hs.inter I.measurableSet_Icc).exists_isClosed_diff_lt A (ENNReal.coe_pos.2 Îµ0).ne'
  obtain âŸ¨U, hsU, hUo, hUt, hÎ¼UâŸ© :
      âˆƒ U, s âˆ© Box.Icc I âŠ† U âˆ§ IsOpen U âˆ§ Î¼ U < âˆ âˆ§ Î¼ (U \ (s âˆ© Box.Icc I)) < Îµ :=
    (hs.inter I.measurableSet_Icc).exists_isOpen_diff_lt A (ENNReal.coe_pos.2 Îµ0).ne'
  have : âˆ€ x âˆˆ s âˆ© Box.Icc I, âˆƒ r : Ioi (0 : â„), closedBall x r âŠ† U := fun x hx => by
    rcases nhds_basis_closedBall.mem_iff.1 (hUo.mem_nhds <| hsU hx) with âŸ¨r, hrâ‚€, hrâŸ©
    exact âŸ¨âŸ¨r, hrâ‚€âŸ©, hrâŸ©
  choose! rs hrsU using this
  have : âˆ€ x âˆˆ Box.Icc I \ s, âˆƒ r : Ioi (0 : â„), closedBall x r âŠ† Fá¶œ := fun x hx => by
    obtain âŸ¨r, hrâ‚€, hrâŸ© :=
      nhds_basis_closedBall.mem_iff.1 (hFc.isOpen_compl.mem_nhds fun hx' => hx.2 (hFs hx').1)
    exact âŸ¨âŸ¨r, hrâ‚€âŸ©, hrâŸ©
  choose! rs' hrs'F using this
  set r : (Î¹ â†’ â„) â†’ Ioi (0 : â„) := s.piecewise rs rs'
  refine' âŸ¨fun _ => r, fun c => l.rCond_of_bRiemann_eq_false hl, fun c Ï€ hÏ€ hÏ€p => _âŸ©; rw [mul_comm]
  dsimp [integralSum]
  simp only [mem_closedBall, dist_eq_norm, â† indicator_const_smul_apply,
    sum_indicator_eq_sum_filter, â† sum_smul, â† sub_smul, norm_smul, Real.norm_eq_abs, â†
    Prepartition.filter_boxes, â† Prepartition.measure_iUnion_toReal]
  refine' mul_le_mul_of_nonneg_right _ (norm_nonneg y)
  set t := (Ï€.filter (Ï€.tag Â· âˆˆ s)).iUnion
  change abs ((Î¼ t).toReal - (Î¼ (s âˆ© I)).toReal) â‰¤ Îµ
  have htU : t âŠ† U âˆ© I := by
    simp only [TaggedPrepartition.iUnion_def, iUnion_subset_iff, TaggedPrepartition.mem_filter,
      and_imp]
    refine' fun J hJ hJs x hx => âŸ¨hrsU _ âŸ¨hJs, Ï€.tag_mem_Icc JâŸ© _, Ï€.le_of_mem' J hJ hxâŸ©
    simpa only [s.piecewise_eq_of_mem _ _ hJs] using hÏ€.1 J hJ (Box.coe_subset_Icc hx)
  refine' abs_sub_le_iff.2 âŸ¨_, _âŸ©
  Â· refine' (ENNReal.le_toReal_sub B).trans (ENNReal.toReal_le_coe_of_le_coe _)
    refine' (tsub_le_tsub (measure_mono htU) le_rfl).trans (le_measure_diff.trans _)
    refine' (measure_mono fun x hx => _).trans hÎ¼U.le
    exact âŸ¨hx.1.1, fun hx' => hx.2 âŸ¨hx'.1, hx.1.2âŸ©âŸ©
  Â· have hÎ¼t : Î¼ t â‰  âˆ := ((measure_mono (htU.trans (inter_subset_left _ _))).trans_lt hUt).ne
    refine' (ENNReal.le_toReal_sub hÎ¼t).trans (ENNReal.toReal_le_coe_of_le_coe _)
    refine' le_measure_diff.trans ((measure_mono _).trans hÎ¼F.le)
    rintro x âŸ¨âŸ¨hxs, hxIâŸ©, hxtâŸ©
    refine' âŸ¨âŸ¨hxs, Box.coe_subset_Icc hxIâŸ©, fun hxF => hxt _âŸ©
    simp only [TaggedPrepartition.iUnion_def, TaggedPrepartition.mem_filter, Set.mem_iUnion,
      exists_prop]
    rcases hÏ€p x hxI with âŸ¨J, hJÏ€, hxJâŸ©
    refine' âŸ¨J, âŸ¨hJÏ€, _âŸ©, hxJâŸ©
    contrapose hxF
    refine' hrs'F _ âŸ¨Ï€.tag_mem_Icc J, hxFâŸ© _
    simpa only [s.piecewise_eq_of_not_mem _ _ hxF] using hÏ€.1 J hJÏ€ (Box.coe_subset_Icc hxJ)","error:  function expected at
  Set.inter_subset_right ?m.4422
term has type
  ?m.4421 âˆˆ ?m.4420
error:  function expected at
  Set.inter_subset_right ?m.5102
term has type
  ?m.5101 âˆˆ ?m.5100
error:  simp made no progress
error:  overloaded, errors 
  function expected at
    Finset.inter_subset_left ?m.17202
  term has type
    ?m.17201 âˆˆ ?m.17199
  
  function expected at
    Set.inter_subset_left ?m.17340
  term has type
    ?m.17339 âˆˆ ?m.17337
error:  simp made no progress","theorem hasIntegralIndicatorConst (l : IntegrationParams) (hl : l.bRiemann = false)
    {s : Set (Î¹ â†’ â„)} (hs : MeasurableSet s) (I : Box Î¹) (y : E) (Î¼ : Measure (Î¹ â†’ â„))
    [IsLocallyFiniteMeasure Î¼] :
    HasIntegral.{u, v, v} I l (s.indicator fun _ => y) Î¼.toBoxAdditive.toSMul
      ((Î¼ (s âˆ© I)).toReal â€¢ y) ",":= by
  refine HasIntegral.of_mul â€–yâ€– fun Îµ Îµ0 => ?_
  lift Îµ to â„â‰¥0 using Îµ0.le; rw [NNReal.coe_pos] at Îµ0
  have A : Î¼ (s âˆ© Box.Icc I) â‰  âˆ :=
    ((measure_mono Set.inter_subset_right).trans_lt (I.measure_Icc_lt_top Î¼)).ne
  have B : Î¼ (s âˆ© I) â‰  âˆ :=
    ((measure_mono Set.inter_subset_right).trans_lt (I.measure_coe_lt_top Î¼)).ne
  obtain âŸ¨F, hFs, hFc, hÎ¼FâŸ© : âˆƒ F, F âŠ† s âˆ© Box.Icc I âˆ§ IsClosed F âˆ§ Î¼ ((s âˆ© Box.Icc I) \ F) < Îµ :=
    (hs.inter I.measurableSet_Icc).exists_isClosed_diff_lt A (ENNReal.coe_pos.2 Îµ0).ne'
  obtain âŸ¨U, hsU, hUo, hUt, hÎ¼UâŸ© :
      âˆƒ U, s âˆ© Box.Icc I âŠ† U âˆ§ IsOpen U âˆ§ Î¼ U < âˆ âˆ§ Î¼ (U \ (s âˆ© Box.Icc I)) < Îµ :=
    (hs.inter I.measurableSet_Icc).exists_isOpen_diff_lt A (ENNReal.coe_pos.2 Îµ0).ne'
  have : âˆ€ x âˆˆ s âˆ© Box.Icc I, âˆƒ r : Ioi (0 : â„), closedBall x r âŠ† U := fun x hx => by
    rcases nhds_basis_closedBall.mem_iff.1 (hUo.mem_nhds <| hsU hx) with âŸ¨r, hrâ‚€, hrâŸ©
    exact âŸ¨âŸ¨r, hrâ‚€âŸ©, hrâŸ©
  choose! rs hrsU using this
  have : âˆ€ x âˆˆ Box.Icc I \ s, âˆƒ r : Ioi (0 : â„), closedBall x r âŠ† Fá¶œ := fun x hx => by
    obtain âŸ¨r, hrâ‚€, hrâŸ© :=
      nhds_basis_closedBall.mem_iff.1 (hFc.isOpen_compl.mem_nhds fun hx' => hx.2 (hFs hx').1)
    exact âŸ¨âŸ¨r, hrâ‚€âŸ©, hrâŸ©
  choose! rs' hrs'F using this
  set r : (Î¹ â†’ â„) â†’ Ioi (0 : â„) := s.piecewise rs rs'
  refine âŸ¨fun _ => r, fun c => l.rCond_of_bRiemann_eq_false hl, fun c Ï€ hÏ€ hÏ€p => ?_âŸ©; rw [mul_comm]
  dsimp [integralSum]
  simp only [mem_closedBall, dist_eq_norm, â† indicator_const_smul_apply,
    sum_indicator_eq_sum_filter, â† sum_smul, â† sub_smul, norm_smul, Real.norm_eq_abs, â†
    Prepartition.filter_boxes, â† Prepartition.measure_iUnion_toReal]
  gcongr
  set t := (Ï€.filter (Ï€.tag Â· âˆˆ s)).iUnion
  change abs ((Î¼ t).toReal - (Î¼ (s âˆ© I)).toReal) â‰¤ Îµ
  have htU : t âŠ† U âˆ© I := by
    simp only [t, TaggedPrepartition.iUnion_def, iUnion_subset_iff, TaggedPrepartition.mem_filter,
      and_imp]
    refine fun J hJ hJs x hx => âŸ¨hrsU _ âŸ¨hJs, Ï€.tag_mem_Icc JâŸ© ?_, Ï€.le_of_mem' J hJ hxâŸ©
    simpa only [r, s.piecewise_eq_of_mem _ _ hJs] using hÏ€.1 J hJ (Box.coe_subset_Icc hx)
  refine abs_sub_le_iff.2 âŸ¨?_, ?_âŸ©
  Â· refine (ENNReal.le_toReal_sub B).trans (ENNReal.toReal_le_coe_of_le_coe ?_)
    refine (tsub_le_tsub (measure_mono htU) le_rfl).trans (le_measure_diff.trans ?_)
    refine (measure_mono fun x hx => ?_).trans hÎ¼U.le
    exact âŸ¨hx.1.1, fun hx' => hx.2 âŸ¨hx'.1, hx.1.2âŸ©âŸ©
  Â· have hÎ¼t : Î¼ t â‰  âˆ := ((measure_mono (htU.trans inter_subset_left)).trans_lt hUt).ne
    refine (ENNReal.le_toReal_sub hÎ¼t).trans (ENNReal.toReal_le_coe_of_le_coe ?_)
    refine le_measure_diff.trans ((measure_mono ?_).trans hÎ¼F.le)
    rintro x âŸ¨âŸ¨hxs, hxIâŸ©, hxtâŸ©
    refine âŸ¨âŸ¨hxs, Box.coe_subset_Icc hxIâŸ©, fun hxF => hxt ?_âŸ©
    simp only [t, TaggedPrepartition.iUnion_def, TaggedPrepartition.mem_filter, Set.mem_iUnion]
    rcases hÏ€p x hxI with âŸ¨J, hJÏ€, hxJâŸ©
    refine âŸ¨J, âŸ¨hJÏ€, ?_âŸ©, hxJâŸ©
    contrapose hxF
    refine hrs'F _ âŸ¨Ï€.tag_mem_Icc J, hxFâŸ© ?_
    simpa only [r, s.piecewise_eq_of_not_mem _ _ hxF] using hÏ€.1 J hJÏ€ (Box.coe_subset_Icc hxJ)"
Mathlib/LinearAlgebra/Projectivization/Independence.lean,Projectivization.dependent_pair_iff_eq,dependent_pair_iff_eq,9a09f1cf9b7b2c735d08da41e5f94eb98dc0798f,":= by
  rw [dependent_iff_not_independent, independent_iff, linearIndependent_fin2,
    Function.comp_apply, Matrix.cons_val_one, Matrix.head_cons, Ne.def]
  simp only [Matrix.cons_val_zero, not_and, not_forall, Classical.not_not, Function.comp_apply,
    â† mk_eq_mk_iff' K _ _ (rep_nonzero u) (rep_nonzero v), mk_rep, imp_iff_right_iff]
  exact Or.inl (rep_nonzero v)","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.28953 â†’ ?m.28953 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.28955
Î¹ : Type u_1
K : Type u_2
V : Type u_3
instâœÂ² : DivisionRing K
instâœÂ¹ : AddCommGroup V
instâœ : Module K V
f : Î¹ â†’ â„™ K V
u v : â„™ K V
âŠ¢ Â¬(v.rep â‰  0 âˆ§ âˆ€ (a : K), a â€¢ v.rep â‰  (Projectivization.rep âˆ˜ ![u, v]) 0) â†” u = v","theorem dependent_pair_iff_eq (u v : â„™ K V) : Dependent ![u, v] â†” u = v ",":= by
  rw [dependent_iff_not_independent, independent_iff, linearIndependent_fin2,
    Function.comp_apply, Matrix.cons_val_one, Matrix.head_cons, Ne]
  simp only [Matrix.cons_val_zero, not_and, not_forall, Classical.not_not, Function.comp_apply,
    â† mk_eq_mk_iff' K _ _ (rep_nonzero u) (rep_nonzero v), mk_rep, Classical.imp_iff_right_iff]
  exact Or.inl (rep_nonzero v)"
Mathlib/LinearAlgebra/Matrix/Block.lean,Matrix.toBlock_inverse_eq_zero,toBlock_inverse_eq_zero,9e80ae3b111c3eecd16d15b3531b28b7aa19b56f,":= by
  let p i := b i < k
  let q i := Â¬b i < k
  have h_sum : Mâ»Â¹.toBlock q p â¬ M.toBlock p p + Mâ»Â¹.toBlock q q â¬ M.toBlock q p = 0 := by
    rw [â† toBlock_mul_eq_add, inv_mul_of_invertible M, toBlock_one_disjoint]
    rw [disjoint_iff_inf_le]
    exact fun i h => h.1 h.2
  have h_zero : M.toBlock q p = 0 := by
    ext (i j)
    simpa using hM (lt_of_lt_of_le j.2 <| le_of_not_lt i.2)
  have h_mul_eq_zero : Mâ»Â¹.toBlock q p â¬ M.toBlock p p = 0 := by simpa [h_zero] using h_sum
  haveI : Invertible (M.toBlock p p) := hM.invertibleToBlock k
  have : (fun i => k â‰¤ b i) = q := by
    ext
    exact not_lt.symm
  rw [this, â† Matrix.zero_mul (M.toBlock p p)â»Â¹, â† h_mul_eq_zero,
    mul_inv_cancel_right_of_invertible]",error:  expected token,"theorem toBlock_inverse_eq_zero [LinearOrder Î±] [Invertible M] (hM : BlockTriangular M b) (k : Î±) :
    (Mâ»Â¹.toBlock (fun i => k â‰¤ b i) fun i => b i < k) = 0 ",":= by
  let p i := b i < k
  let q i := Â¬b i < k
  have h_sum : Mâ»Â¹.toBlock q p * M.toBlock p p + Mâ»Â¹.toBlock q q * M.toBlock q p = 0 := by
    rw [â† toBlock_mul_eq_add, inv_mul_of_invertible M, toBlock_one_disjoint]
    rw [disjoint_iff_inf_le]
    exact fun i h => h.1 h.2
  have h_zero : M.toBlock q p = 0 := by
    ext i j
    simpa using hM (lt_of_lt_of_le j.2 <| le_of_not_lt i.2)
  have h_mul_eq_zero : Mâ»Â¹.toBlock q p * M.toBlock p p = 0 := by simpa [h_zero] using h_sum
  haveI : Invertible (M.toBlock p p) := hM.invertibleToBlock k
  have : (fun i => k â‰¤ b i) = q := by
    ext
    exact not_lt.symm
  rw [this, â† Matrix.zero_mul (M.toBlock p p)â»Â¹, â† h_mul_eq_zero,
    mul_inv_cancel_right_of_invertible]"
Mathlib/Data/NNRat/Defs.lean,NNRat.add_def,add_def,5f71dc2104c23870830cd3dd0cd165dd6913a60b,":= by
  ext; simp [Rat.add_def', Rat.mkRat_eq, num_coe, den_coe]","error:  unknown constant 'Rat.mkRat_eq'
error:  unsolved goals
case a
p qâœ : â„šâ‰¥0
nâ‚ nâ‚‚ dâ‚ dâ‚‚ d : â„•
q r : â„šâ‰¥0
âŠ¢ mkRat (â†‘q.num * â†‘r.den + â†‘r.num * â†‘q.den) (q.den * r.den) =
    Rat.divInt (â†‘q.num * â†‘r.den + â†‘r.num * â†‘q.den) (â†‘q.den * â†‘r.den)",lemma add_def (q r : â„šâ‰¥0) : q + r = divNat (q.num * r.den + r.num * q.den) (q.den * r.den) ,":= by
  ext; simp [Rat.add_def', Rat.mkRat_eq_divInt, num_coe, den_coe]"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine' âŸ¨[], rfl.le, show Ï† = 1 from _âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [Nat.zero_eq, le_zero_iff, finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      linarith
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine' âŸ¨x::l, Nat.succ_le_succ hl, _âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg ((Â· * Â·) Ï) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâµ : _root_.RCLike ğ•œ
instâœâ´ : NormedAddCommGroup E
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : InnerProductSpace ğ•œ E
instâœÂ¹ : InnerProductSpace â„ F
K : Submodule ğ•œ E
instâœ : FiniteDimensional â„ F
Ï† : F â‰ƒâ‚—áµ¢[â„] F
hn :
  finrank â„
      â†¥(LinearMap.ker
            (ContinuousLinearMap.id â„ F -
              â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }))á—® â‰¤
    0
âŠ¢ LinearMap.ker
      (ContinuousLinearMap.id â„ F -
        â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }) =
    âŠ¤","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional â„ F] {n : â„•}
    (Ï† : F â‰ƒâ‚—áµ¢[â„] F) (hn : finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—® â‰¤ n) :
    âˆƒ l : List F, l.length â‰¤ n âˆ§ Ï† = (l.map fun v => reflection (â„ âˆ™ v)á—®).prod ",":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine âŸ¨[], rfl.le, show Ï† = 1 from ?_âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      omega
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine âŸ¨x::l, Nat.succ_le_succ hl, ?_âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this"
Mathlib/RingTheory/Polynomial/Basic.lean,Polynomial.not_finite,not_finite,a12cd30ec7f07e71afca0d8c52cd7a427510d1ed,":= by
  rw [Module.finite_def, Submodule.fg_def]
  push_neg
  intro s hs contra
  rcases span_of_finite_le_degreeLE hs with âŸ¨n,hnâŸ©
  have : ((X : R[X]) ^ (n + 1)) âˆˆ Polynomial.degreeLE R â†‘n := by
    rw [contra] at hn
    exact hn Submodule.mem_top
  rw [mem_degreeLE, degree_X_pow, Nat.cast_le, add_le_iff_nonpos_right, nonpos_iff_eq_zero] at this
  exact one_ne_zero this","error:  unknown identifier 'span_of_finite_le_degreeLE'
error:  rcases tactic failed: xâœ : ?m.54021 is not an inductive datatype",theorem not_finite [Nontrivial R] : Â¬ Module.Finite R R[X] ,":= by
  rw [Module.finite_def, Submodule.fg_def]
  push_neg
  intro s hs contra
  rcases span_le_degreeLE_of_finite hs with âŸ¨n,hnâŸ©
  have : ((X : R[X]) ^ (n + 1)) âˆˆ Polynomial.degreeLE R â†‘n := by
    rw [contra] at hn
    exact hn Submodule.mem_top
  rw [mem_degreeLE, degree_X_pow, Nat.cast_le, add_le_iff_nonpos_right, nonpos_iff_eq_zero] at this
  exact one_ne_zero this"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.ae_eventually_measure_zero_of_singular,ae_eventually_measure_zero_of_singular,9e34a191034458a56331f976ff7400a26407c888,":= by
  have A : âˆ€ Îµ > (0 : â„â‰¥0), âˆ€áµ x âˆ‚Î¼, âˆ€á¶  a in v.filterAt x, Ï a < Îµ * Î¼ a := by
    intro Îµ Îµpos
    set s := {x | Â¬âˆ€á¶  a in v.filterAt x, Ï a < Îµ * Î¼ a} with hs
    change Î¼ s = 0
    obtain âŸ¨o, _, Ïo, Î¼oâŸ© : âˆƒ o : Set Î±, MeasurableSet o âˆ§ Ï o = 0 âˆ§ Î¼ oá¶œ = 0 := hÏ
    apply le_antisymm _ bot_le
    calc
      Î¼ s â‰¤ Î¼ (s âˆ© o âˆª oá¶œ) := by
        conv_lhs => rw [â† inter_union_compl s o]
        exact measure_mono (union_subset_union_right _ (inter_subset_right _ _))
      _ â‰¤ Î¼ (s âˆ© o) + Î¼ oá¶œ := (measure_union_le _ _)
      _ = Î¼ (s âˆ© o) := by rw [Î¼o, add_zero]
      _ = (Îµ : â„â‰¥0âˆ)â»Â¹ * (Îµ â€¢ Î¼) (s âˆ© o) := by
        simp only [coe_nnreal_smul_apply, â† mul_assoc, mul_comm _ (Îµ : â„â‰¥0âˆ)]
        rw [ENNReal.mul_inv_cancel (ENNReal.coe_pos.2 Îµpos).ne' ENNReal.coe_ne_top, one_mul]
      _ â‰¤ (Îµ : â„â‰¥0âˆ)â»Â¹ * Ï (s âˆ© o) := by
        refine' mul_le_mul_left' _ _
        refine' v.measure_le_of_frequently_le Ï ((Measure.AbsolutelyContinuous.refl Î¼).smul Îµ) _ _
        intro x hx
        rw [hs] at hx
        simp only [mem_inter_iff, not_lt, not_eventually, mem_setOf_eq] at hx
        exact hx.1
      _ â‰¤ (Îµ : â„â‰¥0âˆ)â»Â¹ * Ï o := (mul_le_mul_left' (measure_mono (inter_subset_right _ _)) _)
      _ = 0 := by rw [Ïo, MulZeroClass.mul_zero]
  obtain âŸ¨u, _, u_pos, u_limâŸ© :
    âˆƒ u : â„• â†’ â„â‰¥0, StrictAnti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=
    exists_seq_strictAnti_tendsto (0 : â„â‰¥0)
  have B : âˆ€áµ x âˆ‚Î¼, âˆ€ n, âˆ€á¶  a in v.filterAt x, Ï a < u n * Î¼ a :=
    ae_all_iff.2 fun n => A (u n) (u_pos n)
  filter_upwards [B, v.ae_eventually_measure_pos]
  intro x hx h'x
  refine' tendsto_order.2 âŸ¨fun z hz => (ENNReal.not_lt_zero hz).elim, fun z hz => _âŸ©
  obtain âŸ¨w, w_pos, w_ltâŸ© : âˆƒ w : â„â‰¥0, (0 : â„â‰¥0âˆ) < w âˆ§ (w : â„â‰¥0âˆ) < z :=
    ENNReal.lt_iff_exists_nnreal_btwn.1 hz
  obtain âŸ¨n, hnâŸ© : âˆƒ n, u n < w := ((tendsto_order.1 u_lim).2 w (ENNReal.coe_pos.1 w_pos)).exists
  filter_upwards [hx n, h'x, v.eventually_measure_lt_top x]
  intro a ha Î¼a_pos Î¼a_lt_top
  rw [ENNReal.div_lt_iff (Or.inl Î¼a_pos.ne') (Or.inl Î¼a_lt_top.ne)]
  exact ha.trans_le (mul_le_mul_right' ((ENNReal.coe_le_coe.2 hn.le).trans w_lt.le) _)","error:  function expected at
  inter_subset_right ?m.20645
term has type
  ?m.20644 âˆˆ ?m.20643
error:  function expected at
  inter_subset_right ?m.21767
term has type
  ?m.21766 âˆˆ ?m.21765","theorem ae_eventually_measure_zero_of_singular (hÏ : Ï âŸ‚â‚˜ Î¼) :
    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => Ï a / Î¼ a) (v.filterAt x) (ğ“ 0) ",":= by
  have A : âˆ€ Îµ > (0 : â„â‰¥0), âˆ€áµ x âˆ‚Î¼, âˆ€á¶  a in v.filterAt x, Ï a < Îµ * Î¼ a := by
    intro Îµ Îµpos
    set s := {x | Â¬âˆ€á¶  a in v.filterAt x, Ï a < Îµ * Î¼ a} with hs
    change Î¼ s = 0
    obtain âŸ¨o, _, Ïo, Î¼oâŸ© : âˆƒ o : Set Î±, MeasurableSet o âˆ§ Ï o = 0 âˆ§ Î¼ oá¶œ = 0 := hÏ
    apply le_antisymm _ bot_le
    calc
      Î¼ s â‰¤ Î¼ (s âˆ© o âˆª oá¶œ) := by
        conv_lhs => rw [â† inter_union_compl s o]
        gcongr
        apply inter_subset_right
      _ â‰¤ Î¼ (s âˆ© o) + Î¼ oá¶œ := measure_union_le _ _
      _ = Î¼ (s âˆ© o) := by rw [Î¼o, add_zero]
      _ = (Îµ : â„â‰¥0âˆ)â»Â¹ * (Îµ â€¢ Î¼) (s âˆ© o) := by
        simp only [coe_nnreal_smul_apply, â† mul_assoc, mul_comm _ (Îµ : â„â‰¥0âˆ)]
        rw [ENNReal.mul_inv_cancel (ENNReal.coe_pos.2 Îµpos).ne' ENNReal.coe_ne_top, one_mul]
      _ â‰¤ (Îµ : â„â‰¥0âˆ)â»Â¹ * Ï (s âˆ© o) := by
        gcongr
        refine v.measure_le_of_frequently_le Ï ((Measure.AbsolutelyContinuous.refl Î¼).smul Îµ) _ ?_
        intro x hx
        rw [hs] at hx
        simp only [mem_inter_iff, not_lt, not_eventually, mem_setOf_eq] at hx
        exact hx.1
      _ â‰¤ (Îµ : â„â‰¥0âˆ)â»Â¹ * Ï o := by gcongr; apply inter_subset_right
      _ = 0 := by rw [Ïo, mul_zero]
  obtain âŸ¨u, _, u_pos, u_limâŸ© :
    âˆƒ u : â„• â†’ â„â‰¥0, StrictAnti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=
    exists_seq_strictAnti_tendsto (0 : â„â‰¥0)
  have B : âˆ€áµ x âˆ‚Î¼, âˆ€ n, âˆ€á¶  a in v.filterAt x, Ï a < u n * Î¼ a :=
    ae_all_iff.2 fun n => A (u n) (u_pos n)
  filter_upwards [B, v.ae_eventually_measure_pos]
  intro x hx h'x
  refine tendsto_order.2 âŸ¨fun z hz => (ENNReal.not_lt_zero hz).elim, fun z hz => ?_âŸ©
  obtain âŸ¨w, w_pos, w_ltâŸ© : âˆƒ w : â„â‰¥0, (0 : â„â‰¥0âˆ) < w âˆ§ (w : â„â‰¥0âˆ) < z :=
    ENNReal.lt_iff_exists_nnreal_btwn.1 hz
  obtain âŸ¨n, hnâŸ© : âˆƒ n, u n < w := ((tendsto_order.1 u_lim).2 w (ENNReal.coe_pos.1 w_pos)).exists
  filter_upwards [hx n, h'x, v.eventually_measure_lt_top x]
  intro a ha Î¼a_pos Î¼a_lt_top
  rw [ENNReal.div_lt_iff (Or.inl Î¼a_pos.ne') (Or.inl Î¼a_lt_top.ne)]
  exact ha.trans_le (mul_le_mul_right' ((ENNReal.coe_le_coe.2 hn.le).trans w_lt.le) _)"
Mathlib/Computability/PartrecCode.lean,Nat.Partrec.Code.evaln_complete,evaln_complete,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  refine âŸ¨fun h => ?_, fun âŸ¨k, hâŸ© => evaln_sound hâŸ©
  rsuffices âŸ¨k, hâŸ© : âˆƒ k, x âˆˆ evaln (k + 1) c n
  Â· exact âŸ¨k + 1, hâŸ©
  induction c generalizing n x with simp [eval, evaln, pure, PFun.pure, Seq.seq, Bind.bind] at h âŠ¢
  | pair cf cg hf hg =>
    rcases h with âŸ¨x, hx, y, hy, rflâŸ©
    rcases hf hx with âŸ¨kâ‚, hkâ‚âŸ©; rcases hg hy with âŸ¨kâ‚‚, hkâ‚‚âŸ©
    refine âŸ¨max kâ‚ kâ‚‚, ?_âŸ©
    refine'
      âŸ¨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚, rflâŸ©
  | comp cf cg hf hg =>
    rcases h with âŸ¨y, hy, hxâŸ©
    rcases hg hy with âŸ¨kâ‚, hkâ‚âŸ©; rcases hf hx with âŸ¨kâ‚‚, hkâ‚‚âŸ©
    refine âŸ¨max kâ‚ kâ‚‚, ?_âŸ©
    exact
      âŸ¨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hkâ‚,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚âŸ©
  | prec cf cg hf hg =>
    revert h
    generalize n.unpair.1 = nâ‚; generalize n.unpair.2 = nâ‚‚
    induction' nâ‚‚ with m IH generalizing x n <;> simp
    Â· intro h
      rcases hf h with âŸ¨k, hkâŸ©
      exact âŸ¨_, le_max_left _ _, evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâŸ©
    Â· intro y hy hx
      rcases IH hy with âŸ¨kâ‚, nkâ‚, hkâ‚âŸ©
      rcases hg hx with âŸ¨kâ‚‚, hkâ‚‚âŸ©
      refine'
        âŸ¨(max kâ‚ kâ‚‚).succ,
          Nat.le_succ_of_le <| le_max_of_le_left <|
            le_trans (le_max_left _ (Nat.pair nâ‚ m)) nkâ‚, y,
          evaln_mono (Nat.succ_le_succ <| le_max_left _ _) _,
          evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_right _ _) hkâ‚‚âŸ©
      simp only [evaln.eq_8, bind, unpaired, unpair_pair, Option.mem_def, Option.bind_eq_some,
        Option.guard_eq_some', exists_and_left, exists_const]
      exact âŸ¨le_trans (le_max_right _ _) nkâ‚, hkâ‚âŸ©
  | rfind' cf hf =>
    rcases h with âŸ¨y, âŸ¨hyâ‚, hyâ‚‚âŸ©, rflâŸ©
    suffices âˆƒ k, y + n.unpair.2 âˆˆ evaln (k + 1) (rfind' cf) (Nat.pair n.unpair.1 n.unpair.2) by
      simpa [evaln, Bind.bind]
    revert hyâ‚ hyâ‚‚
    generalize n.unpair.2 = m
    intro hyâ‚ hyâ‚‚
    induction' y with y IH generalizing m <;> simp [evaln, Bind.bind]
    Â· simp at hyâ‚
      rcases hf hyâ‚ with âŸ¨k, hkâŸ©
      exact âŸ¨_, Nat.le_of_lt_succ <| evaln_bound hk, _, hk, by simpâŸ©
    Â· rcases hyâ‚‚ (Nat.succ_pos _) with âŸ¨a, ha, a0âŸ©
      rcases hf ha with âŸ¨kâ‚, hkâ‚âŸ©
      rcases IH m.succ (by simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using hyâ‚)
          fun {i} hi => by
          simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using
            hyâ‚‚ (Nat.succ_lt_succ hi) with
        âŸ¨kâ‚‚, hkâ‚‚âŸ©
      use (max kâ‚ kâ‚‚).succ
      rw [zero_add] at hkâ‚
      use Nat.le_succ_of_le <| le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚
      use a
      use evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_left _ _) hkâ‚
      simpa [Nat.succ_eq_add_one, a0, -max_eq_left, -max_eq_right, add_comm, add_left_comm] using
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚
  | _ => exact âŸ¨âŸ¨_, le_rflâŸ©, h.symmâŸ©","error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #6 provided
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #4 provided
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #2 provided
error:  tactic 'cases' failed, nested error:
dependent elimination failed, failed to solve equation
  some y =
    match guard (?m.364435 â‰¤ kâ‚), fun a â†¦
      Nat.rec (evaln (kâ‚ + 1) cf nâ‚)
        (fun n n_ih â†¦
          (evaln kâ‚ (cf.prec cg) (Nat.pair nâ‚ n)).bind fun i â†¦ evaln (kâ‚ + 1) cg (Nat.pair nâ‚ (Nat.pair n i)))
        m with
    | Option.none, x => Option.none
    | some a, f => f a
at case Eq.refl
error:  invalid constructor âŸ¨...âŸ©, insufficient number of arguments, constructs 'Eq.refl' does not have explicit fields, but #4 provided
error:  type mismatch
  le_succ_of_le (le_max_of_le_left (le_of_lt_succ (evaln_bound hkâ‚)))
has type
  Nat.pair (unpair n).1 m â‰¤ (max kâ‚ ?m.381477).succ : Prop
but is expected to have type
  ((guard (Nat.pair (unpair n).1 m â‰¤ (max kâ‚ kâ‚‚).succ)).bind fun a â†¦
      (evaln ((max kâ‚ kâ‚‚).succ + 1) cf (Nat.pair (unpair n).1 m)).bind fun a â†¦
        if a = 0 then some m else evaln (max kâ‚ kâ‚‚).succ cf.rfind' (Nat.pair (unpair n).1 (m + 1))) =
    some (y + 1 + m) : Prop
error:  no goals to be solved
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type with only one constructor 
  â„•
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type with only one constructor 
  â„•
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type with only one constructor 
  â„•
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type with only one constructor 
  â„•","theorem evaln_complete {c n x} : x âˆˆ eval c n â†” âˆƒ k, x âˆˆ evaln k c n ",":= by
  refine âŸ¨fun h => ?_, fun âŸ¨k, hâŸ© => evaln_sound hâŸ©
  rsuffices âŸ¨k, hâŸ© : âˆƒ k, x âˆˆ evaln (k + 1) c n
  Â· exact âŸ¨k + 1, hâŸ©
  induction c generalizing n x with
      simp [eval, evaln, pure, PFun.pure, Seq.seq, Option.bind_eq_some] at h âŠ¢
  | pair cf cg hf hg =>
    rcases h with âŸ¨x, hx, y, hy, rflâŸ©
    rcases hf hx with âŸ¨kâ‚, hkâ‚âŸ©; rcases hg hy with âŸ¨kâ‚‚, hkâ‚‚âŸ©
    refine âŸ¨max kâ‚ kâ‚‚, ?_âŸ©
    refine
      âŸ¨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚, rflâŸ©
  | comp cf cg hf hg =>
    rcases h with âŸ¨y, hy, hxâŸ©
    rcases hg hy with âŸ¨kâ‚, hkâ‚âŸ©; rcases hf hx with âŸ¨kâ‚‚, hkâ‚‚âŸ©
    refine âŸ¨max kâ‚ kâ‚‚, ?_âŸ©
    exact
      âŸ¨le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚, _,
        evaln_mono (Nat.succ_le_succ <| le_max_left _ _) hkâ‚,
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚âŸ©
  | prec cf cg hf hg =>
    revert h
    generalize n.unpair.1 = nâ‚; generalize n.unpair.2 = nâ‚‚
    induction' nâ‚‚ with m IH generalizing x n <;> simp [Option.bind_eq_some]
    Â· intro h
      rcases hf h with âŸ¨k, hkâŸ©
      exact âŸ¨_, le_max_left _ _, evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâŸ©
    Â· intro y hy hx
      rcases IH hy with âŸ¨kâ‚, nkâ‚, hkâ‚âŸ©
      rcases hg hx with âŸ¨kâ‚‚, hkâ‚‚âŸ©
      refine
        âŸ¨(max kâ‚ kâ‚‚).succ,
          Nat.le_succ_of_le <| le_max_of_le_left <|
            le_trans (le_max_left _ (Nat.pair nâ‚ m)) nkâ‚, y,
          evaln_mono (Nat.succ_le_succ <| le_max_left _ _) ?_,
          evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_right _ _) hkâ‚‚âŸ©
      simp only [evaln.eq_8, bind, unpaired, unpair_pair, Option.mem_def, Option.bind_eq_some,
        Option.guard_eq_some', exists_and_left, exists_const]
      exact âŸ¨le_trans (le_max_right _ _) nkâ‚, hkâ‚âŸ©
  | rfind' cf hf =>
    rcases h with âŸ¨y, âŸ¨hyâ‚, hyâ‚‚âŸ©, rflâŸ©
    suffices âˆƒ k, y + n.unpair.2 âˆˆ evaln (k + 1) (rfind' cf) (Nat.pair n.unpair.1 n.unpair.2) by
      simpa [evaln, Option.bind_eq_some]
    revert hyâ‚ hyâ‚‚
    generalize n.unpair.2 = m
    intro hyâ‚ hyâ‚‚
    induction' y with y IH generalizing m <;> simp [evaln, Option.bind_eq_some]
    Â· simp at hyâ‚
      rcases hf hyâ‚ with âŸ¨k, hkâŸ©
      exact âŸ¨_, Nat.le_of_lt_succ <| evaln_bound hk, _, hk, by simpâŸ©
    Â· rcases hyâ‚‚ (Nat.succ_pos _) with âŸ¨a, ha, a0âŸ©
      rcases hf ha with âŸ¨kâ‚, hkâ‚âŸ©
      rcases IH m.succ (by simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using hyâ‚)
          fun {i} hi => by
          simpa [Nat.succ_eq_add_one, add_comm, add_left_comm] using
            hyâ‚‚ (Nat.succ_lt_succ hi) with
        âŸ¨kâ‚‚, hkâ‚‚âŸ©
      use (max kâ‚ kâ‚‚).succ
      rw [zero_add] at hkâ‚
      use Nat.le_succ_of_le <| le_max_of_le_left <| Nat.le_of_lt_succ <| evaln_bound hkâ‚
      use a
      use evaln_mono (Nat.succ_le_succ <| Nat.le_succ_of_le <| le_max_left _ _) hkâ‚
      simpa [Nat.succ_eq_add_one, a0, -max_eq_left, -max_eq_right, add_comm, add_left_comm] using
        evaln_mono (Nat.succ_le_succ <| le_max_right _ _) hkâ‚‚
  | _ => exact âŸ¨âŸ¨_, le_rflâŸ©, h.symmâŸ©"
Mathlib/RingTheory/Finiteness.lean,Submodule.fg_induction,fg_induction,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
    obtain âŸ¨s, rflâŸ© := hN
    induction s
    Â· rw [Finset.coe_empty, Submodule.span_empty, â† Submodule.span_zero_singleton]
      apply hâ‚
    Â· rw [Finset.coe_insert, Submodule.span_insert]
      apply hâ‚‚ <;> apply_assumption","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â†‘âˆ…
case intro.mk
Râœ : Type u_1
Mâœ : Type u_2
instâœâ· : Semiring Râœ
instâœâ¶ : AddCommMonoid Mâœ
instâœâµ : Module Râœ Mâœ
Pâœ : Type u_3
instâœâ´ : AddCommMonoid Pâœ
instâœÂ³ : Module Râœ Pâœ
f : Mâœ â†’â‚—[Râœ] Pâœ
R : Type u_4
M : Type u_5
instâœÂ² : Semiring R
instâœÂ¹ : AddCommMonoid M
instâœ : Module R M
P : Submodule R M â†’ Prop
hâ‚ : âˆ€ (x : M), P (span R {x})
hâ‚‚ : âˆ€ (Mâ‚ Mâ‚‚ : Submodule R M), P Mâ‚ â†’ P Mâ‚‚ â†’ P (Mâ‚ âŠ” Mâ‚‚)
valâœ : Multiset M
nodupâœ : valâœ.Nodup
âŠ¢ P (span R â†‘{ val := valâœ, nodup := nodupâœ })
error:  no goals to be solved
warning:  Module.Finite does not have a doc string","theorem fg_induction (R M : Type*) [Semiring R] [AddCommMonoid M] [Module R M]
    (P : Submodule R M â†’ Prop) (hâ‚ : âˆ€ x, P (Submodule.span R {x}))
    (hâ‚‚ : âˆ€ Mâ‚ Mâ‚‚, P Mâ‚ â†’ P Mâ‚‚ â†’ P (Mâ‚ âŠ” Mâ‚‚)) (N : Submodule R M) (hN : N.FG) : P N ",":= by
  classical
    obtain âŸ¨s, rflâŸ© := hN
    induction s using Finset.induction
    Â· rw [Finset.coe_empty, Submodule.span_empty, â† Submodule.span_zero_singleton]
      apply hâ‚
    Â· rw [Finset.coe_insert, Submodule.span_insert]
      apply hâ‚‚ <;> apply_assumption"
Mathlib/RingTheory/Localization/Integer.lean,IsLocalization.exist_integer_multiples,exist_integer_multiples,047f73c34cd3e6bae28166f72847965b1a989c70,":= by
  haveI := Classical.propDecidable
  refine' âŸ¨âˆ i in s, (sec M (f i)).2, fun i hi => âŸ¨_, _âŸ©âŸ©
  Â· exact (âˆ j in s.erase i, (sec M (f j)).2) * (sec M (f i)).1
  rw [RingHom.map_mul, sec_spec', â† mul_assoc, â† (algebraMap R S).map_mul, â† Algebra.smul_def]
  congr 2
  refine' trans _ ((Submonoid.subtype M).map_prod _ _).symm
  rw [mul_comm,Submonoid.coe_finset_prod,
    â† Finset.prod_insert (f := fun i => ((sec M (f i)).snd : R)) (s.not_mem_erase i),
    Finset.insert_erase hi]
  rfl","error:  overloaded, errors 
  54:19 invalid field 'map_prod', the environment does not contain 'MonoidHom.map_prod'
    M.subtype
  has type
    â†¥M â†’* R
  
  54:19 invalid field 'map_prod', the environment does not contain 'MonoidHom.map_prod'
    M.subtype
  has type
    â†¥M â†’* R
error:  no goals to be solved","theorem exist_integer_multiples {Î¹ : Type*} (s : Finset Î¹) (f : Î¹ â†’ S) :
    âˆƒ b : M, âˆ€ i âˆˆ s, IsLocalization.IsInteger R ((b : R) â€¢ f i) ",":= by
  haveI := Classical.propDecidable
  refine âŸ¨âˆ i âˆˆ s, (sec M (f i)).2, fun i hi => âŸ¨?_, ?_âŸ©âŸ©
  Â· exact (âˆ j âˆˆ s.erase i, (sec M (f j)).2) * (sec M (f i)).1
  rw [RingHom.map_mul, sec_spec', â† mul_assoc, â† (algebraMap R S).map_mul, â† Algebra.smul_def]
  congr 2
  refine _root_.trans ?_ (map_prod (Submonoid.subtype M) _ _).symm
  rw [mul_comm,Submonoid.coe_finset_prod,
    â† Finset.prod_insert (f := fun i => ((sec M (f i)).snd : R)) (s.not_mem_erase i),
    Finset.insert_erase hi]
  rfl"
Mathlib/Combinatorics/HalesJewett.lean,Combinatorics.Line.exists_mono_in_high_dimension,exists_mono_in_high_dimension,20100f1475ea197bf6dea643b6ee137219455a51,":=
  Finite.induction_empty_option
  (
  fun {Î± Î±'} e =>
    forall_imp fun Îº =>
      forall_imp fun _ =>
        Exists.imp fun Î¹ =>
          Exists.imp fun _ h C =>
            let âŸ¨l, c, lcâŸ© := h fun v => C (e âˆ˜ v)
            âŸ¨l.map e, c, e.forall_congr_left.mp fun x => by rw [â† lc x, Line.map_apply]âŸ©)
  (by
    intro Îº _
    by_cases h : Nonempty Îº
    Â· refine' âŸ¨Unit, inferInstance, fun C => âŸ¨default, Classical.arbitrary _, PEmpty.recâŸ©âŸ©
    Â· exact âŸ¨Empty, inferInstance, fun C => (h âŸ¨C (Empty.rec)âŸ©).elimâŸ©)
  (by
    intro Î± _ ihÎ± Îº _
    cases nonempty_fintype Îº
    by_cases h : Nonempty Î±
    case neg =>
      refine' âŸ¨Unit, inferInstance, fun C => âŸ¨diagonal _ Unit, C fun _ => none, ?_âŸ©âŸ©
      rintro (_ | âŸ¨aâŸ©)
      Â· rfl
      Â· exact (h âŸ¨aâŸ©).elim
    suffices key :
      âˆ€ r : â„•,
        âˆƒ (Î¹ : Type) (_ : Fintype Î¹),
          âˆ€ C : (Î¹ â†’ Option Î±) â†’ Îº,
            (âˆƒ s : ColorFocused C, Multiset.card s.lines = r) âˆ¨ âˆƒ l, IsMono C l
    Â· obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := key (Fintype.card Îº + 1)
      refine' âŸ¨Î¹, _inst, fun C => (hÎ¹ C).resolve_left _âŸ©
      rintro âŸ¨s, srâŸ©
      apply Nat.not_succ_le_self (Fintype.card Îº)
      rw [â† Nat.add_one, â† sr, â† Multiset.card_map, â† Finset.card_mk]
      exact Finset.card_le_univ âŸ¨_, s.distinct_colorsâŸ©
    intro r
    induction' r with r ihr
    Â· exact âŸ¨Empty, inferInstance, fun C => Or.inl âŸ¨default, Multiset.card_zeroâŸ©âŸ©
    obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := ihr
    specialize ihÎ± ((Î¹ â†’ Option Î±) â†’ Îº)
    obtain âŸ¨Î¹', _inst, hÎ¹'âŸ© := ihÎ±
    refine' âŸ¨Sum Î¹ Î¹', inferInstance, _âŸ©
    intro C
    specialize hÎ¹' fun v' v => C (Sum.elim v (some âˆ˜ v'))
    obtain âŸ¨l', C', hl'âŸ© := hÎ¹'
    have mono_of_mono : (âˆƒ l, IsMono C' l) â†’ âˆƒ l, IsMono C l := by
      rintro âŸ¨l, c, hlâŸ©
      refine' âŸ¨l.horizontal (some âˆ˜ l' (Classical.arbitrary Î±)), c, fun x => _âŸ©
      rw [Line.horizontal_apply, â† hl, â† hl']
    specialize hÎ¹ C'
    rcases hÎ¹ with (âŸ¨s, srâŸ© | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : âˆƒ p âˆˆ s.lines, (p : AlmostMono _).color = C' s.focus
    Â· obtain âŸ¨p, p_mem, hpâŸ© := h
      refine' Or.inr (mono_of_mono âŸ¨p.line, p.color, _âŸ©)
      rintro (_ | _)
      rw [hp, s.is_focused p p_mem]
      apply p.has_color
    refine' Or.inl âŸ¨âŸ¨(s.lines.map _).cons âŸ¨(l'.map some).vertical s.focus, C' s.focus, fun x => _âŸ©,
            Sum.elim s.focus (l'.map some none), _, _âŸ©, _âŸ©
    Â· refine' fun p => âŸ¨p.line.prod (l'.map some), p.color, fun x => _âŸ©
      rw [Line.prod_apply, Line.map_apply, â† p.has_color, â† congr_fun (hl' x)]
    Â· rw [vertical_apply, â† congr_fun (hl' x), Line.map_apply]
    Â· simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | âŸ¨q, hq, rflâŸ©)
      Â· simp only [vertical_apply]
      Â· simp only [prod_apply, s.is_focused q hq]
    Â· rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact âŸ¨fun âŸ¨q, hq, heâŸ© => h âŸ¨q, hq, heâŸ©, s.distinct_colorsâŸ©
    Â· rw [Multiset.card_cons, Multiset.card_map, sr])",error:  unexpected token 'Â·'; expected 'by' or 'from',"theorem exists_mono_in_high_dimension' :
    âˆ€ (Î± : Type u) [Finite Î±] (Îº : Type max v u) [Finite Îº],
      âˆƒ (Î¹ : Type) (_ : Fintype Î¹), âˆ€ C : (Î¹ â†’ Î±) â†’ Îº, âˆƒ l : Line Î± Î¹, l.IsMono C ",":=
  Finite.induction_empty_option
  (
  fun {Î± Î±'} e =>
    forall_imp fun Îº =>
      forall_imp fun _ =>
        Exists.imp fun Î¹ =>
          Exists.imp fun _ h C =>
            let âŸ¨l, c, lcâŸ© := h fun v => C (e âˆ˜ v)
            âŸ¨l.map e, c, e.forall_congr_right.mp fun x => by rw [â† lc x, Line.map_apply]âŸ©)
  (by
    intro Îº _
    by_cases h : Nonempty Îº
    Â· refine âŸ¨Unit, inferInstance, fun C => âŸ¨default, Classical.arbitrary _, PEmpty.recâŸ©âŸ©
    Â· exact âŸ¨Empty, inferInstance, fun C => (h âŸ¨C (Empty.rec)âŸ©).elimâŸ©)
  (by
    intro Î± _ ihÎ± Îº _
    cases nonempty_fintype Îº
    by_cases h : Nonempty Î±
    case neg =>
      refine âŸ¨Unit, inferInstance, fun C => âŸ¨diagonal _ Unit, C fun _ => none, ?_âŸ©âŸ©
      rintro (_ | âŸ¨aâŸ©)
      Â· rfl
      Â· exact (h âŸ¨aâŸ©).elim
    suffices key :
      âˆ€ r : â„•,
        âˆƒ (Î¹ : Type) (_ : Fintype Î¹),
          âˆ€ C : (Î¹ â†’ Option Î±) â†’ Îº,
            (âˆƒ s : ColorFocused C, Multiset.card s.lines = r) âˆ¨ âˆƒ l, IsMono C l by
      obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := key (Fintype.card Îº + 1)
      refine âŸ¨Î¹, _inst, fun C => (hÎ¹ C).resolve_left ?_âŸ©
      rintro âŸ¨s, srâŸ©
      apply Nat.not_succ_le_self (Fintype.card Îº)
      rw [â† Nat.add_one, â† sr, â† Multiset.card_map, â† Finset.card_mk]
      exact Finset.card_le_univ âŸ¨_, s.distinct_colorsâŸ©
    intro r
    induction' r with r ihr
    Â· exact âŸ¨Empty, inferInstance, fun C => Or.inl âŸ¨default, Multiset.card_zeroâŸ©âŸ©
    obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := ihr
    specialize ihÎ± ((Î¹ â†’ Option Î±) â†’ Îº)
    obtain âŸ¨Î¹', _inst, hÎ¹'âŸ© := ihÎ±
    refine âŸ¨Sum Î¹ Î¹', inferInstance, ?_âŸ©
    intro C
    specialize hÎ¹' fun v' v => C (Sum.elim v (some âˆ˜ v'))
    obtain âŸ¨l', C', hl'âŸ© := hÎ¹'
    have mono_of_mono : (âˆƒ l, IsMono C' l) â†’ âˆƒ l, IsMono C l := by
      rintro âŸ¨l, c, hlâŸ©
      refine âŸ¨l.horizontal (some âˆ˜ l' (Classical.arbitrary Î±)), c, fun x => ?_âŸ©
      rw [Line.horizontal_apply, â† hl, â† hl']
    specialize hÎ¹ C'
    rcases hÎ¹ with (âŸ¨s, srâŸ© | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : âˆƒ p âˆˆ s.lines, (p : AlmostMono _).color = C' s.focus
    Â· obtain âŸ¨p, p_mem, hpâŸ© := h
      refine Or.inr (mono_of_mono âŸ¨p.line, p.color, ?_âŸ©)
      rintro (_ | _)
      Â· rw [hp, s.is_focused p p_mem]
      Â· apply p.has_color
    refine Or.inl âŸ¨âŸ¨(s.lines.map ?_).cons âŸ¨(l'.map some).vertical s.focus, C' s.focus, fun x => ?_âŸ©,
            Sum.elim s.focus (l'.map some none), ?_, ?_âŸ©, ?_âŸ©
    Â· refine fun p => âŸ¨p.line.prod (l'.map some), p.color, fun x => ?_âŸ©
      rw [Line.prod_apply, Line.map_apply, â† p.has_color, â† congr_fun (hl' x)]
    Â· rw [vertical_apply, â† congr_fun (hl' x), Line.map_apply]
    Â· simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | âŸ¨q, hq, rflâŸ©)
      Â· simp only [vertical_apply]
      Â· simp only [prod_apply, s.is_focused q hq]
    Â· rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact âŸ¨fun âŸ¨q, hq, heâŸ© => h âŸ¨q, hq, heâŸ©, s.distinct_colorsâŸ©
    Â· rw [Multiset.card_cons, Multiset.card_map, sr])"
Mathlib/RingTheory/Polynomial/Pochhammer.lean,descPochhammer_mul,descPochhammer_mul,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' m with m ih
  Â· simp
  Â· rw [descPochhammer_succ_right, Polynomial.mul_X_sub_intCast_comp, â† mul_assoc, ih,
      Nat.succ_eq_add_one, â† add_assoc, descPochhammer_succ_right, Nat.cast_add, sub_add_eq_sub_sub]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ
R : Type u
instâœ : Ring R
n m : â„•
ih : descPochhammer R n * (descPochhammer R m).comp (X - â†‘n) = descPochhammer R (n + m)
âŠ¢ descPochhammer R (n + m) * (X - â†‘n - â†‘m) = descPochhammer R (n + (m + 1))","theorem descPochhammer_mul (n m : â„•) :
    descPochhammer R n * (descPochhammer R m).comp (X - (n : R[X])) = descPochhammer R (n + m) ",":= by
  induction' m with m ih
  Â· simp
  Â· rw [descPochhammer_succ_right, Polynomial.mul_X_sub_intCast_comp, â† mul_assoc, ih,
      â† add_assoc, descPochhammer_succ_right, Nat.cast_add, sub_add_eq_sub_sub]"
Mathlib/LinearAlgebra/BilinearForm/Properties.lean,LinearMap.BilinForm.dualBasis_dualBasis,dualBasis_dualBasis,31c261277bc3e8a52b74d248691ef6b40c75b452,":=
  LinearMap.BilinForm.dualBasis_dualBasis_flip (BilinForm.toLin B) hB b","warning:  `LinearMap.BilinForm.toLin` has been deprecated
error:  fail to show termination for
  LinearMap.BilinForm.dualBasis_dualBasis_flip
with errors
structural recursion cannot be used:

argument #1 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #2 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #3 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #4 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #5 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #6 cannot be used for structural recursion
  it is unchanged in the recursive calls

argument #7 cannot be used for structural recursion
  its type does not have a recursor

argument #8 cannot be used for structural recursion
  its type is not an inductive

argument #9 cannot be used for structural recursion
  its type is not an inductive

argument #10 cannot be used for structural recursion
  its type does not have a recursor

argument #11 cannot be used for structural recursion
  its type is not an inductive

argument #12 cannot be used for structural recursion
  its type does not have a recursor

Could not find a decreasing measure.
The arguments relate at each recursive call as follows:
(<, â‰¤, =: relation proved, ? all proofs failed, _: no proof attempted)
           
1) 357:2-71
Please use `termination_by` to specify a decreasing measure.","lemma dualBasis_dualBasis_flip (B : BilinForm K V) (hB : B.Nondegenerate) {Î¹}
    [Finite Î¹] [DecidableEq Î¹] (b : Basis Î¹ K V) :
    B.dualBasis hB (B.flip.dualBasis hB.flip b) = b ",":= by
  ext i
  refine LinearMap.ker_eq_bot.mp hB.ker_eq_bot ((B.flip.dualBasis hB.flip b).ext (fun j â†¦ ?_))
  simp_rw [apply_dualBasis_left, â† B.flip_apply, apply_dualBasis_left, @eq_comm _ i j]"
Mathlib/Geometry/Euclidean/Inversion/Calculus.lean,EuclideanGeometry.hasFDerivAt_inversion,hasFDerivAt_inversion,1aadd4f4012334f6f1cd811e685b9c75a27ee9ed,":= by
  rcases add_left_surjective c x with âŸ¨x, rflâŸ©
  have : HasFDerivAt (inversion c R) (_ : F â†’L[â„] F) (c + x)
  Â· simp_rw [inversion, dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ğ•œ := â„) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := â„ âˆ™ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy â†¦ ?_)
  Â· have : ((â€–xâ€– ^ 2) ^ 2)â»Â¹ * (â€–xâ€– ^ 2) = (â€–xâ€– ^ 2)â»Â¹
    Â· rw [â† div_eq_inv_mul, sq (â€–xâ€– ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  Â· simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]","error:  unexpected token 'Â·'; expected '|'
error:  don't know how to synthesize placeholder for argument 'f''
context:
E : Type u_1
F : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace â„ E
instâœÂ¹ : NormedAddCommGroup F
instâœ : InnerProductSpace â„ F
a b c d y z : F
r R : â„
x : F
hx : (fun x â†¦ c + x) x â‰  c
âŠ¢ F â†’L[â„] F
error:  unsolved goals
case intro
E : Type u_1
F : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace â„ E
instâœÂ¹ : NormedAddCommGroup F
instâœ : InnerProductSpace â„ F
a b c d y z : F
r R : â„
x : F
hx : (fun x â†¦ c + x) x â‰  c
âŠ¢ HasFDerivAt (inversion c R)
    ((R / dist ((fun x â†¦ c + x) x) c) ^ 2 â€¢
      â†‘{ toLinearEquiv := (reflection (Submodule.span â„ {(fun x â†¦ c + x) x - c})á—®).toLinearEquiv, continuous_toFun := â‹¯,
          continuous_invFun := â‹¯ })
    ((fun x â†¦ c + x) x)","theorem hasFDerivAt_inversion (hx : x â‰  c) :
    HasFDerivAt (inversion c R)
      ((R / dist x c) ^ 2 â€¢ (reflection (â„ âˆ™ (x - c))á—® : F â†’L[â„] F)) x ",":= by
  rcases add_left_surjective c x with âŸ¨x, rflâŸ©
  have : HasFDerivAt (inversion c R) (?_ : F â†’L[â„] F) (c + x) := by
    simp only [inversion_def]
    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]
    have A := (hasFDerivAt_id (ğ•œ := â„) (c + x)).sub_const c
    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul
      (R ^ 2)
    exact (B.smul A).add_const c
  refine this.congr_fderiv (LinearMap.ext_on_codisjoint
    (Submodule.isCompl_orthogonal_of_completeSpace (K := â„ âˆ™ x)).codisjoint
    (LinearMap.eqOn_span' ?_) fun y hy â†¦ ?_)
  Â· have : ((â€–xâ€– ^ 2) ^ 2)â»Â¹ * (â€–xâ€– ^ 2) = (â€–xâ€– ^ 2)â»Â¹ := by
      rw [â† div_eq_inv_mul, sq (â€–xâ€– ^ 2), div_self_mul_self']
    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,
      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]
  Â· simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,
      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]"
Mathlib/MeasureTheory/Constructions/Polish.lean,MeasureTheory.measurableSet_range_of_continuous_injective,measurableSet_range_of_continuous_injective,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  letI := upgradePolishSpace Î³
  obtain âŸ¨b, b_count, b_nonempty, hbâŸ© :
    âˆƒ b : Set (Set Î³), b.Countable âˆ§ âˆ… âˆ‰ b âˆ§ IsTopologicalBasis b := exists_countable_basis Î³
  haveI : Encodable b := b_count.toEncodable
  let A := { p : b Ã— b // Disjoint (p.1 : Set Î³) p.2 }
  have : âˆ€ p : A, âˆƒ q : Set Î²,
      f '' (p.1.1 : Set Î³) âŠ† q âˆ§ Disjoint (f '' (p.1.2 : Set Î³)) q âˆ§ MeasurableSet q := by
    intro p
    apply
      AnalyticSet.measurablySeparable ((hb.isOpen p.1.1.2).analyticSet_image f_cont)
        ((hb.isOpen p.1.2.2).analyticSet_image f_cont)
    exact Disjoint.image p.2 (f_inj.injOn univ) (subset_univ _) (subset_univ _)
  choose q hq1 hq2 q_meas using this
  let E : b â†’ Set Î² := fun s =>
    closure (f '' s) âˆ© â‹‚ (t : b) (ht : Disjoint s.1 t.1), q âŸ¨(s, t), htâŸ© \ q âŸ¨(t, s), ht.symmâŸ©
  obtain âŸ¨u, u_anti, u_pos, u_limâŸ© :
      âˆƒ u : â„• â†’ â„, StrictAnti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=
    exists_seq_strictAnti_tendsto (0 : â„)
  let F : â„• â†’ Set Î² := fun n => â‹ƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), E s
  suffices range f = â‹‚ n, F n by
    have E_meas : âˆ€ s : b, MeasurableSet (E s) := by
      intro b
      refine isClosed_closure.measurableSet.inter ?_
      refine MeasurableSet.iInter fun s => ?_
      exact MeasurableSet.iInter fun hs => (q_meas _).diff (q_meas _)
    have F_meas : âˆ€ n, MeasurableSet (F n) := by
      intro n
      refine MeasurableSet.iUnion fun s => ?_
      exact MeasurableSet.iUnion fun _ => E_meas _
    rw [this]
    exact MeasurableSet.iInter fun n => F_meas n
  apply Subset.antisymm
  Â· rintro x âŸ¨y, rflâŸ©
    refine mem_iInter.2 fun n => ?_
    obtain âŸ¨s, sb, ys, hsâŸ© : âˆƒ (s : Set Î³), s âˆˆ b âˆ§ y âˆˆ s âˆ§ s âŠ† ball y (u n / 2) := by
      apply hb.mem_nhds_iff.1
      exact ball_mem_nhds _ (half_pos (u_pos n))
    have diam_s : diam s â‰¤ u n := by
      apply (diam_mono hs isBounded_ball).trans
      convert diam_ball (x := y) (half_pos (u_pos n)).le
      ring
    refine mem_iUnion.2 âŸ¨âŸ¨s, sbâŸ©, ?_âŸ©
    refine mem_iUnion.2 âŸ¨âŸ¨isBounded_ball.subset hs, diam_sâŸ©, ?_âŸ©
    apply mem_inter (subset_closure (mem_image_of_mem _ ys))
    refine mem_iInter.2 fun t => mem_iInter.2 fun ht => âŸ¨?_, ?_âŸ©
    Â· apply hq1
      exact mem_image_of_mem _ ys
    Â· apply disjoint_left.1 (hq2 âŸ¨(t, âŸ¨s, sbâŸ©), ht.symmâŸ©)
      exact mem_image_of_mem _ ys
  Â· intro x hx
    have C1 : âˆ€ n, âˆƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), x âˆˆ E s := fun n => by
      simpa only [F, mem_iUnion] using mem_iInter.1 hx n
    choose s hs hxs using C1
    have C2 : âˆ€ n, (s n).1.Nonempty := by
      intro n
      rw [nonempty_iff_ne_empty]
      intro hn
      have := (s n).2
      rw [hn] at this
      exact b_nonempty this
    choose y hy using C2
    have I : âˆ€ m n, ((s m).1 âˆ© (s n).1).Nonempty := by
      intro m n
      rw [â† not_disjoint_iff_nonempty_inter]
      by_contra! h
      have A : x âˆˆ q âŸ¨(s m, s n), hâŸ© \ q âŸ¨(s n, s m), h.symmâŸ© :=
        haveI := mem_iInter.1 (hxs m).2 (s n)
        (mem_iInter.1 this h : _)
      have B : x âˆˆ q âŸ¨(s n, s m), h.symmâŸ© \ q âŸ¨(s m, s n), hâŸ© :=
        haveI := mem_iInter.1 (hxs n).2 (s m)
        (mem_iInter.1 this h.symm : _)
      exact A.2 B.1
    have cauchy_y : CauchySeq y := by
      have : Tendsto (fun n => 2 * u n) atTop (ğ“ 0) := by
        simpa only [mul_zero] using u_lim.const_mul 2
      refine cauchySeq_of_le_tendsto_0' (fun n => 2 * u n) (fun m n hmn => ?_) this
      rcases I m n with âŸ¨z, zsm, zsnâŸ©
      calc
        dist (y m) (y n) â‰¤ dist (y m) z + dist z (y n) := dist_triangle _ _ _
        _ â‰¤ u m + u n :=
          (add_le_add ((dist_le_diam_of_mem (hs m).1 (hy m) zsm).trans (hs m).2)
            ((dist_le_diam_of_mem (hs n).1 zsn (hy n)).trans (hs n).2))
        _ â‰¤ 2 * u m := by linarith [u_anti.antitone hmn]
    haveI : Nonempty Î³ := âŸ¨y 0âŸ©
    let z := limUnder atTop y
    have y_lim : Tendsto y atTop (ğ“ z) := cauchy_y.tendsto_limUnder
    suffices f z = x by
      rw [â† this]
      exact mem_range_self _
    by_contra! hne
    obtain âŸ¨v, w, v_open, w_open, fzv, xw, hvwâŸ© := t2_separation hne
    obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´ > (0 : â„), ball z Î´ âŠ† f â»Â¹' v := by
      apply Metric.mem_nhds_iff.1
      exact f_cont.continuousAt.preimage_mem_nhds (v_open.mem_nhds fzv)
    obtain âŸ¨n, hnâŸ© : âˆƒ n, u n + dist (y n) z < Î´ :=
      haveI : Tendsto (fun n => u n + dist (y n) z) atTop (ğ“ 0) := by
        simpa only [add_zero] using u_lim.add (tendsto_iff_dist_tendsto_zero.1 y_lim)
      ((tendsto_order.1 this).2 _ Î´pos).exists
    have fsnv : f '' s n âŠ† v := by
      rw [image_subset_iff]
      apply Subset.trans _ hÎ´
      intro a ha
      calc
        dist a z â‰¤ dist a (y n) + dist (y n) z := dist_triangle _ _ _
        _ â‰¤ u n + dist (y n) z :=
          (add_le_add_right ((dist_le_diam_of_mem (hs n).1 ha (hy n)).trans (hs n).2) _)
        _ < Î´ := hn
    have : x âˆˆ closure v := closure_mono fsnv (hxs n).1
    exact disjoint_left.1 (hvw.closure_left w_open) this xw","error:  application type mismatch
  Disjoint.image p.property (Injective.injOn f_inj ?m.51560)
argument
  Injective.injOn f_inj ?m.51560
has type
  âˆ€ â¦ƒxâ‚‚ : Î³â¦„, xâ‚‚ âˆˆ ?m.51281 â†’ f ?m.51282 = f xâ‚‚ â†’ ?m.51282 = xâ‚‚ : Prop
but is expected to have type
  InjOn f ?m.51227 : Prop
error:  application type mismatch
  Injective.injOn f_inj univ
argument
  univ
has type
  Set ?m.51284 : Type ?u.51283
but is expected to have type
  ?m.51282 âˆˆ ?m.51281 : Prop","theorem measurableSet_range_of_continuous_injective {Î² : Type*} [TopologicalSpace Î³]
    [PolishSpace Î³] [TopologicalSpace Î²] [T2Space Î²] [MeasurableSpace Î²] [OpensMeasurableSpace Î²]
    {f : Î³ â†’ Î²} (f_cont : Continuous f) (f_inj : Injective f) :
    MeasurableSet (range f) ",":= by
  letI := upgradePolishSpace Î³
  obtain âŸ¨b, b_count, b_nonempty, hbâŸ© :
    âˆƒ b : Set (Set Î³), b.Countable âˆ§ âˆ… âˆ‰ b âˆ§ IsTopologicalBasis b := exists_countable_basis Î³
  haveI : Encodable b := b_count.toEncodable
  let A := { p : b Ã— b // Disjoint (p.1 : Set Î³) p.2 }
  have : âˆ€ p : A, âˆƒ q : Set Î²,
      f '' (p.1.1 : Set Î³) âŠ† q âˆ§ Disjoint (f '' (p.1.2 : Set Î³)) q âˆ§ MeasurableSet q := by
    intro p
    apply
      AnalyticSet.measurablySeparable ((hb.isOpen p.1.1.2).analyticSet_image f_cont)
        ((hb.isOpen p.1.2.2).analyticSet_image f_cont)
    exact Disjoint.image p.2 f_inj.injOn (subset_univ _) (subset_univ _)
  choose q hq1 hq2 q_meas using this
  let E : b â†’ Set Î² := fun s =>
    closure (f '' s) âˆ© â‹‚ (t : b) (ht : Disjoint s.1 t.1), q âŸ¨(s, t), htâŸ© \ q âŸ¨(t, s), ht.symmâŸ©
  obtain âŸ¨u, u_anti, u_pos, u_limâŸ© :
      âˆƒ u : â„• â†’ â„, StrictAnti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=
    exists_seq_strictAnti_tendsto (0 : â„)
  let F : â„• â†’ Set Î² := fun n => â‹ƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), E s
  suffices range f = â‹‚ n, F n by
    have E_meas : âˆ€ s : b, MeasurableSet (E s) := by
      intro b
      refine isClosed_closure.measurableSet.inter ?_
      refine MeasurableSet.iInter fun s => ?_
      exact MeasurableSet.iInter fun hs => (q_meas _).diff (q_meas _)
    have F_meas : âˆ€ n, MeasurableSet (F n) := by
      intro n
      refine MeasurableSet.iUnion fun s => ?_
      exact MeasurableSet.iUnion fun _ => E_meas _
    rw [this]
    exact MeasurableSet.iInter fun n => F_meas n
  apply Subset.antisymm
  Â· rintro x âŸ¨y, rflâŸ©
    refine mem_iInter.2 fun n => ?_
    obtain âŸ¨s, sb, ys, hsâŸ© : âˆƒ (s : Set Î³), s âˆˆ b âˆ§ y âˆˆ s âˆ§ s âŠ† ball y (u n / 2) := by
      apply hb.mem_nhds_iff.1
      exact ball_mem_nhds _ (half_pos (u_pos n))
    have diam_s : diam s â‰¤ u n := by
      apply (diam_mono hs isBounded_ball).trans
      convert diam_ball (x := y) (half_pos (u_pos n)).le
      ring
    refine mem_iUnion.2 âŸ¨âŸ¨s, sbâŸ©, ?_âŸ©
    refine mem_iUnion.2 âŸ¨âŸ¨isBounded_ball.subset hs, diam_sâŸ©, ?_âŸ©
    apply mem_inter (subset_closure (mem_image_of_mem _ ys))
    refine mem_iInter.2 fun t => mem_iInter.2 fun ht => âŸ¨?_, ?_âŸ©
    Â· apply hq1
      exact mem_image_of_mem _ ys
    Â· apply disjoint_left.1 (hq2 âŸ¨(t, âŸ¨s, sbâŸ©), ht.symmâŸ©)
      exact mem_image_of_mem _ ys
  Â· intro x hx
    have C1 : âˆ€ n, âˆƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), x âˆˆ E s := fun n => by
      simpa only [F, mem_iUnion] using mem_iInter.1 hx n
    choose s hs hxs using C1
    have C2 : âˆ€ n, (s n).1.Nonempty := by
      intro n
      rw [nonempty_iff_ne_empty]
      intro hn
      have := (s n).2
      rw [hn] at this
      exact b_nonempty this
    choose y hy using C2
    have I : âˆ€ m n, ((s m).1 âˆ© (s n).1).Nonempty := by
      intro m n
      rw [â† not_disjoint_iff_nonempty_inter]
      by_contra! h
      have A : x âˆˆ q âŸ¨(s m, s n), hâŸ© \ q âŸ¨(s n, s m), h.symmâŸ© :=
        haveI := mem_iInter.1 (hxs m).2 (s n)
        (mem_iInter.1 this h : _)
      have B : x âˆˆ q âŸ¨(s n, s m), h.symmâŸ© \ q âŸ¨(s m, s n), hâŸ© :=
        haveI := mem_iInter.1 (hxs n).2 (s m)
        (mem_iInter.1 this h.symm : _)
      exact A.2 B.1
    have cauchy_y : CauchySeq y := by
      have : Tendsto (fun n => 2 * u n) atTop (ğ“ 0) := by
        simpa only [mul_zero] using u_lim.const_mul 2
      refine cauchySeq_of_le_tendsto_0' (fun n => 2 * u n) (fun m n hmn => ?_) this
      rcases I m n with âŸ¨z, zsm, zsnâŸ©
      calc
        dist (y m) (y n) â‰¤ dist (y m) z + dist z (y n) := dist_triangle _ _ _
        _ â‰¤ u m + u n :=
          (add_le_add ((dist_le_diam_of_mem (hs m).1 (hy m) zsm).trans (hs m).2)
            ((dist_le_diam_of_mem (hs n).1 zsn (hy n)).trans (hs n).2))
        _ â‰¤ 2 * u m := by linarith [u_anti.antitone hmn]
    haveI : Nonempty Î³ := âŸ¨y 0âŸ©
    let z := limUnder atTop y
    have y_lim : Tendsto y atTop (ğ“ z) := cauchy_y.tendsto_limUnder
    suffices f z = x by
      rw [â† this]
      exact mem_range_self _
    by_contra! hne
    obtain âŸ¨v, w, v_open, w_open, fzv, xw, hvwâŸ© := t2_separation hne
    obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´ > (0 : â„), ball z Î´ âŠ† f â»Â¹' v := by
      apply Metric.mem_nhds_iff.1
      exact f_cont.continuousAt.preimage_mem_nhds (v_open.mem_nhds fzv)
    obtain âŸ¨n, hnâŸ© : âˆƒ n, u n + dist (y n) z < Î´ :=
      haveI : Tendsto (fun n => u n + dist (y n) z) atTop (ğ“ 0) := by
        simpa only [add_zero] using u_lim.add (tendsto_iff_dist_tendsto_zero.1 y_lim)
      ((tendsto_order.1 this).2 _ Î´pos).exists
    have fsnv : f '' s n âŠ† v := by
      rw [image_subset_iff]
      apply Subset.trans _ hÎ´
      intro a ha
      calc
        dist a z â‰¤ dist a (y n) + dist (y n) z := dist_triangle _ _ _
        _ â‰¤ u n + dist (y n) z :=
          (add_le_add_right ((dist_le_diam_of_mem (hs n).1 ha (hy n)).trans (hs n).2) _)
        _ < Î´ := hn
    have : x âˆˆ closure v := closure_mono fsnv (hxs n).1
    exact disjoint_left.1 (hvw.closure_left w_open) this xw"
Mathlib/GroupTheory/CoprodI.lean,FreeGroup.injective_lift_of_ping_pong,_root_.FreeGroup.injective_lift_of_ping_pong,9d3887769246754772c178dd6c594378dce58448,":= by
  have : FreeGroup.lift a =
      (CoprodI.lift fun i => FreeGroup.lift fun _ => a i).comp
        (@freeGroupEquivCoprodI Î¹).toMonoidHom := by
    ext i
    simp
  rw [this, MonoidHom.coe_comp]
  clear this
  refine' Function.Injective.comp _ (MulEquiv.injective freeGroupEquivCoprodI)
  show Function.Injective (lift fun i : Î¹ => FreeGroup.lift fun _ => a i)
  let H : Î¹ â†’ Type _ := fun _i => FreeGroup Unit
  let f : âˆ€ i, H i â†’* G := fun i => FreeGroup.lift fun _ => a i
  let X' : Î¹ â†’ Set Î± := fun i => X i âˆª Y i
  apply lift_injective_of_ping_pong f _ X'
  Â· show âˆ€ i, (X' i).Nonempty
    exact fun i => Set.Nonempty.inl (hXnonempty i)
  Â· show Pairwise fun i j => Disjoint (X' i) (X' j)
    intro i j hij
    simp only [X']
    apply Disjoint.union_left <;> apply Disjoint.union_right
    Â· exact hXdisj hij
    Â· exact hXYdisj i j
    Â· exact (hXYdisj j i).symm
    Â· exact hYdisj hij
  Â· show Pairwise fun i j => âˆ€ h : H i, h â‰  1 â†’ f i h â€¢ X' j âŠ† X' i
    rintro i j hij
    refine' FreeGroup.freeGroupUnitEquivInt.forall_congr_left'.mpr _
    intro n hne1
    change FreeGroup.lift (fun _ => a i) (FreeGroup.of () ^ n) â€¢ X' j âŠ† X' i
    simp only [map_zpow, FreeGroup.lift.of]
    change a i ^ n â€¢ X' j âŠ† X' i
    have hnne0 : n â‰  0 := by
      rintro rfl
      apply hne1
      simp [H]; rfl
    clear hne1
    simp only [X']
    cases' (lt_or_gt_of_ne hnne0).symm with hlt hgt
    Â· have h1n : 1 â‰¤ n := hlt
      calc
        a i ^ n â€¢ X' j âŠ† a i ^ n â€¢ (Y i)á¶œ :=
          smul_set_mono ((hXYdisj j i).union_left <| hYdisj hij.symm).subset_compl_right
        _ âŠ† X i := by
          clear hnne0 hlt
          refine Int.le_induction (P := fun n => a i ^ n â€¢ (Y i)á¶œ âŠ† X i) ?_ ?_ n h1n
          Â· dsimp
            rw [zpow_one]
            exact hX i
          Â· dsimp
            intro n _hle hi
            calc
              a i ^ (n + 1) â€¢ (Y i)á¶œ = (a i ^ n * a i) â€¢ (Y i)á¶œ := by rw [zpow_add, zpow_one]
              _ = a i ^ n â€¢ a i â€¢ (Y i)á¶œ := MulAction.mul_smul _ _ _
              _ âŠ† a i ^ n â€¢ X i := smul_set_mono <| hX i
              _ âŠ† a i ^ n â€¢ (Y i)á¶œ := smul_set_mono (hXYdisj i i).subset_compl_right
              _ âŠ† X i := hi
        _ âŠ† X' i := Set.subset_union_left _ _
    Â· have h1n : n â‰¤ -1 := by
        apply Int.le_of_lt_add_one
        simpa using hgt
      calc
        a i ^ n â€¢ X' j âŠ† a i ^ n â€¢ (X i)á¶œ :=
          smul_set_mono ((hXdisj hij.symm).union_left (hXYdisj i j).symm).subset_compl_right
        _ âŠ† Y i := by
          refine' Int.le_induction_down (P := fun n => a i ^ n â€¢ (X i)á¶œ âŠ† Y i) _ _ _ h1n
          Â· dsimp
            rw [zpow_neg, zpow_one]
            exact hY i
          Â· dsimp
            intro n _ hi
            calc
              a i ^ (n - 1) â€¢ (X i)á¶œ = (a i ^ n * (a i)â»Â¹) â€¢ (X i)á¶œ := by rw [zpow_sub, zpow_one]
              _ = a i ^ n â€¢ (a i)â»Â¹ â€¢ (X i)á¶œ := MulAction.mul_smul _ _ _
              _ âŠ† a i ^ n â€¢ Y i := smul_set_mono <| hY i
              _ âŠ† a i ^ n â€¢ (X i)á¶œ := smul_set_mono (hXYdisj i i).symm.subset_compl_right
              _ âŠ† Y i := hi
        _ âŠ† X' i := Set.subset_union_right _ _
  show _ âˆ¨ âˆƒ i, 3 â‰¤ #(H i)
  inhabit Î¹
  right
  use Inhabited.default
  simp only [H]
  rw [FreeGroup.freeGroupUnitEquivInt.cardinal_eq, Cardinal.mk_denumerable]
  apply le_of_lt
  exact nat_lt_aleph0 3","warning:  `Equiv.forall_congr_left'` has been deprecated, use `Equiv.forall_congr_left` instead
error:  function expected at
  subset_union_left ?m.403394
term has type
  ?m.403393 âˆˆ ?m.403391 âˆª ?m.403392
error:  function expected at
  subset_union_right ?m.412891
term has type
  ?m.412890 âˆˆ ?m.412888 âˆª ?m.412889",theorem _root_.FreeGroup.injective_lift_of_ping_pong : Function.Injective (FreeGroup.lift a) ,":= by
  have : FreeGroup.lift a =
      (CoprodI.lift fun i => FreeGroup.lift fun _ => a i).comp
        (@freeGroupEquivCoprodI Î¹).toMonoidHom := by
    ext i
    simp
  rw [this, MonoidHom.coe_comp]
  clear this
  refine Function.Injective.comp ?_ (MulEquiv.injective freeGroupEquivCoprodI)
  show Function.Injective (lift fun i : Î¹ => FreeGroup.lift fun _ => a i)
  let H : Î¹ â†’ Type _ := fun _i => FreeGroup Unit
  let f : âˆ€ i, H i â†’* G := fun i => FreeGroup.lift fun _ => a i
  let X' : Î¹ â†’ Set Î± := fun i => X i âˆª Y i
  apply lift_injective_of_ping_pong f _ X'
  Â· show âˆ€ i, (X' i).Nonempty
    exact fun i => Set.Nonempty.inl (hXnonempty i)
  Â· show Pairwise fun i j => Disjoint (X' i) (X' j)
    intro i j hij
    simp only [X']
    apply Disjoint.union_left <;> apply Disjoint.union_right
    Â· exact hXdisj hij
    Â· exact hXYdisj i j
    Â· exact (hXYdisj j i).symm
    Â· exact hYdisj hij
  Â· show Pairwise fun i j => âˆ€ h : H i, h â‰  1 â†’ f i h â€¢ X' j âŠ† X' i
    rintro i j hij
    refine FreeGroup.freeGroupUnitEquivInt.forall_congr_left.mpr ?_
    intro n hne1
    change FreeGroup.lift (fun _ => a i) (FreeGroup.of () ^ n) â€¢ X' j âŠ† X' i
    simp only [map_zpow, FreeGroup.lift.of]
    change a i ^ n â€¢ X' j âŠ† X' i
    have hnne0 : n â‰  0 := by
      rintro rfl
      apply hne1
      simp [H]; rfl
    clear hne1
    simp only [X']
    cases' (lt_or_gt_of_ne hnne0).symm with hlt hgt
    Â· have h1n : 1 â‰¤ n := hlt
      calc
        a i ^ n â€¢ X' j âŠ† a i ^ n â€¢ (Y i)á¶œ :=
          smul_set_mono ((hXYdisj j i).union_left <| hYdisj hij.symm).subset_compl_right
        _ âŠ† X i := by
          clear hnne0 hlt
          refine Int.le_induction (P := fun n => a i ^ n â€¢ (Y i)á¶œ âŠ† X i) ?_ ?_ n h1n
          Â· dsimp
            rw [zpow_one]
            exact hX i
          Â· dsimp
            intro n _hle hi
            calc
              a i ^ (n + 1) â€¢ (Y i)á¶œ = (a i ^ n * a i) â€¢ (Y i)á¶œ := by rw [zpow_add, zpow_one]
              _ = a i ^ n â€¢ a i â€¢ (Y i)á¶œ := MulAction.mul_smul _ _ _
              _ âŠ† a i ^ n â€¢ X i := smul_set_mono <| hX i
              _ âŠ† a i ^ n â€¢ (Y i)á¶œ := smul_set_mono (hXYdisj i i).subset_compl_right
              _ âŠ† X i := hi
        _ âŠ† X' i := Set.subset_union_left
    Â· have h1n : n â‰¤ -1 := by
        apply Int.le_of_lt_add_one
        simpa using hgt
      calc
        a i ^ n â€¢ X' j âŠ† a i ^ n â€¢ (X i)á¶œ :=
          smul_set_mono ((hXdisj hij.symm).union_left (hXYdisj i j).symm).subset_compl_right
        _ âŠ† Y i := by
          refine Int.le_induction_down (P := fun n => a i ^ n â€¢ (X i)á¶œ âŠ† Y i) ?_ ?_ _ h1n
          Â· dsimp
            rw [zpow_neg, zpow_one]
            exact hY i
          Â· dsimp
            intro n _ hi
            calc
              a i ^ (n - 1) â€¢ (X i)á¶œ = (a i ^ n * (a i)â»Â¹) â€¢ (X i)á¶œ := by rw [zpow_sub, zpow_one]
              _ = a i ^ n â€¢ (a i)â»Â¹ â€¢ (X i)á¶œ := MulAction.mul_smul _ _ _
              _ âŠ† a i ^ n â€¢ Y i := smul_set_mono <| hY i
              _ âŠ† a i ^ n â€¢ (X i)á¶œ := smul_set_mono (hXYdisj i i).symm.subset_compl_right
              _ âŠ† Y i := hi
        _ âŠ† X' i := Set.subset_union_right
  show _ âˆ¨ âˆƒ i, 3 â‰¤ #(H i)
  inhabit Î¹
  right
  use Inhabited.default
  simp only [H]
  rw [FreeGroup.freeGroupUnitEquivInt.cardinal_eq, Cardinal.mk_denumerable]
  apply le_of_lt
  exact nat_lt_aleph0 3"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOnFilter,hasFDerivAt_of_tendstoUniformlyOnFilter,56d6c36569bfa5f38809662c438716c5f84ec909,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)","warning:  `Prod_map` has been deprecated, use `Prod.map_apply` instead
error:  type mismatch
  ContinuousLinearMap.le_opNorm (f' n.1 x - g' x) (n.2 - x)
has type
  â€–(f' n.1 x - g' x) (n.2 - x)â€– â‰¤ â€–f' n.1 x - g' xâ€– * â€–n.2 - xâ€– : Prop
but is expected to have type
  â€–(f' n.1 x - g' x) (n.2 - x)â€– â‰¤ â€–(Prod.map (fun n â†¦ g' x - f' n x) id n).1â€– * â€–x - n.2â€– : Prop","theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ğ“ x))
    (hf : âˆ€á¶  n : Î¹ Ã— E in l Ã—Ë¢ ğ“ x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : âˆ€á¶  y in ğ“ x, Tendsto (fun n => f n y) l (ğ“ (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)"
Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean,MeasureTheory.Measure.integral_toReal_rnDeriv,integral_toReal_rnDeriv,069e96204afb60639e37cc18449fd7f58ab913c1,":= by
  rw [â† integral_univ, set_integral_toReal_rnDeriv hÎ¼Î½ MeasurableSet.univ]","warning:  `MeasureTheory.Measure.set_integral_toReal_rnDeriv` has been deprecated, use `MeasureTheory.Measure.setIntegral_toReal_rnDeriv` instead
error:  application type mismatch
  set_integral_toReal_rnDeriv hÎ¼Î½ MeasurableSet.univ
argument
  MeasurableSet.univ
has type
  MeasurableSet Set.univ : Prop
but is expected to have type
  Set Î± : Type u_1","lemma integral_toReal_rnDeriv [SigmaFinite Î¼] [SigmaFinite Î½] (hÎ¼Î½ : Î¼ â‰ª Î½) :
    âˆ« x, (Î¼.rnDeriv Î½ x).toReal âˆ‚Î½ = (Î¼ Set.univ).toReal ",":= by
  rw [â† integral_univ, setIntegral_toReal_rnDeriv hÎ¼Î½ Set.univ]"
Mathlib/NumberTheory/NumberField/CanonicalEmbedding/Basic.lean,NumberField.mixedEmbedding.stdBasis_repr_eq_matrixToStdBasis_mul,stdBasis_repr_eq_matrixToStdBasis_mul,d668f9703aef3d591f5299b13ae554349e37c161,":= by
  simp_rw [commMap, matrixToStdBasis, LinearMap.coe_mk, AddHom.coe_mk,
    mulVec, dotProduct, Function.comp_apply, index, Fintype.sum_sum_type,
    diagonal_one, reindex_apply, â† Finset.univ_product_univ, Finset.sum_product,
    indexEquiv_apply_ofIsReal, Fin.sum_univ_two, indexEquiv_apply_ofIsComplex_fst,
    indexEquiv_apply_ofIsComplex_snd, smul_of, smul_cons, smul_eq_mul,
    mul_one, smul_empty, Equiv.prodComm_symm, Equiv.coe_prodComm]
  cases c with
  | inl w =>
      simp_rw [stdBasis_repr_apply_ofIsReal, fromBlocks_applyâ‚â‚, fromBlocks_applyâ‚â‚‚,
        one_apply, Matrix.zero_apply, ite_mul, one_mul, zero_mul, Finset.sum_ite_eq,
        Finset.mem_univ, ite_true, add_zero, Finset.sum_const_zero, add_zero,
        â† conj_eq_iff_re, hx (embedding w.val), conjugate_embedding_eq_of_isReal w.prop]
  | inr c =>
    rcases c with âŸ¨w, jâŸ©
    fin_cases j
    Â· simp_rw [Fin.mk_zero, stdBasis_repr_apply_ofIsComplex_fst, fromBlocks_applyâ‚‚â‚,
        fromBlocks_applyâ‚‚â‚‚, Matrix.zero_apply, submatrix_apply,
        blockDiagonal_apply, Prod.swap_prod_mk, ite_mul, zero_mul, Finset.sum_const_zero,
        zero_add, Finset.sum_add_distrib, Finset.sum_ite_eq, Finset.mem_univ, ite_true,
        of_apply, cons_val', cons_val_zero, cons_val_one,
        head_cons, â† hx (embedding w), re_eq_add_conj]
      field_simp
    Â· simp_rw [Fin.mk_one, stdBasis_repr_apply_ofIsComplex_snd, fromBlocks_applyâ‚‚â‚,
        fromBlocks_applyâ‚‚â‚‚, Matrix.zero_apply, submatrix_apply,
        blockDiagonal_apply, Prod.swap_prod_mk, ite_mul, zero_mul, Finset.sum_const_zero,
        zero_add, Finset.sum_add_distrib, Finset.sum_ite_eq, Finset.mem_univ, ite_true,
        of_apply, cons_val', cons_val_zero, cons_val_one,
        head_cons, â† hx (embedding w), im_eq_sub_conj]
      ring_nf; field_simp","error:  ambiguous, possible interpretations 
  Matrix.smul_empty : âˆ€ (x : ?m.335422) (v : Fin 0 â†’ ?m.335421), x â€¢ v = ![]
  
  Finset.smul_empty : âˆ€ (s : Finset ?m.335712), s â€¢ âˆ… = âˆ…
error:  simp made no progress","theorem stdBasis_repr_eq_matrixToStdBasis_mul (x : (K â†’+* â„‚) â†’ â„‚)
    (hx : âˆ€ Ï†, conj (x Ï†) = x (ComplexEmbedding.conjugate Ï†)) (c : index K) :
    ((stdBasis K).repr (commMap K x) c : â„‚) =
      (matrixToStdBasis K *áµ¥ (x âˆ˜ (indexEquiv K))) c ",":= by
  simp_rw [commMap, matrixToStdBasis, LinearMap.coe_mk, AddHom.coe_mk,
    mulVec, dotProduct, Function.comp_apply, index, Fintype.sum_sum_type,
    diagonal_one, reindex_apply, â† univ_product_univ, sum_product,
    indexEquiv_apply_ofIsReal, Fin.sum_univ_two, indexEquiv_apply_ofIsComplex_fst,
    indexEquiv_apply_ofIsComplex_snd, smul_of, smul_cons, smul_eq_mul,
    mul_one, Matrix.smul_empty, Equiv.prodComm_symm, Equiv.coe_prodComm]
  cases c with
  | inl w =>
      simp_rw [stdBasis_apply_ofIsReal, fromBlocks_applyâ‚â‚, fromBlocks_applyâ‚â‚‚,
        one_apply, Matrix.zero_apply, ite_mul, one_mul, zero_mul, sum_ite_eq, mem_univ, ite_true,
        add_zero, sum_const_zero, add_zero, â† conj_eq_iff_re, hx (embedding w.val),
        conjugate_embedding_eq_of_isReal w.prop]
  | inr c =>
    rcases c with âŸ¨w, jâŸ©
    fin_cases j
    Â· simp_rw [Fin.mk_zero, stdBasis_apply_ofIsComplex_fst, fromBlocks_applyâ‚‚â‚,
        fromBlocks_applyâ‚‚â‚‚, Matrix.zero_apply, submatrix_apply,
        blockDiagonal_apply, Prod.swap_prod_mk, ite_mul, zero_mul, sum_const_zero, zero_add,
        sum_add_distrib, sum_ite_eq, mem_univ, ite_true, of_apply, cons_val', cons_val_zero,
        cons_val_one, head_cons, â† hx (embedding w), re_eq_add_conj]
      field_simp
    Â· simp_rw [Fin.mk_one, stdBasis_apply_ofIsComplex_snd, fromBlocks_applyâ‚‚â‚,
        fromBlocks_applyâ‚‚â‚‚, Matrix.zero_apply, submatrix_apply, blockDiagonal_apply,
        Prod.swap_prod_mk, ite_mul, zero_mul, sum_const_zero, zero_add, sum_add_distrib, sum_ite_eq,
        mem_univ, ite_true, of_apply, cons_val', cons_val_zero, cons_val_one, head_cons,
        â† hx (embedding w), im_eq_sub_conj]
      ring_nf; field_simp"
Mathlib/AlgebraicGeometry/EllipticCurve/Affine.lean,WeierstrassCurve.Affine.nonsingular_zero,nonsingular_zero,d6f6c1aa076933ead66d5d1829106509f75ddfd5,":= by
  rw [Nonsingular, equation_zero, evalEval, evalEval, C_0, eval_polynomialX_zero, neg_ne_zero,
    eval_polynomialY_zero, or_comm]","warning:  `WeierstrassCurve.Affine.eval_polynomialX_zero` has been deprecated, use `WeierstrassCurve.Affine.evalEval_polynomialX_zero` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  evalEval 0 0 ?W.polynomialX
R : Type u
instâœ : CommRing R
W : Affine R
âŠ¢ W.aâ‚† = 0 âˆ§ (eval 0 (eval 0 W.polynomialX) â‰  0 âˆ¨ eval 0 (eval 0 W.polynomialY) â‰  0) â†” W.aâ‚† = 0 âˆ§ (W.aâ‚ƒ â‰  0 âˆ¨ W.aâ‚„ â‰  0)",lemma nonsingular_zero : W.Nonsingular 0 0 â†” W.aâ‚† = 0 âˆ§ (W.aâ‚ƒ â‰  0 âˆ¨ W.aâ‚„ â‰  0) ,":= by
  rw [Nonsingular, equation_zero, evalEval_polynomialX_zero, neg_ne_zero, evalEval_polynomialY_zero,
    or_comm]"
Mathlib/Algebra/Homology/DerivedCategory/Basic.lean,HomotopyCategory.quotient_obj_mem_subcategoryAcyclic_iff_exactAt,quotient_obj_mem_subcategoryAcyclic_iff_exactAt,660d4d5e85504851f32fdcb363260a8048d0609c,:= by,"error:  unexpected token 'variable'; expected '{' or tactic
error:  unsolved goals
C : Type u
instâœÂ¹ : Category.{v, u} C
instâœ : Abelian C
K : CochainComplex C â„¤
âŠ¢ (subcategoryAcyclic C).P ((quotient C (ComplexShape.up â„¤)).obj K) â†” âˆ€ (n : â„¤), HomologicalComplex.ExactAt K n","lemma quotient_obj_mem_subcategoryAcyclic_iff_exactAt (K : CochainComplex C â„¤) :
    (subcategoryAcyclic C).P ((quotient _ _).obj K) â†” âˆ€ (n : â„¤), K.ExactAt n ",":= by
  rw [mem_subcategoryAcyclic_iff]
  refine forall_congr' (fun n => ?_)
  simp only [HomologicalComplex.exactAt_iff_isZero_homology]
  exact ((homologyFunctorFactors C (ComplexShape.up â„¤) n).app K).isZero_iff"
Mathlib/MeasureTheory/Covering/BesicovitchVectorSpace.lean,Besicovitch.exists_goodÎ´,exists_goodÎ´,693fd79515903b10b1d31f10dccfc49e633cf7ee,":= by
  classical
  by_contra' h
  set N := multiplicity E + 1 with hN
  have :
    âˆ€ Î´ : â„, 0 < Î´ â†’ âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§
      âˆ€ i j, i â‰  j â†’ 1 - Î´ â‰¤ â€–f i - f jâ€– := by
    intro Î´ hÎ´
    rcases lt_or_le Î´ 1 with (hÎ´' | hÎ´')
    Â· rcases h Î´ hÎ´ hÎ´' with âŸ¨s, hs, h's, s_cardâŸ©
      obtain âŸ¨f, f_inj, hfsâŸ© : âˆƒ f : Fin N â†’ E, Function.Injective f âˆ§ range f âŠ† â†‘s := by
        have : Fintype.card (Fin N) â‰¤ s.card := by simp only [Fintype.card_fin]; exact s_card
        rcases Function.Embedding.exists_of_card_le_finset this with âŸ¨f, hfâŸ©
        exact âŸ¨f, f.injective, hfâŸ©
      simp only [range_subset_iff, Finset.mem_coe] at hfs
      refine' âŸ¨f, fun i => hs _ (hfs i), fun i j hij => h's _ (hfs i) _ (hfs j) (f_inj.ne hij)âŸ©
    Â· exact
        âŸ¨fun _ => 0, fun i => by simp; norm_num, fun i j _ => by
          simpa only [norm_zero, sub_nonpos, sub_self]âŸ©
  choose! F hF using this
  have : âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§ âˆ€ i j, i â‰  j â†’ 1 â‰¤ â€–f i - f jâ€– := by
    obtain âŸ¨u, _, zero_lt_u, huâŸ© :
      âˆƒ u : â„• â†’ â„,
        (âˆ€ m n : â„•, m < n â†’ u n < u m) âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Filter.Tendsto u Filter.atTop (ğ“ 0) :=
      exists_seq_strictAnti_tendsto (0 : â„)
    have A : âˆ€ n, F (u n) âˆˆ closedBall (0 : Fin N â†’ E) 2 := by
      intro n
      simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right,
        (hF (u n) (zero_lt_u n)).left, forall_const]
    obtain âŸ¨f, fmem, Ï†, Ï†_mono, hfâŸ© :
      âˆƒ f âˆˆ closedBall (0 : Fin N â†’ E) 2,
        âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (ğ“ f) :=
      IsCompact.tendsto_subseq (isCompact_closedBall _ _) A
    refine' âŸ¨f, fun i => _, fun i j hij => _âŸ©
    Â· simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right] at fmem
      exact fmem i
    Â· have A : Tendsto (fun n => â€–F (u (Ï† n)) i - F (u (Ï† n)) jâ€–) atTop (ğ“ â€–f i - f jâ€–) :=
        ((hf.apply i).sub (hf.apply j)).norm
      have B : Tendsto (fun n => 1 - u (Ï† n)) atTop (ğ“ (1 - 0)) :=
        tendsto_const_nhds.sub (hu.comp Ï†_mono.tendsto_atTop)
      rw [sub_zero] at B
      exact le_of_tendsto_of_tendsto' B A fun n => (hF (u (Ï† n)) (zero_lt_u _)).2 i j hij
  rcases this with âŸ¨f, hf, h'fâŸ©
  have finj : Function.Injective f := by
    intro i j hij
    by_contra h
    have : 1 â‰¤ â€–f i - f jâ€– := h'f i j h
    simp only [hij, norm_zero, sub_self] at this
    exact lt_irrefl _ (this.trans_lt zero_lt_one)
  let s := Finset.image f Finset.univ
  have s_card : s.card = N := by rw [Finset.card_image_of_injective _ finj]; exact Finset.card_fin N
  have hs : âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2 := by
    simp only [hf, forall_apply_eq_imp_iff, forall_const, forall_exists_index, Finset.mem_univ,
      Finset.mem_image, true_and]
  have h's : âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 â‰¤ â€–c - dâ€– := by
    simp only [forall_apply_eq_imp_iff, forall_exists_index, Finset.mem_univ, Finset.mem_image,
      Ne.def, exists_true_left, forall_apply_eq_imp_iff, forall_true_left, true_and]
    intro i j hij
    have : i â‰  j := fun h => by rw [h] at hij; exact hij rfl
    exact h'f i j this
  have : s.card â‰¤ multiplicity E := card_le_multiplicity hs h's
  rw [s_card, hN] at this
  exact lt_irrefl _ ((Nat.lt_succ_self (multiplicity E)).trans_le this)","error:  unknown tactic
error:  unsolved goals
E : Type u_1
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
instâœ : FiniteDimensional â„ E
âŠ¢ âˆƒ Î´,
    0 < Î´ âˆ§
      Î´ < 1 âˆ§
        âˆ€ (s : Finset E), (âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2) â†’ (âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 - Î´ â‰¤ â€–c - dâ€–) â†’ s.card â‰¤ multiplicity E","theorem exists_goodÎ´ :
    âˆƒ Î´ : â„, 0 < Î´ âˆ§ Î´ < 1 âˆ§ âˆ€ s : Finset E, (âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2) â†’
      (âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 - Î´ â‰¤ â€–c - dâ€–) â†’ s.card â‰¤ multiplicity E ",":= by
  classical
  by_contra! h
  set N := multiplicity E + 1 with hN
  have :
    âˆ€ Î´ : â„, 0 < Î´ â†’ âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§
      Pairwise fun i j => 1 - Î´ â‰¤ â€–f i - f jâ€– := by
    intro Î´ hÎ´
    rcases lt_or_le Î´ 1 with (hÎ´' | hÎ´')
    Â· rcases h Î´ hÎ´ hÎ´' with âŸ¨s, hs, h's, s_cardâŸ©
      obtain âŸ¨f, f_inj, hfsâŸ© : âˆƒ f : Fin N â†’ E, Function.Injective f âˆ§ range f âŠ† â†‘s := by
        have : Fintype.card (Fin N) â‰¤ s.card := by simp only [Fintype.card_fin]; exact s_card
        rcases Function.Embedding.exists_of_card_le_finset this with âŸ¨f, hfâŸ©
        exact âŸ¨f, f.injective, hfâŸ©
      simp only [range_subset_iff, Finset.mem_coe] at hfs
      exact âŸ¨f, fun i => hs _ (hfs i), fun i j hij => h's _ (hfs i) _ (hfs j) (f_inj.ne hij)âŸ©
    Â· exact
        âŸ¨fun _ => 0, by simp, fun i j _ => by
          simpa only [norm_zero, sub_nonpos, sub_self]âŸ©
  choose! F hF using this
  have : âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§ Pairwise fun i j => 1 â‰¤ â€–f i - f jâ€– := by
    obtain âŸ¨u, _, zero_lt_u, huâŸ© :
      âˆƒ u : â„• â†’ â„,
        (âˆ€ m n : â„•, m < n â†’ u n < u m) âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Filter.Tendsto u Filter.atTop (ğ“ 0) :=
      exists_seq_strictAnti_tendsto (0 : â„)
    have A : âˆ€ n, F (u n) âˆˆ closedBall (0 : Fin N â†’ E) 2 := by
      intro n
      simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right,
        (hF (u n) (zero_lt_u n)).left, forall_const]
    obtain âŸ¨f, fmem, Ï†, Ï†_mono, hfâŸ© :
      âˆƒ f âˆˆ closedBall (0 : Fin N â†’ E) 2,
        âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (ğ“ f) :=
      IsCompact.tendsto_subseq (isCompact_closedBall _ _) A
    refine âŸ¨f, fun i => ?_, fun i j hij => ?_âŸ©
    Â· simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right] at fmem
      exact fmem i
    Â· have A : Tendsto (fun n => â€–F (u (Ï† n)) i - F (u (Ï† n)) jâ€–) atTop (ğ“ â€–f i - f jâ€–) :=
        ((hf.apply_nhds i).sub (hf.apply_nhds j)).norm
      have B : Tendsto (fun n => 1 - u (Ï† n)) atTop (ğ“ (1 - 0)) :=
        tendsto_const_nhds.sub (hu.comp Ï†_mono.tendsto_atTop)
      rw [sub_zero] at B
      exact le_of_tendsto_of_tendsto' B A fun n => (hF (u (Ï† n)) (zero_lt_u _)).2 hij
  rcases this with âŸ¨f, hf, h'fâŸ©
  have finj : Function.Injective f := by
    intro i j hij
    by_contra h
    have : 1 â‰¤ â€–f i - f jâ€– := h'f h
    simp only [hij, norm_zero, sub_self] at this
    exact lt_irrefl _ (this.trans_lt zero_lt_one)
  let s := Finset.image f Finset.univ
  have s_card : s.card = N := by rw [Finset.card_image_of_injective _ finj]; exact Finset.card_fin N
  have hs : âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2 := by
    simp only [s, hf, forall_apply_eq_imp_iff, forall_const, forall_exists_index, Finset.mem_univ,
      Finset.mem_image, true_and]
  have h's : âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 â‰¤ â€–c - dâ€– := by
    simp only [s, forall_apply_eq_imp_iff, forall_exists_index, Finset.mem_univ, Finset.mem_image,
      Ne, exists_true_left, forall_apply_eq_imp_iff, forall_true_left, true_and]
    intro i j hij
    have : i â‰  j := fun h => by rw [h] at hij; exact hij rfl
    exact h'f this
  have : s.card â‰¤ multiplicity E := card_le_multiplicity hs h's
  rw [s_card, hN] at this
  exact lt_irrefl _ ((Nat.lt_succ_self (multiplicity E)).trans_le this)"
Mathlib/Algebra/Group/Submonoid/Units.lean,Submonoid.coe_val_mul_coe_inv_val,coe_val_mul_coe_inv_val,efb7091c8693e7c41303e2998bcb2cf60d811910,:= S.subtype.congr_arg x.mul_inv,"error:  invalid field 'congr_arg', the environment does not contain 'MonoidHom.congr_arg'
  S.subtype
has type
  â†¥S â†’* M","lemma coe_val_mul_coe_inv_val (S : Submonoid M) {x : SË£} :
    ((x : SË£) : M) * ((xâ»Â¹ : SË£) : M) = 1 ",:= DFunLike.congr_arg S.subtype x.mul_inv
Mathlib/Topology/NoetherianSpace.lean,TopologicalSpace.NoetherianSpace.finite_irreducibleComponents,NoetherianSpace.finite_irreducibleComponents,d1eb6264448286c8ff0dd2875db90fd9724a3cbf,":= by
  obtain âŸ¨S : Set (Set Î±), hSf, hSc, hSi, hSUâŸ© :=
    NoetherianSpace.exists_finite_set_isClosed_irreducible isClosed_univ
  refine hSf.subset fun s hs => ?_
  lift S to Finset (Set Î±) using hSf
  rcases isIrreducible_iff_sUnion_closed.1 hs.1 S hSc (hSU â–¸ Set.subset_univ _) with âŸ¨t, htS, htâŸ©
  rwa [ht.antisymm (hs.2 (hSi _ htS) ht)]","error:  typeclass instance problem is stuck, it is often due to metavariables
  NoetherianSpace ?m.25536","theorem NoetherianSpace.finite_irreducibleComponents [NoetherianSpace Î±] :
    (irreducibleComponents Î±).Finite ",":= by
  obtain âŸ¨S : Set (Set Î±), hSf, hSc, hSi, hSUâŸ© :=
    NoetherianSpace.exists_finite_set_isClosed_irreducible isClosed_univ (Î± := Î±)
  refine hSf.subset fun s hs => ?_
  lift S to Finset (Set Î±) using hSf
  rcases isIrreducible_iff_sUnion_closed.1 hs.1 S hSc (hSU â–¸ Set.subset_univ _) with âŸ¨t, htS, htâŸ©
  rwa [ht.antisymm (hs.2 (hSi _ htS) ht)]"
Mathlib/Data/List/Sym.lean,List.sym2_eq_sym_two,sym2_eq_sym_two,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction xs with
  | nil => rfl
  | cons x xs ih =>
    rw [List.sym, â† ih, sym_one_eq, map_map, List.sym2, map_append, map_map]
    rfl","error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case nil
Î± : Type u_1
xs ys : List Î±
n : â„•
âŠ¢ map â‡‘(Sym2.equivSym Î±) [].sym2 = List.sym 2 []",theorem sym2_eq_sym_two : xs.sym2.map (Sym2.equivSym Î±) = xs.sym 2 ,":= by
  induction xs with
  | nil => simp only [List.sym, map_eq_nil, sym2_eq_nil_iff]
  | cons x xs ih =>
    rw [List.sym, â† ih, sym_one_eq, map_map, List.sym2, map_append, map_map]
    rfl"
Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean,Finpartition.equitabilise_aux,equitabilise_aux,cfe2b104ceb95fb293bba238c1de08ee2efeda94,":= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  Â· refine' âŸ¨âŠ¥, by simp, _, by simpa using hs.symmâŸ©
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id.def, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      âŸ¨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _âŸ©
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 âˆ§ b = 0
  Â· simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (Î± := Finpartition âŠ¥) P
    exact âŸ¨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]âŸ©
  simp_rw [not_and_or, â† Ne.def, â† pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain âŸ¨hnâ‚€, hnâ‚, hnâ‚‚, hnâ‚ƒâŸ© : 0 < n âˆ§ n â‰¤ m + 1 âˆ§ n â‰¤ a * m + b * (m + 1) âˆ§
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, â† hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    Â· refine' âŸ¨m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ â€¹0 < aâ€º), _âŸ©
      rw [tsub_add_eq_add_tsub (Nat.le_mul_of_pos_left _ h)]
    Â· refine' âŸ¨succ_pos', le_rfl,
        le_add_left (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º), _âŸ©
      rw [â† add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º)]
  by_cases h : âˆ€ u âˆˆ P.parts, card u < m + 1
  Â· obtain âŸ¨t, hts, htnâŸ© := exists_smaller_set s n (hnâ‚‚.trans_eq hs)
    have ht : t.Nonempty := by rwa [â† card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff â€¹t âŠ† sâ€º, htn, hnâ‚ƒ]
    obtain âŸ¨R, hRâ‚, _, hRâ‚ƒâŸ© :=
      @ih (s \ t) (sdiff_ssubset hts â€¹t.Nonemptyâ€º) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine' âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), _, _, _âŸ©
    Â· simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => (card_le_card <| sdiff_subset _ _).trans (Nat.lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    Â· rw [hRâ‚ƒ, if_pos ha]
    rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg ha, tsub_add_cancel_of_le]
    Â· exact hab.resolve_left ha
    Â· intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg at h
  obtain âŸ¨u, huâ‚, huâ‚‚âŸ© := h
  obtain âŸ¨t, htu, htnâŸ© := exists_smaller_set _ _ (hnâ‚.trans huâ‚‚)
  have ht : t.Nonempty := by rwa [â† card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le huâ‚), htn, hnâ‚ƒ]
  obtain âŸ¨R, hRâ‚, hRâ‚‚, hRâ‚ƒâŸ© :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le huâ‚) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine' âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le huâ‚), _, _, _âŸ©
  Â· simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hRâ‚, htn, hn]
    exact ite_eq_or_eq _ _ _
  Â· conv in _ âˆˆ _ => rw [â† insert_erase huâ‚]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne.def, extend_parts]
    refine' âŸ¨_, fun x hx => (card_le_card _).trans <| hRâ‚‚ x _âŸ©
    Â· simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id.def]
      obtain rfl | hut := eq_or_ne u t
      Â· rw [sdiff_eq_empty_iff_subset.2 (subset_union_left _ _)]
        exact bot_le
      refine'
        (card_le_card fun i => _).trans
          (hRâ‚‚ (u \ t) <| P.mem_avoid.2 âŸ¨u, huâ‚, fun i => hut <| i.antisymm htu, rflâŸ©)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id.def, not_or]
      exact fun hiâ‚ hiâ‚‚ hiâ‚ƒ =>
        âŸ¨âŸ¨hiâ‚, hiâ‚‚âŸ©, fun x hx hx' => hiâ‚ƒ _ hx <| hx'.trans <| sdiff_subset _ _âŸ©
    Â· apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      âŸ¨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) huâ‚ <| ne_of_mem_erase hx).sdiff_eq_leftâŸ©
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  Â· rw [hRâ‚ƒ, if_pos h]
  Â· rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)","error:  type mismatch
  hâœ
has type
  s.card = b : Prop
but is expected to have type
  (filter (fun i â†¦ i.card = 1) (Finset.map { toFun := singleton, inj' := â‹¯ } s)).card = b : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.6768 â†’ ?m.6768
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.12503 â†’ ?m.12503 â†’ Prop
error:  simp made no progress","theorem equitabilise_aux (hs : a * m + b * (m + 1) = s.card) :
    âˆƒ Q : Finpartition s,
      (âˆ€ x : Finset Î±, x âˆˆ Q.parts â†’ x.card = m âˆ¨ x.card = m + 1) âˆ§
        (âˆ€ x, x âˆˆ P.parts â†’ (x \ (Q.parts.filter fun y => y âŠ† x).biUnion id).card â‰¤ m) âˆ§
          (Q.parts.filter fun i => card i = m + 1).card = b ",":= by
  obtain rfl | m_pos := m.eq_zero_or_pos
  Â· refine âŸ¨âŠ¥, by simp, ?_, by simpa [Finset.filter_true_of_mem] using hs.symmâŸ©
    simp only [le_zero_iff, card_eq_zero, mem_biUnion, exists_prop, mem_filter, id, and_assoc,
      sdiff_eq_empty_iff_subset, subset_iff]
    exact fun x hx a ha =>
      âŸ¨{a}, mem_map_of_mem _ (P.le hx ha), singleton_subset_iff.2 ha, mem_singleton_self _âŸ©
  induction' s using Finset.strongInduction with s ih generalizing a b
  by_cases hab : a = 0 âˆ§ b = 0
  Â· simp only [hab.1, hab.2, add_zero, zero_mul, eq_comm, card_eq_zero, Finset.bot_eq_empty] at hs
    subst hs
    have : P = Finpartition.empty _ := Unique.eq_default (Î± := Finpartition âŠ¥) P
    exact âŸ¨Finpartition.empty _, by simp, by simp [this], by simp [hab.2]âŸ©
  simp_rw [not_and_or, â† Ne.eq_def, â† pos_iff_ne_zero] at hab
  set n := if 0 < a then m else m + 1 with hn
  obtain âŸ¨hnâ‚€, hnâ‚, hnâ‚‚, hnâ‚ƒâŸ© : 0 < n âˆ§ n â‰¤ m + 1 âˆ§ n â‰¤ a * m + b * (m + 1) âˆ§
      ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = s.card - n := by
    rw [hn, â† hs]
    split_ifs with h <;> rw [tsub_mul, one_mul]
    Â· refine âŸ¨m_pos, le_succ _, le_add_right (Nat.le_mul_of_pos_left _ â€¹0 < aâ€º), ?_âŸ©
      rw [tsub_add_eq_add_tsub (Nat.le_mul_of_pos_left _ h)]
    Â· refine âŸ¨succ_pos', le_rfl,
        le_add_left (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º), ?_âŸ©
      rw [â† add_tsub_assoc_of_le (Nat.le_mul_of_pos_left _ <| hab.resolve_left â€¹Â¬0 < aâ€º)]
  by_cases h : âˆ€ u âˆˆ P.parts, card u < m + 1
  Â· obtain âŸ¨t, hts, htnâŸ© := exists_subset_card_eq (hnâ‚‚.trans_eq hs)
    have ht : t.Nonempty := by rwa [â† card_pos, htn]
    have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
      rw [card_sdiff â€¹t âŠ† sâ€º, htn, hnâ‚ƒ]
    obtain âŸ¨R, hRâ‚, _, hRâ‚ƒâŸ© :=
      @ih (s \ t) (sdiff_ssubset hts â€¹t.Nonemptyâ€º) (if 0 < a then a - 1 else a)
        (if 0 < a then b else b - 1) (P.avoid t) hcard
    refine âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel hts), ?_, ?_, ?_âŸ©
    Â· simp only [extend_parts, mem_insert, forall_eq_or_imp, and_iff_left hRâ‚, htn, hn]
      exact ite_eq_or_eq _ _ _
    Â· exact fun x hx => (card_le_card sdiff_subset).trans (Nat.lt_succ_iff.1 <| h _ hx)
    simp_rw [extend_parts, filter_insert, htn, m.succ_ne_self.symm.ite_eq_right_iff]
    split_ifs with ha
    Â· rw [hRâ‚ƒ, if_pos ha]
    rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg ha, tsub_add_cancel_of_le]
    Â· exact hab.resolve_left ha
    Â· intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)
  push_neg at h
  obtain âŸ¨u, huâ‚, huâ‚‚âŸ© := h
  obtain âŸ¨t, htu, htnâŸ© := exists_subset_card_eq (hnâ‚.trans huâ‚‚)
  have ht : t.Nonempty := by rwa [â† card_pos, htn]
  have hcard : ite (0 < a) (a - 1) a * m + ite (0 < a) b (b - 1) * (m + 1) = (s \ t).card := by
    rw [card_sdiff (htu.trans <| P.le huâ‚), htn, hnâ‚ƒ]
  obtain âŸ¨R, hRâ‚, hRâ‚‚, hRâ‚ƒâŸ© :=
    @ih (s \ t) (sdiff_ssubset (htu.trans <| P.le huâ‚) ht) (if 0 < a then a - 1 else a)
      (if 0 < a then b else b - 1) (P.avoid t) hcard
  refine
    âŸ¨R.extend ht.ne_empty sdiff_disjoint (sdiff_sup_cancel <| htu.trans <| P.le huâ‚), ?_, ?_, ?_âŸ©
  Â· simp only [mem_insert, forall_eq_or_imp, extend_parts, and_iff_left hRâ‚, htn, hn]
    exact ite_eq_or_eq _ _ _
  Â· conv in _ âˆˆ _ => rw [â† insert_erase huâ‚]
    simp only [and_imp, mem_insert, forall_eq_or_imp, Ne, extend_parts]
    refine âŸ¨?_, fun x hx => (card_le_card ?_).trans <| hRâ‚‚ x ?_âŸ©
    Â· simp only [filter_insert, if_pos htu, biUnion_insert, mem_erase, id]
      obtain rfl | hut := eq_or_ne u t
      Â· rw [sdiff_eq_empty_iff_subset.2 subset_union_left]
        exact bot_le
      refine
        (card_le_card fun i => ?_).trans
          (hRâ‚‚ (u \ t) <| P.mem_avoid.2 âŸ¨u, huâ‚, fun i => hut <| i.antisymm htu, rflâŸ©)
      simp only [not_exists, not_and, mem_biUnion, and_imp, mem_union, mem_filter, mem_sdiff,
        id, not_or]
      exact fun hiâ‚ hiâ‚‚ hiâ‚ƒ =>
        âŸ¨âŸ¨hiâ‚, hiâ‚‚âŸ©, fun x hx hx' => hiâ‚ƒ _ hx <| hx'.trans sdiff_subsetâŸ©
    Â· apply sdiff_subset_sdiff Subset.rfl (biUnion_subset_biUnion_of_subset_left _ _)
      exact filter_subset_filter _ (subset_insert _ _)
    simp only [avoid, ofErase, mem_erase, mem_image, bot_eq_empty]
    exact
      âŸ¨(nonempty_of_mem_parts _ <| mem_of_mem_erase hx).ne_empty, _, mem_of_mem_erase hx,
        (disjoint_of_subset_right htu <|
            P.disjoint (mem_of_mem_erase hx) huâ‚ <| ne_of_mem_erase hx).sdiff_eq_leftâŸ©
  simp only [extend_parts, filter_insert, htn, hn, m.succ_ne_self.symm.ite_eq_right_iff]
  split_ifs with h
  Â· rw [hRâ‚ƒ, if_pos h]
  Â· rw [card_insert_of_not_mem, hRâ‚ƒ, if_neg h, Nat.sub_add_cancel (hab.resolve_left h)]
    intro H; exact ht.ne_empty (le_sdiff_iff.1 <| R.le <| filter_subset _ _ H)"
Mathlib/LinearAlgebra/Matrix/IsDiag.lean,Matrix.isDiag_fromBlocks_iff,isDiag_fromBlocks_iff,8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85,":= by
  constructor
  Â· intro h
    refine âŸ¨fun i j hij => ?_, ext fun i j => ?_, ext fun i j =?> _, fun i j hij => ?_âŸ©
    Â· exact h (Sum.inl_injective.ne hij)
    Â· exact h Sum.inl_ne_inr
    Â· exact h Sum.inr_ne_inl
    Â· exact h (Sum.inr_injective.ne hij)
  Â· rintro âŸ¨ha, hb, hc, hdâŸ©
    convert IsDiag.fromBlocks ha hd","error:  unexpected token '='; expected 'â†¦', '=>'
error:  unsolved goals
case mp.refine_1
Î± : Type u_1
Î² : Type u_2
R : Type u_3
n : Type u_4
m : Type u_5
instâœ : Zero Î±
A : Matrix m m Î±
B : Matrix m n Î±
C : Matrix n m Î±
D : Matrix n n Î±
h : (fromBlocks A B C D).IsDiag
i j : m
hij : i â‰  j
âŠ¢ (fun i j â†¦ A i j = 0) i j

case mp.refine_2
Î± : Type u_1
Î² : Type u_2
R : Type u_3
n : Type u_4
m : Type u_5
instâœ : Zero Î±
A : Matrix m m Î±
B : Matrix m n Î±
C : Matrix n m Î±
D : Matrix n n Î±
h : (fromBlocks A B C D).IsDiag
i : m
j : n
âŠ¢ B i j = 0 i j
error:  unsolved goals
case mpr
Î± : Type u_1
Î² : Type u_2
R : Type u_3
n : Type u_4
m : Type u_5
instâœ : Zero Î±
A : Matrix m m Î±
B : Matrix m n Î±
C : Matrix n m Î±
D : Matrix n n Î±
âŠ¢ A.IsDiag âˆ§ B = 0 âˆ§ C = 0 âˆ§ D.IsDiag â†’ (fromBlocks A B C D).IsDiag","theorem isDiag_fromBlocks_iff [Zero Î±] {A : Matrix m m Î±} {B : Matrix m n Î±} {C : Matrix n m Î±}
    {D : Matrix n n Î±} : (A.fromBlocks B C D).IsDiag â†” A.IsDiag âˆ§ B = 0 âˆ§ C = 0 âˆ§ D.IsDiag ",":= by
  constructor
  Â· intro h
    refine âŸ¨fun i j hij => ?_, ext fun i j => ?_, ext fun i j => ?_, fun i j hij => ?_âŸ©
    Â· exact h (Sum.inl_injective.ne hij)
    Â· exact h Sum.inl_ne_inr
    Â· exact h Sum.inr_ne_inl
    Â· exact h (Sum.inr_injective.ne hij)
  Â· rintro âŸ¨ha, hb, hc, hdâŸ©
    convert IsDiag.fromBlocks ha hd"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exist_finset_disjoint_balls_large_measure,exist_finset_disjoint_balls_large_measure,b50a8b2e9760b6f582390d3948a953c553480df1,":= by
  rcases le_or_lt (Î¼ s) 0 with (hÎ¼s | hÎ¼s)
  Â· have : Î¼ s = 0 := le_bot_iff.1 hÎ¼s
    refine' âŸ¨âˆ…, by simp only [Finset.coe_empty, empty_subset], _, _âŸ©
    Â· simp only [this, Finset.not_mem_empty, diff_empty, iUnion_false, iUnion_empty,
        nonpos_iff_eq_zero, mul_zero]
    Â· simp only [Finset.coe_empty, pairwiseDisjoint_empty]
  cases isEmpty_or_nonempty Î±
  Â· simp only [eq_empty_of_isEmpty s, measure_empty] at hÎ¼s
    exact (lt_irrefl _ hÎ¼s).elim
  have Npos : N â‰  0 := by
    rintro rfl
    inhabit Î±
    exact not_isEmpty_of_nonempty _ hN
  obtain âŸ¨o, so, omeas, Î¼oâŸ© : âˆƒ o : Set Î±, s âŠ† o âˆ§ MeasurableSet o âˆ§ Î¼ o = Î¼ s :=
    exists_measurable_superset Î¼ s
  let a : BallPackage s Î± :=
    { c := fun x => x
      r := fun x => r x
      rpos := fun x => rpos x x.2
      r_bound := 1
      r_le := fun x => rle x x.2 }
  rcases exist_disjoint_covering_families hÏ„ hN a with âŸ¨u, hu, hu'âŸ©
  have u_count : âˆ€ i, (u i).Countable := by
    intro i
    refine' (hu i).countable_of_nonempty_interior fun j _ => _
    have : (ball (j : Î±) (r j)).Nonempty := nonempty_ball.2 (a.rpos _)
    exact this.mono ball_subset_interior_closedBall
  let v : Fin N â†’ Set Î± := fun i => â‹ƒ (x : s) (_ : x âˆˆ u i), closedBall x (r x)
  have A : s = â‹ƒ i : Fin N, s âˆ© v i := by
    refine' Subset.antisymm _ (iUnion_subset fun i => inter_subset_left _ _)
    intro x hx
    obtain âŸ¨i, y, hxy, h'âŸ© :
        âˆƒ (i : Fin N) (i_1 : â†¥s), i_1 âˆˆ u i âˆ§ x âˆˆ ball (â†‘i_1) (r â†‘i_1) := by
      have : x âˆˆ range a.c := by simpa only [Subtype.range_coe_subtype, setOf_mem_eq]
      simpa only [mem_iUnion, bex_def] using hu' this
    refine' mem_iUnion.2 âŸ¨i, âŸ¨hx, _âŸ©âŸ©
    simp only [v, exists_prop, mem_iUnion, SetCoe.exists, exists_and_right, Subtype.coe_mk]
    exact âŸ¨y, âŸ¨y.2, by simpa only [Subtype.coe_eta]âŸ©, ball_subset_closedBall h'âŸ©
  have S : âˆ‘ _i : Fin N, Î¼ s / N â‰¤ âˆ‘ i, Î¼ (s âˆ© v i) :=
    calc
      âˆ‘ _i : Fin N, Î¼ s / N = Î¼ s := by
        simp only [Finset.card_fin, Finset.sum_const, nsmul_eq_mul]
        rw [ENNReal.mul_div_cancel']
        Â· simp only [Npos, Ne, Nat.cast_eq_zero, not_false_iff]
        Â· exact ENNReal.nat_ne_top _
      _ â‰¤ âˆ‘ i, Î¼ (s âˆ© v i) := by
        conv_lhs => rw [A]
        apply measure_iUnion_fintype_le
  obtain âŸ¨i, -, hiâŸ© : âˆƒ (i : Fin N), i âˆˆ Finset.univ âˆ§ Î¼ s / N â‰¤ Î¼ (s âˆ© v i) := by
    apply ENNReal.exists_le_of_sum_le _ S
    exact âŸ¨âŸ¨0, bot_lt_iff_ne_bot.2 NposâŸ©, Finset.mem_univ _âŸ©
  replace hi : Î¼ s / (N + 1) < Î¼ (s âˆ© v i) := by
    apply lt_of_lt_of_le _ hi
    apply (ENNReal.mul_lt_mul_left hÎ¼s.ne' (measure_lt_top Î¼ s).ne).2
    rw [ENNReal.inv_lt_inv]
    conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
    exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
  have B : Î¼ (o âˆ© v i) = âˆ‘' x : u i, Î¼ (o âˆ© closedBall x (r x)) := by
    have : o âˆ© v i = â‹ƒ (x : s) (_ : x âˆˆ u i), o âˆ© closedBall x (r x) := by
      simp only [v, inter_iUnion]
    rw [this, measure_biUnion (u_count i)]
    Â· exact (hu i).mono fun k => inter_subset_right _ _
    Â· exact fun b _ => omeas.inter measurableSet_closedBall
  obtain âŸ¨w, hwâŸ© :
    âˆƒ w : Finset (u i), Î¼ s / (N + 1) <
      âˆ‘ x : u i in w, Î¼ (o âˆ© closedBall (x : Î±) (r (x : Î±))) := by
    have C : HasSum (fun x : u i => Î¼ (o âˆ© closedBall x (r x))) (Î¼ (o âˆ© v i)) := by
      rw [B]; exact ENNReal.summable.hasSum
    have : Î¼ s / (N + 1) < Î¼ (o âˆ© v i) := hi.trans_le (measure_mono (inter_subset_inter_left _ so))
    exact ((tendsto_order.1 C).1 _ this).exists
  refine' âŸ¨Finset.image (fun x : u i => x) w, _, _, _âŸ©
  Â· simp only [image_subset_iff, Finset.coe_image]
    intro y _
    simp only [Subtype.coe_prop, mem_preimage]
  Â· suffices H : Î¼ (o \ â‹ƒ x âˆˆ w, closedBall (â†‘x) (r â†‘x)) â‰¤ N / (N + 1) * Î¼ s by
      rw [Finset.set_biUnion_finset_image]
      exact le_trans (measure_mono (diff_subset_diff so (Subset.refl _))) H
    rw [â† diff_inter_self_eq_diff,
      measure_diff_le_iff_le_add _ (inter_subset_right _ _) (measure_lt_top Î¼ _).ne]
    swap
    Â· apply MeasurableSet.inter _ omeas
      haveI : Encodable (u i) := (u_count i).toEncodable
      exact MeasurableSet.iUnion fun b => MeasurableSet.iUnion fun _ => measurableSet_closedBall
    calc
      Î¼ o = 1 / (N + 1) * Î¼ s + N / (N + 1) * Î¼ s := by
        rw [Î¼o, â† add_mul, ENNReal.div_add_div_same, add_comm, ENNReal.div_self, one_mul] <;> simp
      _ â‰¤ Î¼ ((â‹ƒ x âˆˆ w, closedBall (â†‘x) (r â†‘x)) âˆ© o) + N / (N + 1) * Î¼ s := by
        refine' add_le_add _ le_rfl
        rw [div_eq_mul_inv, one_mul, mul_comm, â† div_eq_mul_inv]
        apply hw.le.trans (le_of_eq _)
        rw [â† Finset.set_biUnion_coe, inter_comm _ o, inter_iUnionâ‚‚, Finset.set_biUnion_coe,
          measure_biUnion_finset]
        Â· have : (w : Set (u i)).PairwiseDisjoint
              fun b : u i => closedBall (b : Î±) (r (b : Î±)) := by
            intro k _ l _ hkl; exact hu i k.2 l.2 (Subtype.val_injective.ne hkl)
          exact this.mono fun k => inter_subset_right _ _
        Â· intro b _
          apply omeas.inter measurableSet_closedBall
  Â· intro k hk l hl hkl
    obtain âŸ¨k', _, rflâŸ© : âˆƒ k' : u i, k' âˆˆ w âˆ§ â†‘k' = k := by
      simpa only [mem_image, Finset.mem_coe, Finset.coe_image] using hk
    obtain âŸ¨l', _, rflâŸ© : âˆƒ l' : u i, l' âˆˆ w âˆ§ â†‘l' = l := by
      simpa only [mem_image, Finset.mem_coe, Finset.coe_image] using hl
    have k'nel' : (k' : s) â‰  l' := by intro h; rw [h] at hkl; exact hkl rfl
    exact hu i k'.2 l'.2 k'nel'","error:  function expected at
  inter_subset_left ?m.66215
term has type
  ?m.66214 âˆˆ ?m.66212
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  function expected at
  inter_subset_right ?m.78000
term has type
  ?m.77999 âˆˆ ?m.77998
error:  function expected at
  inter_subset_right ?m.84875
term has type
  ?m.84874 âˆˆ ?m.84873
error:  function expected at
  inter_subset_right ?m.97081
term has type
  ?m.97080 âˆˆ ?m.97079","theorem exist_finset_disjoint_balls_large_measure (Î¼ : Measure Î±) [IsFiniteMeasure Î¼] {N : â„•}
    {Ï„ : â„} (hÏ„ : 1 < Ï„) (hN : IsEmpty (SatelliteConfig Î± N Ï„)) (s : Set Î±) (r : Î± â†’ â„)
    (rpos : âˆ€ x âˆˆ s, 0 < r x) (rle : âˆ€ x âˆˆ s, r x â‰¤ 1) :
    âˆƒ t : Finset Î±, â†‘t âŠ† s âˆ§ Î¼ (s \ â‹ƒ x âˆˆ t, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s âˆ§
      (t : Set Î±).PairwiseDisjoint fun x => closedBall x (r x) ",":= by
  rcases le_or_lt (Î¼ s) 0 with (hÎ¼s | hÎ¼s)
  Â· have : Î¼ s = 0 := le_bot_iff.1 hÎ¼s
    refine âŸ¨âˆ…, by simp only [Finset.coe_empty, empty_subset], ?_, ?_âŸ©
    Â· simp only [this, Finset.not_mem_empty, diff_empty, iUnion_false, iUnion_empty,
        nonpos_iff_eq_zero, mul_zero]
    Â· simp only [Finset.coe_empty, pairwiseDisjoint_empty]
  cases isEmpty_or_nonempty Î±
  Â· simp only [eq_empty_of_isEmpty s, measure_empty] at hÎ¼s
    exact (lt_irrefl _ hÎ¼s).elim
  have Npos : N â‰  0 := by
    rintro rfl
    inhabit Î±
    exact not_isEmpty_of_nonempty _ hN
  obtain âŸ¨o, so, omeas, Î¼oâŸ© : âˆƒ o : Set Î±, s âŠ† o âˆ§ MeasurableSet o âˆ§ Î¼ o = Î¼ s :=
    exists_measurable_superset Î¼ s
  let a : BallPackage s Î± :=
    { c := fun x => x
      r := fun x => r x
      rpos := fun x => rpos x x.2
      r_bound := 1
      r_le := fun x => rle x x.2 }
  rcases exist_disjoint_covering_families hÏ„ hN a with âŸ¨u, hu, hu'âŸ©
  have u_count : âˆ€ i, (u i).Countable := by
    intro i
    refine (hu i).countable_of_nonempty_interior fun j _ => ?_
    have : (ball (j : Î±) (r j)).Nonempty := nonempty_ball.2 (a.rpos _)
    exact this.mono ball_subset_interior_closedBall
  let v : Fin N â†’ Set Î± := fun i => â‹ƒ (x : s) (_ : x âˆˆ u i), closedBall x (r x)
  have A : s = â‹ƒ i : Fin N, s âˆ© v i := by
    refine Subset.antisymm ?_ (iUnion_subset fun i => inter_subset_left)
    intro x hx
    obtain âŸ¨i, y, hxy, h'âŸ© :
        âˆƒ (i : Fin N) (i_1 : â†¥s), i_1 âˆˆ u i âˆ§ x âˆˆ ball (â†‘i_1) (r â†‘i_1) := by
      have : x âˆˆ range a.c := by simpa only [Subtype.range_coe_subtype, setOf_mem_eq]
      simpa only [mem_iUnion, bex_def] using hu' this
    refine mem_iUnion.2 âŸ¨i, âŸ¨hx, ?_âŸ©âŸ©
    simp only [v, exists_prop, mem_iUnion, SetCoe.exists, exists_and_right, Subtype.coe_mk]
    exact âŸ¨y, âŸ¨y.2, by simpa only [Subtype.coe_eta]âŸ©, ball_subset_closedBall h'âŸ©
  have S : âˆ‘ _i : Fin N, Î¼ s / N â‰¤ âˆ‘ i, Î¼ (s âˆ© v i) :=
    calc
      âˆ‘ _i : Fin N, Î¼ s / N = Î¼ s := by
        simp only [Finset.card_fin, Finset.sum_const, nsmul_eq_mul]
        rw [ENNReal.mul_div_cancel']
        Â· simp only [Npos, Ne, Nat.cast_eq_zero, not_false_iff]
        Â· exact ENNReal.natCast_ne_top _
      _ â‰¤ âˆ‘ i, Î¼ (s âˆ© v i) := by
        conv_lhs => rw [A]
        apply measure_iUnion_fintype_le
  obtain âŸ¨i, -, hiâŸ© : âˆƒ (i : Fin N), i âˆˆ Finset.univ âˆ§ Î¼ s / N â‰¤ Î¼ (s âˆ© v i) := by
    apply ENNReal.exists_le_of_sum_le _ S
    exact âŸ¨âŸ¨0, bot_lt_iff_ne_bot.2 NposâŸ©, Finset.mem_univ _âŸ©
  replace hi : Î¼ s / (N + 1) < Î¼ (s âˆ© v i) := by
    apply lt_of_lt_of_le _ hi
    apply (ENNReal.mul_lt_mul_left hÎ¼s.ne' (measure_lt_top Î¼ s).ne).2
    rw [ENNReal.inv_lt_inv]
    conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
    exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
  have B : Î¼ (o âˆ© v i) = âˆ‘' x : u i, Î¼ (o âˆ© closedBall x (r x)) := by
    have : o âˆ© v i = â‹ƒ (x : s) (_ : x âˆˆ u i), o âˆ© closedBall x (r x) := by
      simp only [v, inter_iUnion]
    rw [this, measure_biUnion (u_count i)]
    Â· exact (hu i).mono fun k => inter_subset_right
    Â· exact fun b _ => omeas.inter measurableSet_closedBall
  obtain âŸ¨w, hwâŸ© :
    âˆƒ w : Finset (u i), Î¼ s / (N + 1) <
      âˆ‘ x âˆˆ w, Î¼ (o âˆ© closedBall (x : Î±) (r (x : Î±))) := by
    have C : HasSum (fun x : u i => Î¼ (o âˆ© closedBall x (r x))) (Î¼ (o âˆ© v i)) := by
      rw [B]; exact ENNReal.summable.hasSum
    have : Î¼ s / (N + 1) < Î¼ (o âˆ© v i) := hi.trans_le (measure_mono (inter_subset_inter_left _ so))
    exact ((tendsto_order.1 C).1 _ this).exists
  refine âŸ¨Finset.image (fun x : u i => x) w, ?_, ?_, ?_âŸ©
  Â· simp only [image_subset_iff, Finset.coe_image]
    intro y _
    simp only [Subtype.coe_prop, mem_preimage]
  Â· suffices H : Î¼ (o \ â‹ƒ x âˆˆ w, closedBall (â†‘x) (r â†‘x)) â‰¤ N / (N + 1) * Î¼ s by
      rw [Finset.set_biUnion_finset_image]
      exact le_trans (measure_mono (diff_subset_diff so (Subset.refl _))) H
    rw [â† diff_inter_self_eq_diff,
      measure_diff_le_iff_le_add _ inter_subset_right (measure_lt_top Î¼ _).ne]
    swap
    Â· apply MeasurableSet.inter _ omeas
      haveI : Encodable (u i) := (u_count i).toEncodable
      exact MeasurableSet.iUnion fun b => MeasurableSet.iUnion fun _ => measurableSet_closedBall
    calc
      Î¼ o = 1 / (N + 1) * Î¼ s + N / (N + 1) * Î¼ s := by
        rw [Î¼o, â† add_mul, ENNReal.div_add_div_same, add_comm, ENNReal.div_self, one_mul] <;> simp
      _ â‰¤ Î¼ ((â‹ƒ x âˆˆ w, closedBall (â†‘x) (r â†‘x)) âˆ© o) + N / (N + 1) * Î¼ s := by
        gcongr
        rw [one_div, mul_comm, â† div_eq_mul_inv]
        apply hw.le.trans (le_of_eq _)
        rw [â† Finset.set_biUnion_coe, inter_comm _ o, inter_iUnionâ‚‚, Finset.set_biUnion_coe,
          measure_biUnion_finset]
        Â· have : (w : Set (u i)).PairwiseDisjoint
              fun b : u i => closedBall (b : Î±) (r (b : Î±)) := by
            intro k _ l _ hkl; exact hu i k.2 l.2 (Subtype.val_injective.ne hkl)
          exact this.mono fun k => inter_subset_right
        Â· intro b _
          apply omeas.inter measurableSet_closedBall
  Â· intro k hk l hl hkl
    obtain âŸ¨k', _, rflâŸ© : âˆƒ k' : u i, k' âˆˆ w âˆ§ â†‘k' = k := by
      simpa only [mem_image, Finset.mem_coe, Finset.coe_image] using hk
    obtain âŸ¨l', _, rflâŸ© : âˆƒ l' : u i, l' âˆˆ w âˆ§ â†‘l' = l := by
      simpa only [mem_image, Finset.mem_coe, Finset.coe_image] using hl
    have k'nel' : (k' : s) â‰  l' := by intro h; rw [h] at hkl; exact hkl rfl
    exact hu i k'.2 l'.2 k'nel'"
Mathlib/Data/Complex/Basic.lean,Complex.re_eq_add_conj,re_eq_add_conj,f587581b0ee2b63cad0fe70882acf0e3d6c67d24,":= by
  have : (â†‘(â†‘2 : â„) : â„‚)  = (2 : â„‚) := by rfl
  simp only [add_conj, ofReal_mul, ofReal_one, ofReal_bit0, this,
    mul_div_cancel_left (z.re : â„‚) two_ne_zero]","warning:  Complex does not have a doc string
warning:  Set.reProdIm does not have a doc string
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
error:  unknown identifier 'ofReal_bit0'
error:  application type mismatch
  mul_div_cancel_left (â†‘z.re) two_ne_zero
argument
  two_ne_zero
has type
  2 â‰  0 : Prop
but is expected to have type
  â„‚ : Type
error:  unsolved goals
z : â„‚
this : â†‘2 = 2
âŠ¢ â†‘z.re = 2 * â†‘z.re / 2",theorem re_eq_add_conj (z : â„‚) : (z.re : â„‚) = (z + conj z) / 2 ,":= by
  simp only [add_conj, ofReal_mul, ofReal_ofNat, mul_div_cancel_leftâ‚€ (z.re : â„‚) two_ne_zero]"
Mathlib/SetTheory/Cardinal/Cofinality.lean,Cardinal.mk_bounded_subset,mk_bounded_subset,ad18eeb8eb4cef77ae3faa6e797d7c84c4ea68e2,":= by
  rcases eq_or_ne #Î± 0 with (ha | ha)
  Â· rw [ha]
    haveI := mk_eq_zero_iff.1 ha
    rw [mk_eq_zero_iff]
    constructor
    rintro âŸ¨s, hsâŸ©
    exact (not_unbounded_iff s).2 hs (unbounded_of_isEmpty s)
  have h' : IsStrongLimit #Î± := âŸ¨ha, hâŸ©
  have ha := h'.isLimit.aleph0_le
  apply le_antisymm
  Â· have : { s : Set Î± | Bounded r s } = â‹ƒ i, ğ’«{ j | r j i } := setOf_exists _
    rw [â† coe_setOf, this]
    refine mk_iUnion_le_sum_mk.trans ((sum_le_iSup (fun i => #(ğ’«{ j | r j i }))).trans
      ((mul_le_max_of_aleph0_le_left ha).trans ?_))
    rw [max_eq_left]
    apply ciSup_le' _
    intro i
    rw [mk_powerset]
    apply (h'.two_power_lt _).le
    rw [coe_setOf, card_typein, â† lt_ord, hr]
    apply typein_lt_type
  Â· refine @mk_le_of_injective Î± _ (fun x => Subtype.mk {x} ?_)? _
    Â· apply bounded_singleton
      rw [â† hr]
      apply ord_isLimit ha
    Â· intro a b hab
      simpa [singleton_eq_singleton_iff] using hab","error:  typeclass instance problem is stuck, it is often due to metavariables
  Singleton Î± ?m.90752
error:  unexpected token '?'; expected 'binder_predicate'","theorem mk_bounded_subset {Î± : Type*} (h : âˆ€ x < #Î±, (2^x) < #Î±) {r : Î± â†’ Î± â†’ Prop}
    [IsWellOrder Î± r] (hr : (#Î±).ord = type r) : #{ s : Set Î± // Bounded r s } = #Î± ",":= by
  rcases eq_or_ne #Î± 0 with (ha | ha)
  Â· rw [ha]
    haveI := mk_eq_zero_iff.1 ha
    rw [mk_eq_zero_iff]
    constructor
    rintro âŸ¨s, hsâŸ©
    exact (not_unbounded_iff s).2 hs (unbounded_of_isEmpty s)
  have h' : IsStrongLimit #Î± := âŸ¨ha, hâŸ©
  have ha := h'.isLimit.aleph0_le
  apply le_antisymm
  Â· have : { s : Set Î± | Bounded r s } = â‹ƒ i, ğ’«{ j | r j i } := setOf_exists _
    rw [â† coe_setOf, this]
    refine mk_iUnion_le_sum_mk.trans ((sum_le_iSup (fun i => #(ğ’«{ j | r j i }))).trans
      ((mul_le_max_of_aleph0_le_left ha).trans ?_))
    rw [max_eq_left]
    apply ciSup_le' _
    intro i
    rw [mk_powerset]
    apply (h'.two_power_lt _).le
    rw [coe_setOf, card_typein, â† lt_ord, hr]
    apply typein_lt_type
  Â· refine @mk_le_of_injective Î± _ (fun x => Subtype.mk {x} ?_) ?_
    Â· apply bounded_singleton
      rw [â† hr]
      apply ord_isLimit ha
    Â· intro a b hab
      simpa [singleton_eq_singleton_iff] using hab"
Mathlib/Computability/Primrec.lean,Primrec.list_ofFn,list_ofFn,b912476b37f2ea41ee51af7e63439f4a769be095,"  | 0, _, _ => const []
  | n + 1, f, hf => by
    simp [List.ofFn_succ]; exact list_cons.compâ‚‚ (hf 0) (list_ofFn fun i => hf i.succ)","error:  application type mismatch
  Primrecâ‚‚.compâ‚‚ list_cons (hf 0)
argument
  hf 0
has type
  Primrec (f 0) : Prop
but is expected to have type
  Primrecâ‚‚ ?m.252900 : Prop","theorem list_ofFn :
    âˆ€ {n} {f : Fin n â†’ Î± â†’ Ïƒ}, (âˆ€ i, Primrec (f i)) â†’ Primrec fun a => List.ofFn fun i => f i a
","  | 0, _, _ => const []
  | n + 1, f, hf => by
    simp [List.ofFn_succ]; exact list_cons.comp (hf 0) (list_ofFn fun i => hf i.succ)"
Mathlib/Topology/MetricSpace/HausdorffDistance.lean,EMetric.hausdorffEdist_triangle,hausdorffEdist_triangle,b01e05bf55a8108c265f190f8e38705cf2c8168f,":= by
  rw [hausdorffEdist_def]
  simp only [sup_le_iff, supáµ¢_le_iff]
  constructor
  show âˆ€ x âˆˆ s, infEdist x u â‰¤ hausdorffEdist s t + hausdorffEdist t u
  exact fun x xs =>
    calc
      infEdist x u â‰¤ infEdist x t + hausdorffEdist t u :=
        infEdist_le_infEdist_add_hausdorffEdist
      _ â‰¤ hausdorffEdist s t + hausdorffEdist t u :=
        add_le_add_right (infEdist_le_hausdorffEdist_of_mem xs) _
  show âˆ€ x âˆˆ u, infEdist x s â‰¤ hausdorffEdist s t + hausdorffEdist t u
  exact fun x xu =>
    calc
      infEdist x s â‰¤ infEdist x t + hausdorffEdist t s :=
        infEdist_le_infEdist_add_hausdorffEdist
      _ â‰¤ hausdorffEdist u t + hausdorffEdist t s :=
        add_le_add_right (infEdist_le_hausdorffEdist_of_mem xu) _
      _ = hausdorffEdist s t + hausdorffEdist t u := by simp [hausdorffEdist_comm, add_comm]","error:  unknown identifier 'supáµ¢_le_iff'
error:  type mismatch
  this
has type
  âˆ€ x âˆˆ s, infEdist x u â‰¤ hausdorffEdist s t + hausdorffEdist t u : Prop
but is expected to have type
  â¨† x âˆˆ s, infEdist x u â‰¤ hausdorffEdist s t + hausdorffEdist t u : Prop
error:  type mismatch
  this
has type
  âˆ€ x âˆˆ u, infEdist x s â‰¤ hausdorffEdist s t + hausdorffEdist t u : Prop
but is expected to have type
  â¨† y âˆˆ u, infEdist y s â‰¤ hausdorffEdist s t + hausdorffEdist t u : Prop",theorem hausdorffEdist_triangle : hausdorffEdist s u â‰¤ hausdorffEdist s t + hausdorffEdist t u ,":= by
  rw [hausdorffEdist_def]
  simp only [sup_le_iff, iSup_le_iff]
  constructor
  Â· show âˆ€ x âˆˆ s, infEdist x u â‰¤ hausdorffEdist s t + hausdorffEdist t u
    exact fun x xs =>
      calc
        infEdist x u â‰¤ infEdist x t + hausdorffEdist t u :=
          infEdist_le_infEdist_add_hausdorffEdist
        _ â‰¤ hausdorffEdist s t + hausdorffEdist t u :=
          add_le_add_right (infEdist_le_hausdorffEdist_of_mem xs) _
  Â· show âˆ€ x âˆˆ u, infEdist x s â‰¤ hausdorffEdist s t + hausdorffEdist t u
    exact fun x xu =>
      calc
        infEdist x s â‰¤ infEdist x t + hausdorffEdist t s :=
          infEdist_le_infEdist_add_hausdorffEdist
        _ â‰¤ hausdorffEdist u t + hausdorffEdist t s :=
          add_le_add_right (infEdist_le_hausdorffEdist_of_mem xu) _
        _ = hausdorffEdist s t + hausdorffEdist t u := by simp [hausdorffEdist_comm, add_comm]"
Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean,MeasureTheory.integrableOn_Ioi_deriv_of_nonneg',integrableOn_Ioi_deriv_of_nonneg',c5594244d6b6e5e0c0a479a4501c34b0ea194fce,":= by
  refine integrableOn_Ioi_deriv_of_nonneg (fun x hx â†¦ ?_) (fun x hx => hderiv x hx.out.le) g'pos hg
  exact (hderiv x hx).continuousAt.continuousWithinAt","error:  application type mismatch
  hderiv x
argument
  x
has type
  Set â„ : Type
but is expected to have type
  â„ : Type","theorem integrableOn_Ioi_deriv_of_nonneg' (hderiv : âˆ€ x âˆˆ Ici a, HasDerivAt g (g' x) x)
    (g'pos : âˆ€ x âˆˆ Ioi a, 0 â‰¤ g' x) (hg : Tendsto g atTop (ğ“ l)) : IntegrableOn g' (Ioi a) ",":= by
  refine integrableOn_Ioi_deriv_of_nonneg ?_ (fun x hx => hderiv x hx.out.le) g'pos hg
  exact (hderiv a left_mem_Ici).continuousAt.continuousWithinAt"
Mathlib/Computability/AkraBazzi/AkraBazzi.lean,AkraBazziRecurrence.T_isBigO_smoothingFn_mul_asympBound,T_isBigO_smoothingFn_mul_asympBound,dbf5a47b8c4182b629cafbc5ac0943103cfdca17,":= by
  let b' := b (min_bi b) / 2
  have hb_pos : 0 < b' := R.bi_min_div_two_pos
  rw [isBigO_atTop_iff_eventually_exists]
  obtain âŸ¨câ‚, hcâ‚, h_sumTransform_auxâŸ© := R.eventually_atTop_sumTransform_ge
  filter_upwards [eventually_ge_atTop R.nâ‚€,       
      eventually_forall_ge_atTop.mpr eventually_one_sub_smoothingFn_pos,    
      eventually_forall_ge_atTop.mpr
        <| eventually_one_sub_smoothingFn_gt_const (1/2) (by norm_num),    
      eventually_forall_ge_atTop.mpr R.eventually_asympBound_pos,            
      eventually_forall_ge_atTop.mpr R.eventually_asympBound_r_pos,          
      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop
        R.eventually_asympBound_pos,   
      eventually_gt_atTop 0,                                                
      eventually_forall_ge_atTop.mpr R.eventually_one_sub_smoothingFn_r_pos,  
      eventually_forall_ge_atTop.mpr R.rpow_p_mul_one_sub_smoothingFn_le,    
      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop
        eventually_one_sub_smoothingFn_pos,   
      eventually_forall_ge_atTop.mpr h_sumTransform_aux,                     
      eventually_forall_ge_atTop.mpr R.eventually_bi_mul_le_r]               
    with nâ‚€ nâ‚€_ge_Rnâ‚€ h_smoothing_pos h_smoothing_gt_half
      h_asympBound_pos h_asympBound_r_pos h_asympBound_floor nâ‚€_pos h_smoothing_r_pos
      bound1 h_smoothingFn_floor h_sumTransform h_bi_le_r
  have h_base_nonempty := R.base_nonempty nâ‚€_pos
  let base_max : â„ :=
    (Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€).sup' h_base_nonempty
      fun n => T n / ((1 - Îµ n) * asympBound g a b n)
  set C := max (2 * câ‚â»Â¹) base_max with hC
  refine âŸ¨C, fun n hn => ?_âŸ©
  have h_base : âˆ€ n âˆˆ Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€, T n â‰¤ C * ((1 - Îµ n) * asympBound g a b n) := by
    intro n hn
    rw [Finset.mem_Ico] at hn
    have htmp1 : 0 < 1 - Îµ n := h_smoothingFn_floor n hn.1
    have htmp2 : 0 < asympBound g a b n := h_asympBound_floor n hn.1
    rw [â† _root_.div_le_iff (by positivity)]
    rw [â† Finset.mem_Ico] at hn
    calc T n / ((1 - Îµ â†‘n) * asympBound g a b n)
           â‰¤ (Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€).sup' h_base_nonempty
                (fun z => T z / ((1 - Îµ z) * asympBound g a b z)) :=
                  Finset.le_sup'_of_le _ (b := n) hn le_rfl
         _ â‰¤ C := le_max_right _ _
  have h_asympBound_pos' : 0 < asympBound g a b n := h_asympBound_pos n hn
  have h_one_sub_smoothingFn_pos' : 0 < 1 - Îµ n := h_smoothing_pos n hn
  rw [Real.norm_of_nonneg (R.T_nonneg n), Real.norm_of_nonneg (by positivity)]
  induction n using Nat.strongInductionOn with
  | ind n h_ind =>
    have b_mul_nâ‚€_le_ri i : âŒŠb' * â†‘nâ‚€âŒ‹â‚Š â‰¤ r i n := by
      exact_mod_cast calc âŒŠb' * (nâ‚€ : â„)âŒ‹â‚Š â‰¤ b' * nâ‚€      := Nat.floor_le <| by positivity
                                  _ â‰¤ b' * n        := by gcongr
                                  _ â‰¤ r i n      := h_bi_le_r n hn i
    have g_pos : 0 â‰¤ g n := R.g_nonneg n (by positivity)
    calc
      T n = (âˆ‘ i, a i * T (r i n)) + g n := by exact R.h_rec n <| nâ‚€_ge_Rnâ‚€.trans hn
        _ â‰¤ (âˆ‘ i, a i * (C * ((1 - Îµ (r i n)) * asympBound g a b (r i n)))) + g n := by
            gcongr (âˆ‘ i, a i * ?_) + g n with i _
            Â· exact le_of_lt <| R.a_pos _
            Â· if ri_lt_nâ‚€ : r i n < nâ‚€ then
                exact h_base _ <| by aesop
              else
                push_neg at ri_lt_nâ‚€
                exact h_ind (r i n) (R.r_lt_n _ _ (nâ‚€_ge_Rnâ‚€.trans hn)) ri_lt_nâ‚€
                  (h_asympBound_r_pos _ hn _) (h_smoothing_r_pos n hn i)
        _ = (âˆ‘ i, a i * (C * ((1 - Îµ (r i n)) * ((r i n) ^ (p a b)
                * (1 + (âˆ‘ u in range (r i n), g u / u ^ ((p a b) + 1))))))) + g n := by
            simp_rw [asympBound_def']
        _ = (âˆ‘ i, C * a i * ((r i n) ^ (p a b) * (1 - Îµ (r i n))
                * ((1 + (âˆ‘ u in range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by
            congr; ext; ring
        _ â‰¤ (âˆ‘ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n)
                * ((1 + (âˆ‘ u in range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by
            gcongr (âˆ‘ i, C * a i * (?_
                * ((1 + (âˆ‘ u in range (r i n), g u / u ^ ((p a b) + 1)))))) + g n with i
            Â· have := R.a_pos i
              positivity
            Â· refine add_nonneg zero_le_one <| Finset.sum_nonneg fun j _ => ?_
              rw [div_nonneg_iff]
              exact Or.inl âŸ¨R.g_nonneg j (by positivity), by positivityâŸ©
            Â· exact bound1 n hn i
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n)
                * ((1 + ((âˆ‘ u in range n, g u / u ^ ((p a b) + 1))
                - (âˆ‘ u in Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))) + g n := by
            congr; ext i; congr
            refine eq_sub_of_add_eq ?_
            rw [add_comm]
            exact add_eq_of_eq_sub <| Finset.sum_Ico_eq_sub _
              <| le_of_lt <| R.r_lt_n i n <| nâ‚€_ge_Rnâ‚€.trans hn
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n) * ((n ^ (p a b)
                * (1 + (âˆ‘ u in range n, g u / u ^ ((p a b) + 1)))
                - n ^ (p a b) * (âˆ‘ u in Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))
                + g n := by
            congr; ext; ring
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n)
                * ((asympBound g a b n - sumTransform (p a b) g (r i n) n)))) + g n := by
            simp_rw [asympBound_def', sumTransform_def]
        _ â‰¤ (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n)
                * ((asympBound g a b n - câ‚ * g n)))) + g n := by
            gcongr with i
            Â· have := R.a_pos i
              positivity
            Â· have := R.b_pos i
              positivity
            Â· exact h_sumTransform n hn i
        _ = (âˆ‘ i, C * (1 - Îµ n) * ((asympBound g a b n - câ‚ * g n))
                * (a i * (b i) ^ (p a b))) + g n := by
            congr; ext; ring
        _ = C * (1 - Îµ n) * (asympBound g a b n - câ‚ * g n) + g n := by
            rw [â† Finset.mul_sum, R.sumCoeffsExp_p_eq_one, mul_one]
        _ = C * (1 - Îµ n) * asympBound g a b n + (1 - C * câ‚ * (1 - Îµ n)) * g n := by ring
        _ â‰¤ C * (1 - Îµ n) * asympBound g a b n + 0 := by
            gcongr
            refine mul_nonpos_of_nonpos_of_nonneg ?_ g_pos
            rw [sub_nonpos]
            calc 1 â‰¤ 2 * (câ‚â»Â¹ * câ‚) * (1/2) := by
                    rw [inv_mul_cancel (by positivity : câ‚ â‰  0)]; norm_num
                 _ = (2 * câ‚â»Â¹) * câ‚ * (1/2) := by ring
                 _ â‰¤ C * câ‚ * (1 - Îµ n) := by gcongr
                                              Â· rw [hC]; exact le_max_left _ _
                                              Â· exact le_of_lt <| h_smoothing_gt_half n hn
        _ = C * ((1 - Îµ n) * asympBound g a b n) := by ring","error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information
error:  (deterministic) timeout at `whnf`, maximum number of heartbeats (200000) has been reached
use `set_option maxHeartbeats <num>` to set the limit
use `set_option diagnostics true` to get diagnostic information","lemma T_isBigO_smoothingFn_mul_asympBound :
    T =O[atTop] (fun n => (1 - Îµ n) * asympBound g a b n) ",":= by
  let b' := b (min_bi b) / 2
  have hb_pos : 0 < b' := R.bi_min_div_two_pos
  rw [isBigO_atTop_iff_eventually_exists]
  obtain âŸ¨câ‚, hcâ‚, h_sumTransform_auxâŸ© := R.eventually_atTop_sumTransform_ge
  filter_upwards [eventually_ge_atTop R.nâ‚€,       
      eventually_forall_ge_atTop.mpr eventually_one_sub_smoothingFn_pos,    
      eventually_forall_ge_atTop.mpr
        <| eventually_one_sub_smoothingFn_gt_const (1/2) (by norm_num),    
      eventually_forall_ge_atTop.mpr R.eventually_asympBound_pos,            
      eventually_forall_ge_atTop.mpr R.eventually_asympBound_r_pos,          
      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop
        R.eventually_asympBound_pos,   
      eventually_gt_atTop 0,                                                
      eventually_forall_ge_atTop.mpr R.eventually_one_sub_smoothingFn_r_pos,  
      eventually_forall_ge_atTop.mpr R.rpow_p_mul_one_sub_smoothingFn_le,    
      (tendsto_nat_floor_mul_atTop b' hb_pos).eventually_forall_ge_atTop
        eventually_one_sub_smoothingFn_pos,   
      eventually_forall_ge_atTop.mpr h_sumTransform_aux,                     
      eventually_forall_ge_atTop.mpr R.eventually_bi_mul_le_r]               
    with nâ‚€ nâ‚€_ge_Rnâ‚€ h_smoothing_pos h_smoothing_gt_half
      h_asympBound_pos h_asympBound_r_pos h_asympBound_floor nâ‚€_pos h_smoothing_r_pos
      bound1 h_smoothingFn_floor h_sumTransform h_bi_le_r
  have h_base_nonempty := R.base_nonempty nâ‚€_pos
  let base_max : â„ :=
    (Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€).sup' h_base_nonempty
      fun n => T n / ((1 - Îµ n) * asympBound g a b n)
  set C := max (2 * câ‚â»Â¹) base_max with hC
  refine âŸ¨C, fun n hn => ?_âŸ©
  have h_base : âˆ€ n âˆˆ Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€, T n â‰¤ C * ((1 - Îµ n) * asympBound g a b n) := by
    intro n hn
    rw [Finset.mem_Ico] at hn
    have htmp1 : 0 < 1 - Îµ n := h_smoothingFn_floor n hn.1
    have htmp2 : 0 < asympBound g a b n := h_asympBound_floor n hn.1
    rw [â† _root_.div_le_iff (by positivity)]
    rw [â† Finset.mem_Ico] at hn
    calc T n / ((1 - Îµ â†‘n) * asympBound g a b n)
           â‰¤ (Finset.Ico (âŒŠb' * nâ‚€âŒ‹â‚Š) nâ‚€).sup' h_base_nonempty
                (fun z => T z / ((1 - Îµ z) * asympBound g a b z)) :=
                  Finset.le_sup'_of_le _ (b := n) hn le_rfl
         _ â‰¤ C := le_max_right _ _
  have h_asympBound_pos' : 0 < asympBound g a b n := h_asympBound_pos n hn
  have h_one_sub_smoothingFn_pos' : 0 < 1 - Îµ n := h_smoothing_pos n hn
  rw [Real.norm_of_nonneg (R.T_nonneg n), Real.norm_of_nonneg (by positivity)]
  induction n using Nat.strongInductionOn with
  | ind n h_ind =>
    have b_mul_nâ‚€_le_ri i : âŒŠb' * â†‘nâ‚€âŒ‹â‚Š â‰¤ r i n := by
      exact_mod_cast calc âŒŠb' * (nâ‚€ : â„)âŒ‹â‚Š â‰¤ b' * nâ‚€      := Nat.floor_le <| by positivity
                                  _ â‰¤ b' * n        := by gcongr
                                  _ â‰¤ r i n      := h_bi_le_r n hn i
    have g_pos : 0 â‰¤ g n := R.g_nonneg n (by positivity)
    calc
      T n = (âˆ‘ i, a i * T (r i n)) + g n := by exact R.h_rec n <| nâ‚€_ge_Rnâ‚€.trans hn
        _ â‰¤ (âˆ‘ i, a i * (C * ((1 - Îµ (r i n)) * asympBound g a b (r i n)))) + g n := by
            gcongr (âˆ‘ i, a i * ?_) + g n with i _
            Â· exact le_of_lt <| R.a_pos _
            Â· if ri_lt_nâ‚€ : r i n < nâ‚€ then
                exact h_base _ <| by
                  simp_all only [gt_iff_lt, Nat.ofNat_pos, div_pos_iff_of_pos_right,
                    eventually_atTop, ge_iff_le, sub_pos, one_div, mem_Ico, and_imp,
                    forall_true_left, mem_univ, and_self, b', C, base_max]
              else
                push_neg at ri_lt_nâ‚€
                exact h_ind (r i n) (R.r_lt_n _ _ (nâ‚€_ge_Rnâ‚€.trans hn)) ri_lt_nâ‚€
                  (h_asympBound_r_pos _ hn _) (h_smoothing_r_pos n hn i)
        _ = (âˆ‘ i, a i * (C * ((1 - Îµ (r i n)) * ((r i n) ^ (p a b)
                * (1 + (âˆ‘ u âˆˆ range (r i n), g u / u ^ ((p a b) + 1))))))) + g n := by
            simp_rw [asympBound_def']
        _ = (âˆ‘ i, C * a i * ((r i n) ^ (p a b) * (1 - Îµ (r i n))
                * ((1 + (âˆ‘ u âˆˆ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by
            congr; ext; ring
        _ â‰¤ (âˆ‘ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n)
                * ((1 + (âˆ‘ u âˆˆ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n := by
            gcongr (âˆ‘ i, C * a i * (?_
                * ((1 + (âˆ‘ u âˆˆ range (r i n), g u / u ^ ((p a b) + 1)))))) + g n with i
            Â· have := R.a_pos i
              positivity
            Â· refine add_nonneg zero_le_one <| Finset.sum_nonneg fun j _ => ?_
              rw [div_nonneg_iff]
              exact Or.inl âŸ¨R.g_nonneg j (by positivity), by positivityâŸ©
            Â· exact bound1 n hn i
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * n ^ (p a b) * (1 - Îµ n)
                * ((1 + ((âˆ‘ u âˆˆ range n, g u / u ^ ((p a b) + 1))
                - (âˆ‘ u âˆˆ Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))) + g n := by
            congr; ext i; congr
            refine eq_sub_of_add_eq ?_
            rw [add_comm]
            exact add_eq_of_eq_sub <| Finset.sum_Ico_eq_sub _
              <| le_of_lt <| R.r_lt_n i n <| nâ‚€_ge_Rnâ‚€.trans hn
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n) * ((n ^ (p a b)
                * (1 + (âˆ‘ u âˆˆ range n, g u / u ^ ((p a b) + 1)))
                - n ^ (p a b) * (âˆ‘ u âˆˆ Finset.Ico (r i n) n, g u / u ^ ((p a b) + 1))))))
                + g n := by
            congr; ext; ring
        _ = (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n)
                * ((asympBound g a b n - sumTransform (p a b) g (r i n) n)))) + g n := by
            simp_rw [asympBound_def', sumTransform_def]
        _ â‰¤ (âˆ‘ i, C * a i * ((b i) ^ (p a b) * (1 - Îµ n)
                * ((asympBound g a b n - câ‚ * g n)))) + g n := by
            gcongr with i
            Â· have := R.a_pos i
              positivity
            Â· have := R.b_pos i
              positivity
            Â· exact h_sumTransform n hn i
        _ = (âˆ‘ i, C * (1 - Îµ n) * ((asympBound g a b n - câ‚ * g n))
                * (a i * (b i) ^ (p a b))) + g n := by
            congr; ext; ring
        _ = C * (1 - Îµ n) * (asympBound g a b n - câ‚ * g n) + g n := by
            rw [â† Finset.mul_sum, R.sumCoeffsExp_p_eq_one, mul_one]
        _ = C * (1 - Îµ n) * asympBound g a b n + (1 - C * câ‚ * (1 - Îµ n)) * g n := by ring
        _ â‰¤ C * (1 - Îµ n) * asympBound g a b n + 0 := by
            gcongr
            refine mul_nonpos_of_nonpos_of_nonneg ?_ g_pos
            rw [sub_nonpos]
            calc 1 â‰¤ 2 * (câ‚â»Â¹ * câ‚) * (1/2) := by
                    rw [inv_mul_cancel (by positivity : câ‚ â‰  0)]; norm_num
                 _ = (2 * câ‚â»Â¹) * câ‚ * (1/2) := by ring
                 _ â‰¤ C * câ‚ * (1 - Îµ n) := by gcongr
                                              Â· rw [hC]; exact le_max_left _ _
                                              Â· exact le_of_lt <| h_smoothing_gt_half n hn
        _ = C * ((1 - Îµ n) * asympBound g a b n) := by ring"
Mathlib/RingTheory/MvPolynomial/WeightedHomogeneous.lean,MvPolynomial.weightedHomogeneousComponent_isWeightedHomogeneous,weightedHomogeneousComponent_isWeightedHomogeneous,c04b29dd6b022753894b2fc21d2d4951e76e339e,":= by
  intro d hd
  contrapose! hd
  rw [coeff_weightedHomogeneousComponent, if_neg hd]","error:  failed to synthesize
  DecidableEq M
use `set_option diagnostics true` to get diagnostic information","theorem weightedHomogeneousComponent_isWeightedHomogeneous :
    (weightedHomogeneousComponent w n Ï†).IsWeightedHomogeneous w n ",":= by
  classical
  intro d hd
  contrapose! hd
  rw [coeff_weightedHomogeneousComponent, if_neg hd]"
Mathlib/GroupTheory/Torsion.lean,IsTorsion.not_torsion_free,IsTorsion.not_torsion_free,2ac7d87c221020b247729b180bbe2575cceb0700,":= fun tG =>
  (not_isTorsionFree_iff _).mpr <| by
    obtain âŸ¨x, hxâŸ© := (nontrivial_iff_exists_ne (1 : G)).mp hN
    exact âŸ¨x, hx, tG xâŸ©","error:  function expected at
  not_isTorsionFree_iff
term has type
  Â¬IsTorsionFree ?m.49091 â†” âˆƒ g, g â‰  1 âˆ§ IsOfFinOrder g",theorem IsTorsion.not_torsion_free [hN : Nontrivial G] : IsTorsion G â†’ Â¬IsTorsionFree G ,":= fun tG =>
  not_isTorsionFree_iff.mpr <| by
    obtain âŸ¨x, hxâŸ© := (nontrivial_iff_exists_ne (1 : G)).mp hN
    exact âŸ¨x, hx, tG xâŸ©"
Mathlib/Geometry/Manifold/MFDeriv/Basic.lean,HasMFDerivAt.hasMFDerivWithinAt,HasMFDerivAt.hasMFDerivWithinAt,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  âŸ¨ContinuousAt.continuousWithinAt h.1, HasFDerivWithinAt.mono h.2 (inter_subset_right _ _)âŸ©","error:  function expected at
  inter_subset_right ?m.93025
term has type
  ?m.93024 âˆˆ ?m.93023","theorem HasMFDerivAt.hasMFDerivWithinAt (h : HasMFDerivAt I I' f x f') :
    HasMFDerivWithinAt I I' f s x f' ",":=
  âŸ¨ContinuousAt.continuousWithinAt h.1, HasFDerivWithinAt.mono h.2 inter_subset_rightâŸ©"
Mathlib/RingTheory/PowerSeries/Basic.lean,Polynomial.coe_pow,coe_pow,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":=
  coeToMvPowerSeries.ringHom.map_pow _ _","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
error:  unknown identifier 'coeToMvPowerSeries.ringHom.map_pow'",theorem coe_pow (n : â„•) : ((Ï† ^ n : R[X]) : PowerSeries R) = (Ï† : PowerSeries R) ^ n ,":=
  coeToPowerSeries.ringHom.map_pow _ _"
Mathlib/MeasureTheory/Measure/EverywherePos.lean,MeasureTheory.Measure.measure_eq_zero_of_subset_diff_everywherePosSubset,measure_eq_zero_of_subset_diff_everywherePosSubset,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  apply hk.induction_on (p := fun t â†¦ Î¼ t = 0)
  Â· exact measure_empty
  Â· exact fun s t hst ht â†¦ measure_mono_null hst ht
  Â· exact fun s t hs ht â†¦ measure_union_null hs ht
  Â· intro x hx
    obtain âŸ¨u, ux, huâŸ© : âˆƒ u âˆˆ ğ“[s] x, Î¼ u = 0 :=
      by simpa [everywherePosSubset, (h'k hx).1] using (h'k hx).2
    exact âŸ¨u, nhdsWithin_mono x (h'k.trans (diff_subset _ _)) ux, huâŸ©","error:  function expected at
  diff_subset ?m.28174
term has type
  ?m.28173 âˆˆ ?m.28171","lemma measure_eq_zero_of_subset_diff_everywherePosSubset
    (hk : IsCompact k) (h'k : k âŠ† s \ Î¼.everywherePosSubset s) : Î¼ k = 0 ",":= by
  apply hk.induction_on (p := fun t â†¦ Î¼ t = 0)
  Â· exact measure_empty
  Â· exact fun s t hst ht â†¦ measure_mono_null hst ht
  Â· exact fun s t hs ht â†¦ measure_union_null hs ht
  Â· intro x hx
    obtain âŸ¨u, ux, huâŸ© : âˆƒ u âˆˆ ğ“[s] x, Î¼ u = 0 := by
      simpa [everywherePosSubset, (h'k hx).1] using (h'k hx).2
    exact âŸ¨u, nhdsWithin_mono x (h'k.trans diff_subset) ux, huâŸ©"
Mathlib/Combinatorics/SimpleGraph/Finite.lean,SimpleGraph.maxDegree_le_of_forall_degree_le,maxDegree_le_of_forall_degree_le,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  by_cases hV : (univ : Finset V).Nonempty
  Â· haveI : Nonempty V := univ_nonempty_iff.mp hV
    obtain âŸ¨v, hvâŸ© := G.exists_maximal_degree_vertex
    rw [hv]
    apply h
  Â· rw [not_nonempty_iff_eq_empty] at hV
    rw [maxDegree, hV, image_empty]
    exact zero_le k","error:  failed to synthesize
  CanonicallyOrderedAddCommMonoid â„•
use `set_option diagnostics true` to get diagnostic information","theorem maxDegree_le_of_forall_degree_le [DecidableRel G.Adj] (k : â„•) (h : âˆ€ v, G.degree v â‰¤ k) :
    G.maxDegree â‰¤ k ",":= by
  by_cases hV : (univ : Finset V).Nonempty
  Â· haveI : Nonempty V := univ_nonempty_iff.mp hV
    obtain âŸ¨v, hvâŸ© := G.exists_maximal_degree_vertex
    rw [hv]
    apply h
  Â· rw [not_nonempty_iff_eq_empty] at hV
    rw [maxDegree, hV, image_empty]
    exact k.zero_le"
Mathlib/Algebra/Star/Order.lean,StarOrderedRing.of_nonneg_iff',of_nonneg_iff',d1510db4f0b2443b9be2e0eb107c1b795cfeb4fb,":=
  of_le_iff <| by
    haveI : AddLeftMono R := âŸ¨fun _ _ _ h => h_add h _âŸ©
    simpa [sub_eq_iff_eq_add', sub_nonneg] using fun x y => h_nonneg_iff (y - x)","error:  unknown identifier 'AddLeftMono'
error:  type mismatch
  hâœ
has type
  âˆ€ (x y : R), 0 â‰¤ y - x â†” âˆƒ s, y = x + star s * s : Prop
but is expected to have type
  âˆ€ (x y : R), x â‰¤ y â†” âˆƒ s, y = x + star s * s : Prop","lemma of_nonneg_iff' [NonUnitalRing R] [PartialOrder R] [StarRing R]
    (h_add : âˆ€ {x y : R}, x â‰¤ y â†’ âˆ€ z, z + x â‰¤ z + y)
    (h_nonneg_iff : âˆ€ x : R, 0 â‰¤ x â†” âˆƒ s, x = star s * s) : StarOrderedRing R ",":=
  of_le_iff <| by
    haveI : CovariantClass R R (Â· + Â·) (Â· â‰¤ Â·) := âŸ¨fun _ _ _ h => h_add h _âŸ©
    simpa [sub_eq_iff_eq_add', sub_nonneg] using fun x y => h_nonneg_iff (y - x)"
Mathlib/MeasureTheory/PiSystem.lean,subset_piiUnionInter,subset_piiUnionInter,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have h_ss : {i} âŠ† S := by
    intro j hj
    rw [mem_singleton_iff] at hj
    rwa [hj]
  refine Subset.trans ?_ (piiUnionInter_mono_right h_ss)
  rw [piiUnionInter_singleton]
  exact subset_union_left _ _","error:  function expected at
  subset_union_left ?m.56026
term has type
  ?m.56025 âˆˆ ?m.56023 âˆª ?m.56024","theorem subset_piiUnionInter {Ï€ : Î¹ â†’ Set (Set Î±)} {S : Set Î¹} {i : Î¹} (his : i âˆˆ S) :
    Ï€ i âŠ† piiUnionInter Ï€ S ",":= by
  have h_ss : {i} âŠ† S := by
    intro j hj
    rw [mem_singleton_iff] at hj
    rwa [hj]
  refine Subset.trans ?_ (piiUnionInter_mono_right h_ss)
  rw [piiUnionInter_singleton]
  exact subset_union_left"
Mathlib/Geometry/Euclidean/Circumcenter.lean,Affine.Simplex.centroid_eq_affineCombination_of_pointsWithCircumcenter,centroid_eq_affineCombination_of_pointsWithCircumcenter,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  simp_rw [centroid_def, affineCombination_apply, weightedVSubOfPoint_apply,
    sum_pointsWithCircumcenter, centroidWeightsWithCircumcenter,
    pointsWithCircumcenter_point, zero_smul, add_zero, centroidWeights,
    Set.sum_indicator_subset_of_eq_zero (Function.const (Fin (n + 1)) (card fs : â„)â»Â¹)
      (fun i wi => wi â€¢ (s.points i -áµ¥ Classical.choice AddTorsor.nonempty)) fs.subset_univ fun _ =>
      zero_smul â„ _,
    Set.indicator_apply]
  congr","error:  unknown constant 'Set.sum_indicator_subset_of_eq_zero'
error:  simp made no progress","theorem centroid_eq_affineCombination_of_pointsWithCircumcenter {n : â„•} (s : Simplex â„ P n)
    (fs : Finset (Fin (n + 1))) :
    fs.centroid â„ s.points =
      (univ : Finset (PointsWithCircumcenterIndex n)).affineCombination â„ s.pointsWithCircumcenter
        (centroidWeightsWithCircumcenter fs) ",":= by
  simp_rw [centroid_def, affineCombination_apply, weightedVSubOfPoint_apply,
    sum_pointsWithCircumcenter, centroidWeightsWithCircumcenter,
    pointsWithCircumcenter_point, zero_smul, add_zero, centroidWeights,
    â† sum_indicator_subset_of_eq_zero (Function.const (Fin (n + 1)) (card fs : â„)â»Â¹)
      (fun i wi => wi â€¢ (s.points i -áµ¥ Classical.choice AddTorsor.nonempty)) fs.subset_univ fun _ =>
      zero_smul â„ _,
    Set.indicator_apply]
  congr"
Mathlib/NumberTheory/Multiplicity.lean,multiplicity.Int.pow_sub_pow,Int.pow_sub_pow,d16c7a879e758dc3aee434d847d69bfbaf9f30f0,":= by
  cases' n with n
  Â· simp only [multiplicity.zero, add_top, pow_zero, sub_self, Nat.zero_eq]
  have h : (multiplicity _ _).Dom := finite_nat_iff.mpr âŸ¨hp.ne_one, n.succ_posâŸ©
  rcases eq_coe_iff.mp (PartENat.natCast_get h).symm with âŸ¨âŸ¨k, hkâŸ©, hpnâŸ©
  conv_lhs => rw [hk, pow_mul, pow_mul]
  rw [Nat.prime_iff_prime_int] at hp
  rw [pow_sub_pow_of_prime hp, pow_prime_pow_sub_pow_prime_pow hp hp1 hxy hx, PartENat.natCast_get]
  Â· rw [â† geom_sumâ‚‚_mul]
    exact dvd_mul_of_dvd_right hxy _
  Â· exact fun h => hx (hp.dvd_of_dvd_pow h)
  Â· rw [Int.coe_nat_dvd]
    rintro âŸ¨c, rflâŸ©
    refine' hpn âŸ¨c, _âŸ©
    rwa [pow_succ, mul_assoc]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  n.succ
R : Type u_1
nâœ : â„•
instâœ : CommRing R
a b xâœ yâœ : R
p : â„•
hp : Nat.Prime p
hp1 : Odd p
x y : â„¤
hxy : â†‘p âˆ£ x - y
hx : Â¬â†‘p âˆ£ x
n : â„•
h : (multiplicity p n.succ).Dom
hpn : Â¬p ^ ((multiplicity p n.succ).get h + 1) âˆ£ n.succ
k : â„•
hk : n.succ = p ^ (multiplicity p n.succ).get h * k
| multiplicity (â†‘p) (x ^ (n + 1) - y ^ (n + 1))
error:  application type mismatch
  pow_sub_pow hp hp1
argument
  hp1
has type
  Odd p : Prop
but is expected to have type
  â†‘p âˆ£ ?m.114179 - ?m.114180 : Prop
error:  application type mismatch
  Int.pow_sub_pow hp hp1
argument
  hp1
has type
  Odd p : Prop
but is expected to have type
  â†‘p âˆ£ ?m.116975 - ?m.116976 : Prop
error:  application type mismatch
  Int.pow_add_pow hp
argument
  hp
has type
  Nat.Prime p : Prop
but is expected to have type
  â†‘?m.120154 âˆ£ ?m.120155 + ?m.120156 : Prop
error:  application type mismatch
  multiplicity.Nat.pow_sub_pow Fact.out
argument
  Fact.out
has type
  Nat.Prime p : Prop
but is expected to have type
  ?m.164434 âˆ£ ?m.164435 - ?m.164436 : Prop
error:  application type mismatch
  multiplicity.Nat.pow_add_pow Fact.out
argument
  Fact.out
has type
  Nat.Prime p : Prop
but is expected to have type
  ?m.166313 âˆ£ ?m.166314 + ?m.166315 : Prop","theorem Int.pow_sub_pow {x y : â„¤} (hxy : â†‘p âˆ£ x - y) (hx : Â¬â†‘p âˆ£ x) (n : â„•) :
    multiplicity (â†‘p) (x ^ n - y ^ n) = multiplicity (â†‘p) (x - y) + multiplicity p n ",":= by
  cases' n with n
  Â· simp only [multiplicity.zero, add_top, pow_zero, sub_self, Nat.zero_eq]
  have h : (multiplicity _ _).Dom := finite_nat_iff.mpr âŸ¨hp.ne_one, n.succ_posâŸ©
  simp only [Nat.succ_eq_add_one] at h
  rcases eq_coe_iff.mp (PartENat.natCast_get h).symm with âŸ¨âŸ¨k, hkâŸ©, hpnâŸ©
  conv_lhs => rw [hk, pow_mul, pow_mul]
  rw [Nat.prime_iff_prime_int] at hp
  rw [pow_sub_pow_of_prime hp, pow_prime_pow_sub_pow_prime_pow hp hp1 hxy hx, PartENat.natCast_get]
  Â· rw [â† geom_sumâ‚‚_mul]
    exact dvd_mul_of_dvd_right hxy _
  Â· exact fun h => hx (hp.dvd_of_dvd_pow h)
  Â· rw [Int.natCast_dvd_natCast]
    rintro âŸ¨c, rflâŸ©
    refine hpn âŸ¨c, ?_âŸ©
    rwa [pow_succ, mul_assoc]"
Mathlib/Algebra/Homology/LocalCohomology.lean,localCohomology.hasColimitDiagram,hasColimitDiagram,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have : HasColimitsOfShape Dáµ’áµ– (AddCommGroupCatMax.{u, v}) := inferInstance
  infer_instance",error:  unknown identifier 'AddCommGroupCatMax',"lemma hasColimitDiagram (I : D â¥¤ Ideal R) (i : â„•) :
    HasColimit (diagram I i) ",":= by
  have : HasColimitsOfShape Dáµ’áµ– (AddCommGrpMax.{u, v}) := inferInstance
  infer_instance"
Mathlib/Data/NNRat/Lemmas.lean,NNRat.num_div_den,num_div_den,b31c5abb977bb83fb147c55d651e6e80b17d2171,":= by
  ext : 1
  rw [coe_div, coe_natCast, coe_natCast, num, â† Int.cast_ofNat,
    Int.natAbs_of_nonneg (Rat.num_nonneg.2 q.prop)]
  exact Rat.num_div_den q","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  OfNat.ofNat ?n
case a
p qâœ q : â„šâ‰¥0
âŠ¢ â†‘(â†‘q).num.natAbs / â†‘q.den = â†‘q",lemma num_div_den (q : â„šâ‰¥0) : (q.num : â„šâ‰¥0) / q.den = q ,":= by
  ext : 1
  rw [coe_div, coe_natCast, coe_natCast, num, â† Int.cast_natCast,
    Int.natAbs_of_nonneg (Rat.num_nonneg.2 q.cast_nonneg)]
  exact Rat.num_div_den q"
Mathlib/LinearAlgebra/Matrix/DotProduct.lean,Matrix.conjTranspose_mul_self_mulVec_eq_zero,conjTranspose_mul_self_mulVec_eq_zero,12b387935036620ac4c0b7a36290ea3174d2f485,":= by
  simpa only [â† Matrix.col_mulVec, col_eq_zero] using
    conjTranspose_mul_self_mul_eq_zero A (col v)","error:  application type mismatch
  col v
argument
  v
has type
  n â†’ R : Type (max u_2 u_4)
but is expected to have type
  Type ?u.71628 : Type (?u.71628 + 1)","lemma conjTranspose_mul_self_mulVec_eq_zero (A : Matrix m n R) (v : n â†’ R) :
    (Aá´´ * A) *áµ¥ v = 0 â†” A *áµ¥ v = 0 ",":= by
  simpa only [â† Matrix.col_mulVec, col_eq_zero] using
    conjTranspose_mul_self_mul_eq_zero A (col (Fin 1) v)"
Mathlib/RingTheory/Adjoin/Basic.lean,Algebra.mem_adjoin_of_map_mul,mem_adjoin_of_map_mul,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine
    @adjoin_induction R A _ _ _ _ (fun a => f a âˆˆ adjoin R (f '' (s âˆª {1}))) x h
      (fun a ha => subset_adjoin âŸ¨a, âŸ¨Set.subset_union_left _ _ ha, rflâŸ©âŸ©) (fun r => ?_)
      (fun y z hy hz => by simpa [hy, hz] using Subalgebra.add_mem _ hy hz) fun y z hy hz => by
      simpa [hy, hz, hf y z] using Subalgebra.mul_mem _ hy hz
  have : f 1 âˆˆ adjoin R (f '' (s âˆª {1})) :=
    subset_adjoin âŸ¨1, âŸ¨Set.subset_union_right _ _ <| Set.mem_singleton 1, rflâŸ©âŸ©
  convert Subalgebra.smul_mem (adjoin R (f '' (s âˆª {1}))) this r
  rw [algebraMap_eq_smul_one]
  exact f.map_smul _ _","error:  function expected at
  Set.subset_union_left ?m.66253
term has type
  ?m.66252 âˆˆ ?m.66250 âˆª ?m.66251
error:  function expected at
  Set.subset_union_right ?m.73666
term has type
  ?m.73665 âˆˆ ?m.73663 âˆª ?m.73664","theorem mem_adjoin_of_map_mul {s} {x : A} {f : A â†’â‚—[R] B} (hf : âˆ€ aâ‚ aâ‚‚, f (aâ‚ * aâ‚‚) = f aâ‚ * f aâ‚‚)
    (h : x âˆˆ adjoin R s) : f x âˆˆ adjoin R (f '' (s âˆª {1})) ",":= by
  refine
    @adjoin_induction R A _ _ _ _ (fun a => f a âˆˆ adjoin R (f '' (s âˆª {1}))) x h
      (fun a ha => subset_adjoin âŸ¨a, âŸ¨Set.subset_union_left ha, rflâŸ©âŸ©) (fun r => ?_)
      (fun y z hy hz => by simpa [hy, hz] using Subalgebra.add_mem _ hy hz) fun y z hy hz => by
      simpa [hy, hz, hf y z] using Subalgebra.mul_mem _ hy hz
  have : f 1 âˆˆ adjoin R (f '' (s âˆª {1})) :=
    subset_adjoin âŸ¨1, âŸ¨Set.subset_union_right <| Set.mem_singleton 1, rflâŸ©âŸ©
  convert Subalgebra.smul_mem (adjoin R (f '' (s âˆª {1}))) this r
  rw [algebraMap_eq_smul_one]
  exact f.map_smul _ _"
Mathlib/Analysis/SpecificLimits/FloorPow.lean,tendsto_div_of_monotone_of_exists_subseq_tendsto_div,tendsto_div_of_monotone_of_exists_subseq_tendsto_div,29989664323235e82eaee87f0a17599c62b6e697,":= by
  have lnonneg : 0 â‰¤ l := by
    rcases hlim 2 one_lt_two with âŸ¨c, _, ctop, climâŸ©
    have : Tendsto (fun n => u 0 / c n) atTop (ğ“ 0) :=
      tendsto_const_nhds.div_atTop (tendsto_nat_cast_atTop_iff.2 ctop)
    apply le_of_tendsto_of_tendsto' this clim fun n => _
    simp_rw [div_eq_inv_mul]
    exact fun n => mul_le_mul_of_nonneg_left (hmono (zero_le _)) (inv_nonneg.2 (Nat.cast_nonneg _))
  have A : âˆ€ Îµ : â„, 0 < Îµ â†’ âˆ€á¶  n in atTop, u n - n * l â‰¤ Îµ * (1 + Îµ + l) * n := by
    intro Îµ Îµpos
    rcases hlim (1 + Îµ) ((lt_add_iff_pos_right _).2 Îµpos) with âŸ¨c, cgrowth, ctop, climâŸ©
    have L : âˆ€á¶  n in atTop, u (c n) - c n * l â‰¤ Îµ * c n := by
      rw [â† tendsto_sub_nhds_zero_iff, â† Asymptotics.isLittleO_one_iff â„,
        Asymptotics.isLittleO_iff] at clim
      filter_upwards [clim Îµpos, ctop (Ioi_mem_atTop 0)] with n hn cnpos'
      have cnpos : 0 < c n := cnpos'
      calc
        u (c n) - c n * l = (u (c n) / c n - l) * c n := by
          simp only [cnpos.ne', Ne.def, Nat.cast_eq_zero, not_false_iff, field_simps]
        _ â‰¤ Îµ * c n := by
          refine' mul_le_mul_of_nonneg_right _ (Nat.cast_nonneg _)
          simp only [mul_one, Real.norm_eq_abs, abs_one] at hn
          exact le_trans (le_abs_self _) hn
    obtain âŸ¨a, haâŸ© :
      âˆƒ a : â„•, âˆ€ b : â„•, a â‰¤ b â†’ (c (b + 1) : â„) â‰¤ (1 + Îµ) * c b âˆ§ u (c b) - c b * l â‰¤ Îµ * c b :=
      eventually_atTop.1 (cgrowth.and L)
    let M := ((Finset.range (a + 1)).image fun i => c i).max' (by simp)
    filter_upwards [Ici_mem_atTop M]with n hn
    have exN : âˆƒ N, n < c N := by
      rcases(tendsto_atTop.1 ctop (n + 1)).exists with âŸ¨N, hNâŸ©
      exact âŸ¨N, by linarith only [hN]âŸ©
    let N := Nat.find exN
    have ncN : n < c N := Nat.find_spec exN
    have aN : a + 1 â‰¤ N := by
      by_contra' h
      have cNM : c N â‰¤ M := by
        apply le_max'
        apply mem_image_of_mem
        exact mem_range.2 h
      exact lt_irrefl _ ((cNM.trans hn).trans_lt ncN)
    have Npos : 0 < N := lt_of_lt_of_le Nat.succ_pos' aN
    have cNn : c (N - 1) â‰¤ n := by
      have : N - 1 < N := Nat.pred_lt Npos.ne'
      simpa only [not_lt] using Nat.find_min exN this
    have IcN : (c N : â„) â‰¤ (1 + Îµ) * c (N - 1) := by
      have A : a â‰¤ N - 1 := by
        apply @Nat.le_of_add_le_add_right a 1 (N - 1)
        rw [Nat.sub_add_cancel Npos]
        exact aN
      have B : N - 1 + 1 = N := Nat.succ_pred_eq_of_pos Npos
      have := (ha _ A).1
      rwa [B] at this
    calc
      u n - n * l â‰¤ u (c N) - c (N - 1) * l := by
        apply sub_le_sub (hmono ncN.le)
        apply mul_le_mul_of_nonneg_right (Nat.cast_le.2 cNn) lnonneg
      _ = u (c N) - c N * l + (c N - c (N - 1)) * l := by ring
      _ â‰¤ Îµ * c N + Îµ * c (N - 1) * l := by
        apply add_le_add
        Â· apply (ha _ _).2
          exact le_trans (by simp only [le_add_iff_nonneg_right, zero_le']) aN
        Â· apply mul_le_mul_of_nonneg_right _ lnonneg
          linarith only [IcN]
      _ â‰¤ Îµ * ((1 + Îµ) * c (N - 1)) + Îµ * c (N - 1) * l :=
        (add_le_add (mul_le_mul_of_nonneg_left IcN Îµpos.le) le_rfl)
      _ = Îµ * (1 + Îµ + l) * c (N - 1) := by ring
      _ â‰¤ Îµ * (1 + Îµ + l) * n := by
        refine' mul_le_mul_of_nonneg_left (Nat.cast_le.2 cNn) _
        apply mul_nonneg Îµpos.le
        linarith only [Îµpos, lnonneg]
  have B : âˆ€ Îµ : â„, 0 < Îµ â†’ âˆ€á¶  n : â„• in atTop, (n : â„) * l - u n â‰¤ Îµ * (1 + l) * n := by
    intro Îµ Îµpos
    rcases hlim (1 + Îµ) ((lt_add_iff_pos_right _).2 Îµpos) with âŸ¨c, cgrowth, ctop, climâŸ©
    have L : âˆ€á¶  n : â„• in atTop, (c n : â„) * l - u (c n) â‰¤ Îµ * c n := by
      rw [â† tendsto_sub_nhds_zero_iff, â† Asymptotics.isLittleO_one_iff â„,
        Asymptotics.isLittleO_iff] at clim
      filter_upwards [clim Îµpos, ctop (Ioi_mem_atTop 0)]with n hn cnpos'
      have cnpos : 0 < c n := cnpos'
      calc
        (c n : â„) * l - u (c n) = -(u (c n) / c n - l) * c n := by
          simp only [cnpos.ne', Ne.def, Nat.cast_eq_zero, not_false_iff, neg_sub, field_simps]
        _ â‰¤ Îµ * c n := by
          refine' mul_le_mul_of_nonneg_right _ (Nat.cast_nonneg _)
          simp only [mul_one, Real.norm_eq_abs, abs_one] at hn
          exact le_trans (neg_le_abs_self _) hn
    obtain âŸ¨a, haâŸ© :
      âˆƒ a : â„•,
        âˆ€ b : â„•, a â‰¤ b â†’ (c (b + 1) : â„) â‰¤ (1 + Îµ) * c b âˆ§ (c b : â„) * l - u (c b) â‰¤ Îµ * c b :=
      eventually_atTop.1 (cgrowth.and L)
    let M := ((Finset.range (a + 1)).image fun i => c i).max' (by simp)
    filter_upwards [Ici_mem_atTop M]with n hn
    have exN : âˆƒ N, n < c N := by
      rcases(tendsto_atTop.1 ctop (n + 1)).exists with âŸ¨N, hNâŸ©
      exact âŸ¨N, by linarith only [hN]âŸ©
    let N := Nat.find exN
    have ncN : n < c N := Nat.find_spec exN
    have aN : a + 1 â‰¤ N := by
      by_contra' h
      have cNM : c N â‰¤ M := by
        apply le_max'
        apply mem_image_of_mem
        exact mem_range.2 h
      exact lt_irrefl _ ((cNM.trans hn).trans_lt ncN)
    have Npos : 0 < N := lt_of_lt_of_le Nat.succ_pos' aN
    have aN' : a â‰¤ N - 1 := by
      apply @Nat.le_of_add_le_add_right a 1 (N - 1)
      rw [Nat.sub_add_cancel Npos]
      exact aN
    have cNn : c (N - 1) â‰¤ n := by
      have : N - 1 < N := Nat.pred_lt Npos.ne'
      simpa only [not_lt] using Nat.find_min exN this
    calc
      (n : â„) * l - u n â‰¤ c N * l - u (c (N - 1)) := by
        refine' add_le_add (mul_le_mul_of_nonneg_right (Nat.cast_le.2 ncN.le) lnonneg) _
        exact neg_le_neg (hmono cNn)
      _ â‰¤ (1 + Îµ) * c (N - 1) * l - u (c (N - 1)) := by
        refine' add_le_add (mul_le_mul_of_nonneg_right _ lnonneg) le_rfl
        have B : N - 1 + 1 = N := Nat.succ_pred_eq_of_pos Npos
        have := (ha _ aN').1
        rwa [B] at this
      _ = c (N - 1) * l - u (c (N - 1)) + Îµ * c (N - 1) * l := by ring
      _ â‰¤ Îµ * c (N - 1) + Îµ * c (N - 1) * l := (add_le_add (ha _ aN').2 le_rfl)
      _ = Îµ * (1 + l) * c (N - 1) := by ring
      _ â‰¤ Îµ * (1 + l) * n := by
        refine' mul_le_mul_of_nonneg_left (Nat.cast_le.2 cNn) _
        exact mul_nonneg Îµpos.le (add_nonneg zero_le_one lnonneg)
  refine' tendsto_order.2 âŸ¨fun d hd => _, fun d hd => _âŸ©
  Â· obtain âŸ¨Îµ, hÎµ, ÎµposâŸ© : âˆƒ Îµ : â„, d + Îµ * (1 + l) < l âˆ§ 0 < Îµ := by
      have L : Tendsto (fun Îµ => d + Îµ * (1 + l)) (ğ“[>] 0) (ğ“ (d + 0 * (1 + l))) := by
        apply Tendsto.mono_left _ nhdsWithin_le_nhds
        exact tendsto_const_nhds.add (tendsto_id.mul tendsto_const_nhds)
      simp only [MulZeroClass.zero_mul, add_zero] at L
      exact (((tendsto_order.1 L).2 l hd).and self_mem_nhdsWithin).exists
    filter_upwards [B Îµ Îµpos, Ioi_mem_atTop 0]with n hn npos
    simp_rw [div_eq_inv_mul]
    calc
      d < (n : â„)â»Â¹ * n * (l - Îµ * (1 + l)) := by
        rw [inv_mul_cancel, one_mul]
        Â· linarith only [hÎµ]
        Â· exact Nat.cast_ne_zero.2 (ne_of_gt npos)
      _ = (n : â„)â»Â¹ * (n * l - Îµ * (1 + l) * n) := by ring
      _ â‰¤ (n : â„)â»Â¹ * u n := by
        refine' mul_le_mul_of_nonneg_left _ (inv_nonneg.2 (Nat.cast_nonneg _))
        linarith only [hn]
  Â· obtain âŸ¨Îµ, hÎµ, ÎµposâŸ© : âˆƒ Îµ : â„, l + Îµ * (1 + Îµ + l) < d âˆ§ 0 < Îµ := by
      have L : Tendsto (fun Îµ => l + Îµ * (1 + Îµ + l)) (ğ“[>] 0) (ğ“ (l + 0 * (1 + 0 + l))) := by
        apply Tendsto.mono_left _ nhdsWithin_le_nhds
        exact
          tendsto_const_nhds.add
            (tendsto_id.mul ((tendsto_const_nhds.add tendsto_id).add tendsto_const_nhds))
      simp only [MulZeroClass.zero_mul, add_zero] at L
      exact (((tendsto_order.1 L).2 d hd).and self_mem_nhdsWithin).exists
    filter_upwards [A Îµ Îµpos, Ioi_mem_atTop 0]with n hn npos
    simp_rw [div_eq_inv_mul]
    calc
      (n : â„)â»Â¹ * u n â‰¤ (n : â„)â»Â¹ * (n * l + Îµ * (1 + Îµ + l) * n) := by
        refine' mul_le_mul_of_nonneg_left _ (inv_nonneg.2 (Nat.cast_nonneg _))
        linarith only [hn]
      _ = (n : â„)â»Â¹ * n * (l + Îµ * (1 + Îµ + l)) := by ring
      _ < d := by
        rwa [inv_mul_cancel, one_mul]
        exact Nat.cast_ne_zero.2 (ne_of_gt npos)","error:  unknown tactic
error:  unsolved goals
u : â„• â†’ â„
l : â„
hmono : Monotone u
hlim :
  âˆ€ (a : â„),
    1 < a â†’
      âˆƒ c,
        (âˆ€á¶  (n : â„•) in atTop, â†‘(c (n + 1)) â‰¤ a * â†‘(c n)) âˆ§
          Tendsto c atTop atTop âˆ§ Tendsto (fun n â†¦ u (c n) / â†‘(c n)) atTop (ğ“ l)
lnonneg : 0 â‰¤ l
Îµ : â„
Îµpos : 0 < Îµ
c : â„• â†’ â„•
cgrowth : âˆ€á¶  (n : â„•) in atTop, â†‘(c (n + 1)) â‰¤ (1 + Îµ) * â†‘(c n)
ctop : Tendsto c atTop atTop
clim : Tendsto (fun n â†¦ u (c n) / â†‘(c n)) atTop (ğ“ l)
L : âˆ€á¶  (n : â„•) in atTop, u (c n) - â†‘(c n) * l â‰¤ Îµ * â†‘(c n)
a : â„•
ha : âˆ€ (b : â„•), a â‰¤ b â†’ â†‘(c (b + 1)) â‰¤ (1 + Îµ) * â†‘(c b) âˆ§ u (c b) - â†‘(c b) * l â‰¤ Îµ * â†‘(c b)
M : â„• := (image (fun i â†¦ c i) (range (a + 1))).max' â‹¯
n : â„•
hn : n âˆˆ Set.Ici M
exN : âˆƒ N, n < c N
N : â„• := Nat.find exN
ncN : n < c N
âŠ¢ a + 1 â‰¤ N
error:  unsolved goals
case h
u : â„• â†’ â„
l : â„
hmono : Monotone u
hlim :
  âˆ€ (a : â„),
    1 < a â†’
      âˆƒ c,
        (âˆ€á¶  (n : â„•) in atTop, â†‘(c (n + 1)) â‰¤ a * â†‘(c n)) âˆ§
          Tendsto c atTop atTop âˆ§ Tendsto (fun n â†¦ u (c n) / â†‘(c n)) atTop (ğ“ l)
lnonneg : 0 â‰¤ l
Îµ : â„
Îµpos : 0 < Îµ
c : â„• â†’ â„•
cgrowth : âˆ€á¶  (n : â„•) in atTop, â†‘(c (n + 1)) â‰¤ (1 + Îµ) * â†‘(c n)
ctop : Tendsto c atTop atTop
clim : Tendsto (fun n â†¦ u (c n) / â†‘(c n)) atTop (ğ“ l)
L : âˆ€á¶  (n : â„•) in atTop, u (c n) - â†‘(c n) * l â‰¤ Îµ * â†‘(c n)
a : â„•
ha : âˆ€ (b : â„•), a â‰¤ b â†’ â†‘(c (b + 1)) â‰¤ (1 + Îµ) * â†‘(c b) âˆ§ u (c b) - â†‘(c b) * l â‰¤ Îµ * â†‘(c b)
M : â„• := (image (fun i â†¦ c i) (range (a + 1))).max' â‹¯
n : â„•
hn : n âˆˆ Set.Ici M
exN : âˆƒ N, n < c N
N : â„• := Nat.find exN
ncN : n < c N
aN : a + 1 â‰¤ N
âŠ¢ u n - â†‘n * l â‰¤ Îµ * (1 + Îµ + l) * â†‘n
error:  unsolved goals
u : â„• â†’ â„
l : â„
hmono : Monotone u
hlim :
  âˆ€ (a : â„),
    1 < a â†’
      âˆƒ c,
        (âˆ€á¶  (n : â„•) in atTop, â†‘(c (n + 1)) â‰¤ a * â†‘(c n)) âˆ§
          Tendsto c atTop atTop âˆ§ Tendsto (fun n â†¦ u (c n) / â†‘(c n)) atTop (ğ“ l)
lnonneg : 0 â‰¤ l
A : âˆ€ (Îµ : â„), 0 < Îµ â†’ âˆ€á¶  (n : â„•) in atTop, u n - â†‘n * l â‰¤ Îµ * (1 + Îµ + l) * â†‘n
âŠ¢ Tendsto (fun n â†¦ u n / â†‘n) atTop (ğ“ l)","theorem tendsto_div_of_monotone_of_exists_subseq_tendsto_div (u : â„• â†’ â„) (l : â„)
    (hmono : Monotone u)
    (hlim : âˆ€ a : â„, 1 < a â†’ âˆƒ c : â„• â†’ â„•, (âˆ€á¶  n in atTop, (c (n + 1) : â„) â‰¤ a * c n) âˆ§
      Tendsto c atTop atTop âˆ§ Tendsto (fun n => u (c n) / c n) atTop (ğ“ l)) :
    Tendsto (fun n => u n / n) atTop (ğ“ l) ",":= by
  have lnonneg : 0 â‰¤ l := by
    rcases hlim 2 one_lt_two with âŸ¨c, _, ctop, climâŸ©
    have : Tendsto (fun n => u 0 / c n) atTop (ğ“ 0) :=
      tendsto_const_nhds.div_atTop (tendsto_natCast_atTop_iff.2 ctop)
    apply le_of_tendsto_of_tendsto' this clim fun n => ?_
    gcongr
    exact hmono (zero_le _)
  have A : âˆ€ Îµ : â„, 0 < Îµ â†’ âˆ€á¶  n in atTop, u n - n * l â‰¤ Îµ * (1 + Îµ + l) * n := by
    intro Îµ Îµpos
    rcases hlim (1 + Îµ) ((lt_add_iff_pos_right _).2 Îµpos) with âŸ¨c, cgrowth, ctop, climâŸ©
    have L : âˆ€á¶  n in atTop, u (c n) - c n * l â‰¤ Îµ * c n := by
      rw [â† tendsto_sub_nhds_zero_iff, â† Asymptotics.isLittleO_one_iff â„,
        Asymptotics.isLittleO_iff] at clim
      filter_upwards [clim Îµpos, ctop (Ioi_mem_atTop 0)] with n hn cnpos'
      have cnpos : 0 < c n := cnpos'
      calc
        u (c n) - c n * l = (u (c n) / c n - l) * c n := by
          simp only [cnpos.ne', Ne, Nat.cast_eq_zero, not_false_iff, field_simps]
        _ â‰¤ Îµ * c n := by
          gcongr
          refine (le_abs_self _).trans ?_
          simpa using hn
    obtain âŸ¨a, haâŸ© :
      âˆƒ a : â„•, âˆ€ b : â„•, a â‰¤ b â†’ (c (b + 1) : â„) â‰¤ (1 + Îµ) * c b âˆ§ u (c b) - c b * l â‰¤ Îµ * c b :=
      eventually_atTop.1 (cgrowth.and L)
    let M := ((Finset.range (a + 1)).image fun i => c i).max' (by simp)
    filter_upwards [Ici_mem_atTop M] with n hn
    have exN : âˆƒ N, n < c N := by
      rcases (tendsto_atTop.1 ctop (n + 1)).exists with âŸ¨N, hNâŸ©
      exact âŸ¨N, by linarith only [hN]âŸ©
    let N := Nat.find exN
    have ncN : n < c N := Nat.find_spec exN
    have aN : a + 1 â‰¤ N := by
      by_contra! h
      have cNM : c N â‰¤ M := by
        apply le_max'
        apply mem_image_of_mem
        exact mem_range.2 h
      exact lt_irrefl _ ((cNM.trans hn).trans_lt ncN)
    have Npos : 0 < N := lt_of_lt_of_le Nat.succ_pos' aN
    have cNn : c (N - 1) â‰¤ n := by
      have : N - 1 < N := Nat.pred_lt Npos.ne'
      simpa only [not_lt] using Nat.find_min exN this
    have IcN : (c N : â„) â‰¤ (1 + Îµ) * c (N - 1) := by
      have A : a â‰¤ N - 1 := by
        apply @Nat.le_of_add_le_add_right a 1 (N - 1)
        rw [Nat.sub_add_cancel Npos]
        exact aN
      have B : N - 1 + 1 = N := Nat.succ_pred_eq_of_pos Npos
      have := (ha _ A).1
      rwa [B] at this
    calc
      u n - n * l â‰¤ u (c N) - c (N - 1) * l := by gcongr; exact hmono ncN.le
      _ = u (c N) - c N * l + (c N - c (N - 1)) * l := by ring
      _ â‰¤ Îµ * c N + Îµ * c (N - 1) * l := by
        gcongr
        Â· exact (ha N (a.le_succ.trans aN)).2
        Â· linarith only [IcN]
      _ â‰¤ Îµ * ((1 + Îµ) * c (N - 1)) + Îµ * c (N - 1) * l := by gcongr
      _ = Îµ * (1 + Îµ + l) * c (N - 1) := by ring
      _ â‰¤ Îµ * (1 + Îµ + l) * n := by gcongr
  have B : âˆ€ Îµ : â„, 0 < Îµ â†’ âˆ€á¶  n : â„• in atTop, (n : â„) * l - u n â‰¤ Îµ * (1 + l) * n := by
    intro Îµ Îµpos
    rcases hlim (1 + Îµ) ((lt_add_iff_pos_right _).2 Îµpos) with âŸ¨c, cgrowth, ctop, climâŸ©
    have L : âˆ€á¶  n : â„• in atTop, (c n : â„) * l - u (c n) â‰¤ Îµ * c n := by
      rw [â† tendsto_sub_nhds_zero_iff, â† Asymptotics.isLittleO_one_iff â„,
        Asymptotics.isLittleO_iff] at clim
      filter_upwards [clim Îµpos, ctop (Ioi_mem_atTop 0)] with n hn cnpos'
      have cnpos : 0 < c n := cnpos'
      calc
        (c n : â„) * l - u (c n) = -(u (c n) / c n - l) * c n := by
          simp only [cnpos.ne', Ne, Nat.cast_eq_zero, not_false_iff, neg_sub, field_simps]
        _ â‰¤ Îµ * c n := by
          gcongr
          refine le_trans (neg_le_abs _) ?_
          simpa using hn
    obtain âŸ¨a, haâŸ© :
      âˆƒ a : â„•,
        âˆ€ b : â„•, a â‰¤ b â†’ (c (b + 1) : â„) â‰¤ (1 + Îµ) * c b âˆ§ (c b : â„) * l - u (c b) â‰¤ Îµ * c b :=
      eventually_atTop.1 (cgrowth.and L)
    let M := ((Finset.range (a + 1)).image fun i => c i).max' (by simp)
    filter_upwards [Ici_mem_atTop M] with n hn
    have exN : âˆƒ N, n < c N := by
      rcases (tendsto_atTop.1 ctop (n + 1)).exists with âŸ¨N, hNâŸ©
      exact âŸ¨N, by linarith only [hN]âŸ©
    let N := Nat.find exN
    have ncN : n < c N := Nat.find_spec exN
    have aN : a + 1 â‰¤ N := by
      by_contra! h
      have cNM : c N â‰¤ M := by
        apply le_max'
        apply mem_image_of_mem
        exact mem_range.2 h
      exact lt_irrefl _ ((cNM.trans hn).trans_lt ncN)
    have Npos : 0 < N := lt_of_lt_of_le Nat.succ_pos' aN
    have aN' : a â‰¤ N - 1 := by
      apply @Nat.le_of_add_le_add_right a 1 (N - 1)
      rw [Nat.sub_add_cancel Npos]
      exact aN
    have cNn : c (N - 1) â‰¤ n := by
      have : N - 1 < N := Nat.pred_lt Npos.ne'
      simpa only [not_lt] using Nat.find_min exN this
    calc
      (n : â„) * l - u n â‰¤ c N * l - u (c (N - 1)) := by
        gcongr
        exact hmono cNn
      _ â‰¤ (1 + Îµ) * c (N - 1) * l - u (c (N - 1)) := by
        gcongr
        have B : N - 1 + 1 = N := Nat.succ_pred_eq_of_pos Npos
        simpa [B] using (ha _ aN').1
      _ = c (N - 1) * l - u (c (N - 1)) + Îµ * c (N - 1) * l := by ring
      _ â‰¤ Îµ * c (N - 1) + Îµ * c (N - 1) * l := add_le_add (ha _ aN').2 le_rfl
      _ = Îµ * (1 + l) * c (N - 1) := by ring
      _ â‰¤ Îµ * (1 + l) * n := by gcongr
  refine tendsto_order.2 âŸ¨fun d hd => ?_, fun d hd => ?_âŸ©
  Â· obtain âŸ¨Îµ, hÎµ, ÎµposâŸ© : âˆƒ Îµ : â„, d + Îµ * (1 + l) < l âˆ§ 0 < Îµ := by
      have L : Tendsto (fun Îµ => d + Îµ * (1 + l)) (ğ“[>] 0) (ğ“ (d + 0 * (1 + l))) := by
        apply Tendsto.mono_left _ nhdsWithin_le_nhds
        exact tendsto_const_nhds.add (tendsto_id.mul tendsto_const_nhds)
      simp only [zero_mul, add_zero] at L
      exact (((tendsto_order.1 L).2 l hd).and self_mem_nhdsWithin).exists
    filter_upwards [B Îµ Îµpos, Ioi_mem_atTop 0] with n hn npos
    simp_rw [div_eq_inv_mul]
    calc
      d < (n : â„)â»Â¹ * n * (l - Îµ * (1 + l)) := by
        rw [inv_mul_cancel, one_mul]
        Â· linarith only [hÎµ]
        Â· exact Nat.cast_ne_zero.2 (ne_of_gt npos)
      _ = (n : â„)â»Â¹ * (n * l - Îµ * (1 + l) * n) := by ring
      _ â‰¤ (n : â„)â»Â¹ * u n := by gcongr; linarith only [hn]
  Â· obtain âŸ¨Îµ, hÎµ, ÎµposâŸ© : âˆƒ Îµ : â„, l + Îµ * (1 + Îµ + l) < d âˆ§ 0 < Îµ := by
      have L : Tendsto (fun Îµ => l + Îµ * (1 + Îµ + l)) (ğ“[>] 0) (ğ“ (l + 0 * (1 + 0 + l))) := by
        apply Tendsto.mono_left _ nhdsWithin_le_nhds
        exact
          tendsto_const_nhds.add
            (tendsto_id.mul ((tendsto_const_nhds.add tendsto_id).add tendsto_const_nhds))
      simp only [zero_mul, add_zero] at L
      exact (((tendsto_order.1 L).2 d hd).and self_mem_nhdsWithin).exists
    filter_upwards [A Îµ Îµpos, Ioi_mem_atTop 0] with n hn (npos : 0 < n)
    calc
      u n / n â‰¤ (n * l + Îµ * (1 + Îµ + l) * n) / n := by gcongr; linarith only [hn]
      _ = (l + Îµ * (1 + Îµ + l)) := by field_simp; ring
      _ < d := hÎµ"
Mathlib/Algebra/Polynomial/EraseLead.lean,Polynomial.induction_with_natDegree_le,induction_with_natDegree_le,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  intro f df
  generalize hd : card f.support = c
  revert f
  induction' c with c hc
  Â· intro f _ f0
    convert P_0
    simpa [support_eq_empty, card_eq_zero] using f0
  Â· intro f df f0
    rw [â† eraseLead_add_C_mul_X_pow f]
    cases c
    Â· convert P_C_mul_pow f.natDegree f.leadingCoeff ?_ df using 1
      Â· convert zero_add (C (leadingCoeff f) * X ^ f.natDegree)
        rw [â† card_support_eq_zero, card_support_eraseLead' f0]
      Â· rw [leadingCoeff_ne_zero, Ne, â† card_support_eq_zero, f0]
        exact zero_ne_one.symm
    refine P_C_add f.eraseLead _ ?_ ??_ _? _
    Â· refine (eraseLead_natDegree_lt ?_).trans_le (le_of_eq ?_)
      Â· exact (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _))).trans f0.ge
      Â· rw [natDegree_C_mul_X_pow _ _ (leadingCoeff_ne_zero.mpr _)]
        rintro rfl
        simp at f0
    Â· exact (natDegree_C_mul_X_pow_le f.leadingCoeff f.natDegree).trans df
    Â· exact hc _ (eraseLead_natDegree_le_aux.trans df) (card_support_eraseLead' f0)
    Â· refine P_C_mul_pow _ _ ?_ df
      rw [Ne, leadingCoeff_eq_zero, â† card_support_eq_zero, f0]
      exact Nat.succ_ne_zero _",error:  unexpected token '?'; expected '_' or identifier,"theorem induction_with_natDegree_le (P : R[X] â†’ Prop) (N : â„•) (P_0 : P 0)
    (P_C_mul_pow : âˆ€ n : â„•, âˆ€ r : R, r â‰  0 â†’ n â‰¤ N â†’ P (C r * X ^ n))
    (P_C_add : âˆ€ f g : R[X], f.natDegree < g.natDegree â†’ g.natDegree â‰¤ N â†’ P f â†’ P g â†’ P (f + g)) :
    âˆ€ f : R[X], f.natDegree â‰¤ N â†’ P f ",":= by
  intro f df
  generalize hd : card f.support = c
  revert f
  induction' c with c hc
  Â· intro f _ f0
    convert P_0
    simpa [support_eq_empty, card_eq_zero] using f0
  Â· intro f df f0
    rw [â† eraseLead_add_C_mul_X_pow f]
    cases c
    Â· convert P_C_mul_pow f.natDegree f.leadingCoeff ?_ df using 1
      Â· convert zero_add (C (leadingCoeff f) * X ^ f.natDegree)
        rw [â† card_support_eq_zero, card_support_eraseLead' f0]
      Â· rw [leadingCoeff_ne_zero, Ne, â† card_support_eq_zero, f0]
        exact zero_ne_one.symm
    refine P_C_add f.eraseLead _ ?_ ?_ ?_ ?_
    Â· refine (eraseLead_natDegree_lt ?_).trans_le (le_of_eq ?_)
      Â· exact (Nat.succ_le_succ (Nat.succ_le_succ (Nat.zero_le _))).trans f0.ge
      Â· rw [natDegree_C_mul_X_pow _ _ (leadingCoeff_ne_zero.mpr _)]
        rintro rfl
        simp at f0
    Â· exact (natDegree_C_mul_X_pow_le f.leadingCoeff f.natDegree).trans df
    Â· exact hc _ (eraseLead_natDegree_le_aux.trans df) (card_support_eraseLead' f0)
    Â· refine P_C_mul_pow _ _ ?_ df
      rw [Ne, leadingCoeff_eq_zero, â† card_support_eq_zero, f0]
      exact Nat.succ_ne_zero _"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.aemeasurable_fderivWithin,aemeasurable_fderivWithin,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  refine aemeasurable_of_unif_approx fun Îµ Îµpos => ?_
  let Î´ : â„â‰¥0 := âŸ¨Îµ, le_of_lt ÎµposâŸ©
  have Î´pos : 0 < Î´ := Îµpos
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, _âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) Î´) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Î´) fun _ =>
      Î´pos.ne'
  obtain âŸ¨g, g_meas, hgâŸ© :
      âˆƒ g : E â†’ E â†’L[â„] E, Measurable g âˆ§ âˆ€ (n : â„•) (x : E), x âˆˆ t n â†’ g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine' âŸ¨g, g_meas.aemeasurable, _âŸ©
  suffices H : âˆ€áµ x : E âˆ‚sum fun n â†¦ Î¼.restrict (s âˆ© t n), dist (g x) (f' x) â‰¤ Îµ by
    have : Î¼.restrict s â‰¤ sum fun n => Î¼.restrict (s âˆ© t n) := by
      have : s = â‹ƒ n, s âˆ© t n := by
        rw [â† inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left _ _)
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine' ae_sum_iff.2 fun n => _
  have Eâ‚ : âˆ€áµ x : E âˆ‚Î¼.restrict (s âˆ© t n), â€–f' x - A nâ€–â‚Š â‰¤ Î´ :=
    (ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono (inter_subset_left _ _)
  have Eâ‚‚ : âˆ€áµ x : E âˆ‚Î¼.restrict (s âˆ© t n), g x = A n := by
    suffices H : âˆ€áµ x : E âˆ‚Î¼.restrict (t n), g x = A n from
      ae_mono (restrict_mono (inter_subset_right _ _) le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [Eâ‚, Eâ‚‚] with x hx1 hx2
  rw [â† nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1","error:  function expected at
  inter_subset_left ?m.375907
term has type
  ?m.375906 âˆˆ ?m.375904
error:  function expected at
  inter_subset_left ?m.377059
term has type
  ?m.377058 âˆˆ ?m.377056
error:  function expected at
  inter_subset_right ?m.377638
term has type
  ?m.377637 âˆˆ ?m.377636","theorem aemeasurable_fderivWithin (hs : MeasurableSet s)
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) : AEMeasurable f' (Î¼.restrict s) ",":= by
  refine aemeasurable_of_unif_approx fun Îµ Îµpos => ?_
  let Î´ : â„â‰¥0 := âŸ¨Îµ, le_of_lt ÎµposâŸ©
  have Î´pos : 0 < Î´ := Îµpos
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, _âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) Î´) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Î´) fun _ =>
      Î´pos.ne'
  obtain âŸ¨g, g_meas, hgâŸ© :
      âˆƒ g : E â†’ E â†’L[â„] E, Measurable g âˆ§ âˆ€ (n : â„•) (x : E), x âˆˆ t n â†’ g x = A n :=
    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|
      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]
  refine âŸ¨g, g_meas.aemeasurable, ?_âŸ©
  suffices H : âˆ€áµ x : E âˆ‚sum fun n â†¦ Î¼.restrict (s âˆ© t n), dist (g x) (f' x) â‰¤ Îµ by
    have : Î¼.restrict s â‰¤ sum fun n => Î¼.restrict (s âˆ© t n) := by
      have : s = â‹ƒ n, s âˆ© t n := by
        rw [â† inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left
      conv_lhs => rw [this]
      exact restrict_iUnion_le
    exact ae_mono this H
  refine ae_sum_iff.2 fun n => ?_
  have Eâ‚ : âˆ€áµ x : E âˆ‚Î¼.restrict (s âˆ© t n), â€–f' x - A nâ€–â‚Š â‰¤ Î´ :=
    (ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
      (hf' x hx.1).mono inter_subset_left
  have Eâ‚‚ : âˆ€áµ x : E âˆ‚Î¼.restrict (s âˆ© t n), g x = A n := by
    suffices H : âˆ€áµ x : E âˆ‚Î¼.restrict (t n), g x = A n from
      ae_mono (restrict_mono inter_subset_right le_rfl) H
    filter_upwards [ae_restrict_mem (t_meas n)]
    exact hg n
  filter_upwards [Eâ‚, Eâ‚‚] with x hx1 hx2
  rw [â† nndist_eq_nnnorm] at hx1
  rw [hx2, dist_comm]
  exact hx1"
Mathlib/LinearAlgebra/FreeModule/Finite/Matrix.lean,Matrix.rank_vecMulVec,Matrix.rank_vecMulVec,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  nontriviality K
  rw [Matrix.vecMulVec_eq, Matrix.toLin'_mul]
  refine' le_trans (LinearMap.rank_comp_le_left _ _) _
  refine' (LinearMap.rank_le_domain _).trans_eq _
  rw [rank_fun', Fintype.card_unit, Nat.cast_one]","error:  failed to synthesize
  Unique ?Î¹
use `set_option diagnostics true` to get diagnostic information","theorem Matrix.rank_vecMulVec {K m n : Type u} [CommRing K] [Fintype n]
    [DecidableEq n] (w : m â†’ K) (v : n â†’ K) : (Matrix.vecMulVec w v).toLin'.rank â‰¤ 1 ",":= by
  nontriviality K
  rw [Matrix.vecMulVec_eq (Fin 1), Matrix.toLin'_mul]
  refine le_trans (LinearMap.rank_comp_le_left _ _) ?_
  refine (LinearMap.rank_le_domain _).trans_eq ?_
  rw [rank_fun', Fintype.card_ofSubsingleton, Nat.cast_one]"
Mathlib/Topology/OmegaCompletePartialOrder.lean,notBelow_isOpen,notBelow_isOpen,0c1dd9cbd45d804e559a743f61a0763f683221f0,":= by
  have h : Monotone (notBelow y) := fun x z hle â†¦ mt hle.trans
  change Ï‰ScottContinuous fun x â†¦ x âˆˆ (notBelow y)
  rw [Ï‰ScottContinuous_iff_monotone_map_Ï‰Sup]
  refine âŸ¨h, fun c â†¦ eq_of_forall_ge_iff fun z â†¦ ?_âŸ©
  simp only [Ï‰Sup_le_iff, notBelow, mem_setOf_eq, le_Prop_eq, OrderHom.coe_mk, Chain.map_coe,
    Function.comp_apply, exists_imp, not_forall]","error:  unknown identifier 'Ï‰ScottContinuous'
error:  unknown identifier 'Ï‰ScottContinuous_iff_monotone_map_Ï‰Sup'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.30292
Î± : Type u_1
instâœ : OmegaCompletePartialOrder Î±
y : Scott Î±
h : Monotone (notBelow y)
âŠ¢ sorryAx (Sort ?u.30117) true
error:  invalid occurrence of universe level 'u_3' at 'scottContinuous_of_continuous', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  notBelow_isOpen.{u_2, u_3} (f y)
at declaration body
  fun {Î± : Type u_1} {Î² : Type u_2} [OmegaCompletePartialOrder Î±] [OmegaCompletePartialOrder Î²] (f : Scott Î± â†’ Scott Î²)
      (hf : _root_.Continuous f) â†¦
    let_fun h : Monotone f := fun (x y : Scott Î±) (h : x â‰¤ y) â†¦
      let_fun hf : IsUpperSet {x : Scott Î± | Â¬f x â‰¤ f y} :=
        IsOpen.isUpperSet Î± (IsOpen.preimage hf (notBelow_isOpen (f y)));
      Eq.mp
        (Eq.trans
          (Eq.trans
            (implies_congr (Eq.refl Â¬f x â‰¤ f y)
              (Eq.trans (congrArg Not (Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.5 (f y)))
                Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.6))
            Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.7)
          Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.8)
        (hf h);
    Exists.intro h fun (c : Chain (Scott Î±)) â†¦
      eq_of_forall_ge_iff fun (z : Scott Î²) â†¦
        Exists.casesOn (IsOpen.preimage hf (notBelow_isOpen z))
          fun (hf : Monotone fun (x : Î±) â†¦ x âˆˆ f â»Â¹' notBelow z)
            (hf' :
              OmegaCompletePartialOrder.Continuous { toFun := fun (x : Î±) â†¦ x âˆˆ f â»Â¹' notBelow z, monotone' := hf }) â†¦
          Eq.mpr (id (congrArg (fun (_a : Prop) â†¦ _a) (Eq.symm (propext not_iff_not))))
            (Eq.mpr
              (id
                (congr
                  (congrArg Iff
                    (Eq.trans
                      (Eq.mp
                        (congr
                          (congrArg (fun (x : Î± â†’o Prop) â†¦ Eq (x (Ï‰Sup c)))
                            ((fun {Î± : Type u_1} {Î² : Type} [Preorder Î±] [Preorder Î²] (toFun toFun_1 : Î± â†’ Î²)
                                  (e_toFun : toFun = toFun_1) â†¦
                                Eq.rec (motive := fun (toFun_2 : Î± â†’ Î²) (e_toFun : toFun = toFun_2) â†¦
                                  âˆ€ (monotone' : Monotone toFun),
                                    { toFun := toFun, monotone' := monotone' } =
                                      { toFun := toFun_2, monotone' := e_toFun â–¸ monotone' })
                                  (fun (monotone' : Monotone toFun) â†¦
                                    Eq.refl { toFun := toFun, monotone' := monotone' })
                                  e_toFun)
                              (fun (x : Î±) â†¦ x âˆˆ f â»Â¹' notBelow z) (fun (x : Î±) â†¦ Â¬f x â‰¤ z)
                              (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf))
                          (congrArg (fun (x : Î± â†’o Prop) â†¦ Ï‰Sup (c.map x))
                            ((fun {Î± : Type u_1} {Î² : Type} [Preorder Î±] [Preorder Î²] (toFun toFun_1 : Î± â†’ Î²)
                                  (e_toFun : toFun = toFun_1) â†¦
                                Eq.rec (motive := fun (toFun_2 : Î± â†’ Î²) (e_toFun : toFun = toFun_2) â†¦
                                  âˆ€ (monotone' : Monotone toFun),
                                    { toFun := toFun, monotone' := monotone' } =
                                      { toFun := toFun_2, monotone' := e_toFun â–¸ monotone' })
                                  (fun (monotone' : Monotone toFun) â†¦
                                    Eq.refl { toFun := toFun, monotone' := monotone' })
                                  e_toFun)
                              (fun (x : Î±) â†¦ x âˆˆ f â»Â¹' notBelow z) (fun (x : Î±) â†¦ Â¬f x â‰¤ z)
                              (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf)))
                        (hf' c))
                      (congrArg Exists
                        (funext fun (a : Prop) â†¦
                          congrArg (fun (x : Prop) â†¦ x âˆ§ a)
                            (Eq.trans Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.10
                              (congrArg Exists
                                (funext fun (y : â„•) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.11)))))))
                  (Eq.trans
                    (congrArg Not
                      (Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.9 (c.map { toFun := f, monotone' := h }) z))
                    Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.12)))
              (Or.casesOn
                (Decidable.iff_iff_and_or_not_and_not.mp
                  (Eq.to_iff
                    (Eq.mp
                      (congr
                        (congrArg (fun (x : Î± â†’o Prop) â†¦ Eq (x (Ï‰Sup c)))
                          ((fun {Î± : Type u_1} {Î² : Type} [Preorder Î±] [Preorder Î²] (toFun toFun_1 : Î± â†’ Î²)
                                (e_toFun : toFun = toFun_1) â†¦
                              Eq.rec (motive := fun (toFun_2 : Î± â†’ Î²) (e_toFun : toFun = toFun_2) â†¦
                                âˆ€ (monotone' : Monotone toFun),
                                  { toFun := toFun, monotone' := monotone' } =
                                    { toFun := toFun_2, monotone' := e_toFun â–¸ monotone' })
                                (fun (monotone' : Monotone toFun) â†¦ Eq.refl { toFun := toFun, monotone' := monotone' })
                                e_toFun)
                            (fun (x : Î±) â†¦ x âˆˆ f â»Â¹' notBelow z) (fun (x : Î±) â†¦ Â¬f x â‰¤ z)
                            (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf))
                        (congrArg (fun (x : Î± â†’o Prop) â†¦ Ï‰Sup (c.map x))
                          ((fun {Î± : Type u_1} {Î² : Type} [Preorder Î±] [Preorder Î²] (toFun toFun_1 : Î± â†’ Î²)
                                (e_toFun : toFun = toFun_1) â†¦
                              Eq.rec (motive := fun (toFun_2 : Î± â†’ Î²) (e_toFun : toFun = toFun_2) â†¦
                                âˆ€ (monotone' : Monotone toFun),
                                  { toFun := toFun, monotone' := monotone' } =
                                    { toFun := toFun_2, monotone' := e_toFun â–¸ monotone' })
                                (fun (monotone' : Monotone toFun) â†¦ Eq.refl { toFun := toFun, monotone' := monotone' })
                                e_toFun)
                            (fun (x : Î±) â†¦ x âˆˆ f â»Â¹' notBelow z) (fun (x : Î±) â†¦ Â¬f x â‰¤ z)
                            (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) hf)))
                      (hf' c))))
                (fun
                    (h :
                      Â¬f (Ï‰Sup c) â‰¤ z âˆ§
                        Ï‰Sup
                          (c.map
                            { toFun := fun (x : Î±) â†¦ Â¬f x â‰¤ z,
                              monotone' :=
                                (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) â–¸ hf })) â†¦
                  And.casesOn h
                    fun (left : Â¬f (Ï‰Sup c) â‰¤ z)
                      (right :
                        Ï‰Sup
                          (c.map
                            { toFun := fun (x : Î±) â†¦ Â¬f x â‰¤ z,
                              monotone' :=
                                (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) â–¸ hf })) â†¦
                    {
                      mp := fun (a : âˆƒ (a : Prop), (âˆƒ (y : â„•), Â¬f (c y) â‰¤ z â†” a) âˆ§ a) â†¦
                        Exists.casesOn a fun (w : Prop) (h : (âˆƒ (y : â„•), Â¬f (c y) â‰¤ z â†” w) âˆ§ w) â†¦
                          And.casesOn h fun (left : âˆƒ (y : â„•), Â¬f (c y) â‰¤ z â†” w) (right : w) â†¦
                            Exists.casesOn left fun (w_1 : â„•) (h : Â¬f (c w_1) â‰¤ z â†” w) â†¦
                              Or.casesOn (Decidable.iff_iff_and_or_not_and_not.mp h)
                                (fun (h : Â¬f (c w_1) â‰¤ z âˆ§ w) â†¦
                                  And.casesOn h fun (left : Â¬f (c w_1) â‰¤ z) (right : w) â†¦ Exists.intro w_1 left)
                                fun (h : Â¬Â¬f (c w_1) â‰¤ z âˆ§ Â¬w) â†¦
                                And.casesOn h fun (left : Â¬Â¬f (c w_1) â‰¤ z) (right_1 : Â¬w) â†¦ absurd right right_1,
                      mpr := fun (a : âˆƒ (x : â„•), Â¬f (c x) â‰¤ z) â†¦
                        Exists.casesOn a fun (w : â„•) (h : Â¬f (c w) â‰¤ z) â†¦
                          Exists.intro (Â¬f (c w) â‰¤ z) âŸ¨Exists.intro w Iff.rfl, hâŸ© })
                fun
                  (h :
                    Â¬Â¬f (Ï‰Sup c) â‰¤ z âˆ§
                      Â¬Ï‰Sup
                          (c.map
                            { toFun := fun (x : Î±) â†¦ Â¬f x â‰¤ z,
                              monotone' :=
                                (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) â–¸ hf })) â†¦
                And.casesOn h
                  fun (left : Â¬Â¬f (Ï‰Sup c) â‰¤ z)
                    (right :
                      Â¬Ï‰Sup
                          (c.map
                            { toFun := fun (x : Î±) â†¦ Â¬f x â‰¤ z,
                              monotone' :=
                                (funext fun (x : Î±) â†¦ Mathlib.Topology.OmegaCompletePartialOrder._auxLemma.2) â–¸ hf })) â†¦
                  {
                    mp := fun (a : âˆƒ (a : Prop), (âˆƒ (y : â„•), Â¬f (c y) â‰¤ z â†” a) âˆ§ a) â†¦
                      Exists.casesOn a fun (w : Prop) (h : (âˆƒ (y : â„•), Â¬f (c y) â‰¤ z â†” w) âˆ§ w) â†¦
                        And.casesOn h fun (left : âˆƒ (y : â„•), Â¬f (c y) â‰¤ z â†” w) (right : w) â†¦
                          Exists.casesOn left fun (w_1 : â„•) (h : Â¬f (c w_1) â‰¤ z â†” w) â†¦
                            Or.casesOn (Decidable.iff_iff_and_or_not_and_not.mp h)
                              (fun (h : Â¬f (c w_1) â‰¤ z âˆ§ w) â†¦
                                And.casesOn h fun (left : Â¬f (c w_1) â‰¤ z) (right : w) â†¦ Exists.intro w_1 left)
                              fun (h : Â¬Â¬f (c w_1) â‰¤ z âˆ§ Â¬w) â†¦
                              And.casesOn h fun (left : Â¬Â¬f (c w_1) â‰¤ z) (right_1 : Â¬w) â†¦ absurd right right_1,
                    mpr := fun (a : âˆƒ (x : â„•), Â¬f (c x) â‰¤ z) â†¦
                      Exists.casesOn a fun (w : â„•) (h : Â¬f (c w) â‰¤ z) â†¦
                        Exists.intro (Â¬f (c w) â‰¤ z) âŸ¨Exists.intro w Iff.rfl, hâŸ© }))",theorem notBelow_isOpen : IsOpen (notBelow y) ,":= by
  have h : Monotone (notBelow y) := fun x z hle â†¦ mt hle.trans
  refine âŸ¨h, fun c â†¦ eq_of_forall_ge_iff fun z â†¦ ?_âŸ©
  simp only [Ï‰Sup_le_iff, notBelow, mem_setOf_eq, le_Prop_eq, OrderHom.coe_mk, Chain.map_coe,
    Function.comp_apply, exists_imp, not_forall]"
Mathlib/Data/Set/Function.lean,Set.bijective_iff_bijOn_univ,bijective_iff_bijOn_univ,ea1b2576466eb49ae109b64acf312f52285dafce,":=
  Iff.intro
    (fun h =>
      let âŸ¨inj, surjâŸ© := h
      âŸ¨mapsTo_univ f _, inj.injOn _, Iff.mp surjective_iff_surjOn_univ surjâŸ©)
    fun h =>
    let âŸ¨_map, inj, surjâŸ© := h
    âŸ¨Iff.mpr injective_iff_injOn_univ inj, Iff.mpr surjective_iff_surjOn_univ surjâŸ©","error:  application type mismatch
  And.intro (Injective.injOn inj ?m.71902)
argument
  Injective.injOn inj ?m.71902
has type
  âˆ€ â¦ƒxâ‚‚ : Î±â¦„, xâ‚‚ âˆˆ ?m.71900 â†’ f ?m.71901 = f xâ‚‚ â†’ ?m.71901 = xâ‚‚ : Prop
but is expected to have type
  InjOn f univ : Prop
warning:  declaration uses 'sorry'",theorem bijective_iff_bijOn_univ : Bijective f â†” BijOn f univ univ ,":=
  Iff.intro
    (fun h =>
      let âŸ¨inj, surjâŸ© := h
      âŸ¨mapsTo_univ f _, inj.injOn, Iff.mp surjective_iff_surjOn_univ surjâŸ©)
    fun h =>
    let âŸ¨_map, inj, surjâŸ© := h
    âŸ¨Iff.mpr injective_iff_injOn_univ inj, Iff.mpr surjective_iff_surjOn_univ surjâŸ©"
Mathlib/RingTheory/IntegralRestrict.lean,galRestrictHom_symm_algebraMap_apply,galRestrictHom_symm_algebraMap_apply,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have := (IsFractionRing.injective A K).isDomain
  have := IsIntegralClosure.isLocalization A K L B (Algebra.IsIntegral.of_finite _ _).isAlgebraic
  simp [galRestrictHom, galLift, Subalgebra.algebraMap_eq]","error:  function expected at
  IsIntegralClosure.isLocalization A K L B
term has type
  IsLocalization (Algebra.algebraMapSubmonoid B Aâ°) L
error:  unsolved goals
A : Type u_1
K : Type u_2
L : Type u_3
B : Type u_4
instâœÂ¹Â³ : CommRing A
instâœÂ¹Â² : CommRing B
instâœÂ¹Â¹ : Algebra A B
instâœÂ¹â° : Field K
instâœâ¹ : Field L
instâœâ¸ : Algebra A K
instâœâ· : IsFractionRing A K
instâœâ¶ : Algebra B L
instâœâµ : Algebra K L
instâœâ´ : Algebra A L
instâœÂ³ : IsScalarTower A B L
instâœÂ² : IsScalarTower A K L
instâœÂ¹ : IsIntegralClosure B A L
instâœ : FiniteDimensional K L
Ïƒ : B â†’â‚[A] B
x : B
this : IsDomain A
âŠ¢ ((galRestrictHom A K L B).symm Ïƒ) ((algebraMap B L) x) = (algebraMap B L) (Ïƒ x)","lemma galRestrictHom_symm_algebraMap_apply (Ïƒ : B â†’â‚[A] B) (x : B) :
    (galRestrictHom A K L B).symm Ïƒ (algebraMap B L x) = algebraMap B L (Ïƒ x) ",":= by
  have := (IsFractionRing.injective A K).isDomain
  have := IsIntegralClosure.isLocalization A K L B
  simp [galRestrictHom, galLift, Subalgebra.algebraMap_eq]"
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.Memâ„’p.snorm_indicator_norm_ge_pos_le,Memâ„’p.snorm_indicator_norm_ge_pos_le,ff33d25c791a3fac407c782b49018fcb63700d0d,":= by
  obtain âŸ¨M, hMâŸ© := hf.snorm_indicator_norm_ge_le Î¼ hmeas hÎµ
  refine'
    âŸ¨max M 1, lt_of_lt_of_le zero_lt_one (le_max_right _ _), le_trans (snorm_mono fun x => _) hMâŸ©
  rw [norm_indicator_eq_indicator_norm, norm_indicator_eq_indicator_norm]
  refine' Set.indicator_le_indicator_of_subset (fun x hx => _) (fun x => norm_nonneg (f x)) x
  rw [Set.mem_setOf_eq] at hx 
  exact (max_le_iff.1 hx).1","error:  application type mismatch
  @snorm_indicator_norm_ge_le Î± Î² m Î¼ instâœ p f hf Î¼
argument
  Î¼
has type
  Measure Î± : Type u_1
but is expected to have type
  StronglyMeasurable f : Prop
error:  rcases tactic failed: xâœ : ?m.69023 is not an inductive datatype","theorem Memâ„’p.snorm_indicator_norm_ge_pos_le (hf : Memâ„’p f p Î¼) (hmeas : StronglyMeasurable f)
    {Îµ : â„} (hÎµ : 0 < Îµ) :
    âˆƒ M : â„, 0 < M âˆ§ snorm ({ x | M â‰¤ â€–f xâ€–â‚Š }.indicator f) p Î¼ â‰¤ ENNReal.ofReal Îµ ",":= by
  obtain âŸ¨M, hMâŸ© := hf.snorm_indicator_norm_ge_le hmeas hÎµ
  refine
    âŸ¨max M 1, lt_of_lt_of_le zero_lt_one (le_max_right _ _), le_trans (snorm_mono fun x => ?_) hMâŸ©
  rw [norm_indicator_eq_indicator_norm, norm_indicator_eq_indicator_norm]
  refine Set.indicator_le_indicator_of_subset (fun x hx => ?_) (fun x => norm_nonneg (f x)) x
  rw [Set.mem_setOf_eq] at hx 
  exact (max_le_iff.1 hx).1"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.lintegral_abs_det_fderiv_le_addHaar_image_aux1,lintegral_abs_det_fderiv_le_addHaar_image_aux1,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  have :
    âˆ€ A : E â†’L[â„] E,
      âˆƒ Î´ : â„â‰¥0,
        0 < Î´ âˆ§
          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§
            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’
              ENNReal.ofReal |A.det| * Î¼ t â‰¤ Î¼ (g '' t) + Îµ * Î¼ t := by
    intro A
    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt Îµ Îµpos
    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©
    have I'' : âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ â†‘Î´'' â†’ |B.det - A.det| â‰¤ â†‘Îµ := by
      intro B hB
      rw [â† Real.dist_eq]
      apply (hÎ´' B _).le
      rw [dist_eq_norm]
      exact hB.trans_lt (half_lt_self Î´'pos)
    rcases eq_or_ne A.det 0 with (hA | hA)
    Â· refine' âŸ¨Î´'', half_pos Î´'pos, I'', _âŸ©
      simp only [hA, forall_const, zero_mul, ENNReal.ofReal_zero, imp_true_iff,
        zero_le, abs_zero]
    let m : â„â‰¥0 := Real.toNNReal |A.det| - Îµ
    have I : (m : â„â‰¥0âˆ) < ENNReal.ofReal |A.det| := by
      simp only [m, ENNReal.ofReal, ENNReal.coe_sub]
      apply ENNReal.sub_lt_self ENNReal.coe_ne_top
      Â· simpa only [abs_nonpos_iff, Real.toNNReal_eq_zero, ENNReal.coe_eq_zero, Ne] using hA
      Â· simp only [Îµpos.ne', ENNReal.coe_eq_zero, Ne, not_false_iff]
    rcases ((mul_le_addHaar_image_of_lt_det Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©
    refine' âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), _, _âŸ©
    Â· intro B hB
      apply I'' _ (hB.trans _)
      simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
    Â· intro t g htg
      rcases eq_or_ne (Î¼ t) âˆ with (ht | ht)
      Â· simp only [ht, Îµpos.ne', ENNReal.mul_top, ENNReal.coe_eq_zero, le_top, Ne,
          not_false_iff, _root_.add_top]
      have := h t g (htg.mono_num (min_le_left _ _))
      rwa [ENNReal.coe_sub, ENNReal.sub_mul, tsub_le_iff_right] at this
      simp only [ht, imp_true_iff, Ne, not_false_iff]
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  have s_eq : s = â‹ƒ n, s âˆ© t n := by
    rw [â† inter_iUnion]
    exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left _ _)
  calc
    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) =
        âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| âˆ‚Î¼ := by
      conv_lhs => rw [s_eq]
      rw [lintegral_iUnion]
      Â· exact fun n => hs.inter (t_meas n)
      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right _ _
    _ â‰¤ âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono (inter_subset_left _ _)]
      intro x hx
      have I : |(f' x).det| â‰¤ |(A n).det| + Îµ :=
        calc
          |(f' x).det| = |(A n).det + ((f' x).det - (A n).det)| := by congr 1; abel
          _ â‰¤ |(A n).det| + |(f' x).det - (A n).det| := abs_add _ _
          _ â‰¤ |(A n).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(f' x).det| â‰¤ ENNReal.ofReal (|(A n).det| + Îµ) :=
          ENNReal.ofReal_le_ofReal I
        _ = ENNReal.ofReal |(A n).det| + Îµ := by
          simp only [ENNReal.ofReal_add, abs_nonneg, NNReal.zero_le_coe, ENNReal.ofReal_coe_nnreal]
    _ = âˆ‘' n, (ENNReal.ofReal |(A n).det| * Î¼ (s âˆ© t n) + Îµ * Î¼ (s âˆ© t n)) := by
      simp only [set_lintegral_const, lintegral_add_right _ measurable_const]
    _ â‰¤ âˆ‘' n, (Î¼ (f '' (s âˆ© t n)) + Îµ * Î¼ (s âˆ© t n) + Îµ * Î¼ (s âˆ© t n)) := by
      gcongr
      exact (hÎ´ (A _)).2.2 _ _ (ht _)
    _ = Î¼ (f '' s) + 2 * Îµ * Î¼ s := by
      conv_rhs => rw [s_eq]
      rw [image_iUnion, measure_iUnion]; rotate_left
      Â· intro i j hij
        apply Disjoint.image _ hf (inter_subset_left _ _) (inter_subset_left _ _)
        exact Disjoint.mono (inter_subset_right _ _) (inter_subset_right _ _) (t_disj hij)
      Â· intro i
        exact
          measurable_image_of_fderivWithin (hs.inter (t_meas i))
            (fun x hx => (hf' x hx.1).mono (inter_subset_left _ _))
            (hf.mono (inter_subset_left _ _))
      rw [measure_iUnion]; rotate_left
      Â· exact pairwise_disjoint_mono t_disj fun i => inter_subset_right _ _
      Â· exact fun i => hs.inter (t_meas i)
      rw [â† ENNReal.tsum_mul_left, â† ENNReal.tsum_add]
      congr 1
      ext1 i
      rw [mul_assoc, two_mul, add_assoc]","error:  function expected at
  inter_subset_left ?m.487300
term has type
  ?m.487299 âˆˆ ?m.487297
error:  function expected at
  inter_subset_right ?m.491737
term has type
  ?m.491736 âˆˆ ?m.491735
error:  function expected at
  inter_subset_left ?m.492037
term has type
  ?m.492036 âˆˆ ?m.492034
warning:  `MeasureTheory.set_lintegral_const` has been deprecated, use `MeasureTheory.setLIntegral_const` instead
error:  function expected at
  inter_subset_left ?m.505648
term has type
  ?m.505647 âˆˆ ?m.505645
error:  function expected at
  inter_subset_left ?m.506119
term has type
  ?m.506118 âˆˆ ?m.506116
error:  function expected at
  inter_subset_left ?m.506190
term has type
  ?m.506189 âˆˆ ?m.506187
error:  function expected at
  inter_subset_right ?m.506602
term has type
  ?m.506601 âˆˆ ?m.506600","theorem lintegral_abs_det_fderiv_le_addHaar_image_aux1 (hs : MeasurableSet s)
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) {Îµ : â„â‰¥0} (Îµpos : 0 < Îµ) :
    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) â‰¤ Î¼ (f '' s) + 2 * Îµ * Î¼ s ",":= by
  have :
    âˆ€ A : E â†’L[â„] E,
      âˆƒ Î´ : â„â‰¥0,
        0 < Î´ âˆ§
          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§
            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’
              ENNReal.ofReal |A.det| * Î¼ t â‰¤ Î¼ (g '' t) + Îµ * Î¼ t := by
    intro A
    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt Îµ Îµpos
    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©
    have I'' : âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ â†‘Î´'' â†’ |B.det - A.det| â‰¤ â†‘Îµ := by
      intro B hB
      rw [â† Real.dist_eq]
      apply (hÎ´' B _).le
      rw [dist_eq_norm]
      exact hB.trans_lt (half_lt_self Î´'pos)
    rcases eq_or_ne A.det 0 with (hA | hA)
    Â· refine âŸ¨Î´'', half_pos Î´'pos, I'', ?_âŸ©
      simp only [hA, forall_const, zero_mul, ENNReal.ofReal_zero, imp_true_iff,
        zero_le, abs_zero]
    let m : â„â‰¥0 := Real.toNNReal |A.det| - Îµ
    have I : (m : â„â‰¥0âˆ) < ENNReal.ofReal |A.det| := by
      simp only [m, ENNReal.ofReal, ENNReal.coe_sub]
      apply ENNReal.sub_lt_self ENNReal.coe_ne_top
      Â· simpa only [abs_nonpos_iff, Real.toNNReal_eq_zero, ENNReal.coe_eq_zero, Ne] using hA
      Â· simp only [Îµpos.ne', ENNReal.coe_eq_zero, Ne, not_false_iff]
    rcases ((mul_le_addHaar_image_of_lt_det Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©
    refine âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), ?_, ?_âŸ©
    Â· intro B hB
      apply I'' _ (hB.trans _)
      simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
    Â· intro t g htg
      rcases eq_or_ne (Î¼ t) âˆ with (ht | ht)
      Â· simp only [ht, Îµpos.ne', ENNReal.mul_top, ENNReal.coe_eq_zero, le_top, Ne,
          not_false_iff, _root_.add_top]
      have := h t g (htg.mono_num (min_le_left _ _))
      rwa [ENNReal.coe_sub, ENNReal.sub_mul, tsub_le_iff_right] at this
      simp only [ht, imp_true_iff, Ne, not_false_iff]
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  have s_eq : s = â‹ƒ n, s âˆ© t n := by
    rw [â† inter_iUnion]
    exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left
  calc
    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) =
        âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| âˆ‚Î¼ := by
      conv_lhs => rw [s_eq]
      rw [lintegral_iUnion]
      Â· exact fun n => hs.inter (t_meas n)
      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
    _ â‰¤ âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono inter_subset_left]
      intro x hx
      have I : |(f' x).det| â‰¤ |(A n).det| + Îµ :=
        calc
          |(f' x).det| = |(A n).det + ((f' x).det - (A n).det)| := by congr 1; abel
          _ â‰¤ |(A n).det| + |(f' x).det - (A n).det| := abs_add _ _
          _ â‰¤ |(A n).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(f' x).det| â‰¤ ENNReal.ofReal (|(A n).det| + Îµ) :=
          ENNReal.ofReal_le_ofReal I
        _ = ENNReal.ofReal |(A n).det| + Îµ := by
          simp only [ENNReal.ofReal_add, abs_nonneg, NNReal.zero_le_coe, ENNReal.ofReal_coe_nnreal]
    _ = âˆ‘' n, (ENNReal.ofReal |(A n).det| * Î¼ (s âˆ© t n) + Îµ * Î¼ (s âˆ© t n)) := by
      simp only [setLIntegral_const, lintegral_add_right _ measurable_const]
    _ â‰¤ âˆ‘' n, (Î¼ (f '' (s âˆ© t n)) + Îµ * Î¼ (s âˆ© t n) + Îµ * Î¼ (s âˆ© t n)) := by
      gcongr
      exact (hÎ´ (A _)).2.2 _ _ (ht _)
    _ = Î¼ (f '' s) + 2 * Îµ * Î¼ s := by
      conv_rhs => rw [s_eq]
      rw [image_iUnion, measure_iUnion]; rotate_left
      Â· intro i j hij
        apply Disjoint.image _ hf inter_subset_left inter_subset_left
        exact Disjoint.mono inter_subset_right inter_subset_right (t_disj hij)
      Â· intro i
        exact
          measurable_image_of_fderivWithin (hs.inter (t_meas i))
            (fun x hx => (hf' x hx.1).mono inter_subset_left)
            (hf.mono inter_subset_left)
      rw [measure_iUnion]; rotate_left
      Â· exact pairwise_disjoint_mono t_disj fun i => inter_subset_right
      Â· exact fun i => hs.inter (t_meas i)
      rw [â† ENNReal.tsum_mul_left, â† ENNReal.tsum_add]
      congr 1
      ext1 i
      rw [mul_assoc, two_mul, add_assoc]"
Mathlib/Algebra/Polynomial/Degree/TrailingDegree.lean,Polynomial.natTrailingDegree_le_of_ne_zero,natTrailingDegree_le_of_ne_zero,bc769a9f781a01550bc7da7431e6157f3b3d6c81,":=
  ENat.toNat_le_of_le_coe <| trailingDegree_le_of_ne_zero h","error:  type mismatch
  ENat.toNat_le_of_le_coe (trailingDegree_le_of_ne_zero h)
has type
  p.trailingDegree.toNat â‰¤ n : Prop
but is expected to have type
  p.natTrailingDegree â‰¤ n : Prop",theorem natTrailingDegree_le_of_ne_zero (h : coeff p n â‰  0) : natTrailingDegree p â‰¤ n ,":= by
  have : WithTop.some (natTrailingDegree p) = Nat.cast (natTrailingDegree p) := rfl
  rw [â† WithTop.coe_le_coe, this, â† trailingDegree_eq_natTrailingDegree]
  Â· exact trailingDegree_le_of_ne_zero h
  Â· intro h
    subst h
    exact h rfl"
Mathlib/Analysis/Fourier/RiemannLebesgueLemma.lean,tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support,tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support,7dc162787d2a79bf721a83a87f641ace70251b17,":= by
  refine' NormedAddCommGroup.tendsto_nhds_zero.mpr fun Îµ hÎµ => _
  suffices âˆƒ T : â„, âˆ€ w : V, T â‰¤ â€–wâ€– â†’ â€–âˆ« v : V, ğ (-âŸªv, wâŸ«) â€¢ f vâ€– < Îµ by
    simp_rw [â† comap_dist_left_atTop_eq_cocompact (0 : V), eventually_comap, eventually_atTop,
      dist_eq_norm', sub_zero]
    exact
      let âŸ¨T, hTâŸ© := this
      âŸ¨T, fun b hb v hv => hT v (hv.symm â–¸ hb)âŸ©
  obtain âŸ¨R, -, hR_bdâŸ© : âˆƒ R : â„, 0 < R âˆ§ âˆ€ x : V, R â‰¤ â€–xâ€– â†’ f x = 0 := hf2.exists_pos_le_norm
  let A := {v : V | â€–vâ€– â‰¤ R + 1}
  have mA : MeasurableSet A := by
    suffices A = Metric.closedBall (0 : V) (R + 1) by
      rw [this]
      exact Metric.isClosed_ball.measurableSet
    simp_rw [Metric.closedBall, dist_eq_norm, sub_zero]
  obtain âŸ¨B, hB_pos, hB_volâŸ© : âˆƒ B : â„â‰¥0, 0 < B âˆ§ volume A â‰¤ B := by
    have hc : IsCompact A := by
      simpa only [Metric.closedBall, dist_eq_norm, sub_zero] using isCompact_closedBall (0 : V) _
    let Bâ‚€ := volume A
    replace hc : Bâ‚€ < âŠ¤ := hc.measure_lt_top
    refine' âŸ¨Bâ‚€.toNNReal + 1, add_pos_of_nonneg_of_pos Bâ‚€.toNNReal.coe_nonneg one_pos, _âŸ©
    rw [ENNReal.coe_add, ENNReal.coe_one, ENNReal.coe_toNNReal hc.ne]
    exact le_self_add
  obtain âŸ¨Î´, hÎ´1, hÎ´2âŸ© :=
    Metric.uniformContinuous_iff.mp (hf2.uniformContinuous_of_continuous hf1) (Îµ / B)
      (div_pos hÎµ hB_pos)
  refine' âŸ¨1 / 2 + 1 / (2 * Î´), fun w hw_bd => _âŸ©
  have hw_ne : w â‰  0 := by
    contrapose! hw_bd; rw [hw_bd, norm_zero]
    exact add_pos one_half_pos (one_div_pos.mpr <| mul_pos two_pos hÎ´1)
  have hw'_nm : â€–i wâ€– = 1 / (2 * â€–wâ€–) := by
    rw [norm_smul, norm_div, Real.norm_of_nonneg (mul_nonneg two_pos.le <| sq_nonneg _), norm_one,
      sq, â† div_div, â† div_div, â† div_div, div_mul_cancelâ‚€ _ (norm_eq_zero.not.mpr hw_ne)]
  have : â€–(1 / 2 : â„‚)â€– = 2â»Â¹ := by norm_num
  rw [fourier_integral_eq_half_sub_half_period_translate hw_ne
      (hf1.integrable_of_hasCompactSupport hf2),
    norm_smul, this, inv_mul_eq_div, div_lt_iff' two_pos]
  refine' lt_of_le_of_lt (norm_integral_le_integral_norm _) _
  simp_rw [norm_circle_smul]
  have int_A : âˆ« v : V, â€–f v - f (v + i w)â€– = âˆ« v in A, â€–f v - f (v + i w)â€– := by
    refine' (set_integral_eq_integral_of_forall_compl_eq_zero fun v hv => _).symm
    dsimp only [A] at hv
    simp only [mem_setOf, not_le] at hv
    rw [hR_bd v _, hR_bd (v + i w) _, sub_zero, norm_zero]
    Â· rw [â† sub_neg_eq_add]
      refine' le_trans _ (norm_sub_norm_le _ _)
      rw [le_sub_iff_add_le, norm_neg]
      refine' le_trans _ hv.le
      rw [add_le_add_iff_left, hw'_nm, â† div_div]
      refine' (div_le_one <| norm_pos_iff.mpr hw_ne).mpr _
      refine' le_trans (le_add_of_nonneg_right <| one_div_nonneg.mpr <| _) hw_bd
      exact (mul_pos (zero_lt_two' â„) hÎ´1).le
    Â· exact (le_add_of_nonneg_right zero_le_one).trans hv.le
  rw [int_A]; clear int_A
  have bdA : âˆ€ v : V, v âˆˆ A â†’ â€–â€–f v - f (v + i w)â€–â€– â‰¤ Îµ / B := by
    simp_rw [norm_norm]
    simp_rw [dist_eq_norm] at hÎ´2
    refine' fun x _ => (hÎ´2 _).le
    rw [sub_add_cancel_left, norm_neg, hw'_nm, â† div_div, div_lt_iff (norm_pos_iff.mpr hw_ne), â†
      div_lt_iff' hÎ´1, div_div]
    exact (lt_add_of_pos_left _ one_half_pos).trans_le hw_bd
  have bdA2 := norm_set_integral_le_of_norm_le_const (hB_vol.trans_lt ENNReal.coe_lt_top) bdA ?_
  swap
  Â· apply Continuous.aestronglyMeasurable
    exact
      continuous_norm.comp <|
        Continuous.sub hf1 <| Continuous.comp hf1 <| continuous_id'.add continuous_const
  have : â€–_â€– = âˆ« v : V in A, â€–f v - f (v + i w)â€– :=
    Real.norm_of_nonneg (set_integral_nonneg mA fun x _ => norm_nonneg _)
  rw [this] at bdA2
  refine' bdA2.trans_lt _
  rw [div_mul_eq_mul_div, div_lt_iff (NNReal.coe_pos.mpr hB_pos), mul_comm (2 : â„), mul_assoc,
    mul_lt_mul_left hÎµ]
  rw [â† ENNReal.toReal_le_toReal] at hB_vol
  Â· refine' hB_vol.trans_lt _
    rw [(by rfl : (â†‘B : ENNReal).toReal = â†‘B), two_mul]
    exact lt_add_of_pos_left _ hB_pos
  exacts [(hB_vol.trans_lt ENNReal.coe_lt_top).ne, ENNReal.coe_lt_top.ne]","error:  unknown identifier 'fourier_integral_eq_half_sub_half_period_translate'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.94353
case intro.intro.intro.intro.intro.intro
E : Type u_1
V : Type u_2
instâœâ· : NormedAddCommGroup E
instâœâ¶ : NormedSpace â„‚ E
f : V â†’ E
instâœâµ : NormedAddCommGroup V
instâœâ´ : MeasurableSpace V
instâœÂ³ : BorelSpace V
instâœÂ² : InnerProductSpace â„ V
instâœÂ¹ : FiniteDimensional â„ V
instâœ : CompleteSpace E
hf1 : Continuous f
hf2 : HasCompactSupport f
Îµ : â„
hÎµ : Îµ > 0
R : â„
hR_bd : âˆ€ (x : V), R â‰¤ â€–xâ€– â†’ f x = 0
A : Set V := {v | â€–vâ€– â‰¤ R + 1}
mA : MeasurableSet A
B : â„â‰¥0
hB_pos : 0 < B
hB_vol : volume A â‰¤ â†‘B
Î´ : â„
hÎ´1 : Î´ > 0
hÎ´2 : âˆ€ {a b : V}, dist a b < Î´ â†’ dist (f a) (f b) < Îµ / â†‘B
w : V
hw_bd : 1 / 2 + 1 / (2 * Î´) â‰¤ â€–wâ€–
hw_ne : w â‰  0
hw'_nm : â€–i wâ€– = 1 / (2 * â€–wâ€–)
this : â€–1 / 2â€– = 2â»Â¹
âŠ¢ â€–âˆ« (v : V), ğ (-âŸªv, wâŸ«_â„) â€¢ f vâ€– < Îµ","theorem tendsto_integral_exp_inner_smul_cocompact_of_continuous_compact_support (hf1 : Continuous f)
    (hf2 : HasCompactSupport f) :
    Tendsto (fun w : V => âˆ« v : V, ğ (-âŸªv, wâŸ«) â€¢ f v) (cocompact V) (ğ“ 0) ",":= by
  refine NormedAddCommGroup.tendsto_nhds_zero.mpr fun Îµ hÎµ => ?_
  suffices âˆƒ T : â„, âˆ€ w : V, T â‰¤ â€–wâ€– â†’ â€–âˆ« v : V, ğ (-âŸªv, wâŸ«) â€¢ f vâ€– < Îµ by
    simp_rw [â† comap_dist_left_atTop_eq_cocompact (0 : V), eventually_comap, eventually_atTop,
      dist_eq_norm', sub_zero]
    exact
      let âŸ¨T, hTâŸ© := this
      âŸ¨T, fun b hb v hv => hT v (hv.symm â–¸ hb)âŸ©
  obtain âŸ¨R, -, hR_bdâŸ© : âˆƒ R : â„, 0 < R âˆ§ âˆ€ x : V, R â‰¤ â€–xâ€– â†’ f x = 0 := hf2.exists_pos_le_norm
  let A := {v : V | â€–vâ€– â‰¤ R + 1}
  have mA : MeasurableSet A := by
    suffices A = Metric.closedBall (0 : V) (R + 1) by
      rw [this]
      exact Metric.isClosed_ball.measurableSet
    simp_rw [Metric.closedBall, dist_eq_norm, sub_zero]
  obtain âŸ¨B, hB_pos, hB_volâŸ© : âˆƒ B : â„â‰¥0, 0 < B âˆ§ volume A â‰¤ B := by
    have hc : IsCompact A := by
      simpa only [Metric.closedBall, dist_eq_norm, sub_zero] using isCompact_closedBall (0 : V) _
    let Bâ‚€ := volume A
    replace hc : Bâ‚€ < âŠ¤ := hc.measure_lt_top
    refine âŸ¨Bâ‚€.toNNReal + 1, add_pos_of_nonneg_of_pos Bâ‚€.toNNReal.coe_nonneg one_pos, ?_âŸ©
    rw [ENNReal.coe_add, ENNReal.coe_one, ENNReal.coe_toNNReal hc.ne]
    exact le_self_add
  obtain âŸ¨Î´, hÎ´1, hÎ´2âŸ© :=
    Metric.uniformContinuous_iff.mp (hf2.uniformContinuous_of_continuous hf1) (Îµ / B)
      (div_pos hÎµ hB_pos)
  refine âŸ¨1 / 2 + 1 / (2 * Î´), fun w hw_bd => ?_âŸ©
  have hw_ne : w â‰  0 := by
    contrapose! hw_bd; rw [hw_bd, norm_zero]
    exact add_pos one_half_pos (one_div_pos.mpr <| mul_pos two_pos hÎ´1)
  have hw'_nm : â€–i wâ€– = 1 / (2 * â€–wâ€–) := by
    rw [norm_smul, norm_div, Real.norm_of_nonneg (mul_nonneg two_pos.le <| sq_nonneg _), norm_one,
      sq, â† div_div, â† div_div, â† div_div, div_mul_cancelâ‚€ _ (norm_eq_zero.not.mpr hw_ne)]
  have : â€–(1 / 2 : â„‚)â€– = 2â»Â¹ := by norm_num
  rw [fourierIntegral_eq_half_sub_half_period_translate hw_ne
      (hf1.integrable_of_hasCompactSupport hf2),
    norm_smul, this, inv_mul_eq_div, div_lt_iff' two_pos]
  refine lt_of_le_of_lt (norm_integral_le_integral_norm _) ?_
  simp_rw [norm_circle_smul]
  have int_A : âˆ« v : V, â€–f v - f (v + i w)â€– = âˆ« v in A, â€–f v - f (v + i w)â€– := by
    refine (setIntegral_eq_integral_of_forall_compl_eq_zero fun v hv => ?_).symm
    dsimp only [A] at hv
    simp only [mem_setOf, not_le] at hv
    rw [hR_bd v _, hR_bd (v + i w) _, sub_zero, norm_zero]
    Â· rw [â† sub_neg_eq_add]
      refine le_trans ?_ (norm_sub_norm_le _ _)
      rw [le_sub_iff_add_le, norm_neg]
      refine le_trans ?_ hv.le
      rw [add_le_add_iff_left, hw'_nm, â† div_div]
      refine (div_le_one <| norm_pos_iff.mpr hw_ne).mpr ?_
      refine le_trans (le_add_of_nonneg_right <| one_div_nonneg.mpr <| ?_) hw_bd
      exact (mul_pos (zero_lt_two' â„) hÎ´1).le
    Â· exact (le_add_of_nonneg_right zero_le_one).trans hv.le
  rw [int_A]; clear int_A
  have bdA : âˆ€ v : V, v âˆˆ A â†’ â€–â€–f v - f (v + i w)â€–â€– â‰¤ Îµ / B := by
    simp_rw [norm_norm]
    simp_rw [dist_eq_norm] at hÎ´2
    refine fun x _ => (hÎ´2 ?_).le
    rw [sub_add_cancel_left, norm_neg, hw'_nm, â† div_div, div_lt_iff (norm_pos_iff.mpr hw_ne), â†
      div_lt_iff' hÎ´1, div_div]
    exact (lt_add_of_pos_left _ one_half_pos).trans_le hw_bd
  have bdA2 := norm_setIntegral_le_of_norm_le_const (hB_vol.trans_lt ENNReal.coe_lt_top) bdA ?_
  swap
  Â· apply Continuous.aestronglyMeasurable
    exact
      continuous_norm.comp <|
        Continuous.sub hf1 <| Continuous.comp hf1 <| continuous_id'.add continuous_const
  have : â€–_â€– = âˆ« v : V in A, â€–f v - f (v + i w)â€– :=
    Real.norm_of_nonneg (setIntegral_nonneg mA fun x _ => norm_nonneg _)
  rw [this] at bdA2
  refine bdA2.trans_lt ?_
  rw [div_mul_eq_mul_div, div_lt_iff (NNReal.coe_pos.mpr hB_pos), mul_comm (2 : â„), mul_assoc,
    mul_lt_mul_left hÎµ]
  rw [â† ENNReal.toReal_le_toReal] at hB_vol
  Â· refine hB_vol.trans_lt ?_
    rw [(by rfl : (â†‘B : ENNReal).toReal = â†‘B), two_mul]
    exact lt_add_of_pos_left _ hB_pos
  exacts [(hB_vol.trans_lt ENNReal.coe_lt_top).ne, ENNReal.coe_lt_top.ne]"
Mathlib/RingTheory/PowerSeries/WellKnown.lean,PowerSeries.mk_one_pow_eq_mk_choose_add,mk_one_pow_eq_mk_choose_add,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":= by
  induction d with
  | zero => simp only [Nat.zero_eq, zero_add, pow_one, Nat.choose_zero_right, Nat.cast_one]; rfl
  | succ d hd =>
      rw [pow_add, pow_one, mul_comm, show Nat.succ d = d + 1 by rfl, ext_iff]; exact fun n => by
        rw [hd, coeff_mul]; simp only [coeff_mk, one_mul]; rw [Nat.succ_add, Nat.choose_succ_succ,
        â† Finset.sum_antidiagonal_choose_add]; simp only [Pi.one_apply, one_mul, Nat.cast_sum]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  d.succ
case succ
S : Type u_1
instâœ : CommRing S
dâœ d : â„•
hd : mk 1 ^ (d + 1) = mk fun n â†¦ â†‘((d + n).choose d)
âŠ¢ mk 1 * mk 1 ^ (d + 1) = mk fun n â†¦ â†‘((d + 1 + n).choose (d + 1))
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated","theorem mk_one_pow_eq_mk_choose_add :
    (mk 1 : SâŸ¦XâŸ§) ^ (d + 1) = (mk fun n => Nat.choose (d + n) d : SâŸ¦XâŸ§) ",":= by
  induction d with
  | zero => ext; simp
  | succ d hd =>
      ext n
      rw [pow_add, hd, pow_one, mul_comm, coeff_mul]
      simp_rw [coeff_mk, Pi.one_apply, one_mul]
      norm_cast
      rw [Finset.sum_antidiagonal_choose_add, â† Nat.choose_succ_succ, Nat.succ_eq_add_one,
        add_right_comm]"
Mathlib/NumberTheory/Cyclotomic/Basic.lean,IsCyclotomicExtension.singleton_one,singleton_one,0bb63b2bff135338722ab98f6da549f3e6350f0a,":=
  Algebra.eq_top_iff.2 fun x => by
    simpa [adjoin_singleton_one] using ((IsCyclotomicExtension_iff _ _ _).1 h).2 x",error:  unknown identifier 'IsCyclotomicExtension_iff',theorem singleton_one [h : IsCyclotomicExtension {1} A B] : (âŠ¥ : Subalgebra A B) = âŠ¤ ,":=
  Algebra.eq_top_iff.2 fun x => by
    simpa [adjoin_singleton_one] using ((isCyclotomicExtension_iff _ _ _).1 h).2 x"
Mathlib/Analysis/Fourier/PoissonSummation.lean,Real.fourierCoeff_tsum_comp_add,Real.fourierCoeff_tsum_comp_add,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  let e : C(â„, â„‚) := (fourier (-m)).comp âŸ¨((â†‘) : â„ â†’ UnitAddCircle), continuous_quotient_mk'âŸ©
  have neK : âˆ€ (K : Compacts â„) (g : C(â„, â„‚)), â€–(e * g).restrict Kâ€– = â€–g.restrict Kâ€– := by
    have (x : â„) : â€–e xâ€– = 1 := abs_coe_circle (AddCircle.toCircle (-m â€¢ x))
    intro K g
    simp_rw [norm_eq_iSup_norm, restrict_apply, mul_apply, norm_mul, this, one_mul]
  have eadd : âˆ€ (n : â„¤), e.comp (ContinuousMap.addRight n) = e := by
    intro n; ext1 x
    have : Periodic e 1 := Periodic.comp (fun x => AddCircle.coe_add_period 1 x) (fourier (-m))
    simpa only [mul_one] using this.int_mul n x
  calc
    fourierCoeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m =
        âˆ« x in (0 : â„)..1, e x * (âˆ‘' n : â„¤, f.comp (ContinuousMap.addRight n)) x := by
      simp_rw [fourierCoeff_eq_intervalIntegral _ m 0, div_one, one_smul, zero_add, e, comp_apply,
        coe_mk, Periodic.lift_coe, zsmul_one, smul_eq_mul]
    _ = âˆ« x in (0 : â„)..1, âˆ‘' n : â„¤, (e * f.comp (ContinuousMap.addRight n)) x : = by
      simp_rw [coe_mul, Pi.mul_apply,
        â† ContinuousMap.tsum_apply (summable_of_locally_summable_norm hf), tsum_mul_left]
    _ = âˆ‘' n : â„¤, âˆ« x in (0 : â„)..1, (e * f.comp (ContinuousMap.addRight n)) x : = by
      refine (intervalIntegral.tsum_intervalIntegral_eq_of_summable_norm ?_).symm
      convert hf âŸ¨uIcc 0 1, isCompact_uIccâŸ© using 1
      exact funext fun n => neK _ _
    _ = âˆ‘' n : â„¤, âˆ« x in (0 : â„)..1, (e * f).comp (ContinuousMap.addRight n) x : = by
      simp only [ContinuousMap.comp_apply, mul_comp] at eadd âŠ¢
      simp_rw [eadd]
    _ = âˆ« x, e x * f x := by
      suffices Integrable (e * f) from this.hasSum_intervalIntegral_comp_add_int.tsum_eq
      apply integrable_of_summable_norm_Icc
      convert hf âŸ¨Icc 0 1, isCompact_IccâŸ© using 1
      simp_rw [mul_comp] at eadd âŠ¢
      simp_rw [eadd]
      exact funext fun n => neK âŸ¨Icc 0 1, isCompact_IccâŸ© _
    _ = ğ“• f m := by
      rw [fourierIntegral_real_eq_integral_exp_smul]
      congr 1 with x : 1
      rw [smul_eq_mul, comp_apply, coe_mk, coe_mk, ContinuousMap.toFun_eq_coe, fourier_coe_apply]
      congr 2
      push_cast
      ring","error:  unexpected token ':'; expected ':='
error:  unsolved goals
case calc.step
f : C(â„, â„‚)
hf : âˆ€ (K : Compacts â„), Summable fun n â†¦ â€–ContinuousMap.restrict (â†‘K) (f.comp (ContinuousMap.addRight â†‘n))â€–
m : â„¤
e : C(â„, â„‚) := (fourier (-m)).comp { toFun := QuotientAddGroup.mk, continuous_toFun := â‹¯ }
neK : âˆ€ (K : Compacts â„) (g : C(â„, â„‚)), â€–ContinuousMap.restrict (â†‘K) (e * g)â€– = â€–ContinuousMap.restrict (â†‘K) gâ€–
eadd : âˆ€ (n : â„¤), e.comp (ContinuousMap.addRight â†‘n) = e
âŠ¢ âˆ« (x : â„) in 0 ..1, âˆ‘' (n : â„¤), (e * f.comp (ContinuousMap.addRight â†‘n)) x = ğ“• â‡‘f â†‘m","theorem Real.fourierCoeff_tsum_comp_add {f : C(â„, â„‚)}
    (hf : âˆ€ K : Compacts â„, Summable fun n : â„¤ => â€–(f.comp (ContinuousMap.addRight n)).restrict Kâ€–)
    (m : â„¤) : fourierCoeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m = ğ“• f m ",":= by
  let e : C(â„, â„‚) := (fourier (-m)).comp âŸ¨((â†‘) : â„ â†’ UnitAddCircle), continuous_quotient_mk'âŸ©
  have neK : âˆ€ (K : Compacts â„) (g : C(â„, â„‚)), â€–(e * g).restrict Kâ€– = â€–g.restrict Kâ€– := by
    have (x : â„) : â€–e xâ€– = 1 := abs_coe_circle (AddCircle.toCircle (-m â€¢ x))
    intro K g
    simp_rw [norm_eq_iSup_norm, restrict_apply, mul_apply, norm_mul, this, one_mul]
  have eadd : âˆ€ (n : â„¤), e.comp (ContinuousMap.addRight n) = e := by
    intro n; ext1 x
    have : Periodic e 1 := Periodic.comp (fun x => AddCircle.coe_add_period 1 x) (fourier (-m))
    simpa only [mul_one] using this.int_mul n x
  calc
    fourierCoeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m =
        âˆ« x in (0 : â„)..1, e x * (âˆ‘' n : â„¤, f.comp (ContinuousMap.addRight n)) x := by
      simp_rw [fourierCoeff_eq_intervalIntegral _ m 0, div_one, one_smul, zero_add, e, comp_apply,
        coe_mk, Periodic.lift_coe, zsmul_one, smul_eq_mul]
    _ = âˆ« x in (0:â„)..1, âˆ‘' n : â„¤, (e * f.comp (ContinuousMap.addRight n)) x := by
      simp_rw [coe_mul, Pi.mul_apply,
        â† ContinuousMap.tsum_apply (summable_of_locally_summable_norm hf), tsum_mul_left]
    _ = âˆ‘' n : â„¤, âˆ« x in (0:â„)..1, (e * f.comp (ContinuousMap.addRight n)) x := by
      refine (intervalIntegral.tsum_intervalIntegral_eq_of_summable_norm ?_).symm
      convert hf âŸ¨uIcc 0 1, isCompact_uIccâŸ© using 1
      exact funext fun n => neK _ _
    _ = âˆ‘' n : â„¤, âˆ« x in (0:â„)..1, (e * f).comp (ContinuousMap.addRight n) x := by
      simp only [ContinuousMap.comp_apply, mul_comp] at eadd âŠ¢
      simp_rw [eadd]
    _ = âˆ« x, e x * f x := by
      suffices Integrable (e * f) from this.hasSum_intervalIntegral_comp_add_int.tsum_eq
      apply integrable_of_summable_norm_Icc
      convert hf âŸ¨Icc 0 1, isCompact_IccâŸ© using 1
      simp_rw [mul_comp] at eadd âŠ¢
      simp_rw [eadd]
      exact funext fun n => neK âŸ¨Icc 0 1, isCompact_IccâŸ© _
    _ = ğ“• f m := by
      rw [fourierIntegral_real_eq_integral_exp_smul]
      congr 1 with x : 1
      rw [smul_eq_mul, comp_apply, coe_mk, coe_mk, ContinuousMap.toFun_eq_coe, fourier_coe_apply]
      congr 2
      push_cast
      ring"
Mathlib/Geometry/Manifold/Instances/Sphere.lean,mfderiv_coe_sphere_injective,mfderiv_coe_sphere_injective,f191a7207be0307faaba26828726ed6192b89854,":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ğ•œ := â„) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices Injective (fderiv â„ ((stereoInvFunAux (-v : E) âˆ˜ (â†‘)) âˆ˜ U.symm) 0) by
    convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddEquivClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have : HasFDerivAt (stereoInvFunAux (-v : E) âˆ˜ ((â†‘) : (â„ âˆ™ (â†‘(-v) : E))á—® â†’ E))
      (â„ âˆ™ (â†‘(-v) : E))á—®.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â‡‘â†‘?e
E : Type u_1
instâœâ¸ : NormedAddCommGroup E
instâœâ· : InnerProductSpace â„ E
F : Type u_2
instâœâ¶ : NormedAddCommGroup F
instâœâµ : NormedSpace â„ F
H : Type u_3
instâœâ´ : TopologicalSpace H
I : ModelWithCorners â„ F H
M : Type u_4
instâœÂ³ : TopologicalSpace M
instâœÂ² : ChartedSpace H M
instâœÂ¹ : SmoothManifoldWithCorners I M
n : â„•
instâœ : Fact (finrank â„ E = n + 1)
v : â†‘(sphere 0 1)
U : â†¥(Submodule.span â„ {â†‘(-v)})á—® â‰ƒâ‚—áµ¢[â„] EuclideanSpace â„ (Fin n) :=
  (OrthonormalBasis.fromOrthogonalSpanSingleton n â‹¯).repr
thisâœ : HasFDerivAt (stereoInvFunAux (-â†‘v) âˆ˜ Subtype.val) (Submodule.span â„ {â†‘(-v)})á—®.subtypeL (U.symm 0)
this :
  â‡‘(fderiv â„ ((stereoInvFunAux (-â†‘v) âˆ˜ Subtype.val) âˆ˜ â‡‘U.symm) 0) =
    â‡‘((Submodule.span â„ {â†‘(-v)})á—®.subtypeL.comp â†‘U.symm.toContinuousLinearEquiv)
âŠ¢ Injective (â‡‘(Submodule.span â„ {â†‘(-v)})á—®.subtypeL âˆ˜ â‡‘â†‘U.symm.toContinuousLinearEquiv)","theorem mfderiv_coe_sphere_injective {n : â„•} [Fact (finrank â„ E = n + 1)] (v : sphere (0 : E) 1) :
    Injective (mfderiv (ğ“¡ n) ğ“˜(â„, E) ((â†‘) : sphere (0 : E) 1 â†’ E) v) ",":= by
  rw [((contMDiff_coe_sphere v).mdifferentiableAt le_top).mfderiv]
  simp only [chartAt, stereographic', stereographic_neg_apply, fderivWithin_univ,
    LinearIsometryEquiv.toHomeomorph_symm, LinearIsometryEquiv.coe_toHomeomorph,
    LinearIsometryEquiv.map_zero, mfld_simps]
  let U := (OrthonormalBasis.fromOrthogonalSpanSingleton
      (ğ•œ := â„) n (ne_zero_of_mem_unit_sphere (-v))).repr
  suffices Injective (fderiv â„ ((stereoInvFunAux (-v : E) âˆ˜ (â†‘)) âˆ˜ U.symm) 0) by
    convert this using 3
    show stereographic' n (-v) v = 0
    dsimp [stereographic']
    simp only [AddEquivClass.map_eq_zero_iff]
    apply stereographic_neg_apply
  have : HasFDerivAt (stereoInvFunAux (-v : E) âˆ˜ (Subtype.val : (â„ âˆ™ (â†‘(-v) : E))á—® â†’ E))
      (â„ âˆ™ (â†‘(-v) : E))á—®.subtypeL (U.symm 0) := by
    convert hasFDerivAt_stereoInvFunAux_comp_coe (-v : E)
    simp
  have := congr_arg DFunLike.coe <| (this.comp 0 U.symm.toContinuousLinearEquiv.hasFDerivAt).fderiv
  refine Eq.subst this.symm ?_
  rw [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe]
  simpa using Subtype.coe_injective"
Mathlib/SetTheory/Cardinal/SchroederBernstein.lean,Function.Embedding.schroeder_bernstein,schroeder_bernstein,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  cases' isEmpty_or_nonempty Î² with hÎ² hÎ²
  Â· have : IsEmpty Î± := Function.isEmpty f
    exact âŸ¨_, ((Equiv.equivEmpty Î±).trans (Equiv.equivEmpty Î²).symm).bijectiveâŸ©
  set F : Set Î± â†’o Set Î± :=
    { toFun := fun s => (g '' (f '' s)á¶œ)á¶œ
      monotone' := fun s t hst =>
        compl_subset_compl.mpr <| image_subset _ <| compl_subset_compl.mpr <| image_subset _ hst }
  set s : Set Î± := OrderHom.lfp F
  have hs : (g '' (f '' s)á¶œ)á¶œ = s := F.map_lfp
  have hns : g '' (f '' s)á¶œ = sá¶œ := compl_injective (by simp [hs])
  set g' := invFun g
  have g'g : LeftInverse g' g := leftInverse_invFun hg
  have hg'ns : g' '' sá¶œ = (f '' s)á¶œ := by rw [â† hns, g'g.image_image]
  set h : Î± â†’ Î² := s.piecewise f g'
  have : Surjective h := by rw [â† range_iff_surjective, range_piecewise, hg'ns, union_compl_self]
  have : Injective h := by
    refine' (injective_piecewise_iff _).2 âŸ¨hf.injOn _, _, _âŸ©
    Â· intro x hx y hy hxy
      obtain âŸ¨x', _, rflâŸ© : x âˆˆ g '' (f '' s)á¶œ := by rwa [hns]
      obtain âŸ¨y', _, rflâŸ© : y âˆˆ g '' (f '' s)á¶œ := by rwa [hns]
      rw [g'g _, g'g _] at hxy
      rw [hxy]
    Â· intro x hx y hy hxy
      obtain âŸ¨y', hy', rflâŸ© : y âˆˆ g '' (f '' s)á¶œ := by rwa [hns]
      rw [g'g _] at hxy
      exact hy' âŸ¨x, hx, hxyâŸ©
  exact âŸ¨h, â€¹Injective hâ€º, â€¹Surjective hâ€ºâŸ©","error:  application type mismatch
  And.intro (Injective.injOn hf ?m.1813)
argument
  Injective.injOn hf ?m.1813
has type
  âˆ€ â¦ƒxâ‚‚ : Î±â¦„, xâ‚‚ âˆˆ ?m.1811 â†’ f ?m.1812 = f xâ‚‚ â†’ ?m.1812 = xâ‚‚ : Prop
but is expected to have type
  InjOn f s : Prop","theorem schroeder_bernstein {f : Î± â†’ Î²} {g : Î² â†’ Î±} (hf : Function.Injective f)
    (hg : Function.Injective g) : âˆƒ h : Î± â†’ Î², Bijective h ",":= by
  cases' isEmpty_or_nonempty Î² with hÎ² hÎ²
  Â· have : IsEmpty Î± := Function.isEmpty f
    exact âŸ¨_, ((Equiv.equivEmpty Î±).trans (Equiv.equivEmpty Î²).symm).bijectiveâŸ©
  set F : Set Î± â†’o Set Î± :=
    { toFun := fun s => (g '' (f '' s)á¶œ)á¶œ
      monotone' := fun s t hst =>
        compl_subset_compl.mpr <| image_subset _ <| compl_subset_compl.mpr <| image_subset _ hst }
  set s : Set Î± := OrderHom.lfp F
  have hs : (g '' (f '' s)á¶œ)á¶œ = s := F.map_lfp
  have hns : g '' (f '' s)á¶œ = sá¶œ := compl_injective (by simp [hs])
  set g' := invFun g
  have g'g : LeftInverse g' g := leftInverse_invFun hg
  have hg'ns : g' '' sá¶œ = (f '' s)á¶œ := by rw [â† hns, g'g.image_image]
  set h : Î± â†’ Î² := s.piecewise f g'
  have : Surjective h := by rw [â† range_iff_surjective, range_piecewise, hg'ns, union_compl_self]
  have : Injective h := by
    refine (injective_piecewise_iff _).2 âŸ¨hf.injOn, ?_, ?_âŸ©
    Â· intro x hx y hy hxy
      obtain âŸ¨x', _, rflâŸ© : x âˆˆ g '' (f '' s)á¶œ := by rwa [hns]
      obtain âŸ¨y', _, rflâŸ© : y âˆˆ g '' (f '' s)á¶œ := by rwa [hns]
      rw [g'g _, g'g _] at hxy
      rw [hxy]
    Â· intro x hx y hy hxy
      obtain âŸ¨y', hy', rflâŸ© : y âˆˆ g '' (f '' s)á¶œ := by rwa [hns]
      rw [g'g _] at hxy
      exact hy' âŸ¨x, hx, hxyâŸ©
  exact âŸ¨h, â€¹Injective hâ€º, â€¹Surjective hâ€ºâŸ©"
Mathlib/Analysis/SpecificLimits/Normed.lean,TFAE_exists_lt_isLittleO_pow,TFAE_exists_lt_isLittleO_pow,eae9bb40604136c5d5ab4ffb1181933613965f9a,":= by
  have A : Ico 0 R âŠ† Ioo (-R) R :=
    fun x hx â†¦ âŸ¨(neg_lt_zero.2 (hx.1.trans_lt hx.2)).trans_le hx.1, hx.2âŸ©
  have B : Ioo 0 R âŠ† Ioo (-R) R := Subset.trans Ioo_subset_Ico_self A
  tfae_have 1 â†’ 3 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha, H.isBigOâŸ©
  tfae_have 2 â†’ 1 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, B ha, HâŸ©
  tfae_have 3 â†’ 2 := by
    rintro âŸ¨a, ha, HâŸ©
    rcases exists_between (abs_lt.2 ha) with âŸ¨b, hab, hbRâŸ©
    exact âŸ¨b, âŸ¨(abs_nonneg a).trans_lt hab, hbRâŸ©,
      H.trans_isLittleO (isLittleO_pow_pow_of_abs_lt_left (hab.trans_le (le_abs_self b)))âŸ©
  tfae_have 2 â†’ 4 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha, H.isBigOâŸ©
  tfae_have 4 â†’ 3 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, B ha, HâŸ©
  tfae_have 4 â†’ 6 := by
    rintro âŸ¨a, ha, HâŸ©
    rcases bound_of_isBigO_nat_atTop H with âŸ¨C, hCâ‚€, hCâŸ©
    refine' âŸ¨a, ha, C, hCâ‚€, fun n â†¦ _âŸ©
    simpa only [Real.norm_eq_abs, abs_pow, abs_of_nonneg ha.1.le] using hC (pow_ne_zero n ha.1.ne')
  tfae_have 6 â†’ 5 := fun âŸ¨a, ha, C, Hâ‚€, HâŸ© â†¦ âŸ¨a, ha.2, C, Or.inl Hâ‚€, HâŸ©
  tfae_have 5 â†’ 3 := by
    rintro âŸ¨a, ha, C, hâ‚€, HâŸ©
    rcases sign_cases_of_C_mul_pow_nonneg fun n â†¦ (abs_nonneg _).trans (H n) with (rfl | âŸ¨hCâ‚€, haâ‚€âŸ©)
    Â· obtain rfl : f = 0 := by
        ext n
        simpa using H n
      simp only [lt_irrefl, false_or_iff] at hâ‚€
      exact âŸ¨0, âŸ¨neg_lt_zero.2 hâ‚€, hâ‚€âŸ©, isBigO_zero _ _âŸ©
    exact âŸ¨a, A âŸ¨haâ‚€, haâŸ©,
      isBigO_of_le' _ fun n â†¦ (H n).trans <| mul_le_mul_of_nonneg_left (le_abs_self _) hCâ‚€.leâŸ©
  tfae_have 2 â†’ 8 := by
    rintro âŸ¨a, ha, HâŸ©
    refine' âŸ¨a, ha, (H.definition zero_lt_one).mono fun n hn â†¦ _âŸ©
    rwa [Real.norm_eq_abs, Real.norm_eq_abs, one_mul, abs_pow, abs_of_pos ha.1] at hn
  tfae_have 8 â†’ 7 := fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha.2, HâŸ©
  tfae_have 7 â†’ 3 := by
    rintro âŸ¨a, ha, HâŸ©
    have : 0 â‰¤ a := nonneg_of_eventually_pow_nonneg (H.mono fun n â†¦ (abs_nonneg _).trans)
    refine' âŸ¨a, A âŸ¨this, haâŸ©, IsBigO.of_bound 1 _âŸ©
    simpa only [Real.norm_eq_abs, one_mul, abs_pow, abs_of_nonneg this]
  tfae_finish","error:  unsolved goals
case tfae_1_to_3
Î± : Type u_1
Î² : Type u_2
Î¹ : Type u_3
f : â„• â†’ â„
R : â„
A : Set.Ico 0 R âŠ† Set.Ioo (-R) R
B : Set.Ioo 0 R âŠ† Set.Ioo (-R) R
âŠ¢ (âˆƒ a âˆˆ Set.Ioo (-R) R, f =o[atTop] fun x â†¦ a ^ x) â†’ âˆƒ a âˆˆ Set.Ioo (-R) R, f =O[atTop] fun x â†¦ a ^ x

Î± : Type u_1
Î² : Type u_2
Î¹ : Type u_3
f : â„• â†’ â„
R : â„
A : Set.Ico 0 R âŠ† Set.Ioo (-R) R
B : Set.Ioo 0 R âŠ† Set.Ioo (-R) R
tfae_1_to_3 : (âˆƒ a âˆˆ Set.Ioo (-R) R, f =o[atTop] fun x â†¦ a ^ x) â†’ âˆƒ a âˆˆ Set.Ioo (-R) R, f =O[atTop] fun x â†¦ a ^ x
âŠ¢ [âˆƒ a âˆˆ Set.Ioo (-R) R, f =o[atTop] fun x â†¦ a ^ x, âˆƒ a âˆˆ Set.Ioo 0 R, f =o[atTop] fun x â†¦ a ^ x,
      âˆƒ a âˆˆ Set.Ioo (-R) R, f =O[atTop] fun x â†¦ a ^ x, âˆƒ a âˆˆ Set.Ioo 0 R, f =O[atTop] fun x â†¦ a ^ x,
      âˆƒ a < R, âˆƒ C, (0 < C âˆ¨ 0 < R) âˆ§ âˆ€ (n : â„•), |f n| â‰¤ C * a ^ n,
      âˆƒ a âˆˆ Set.Ioo 0 R, âˆƒ C > 0, âˆ€ (n : â„•), |f n| â‰¤ C * a ^ n, âˆƒ a < R, âˆ€á¶  (n : â„•) in atTop, |f n| â‰¤ a ^ n,
      âˆƒ a âˆˆ Set.Ioo 0 R, âˆ€á¶  (n : â„•) in atTop, |f n| â‰¤ a ^ n].TFAE
error:  unexpected token ':='; expected command","theorem TFAE_exists_lt_isLittleO_pow (f : â„• â†’ â„) (R : â„) :
    TFAE
      [âˆƒ a âˆˆ Ioo (-R) R, f =o[atTop] (a ^ Â·), âˆƒ a âˆˆ Ioo 0 R, f =o[atTop] (a ^ Â·),
        âˆƒ a âˆˆ Ioo (-R) R, f =O[atTop] (a ^ Â·), âˆƒ a âˆˆ Ioo 0 R, f =O[atTop] (a ^ Â·),
        âˆƒ a < R, âˆƒ C : â„, (0 < C âˆ¨ 0 < R) âˆ§ âˆ€ n, |f n| â‰¤ C * a ^ n,
        âˆƒ a âˆˆ Ioo 0 R, âˆƒ C > 0, âˆ€ n, |f n| â‰¤ C * a ^ n, âˆƒ a < R, âˆ€á¶  n in atTop, |f n| â‰¤ a ^ n,
        âˆƒ a âˆˆ Ioo 0 R, âˆ€á¶  n in atTop, |f n| â‰¤ a ^ n] ",":= by
  have A : Ico 0 R âŠ† Ioo (-R) R :=
    fun x hx â†¦ âŸ¨(neg_lt_zero.2 (hx.1.trans_lt hx.2)).trans_le hx.1, hx.2âŸ©
  have B : Ioo 0 R âŠ† Ioo (-R) R := Subset.trans Ioo_subset_Ico_self A
  tfae_have 1 â†’ 3
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha, H.isBigOâŸ©
  tfae_have 2 â†’ 1
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, B ha, HâŸ©
  tfae_have 3 â†’ 2
  Â· rintro âŸ¨a, ha, HâŸ©
    rcases exists_between (abs_lt.2 ha) with âŸ¨b, hab, hbRâŸ©
    exact âŸ¨b, âŸ¨(abs_nonneg a).trans_lt hab, hbRâŸ©,
      H.trans_isLittleO (isLittleO_pow_pow_of_abs_lt_left (hab.trans_le (le_abs_self b)))âŸ©
  tfae_have 2 â†’ 4
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha, H.isBigOâŸ©
  tfae_have 4 â†’ 3
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, B ha, HâŸ©
  tfae_have 4 â†’ 6
  Â· rintro âŸ¨a, ha, HâŸ©
    rcases bound_of_isBigO_nat_atTop H with âŸ¨C, hCâ‚€, hCâŸ©
    refine âŸ¨a, ha, C, hCâ‚€, fun n â†¦ ?_âŸ©
    simpa only [Real.norm_eq_abs, abs_pow, abs_of_nonneg ha.1.le] using hC (pow_ne_zero n ha.1.ne')
  tfae_have 6 â†’ 5
  Â· exact fun âŸ¨a, ha, C, Hâ‚€, HâŸ© â†¦ âŸ¨a, ha.2, C, Or.inl Hâ‚€, HâŸ©
  tfae_have 5 â†’ 3
  Â· rintro âŸ¨a, ha, C, hâ‚€, HâŸ©
    rcases sign_cases_of_C_mul_pow_nonneg fun n â†¦ (abs_nonneg _).trans (H n) with (rfl | âŸ¨hCâ‚€, haâ‚€âŸ©)
    Â· obtain rfl : f = 0 := by
        ext n
        simpa using H n
      simp only [lt_irrefl, false_or_iff] at hâ‚€
      exact âŸ¨0, âŸ¨neg_lt_zero.2 hâ‚€, hâ‚€âŸ©, isBigO_zero _ _âŸ©
    exact âŸ¨a, A âŸ¨haâ‚€, haâŸ©,
      isBigO_of_le' _ fun n â†¦ (H n).trans <| mul_le_mul_of_nonneg_left (le_abs_self _) hCâ‚€.leâŸ©
  tfae_have 2 â†’ 8
  Â· rintro âŸ¨a, ha, HâŸ©
    refine âŸ¨a, ha, (H.def zero_lt_one).mono fun n hn â†¦ ?_âŸ©
    rwa [Real.norm_eq_abs, Real.norm_eq_abs, one_mul, abs_pow, abs_of_pos ha.1] at hn
  tfae_have 8 â†’ 7
  Â· exact fun âŸ¨a, ha, HâŸ© â†¦ âŸ¨a, ha.2, HâŸ©
  tfae_have 7 â†’ 3
  Â· rintro âŸ¨a, ha, HâŸ©
    have : 0 â‰¤ a := nonneg_of_eventually_pow_nonneg (H.mono fun n â†¦ (abs_nonneg _).trans)
    refine âŸ¨a, A âŸ¨this, haâŸ©, IsBigO.of_bound 1 ?_âŸ©
    simpa only [Real.norm_eq_abs, one_mul, abs_pow, abs_of_nonneg this]
  tfae_have 6 â†’ 7
  Â· exact fun h â†¦ tfae_8_to_7 <| tfae_2_to_8 <| tfae_3_to_2 <| tfae_5_to_3 <| tfae_6_to_5 h
  tfae_finish"
Mathlib/NumberTheory/DiophantineApproximation.lean,Rat.finite_rat_abs_sub_lt_one_div_den_sq,finite_rat_abs_sub_lt_one_div_den_sq,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  let f : â„š â†’ â„¤ Ã— â„• := fun q => (q.num, q.den)
  set s := {q : â„š | |Î¾ - q| < 1 / (q.den : â„š) ^ 2}
  have hinj : Function.Injective f := by
    intro a b hab
    simp only [f, Prod.mk.inj_iff] at hab
    rw [â† Rat.num_div_den a, â† Rat.num_div_den b, hab.1, hab.2]
  have H : f '' s âŠ† â‹ƒ (y : â„•) (_ : y âˆˆ Ioc 0 Î¾.den), Icc (âŒˆÎ¾ * yâŒ‰ - 1) (âŒŠÎ¾ * yâŒ‹ + 1) Ã—Ë¢ {y} := by
    intro xy hxy
    simp only [mem_image, mem_setOf] at hxy
    obtain âŸ¨q, hqâ‚, hqâ‚‚âŸ© := hxy
    obtain âŸ¨hd, hnâŸ© := den_le_and_le_num_le_of_sub_lt_one_div_den_sq hqâ‚
    simp_rw [mem_iUnion]
    refine' âŸ¨q.den, Set.mem_Ioc.mpr âŸ¨q.pos, hdâŸ©, _âŸ©
    simp only [prod_singleton, mem_image, mem_Icc, (congr_arg Prod.snd (Eq.symm hqâ‚‚)).trans rfl]
    exact âŸ¨q.num, hn, hqâ‚‚âŸ©
  refine' Finite.of_finite_image (Finite.subset _ H) (injOn_of_injective hinj s)
  exact Finite.biUnion (finite_Ioc _ _) fun x _ => Finite.prod (finite_Icc _ _) (finite_singleton _)","error:  application type mismatch
  injOn_of_injective hinj s
argument
  s
has type
  Set â„š : Type
but is expected to have type
  ?m.53322 âˆˆ ?m.53321 : Prop","theorem finite_rat_abs_sub_lt_one_div_den_sq (Î¾ : â„š) :
    {q : â„š | |Î¾ - q| < 1 / (q.den : â„š) ^ 2}.Finite ",":= by
  let f : â„š â†’ â„¤ Ã— â„• := fun q => (q.num, q.den)
  set s := {q : â„š | |Î¾ - q| < 1 / (q.den : â„š) ^ 2}
  have hinj : Function.Injective f := by
    intro a b hab
    simp only [f, Prod.mk.inj_iff] at hab
    rw [â† Rat.num_div_den a, â† Rat.num_div_den b, hab.1, hab.2]
  have H : f '' s âŠ† â‹ƒ (y : â„•) (_ : y âˆˆ Ioc 0 Î¾.den), Icc (âŒˆÎ¾ * yâŒ‰ - 1) (âŒŠÎ¾ * yâŒ‹ + 1) Ã—Ë¢ {y} := by
    intro xy hxy
    simp only [mem_image, mem_setOf] at hxy
    obtain âŸ¨q, hqâ‚, hqâ‚‚âŸ© := hxy
    obtain âŸ¨hd, hnâŸ© := den_le_and_le_num_le_of_sub_lt_one_div_den_sq hqâ‚
    simp_rw [mem_iUnion]
    refine âŸ¨q.den, Set.mem_Ioc.mpr âŸ¨q.pos, hdâŸ©, ?_âŸ©
    simp only [prod_singleton, mem_image, mem_Icc, (congr_arg Prod.snd (Eq.symm hqâ‚‚)).trans rfl]
    exact âŸ¨q.num, hn, hqâ‚‚âŸ©
  refine (Finite.subset ?_ H).of_finite_image hinj.injOn
  exact Finite.biUnion (finite_Ioc _ _) fun x _ => Finite.prod (finite_Icc _ _) (finite_singleton _)"
Mathlib/Probability/IdentDistrib.lean,ProbabilityTheory.Memâ„’p.uniformIntegrable_of_identDistrib_aux,Memâ„’p.uniformIntegrable_of_identDistrib_aux,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  refine' uniformIntegrable_of' hp hp' hfmeas fun Îµ hÎµ => _
  by_cases hÎ¹ : Nonempty Î¹
  swap; Â· exact âŸ¨0, fun i => False.elim (hÎ¹ <| Nonempty.intro i)âŸ©
  obtain âŸ¨C, hCâ‚, hCâ‚‚âŸ© := hâ„’p.snorm_indicator_norm_ge_pos_le Î¼ (hfmeas _) hÎµ
  refine' âŸ¨âŸ¨C, hCâ‚.leâŸ©, fun i => le_trans (le_of_eq _) hCâ‚‚âŸ©
  have : {x : Î± | (âŸ¨C, hCâ‚.leâŸ© : â„â‰¥0) â‰¤ â€–f i xâ€–â‚Š}.indicator (f i) =
      (fun x : E => if (âŸ¨C, hCâ‚.leâŸ© : â„â‰¥0) â‰¤ â€–xâ€–â‚Š then x else 0) âˆ˜ f i := by
    ext x
    simp only [Set.indicator, Set.mem_setOf_eq]; norm_cast
  simp_rw [coe_nnnorm, this]
  rw [â† snorm_map_measure _ (hf i).aemeasurable_fst, (hf i).map_eq,
    snorm_map_measure _ (hf j).aemeasurable_fst]
  Â· rfl
  all_goals
    exact_mod_cast aestronglyMeasurable_id.indicator
      (measurableSet_le measurable_const measurable_nnnorm)","error:  application type mismatch
  @Memâ„’p.snorm_indicator_norm_ge_pos_le Î± E instâœâ· Î¼ instâœÂ² p (f j) hâ„’p Î¼
argument
  Î¼
has type
  Measure Î± : Type u_1
but is expected to have type
  StronglyMeasurable (f j) : Prop
error:  rcases tactic failed: xâœ : ?m.35434 is not an inductive datatype","theorem Memâ„’p.uniformIntegrable_of_identDistrib_aux {Î¹ : Type*} {f : Î¹ â†’ Î± â†’ E} {j : Î¹} {p : â„â‰¥0âˆ}
    (hp : 1 â‰¤ p) (hp' : p â‰  âˆ) (hâ„’p : Memâ„’p (f j) p Î¼) (hfmeas : âˆ€ i, StronglyMeasurable (f i))
    (hf : âˆ€ i, IdentDistrib (f i) (f j) Î¼ Î¼) : UniformIntegrable f p Î¼ ",":= by
  refine uniformIntegrable_of' hp hp' hfmeas fun Îµ hÎµ => ?_
  by_cases hÎ¹ : Nonempty Î¹
  swap; Â· exact âŸ¨0, fun i => False.elim (hÎ¹ <| Nonempty.intro i)âŸ©
  obtain âŸ¨C, hCâ‚, hCâ‚‚âŸ© := hâ„’p.snorm_indicator_norm_ge_pos_le (hfmeas _) hÎµ
  refine âŸ¨âŸ¨C, hCâ‚.leâŸ©, fun i => le_trans (le_of_eq ?_) hCâ‚‚âŸ©
  have : {x | (âŸ¨C, hCâ‚.leâŸ© : â„â‰¥0) â‰¤ â€–f i xâ€–â‚Š} = {x | C â‰¤ â€–f i xâ€–} := by
    ext x
    simp_rw [â† norm_toNNReal]
    exact Real.le_toNNReal_iff_coe_le (norm_nonneg _)
  rw [this, â† snorm_norm, â† snorm_norm (Set.indicator _ _)]
  simp_rw [norm_indicator_eq_indicator_norm, coe_nnnorm]
  let F : E â†’ â„ := (fun x : E => if (âŸ¨C, hCâ‚.leâŸ© : â„â‰¥0) â‰¤ â€–xâ€–â‚Š then â€–xâ€– else 0)
  have F_meas : Measurable F := by
    apply measurable_norm.indicator (measurableSet_le measurable_const measurable_nnnorm)
  have : âˆ€ k, (fun x â†¦ Set.indicator {x | C â‰¤ â€–f k xâ€–} (fun a â†¦ â€–f k aâ€–) x) = F âˆ˜ f k := by
    intro k
    ext x
    simp only [Set.indicator, Set.mem_setOf_eq]; norm_cast
  rw [this, this, â† snorm_map_measure F_meas.aestronglyMeasurable (hf i).aemeasurable_fst,
    (hf i).map_eq, snorm_map_measure F_meas.aestronglyMeasurable (hf j).aemeasurable_fst]"
Mathlib/Analysis/NormedSpace/Star/GelfandDuality.lean,gelfandTransform_bijective,gelfandTransform_bijective,c393d66d202dd4b12ddeff8fbeb25c034ce77e57,":= by
  refine' âŸ¨(gelfandTransform_isometry A).injective, _âŸ©
  let rng : StarSubalgebra â„‚ C(characterSpace â„‚ A, â„‚) :=
    { toSubalgebra := (gelfandTransform â„‚ A).range
      star_mem' := by
        rintro - âŸ¨a, rflâŸ©
        use star a
        ext1 Ï†
        simp only [AlgHom.toRingHom_eq_coe, RingHom.coe_coe, gelfandTransform_apply_apply, map_star,
          IsROrC.star_def, ContinuousMap.star_apply] }
  suffices rng = âŠ¤ from
    fun x => show x âˆˆ rng from this.symm â–¸ StarSubalgebra.mem_top
  have h : rng.topologicalClosure = rng := le_antisymm
    (StarSubalgebra.topologicalClosure_minimal le_rfl
      (gelfandTransform_isometry A).closedEmbedding.closed_range)
    (StarSubalgebra.le_topologicalClosure _)
  refine' h â–¸ ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints
    _ (fun _ _ => _)
  contrapose!
  exact fun h => Subtype.ext (ContinuousLinearMap.ext fun a =>
    h (gelfandTransform â„‚ A a) âŸ¨gelfandTransform â„‚ A a, âŸ¨a, rflâŸ©, rflâŸ©)","error:  unknown identifier 'IsROrC.star_def'
error:  invalid field 'closed_range', the environment does not contain 'ClosedEmbedding.closed_range'
  Isometry.closedEmbedding (gelfandTransform_isometry A)
has type
  ClosedEmbedding â‡‘(gelfandTransform â„‚ A)",theorem gelfandTransform_bijective : Function.Bijective (gelfandTransform â„‚ A) ,":= by
  refine âŸ¨(gelfandTransform_isometry A).injective, ?_âŸ©
  let rng : StarSubalgebra â„‚ C(characterSpace â„‚ A, â„‚) :=
    { toSubalgebra := (gelfandTransform â„‚ A).range
      star_mem' := by
        rintro - âŸ¨a, rflâŸ©
        use star a
        ext1 Ï†
        dsimp
        simp only [map_star, RCLike.star_def] }
  suffices rng = âŠ¤ from
    fun x => show x âˆˆ rng from this.symm â–¸ StarSubalgebra.mem_top
  have h : rng.topologicalClosure = rng := le_antisymm
    (StarSubalgebra.topologicalClosure_minimal le_rfl
      (gelfandTransform_isometry A).closedEmbedding.isClosed_range)
    (StarSubalgebra.le_topologicalClosure _)
  refine h â–¸ ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints
    _ (fun _ _ => ?_)
  contrapose!
  exact fun h => Subtype.ext (ContinuousLinearMap.ext fun a =>
    h (gelfandTransform â„‚ A a) âŸ¨gelfandTransform â„‚ A a, âŸ¨a, rflâŸ©, rflâŸ©)"
Mathlib/Algebra/Homology/ShortComplex/HomologicalComplex.lean,HomologicalComplex.liftCycles_homologyÏ€_eq_zero_of_boundary,liftCycles_homologyÏ€_eq_zero_of_boundary,9072ff84a0d139a344bf9eed4a00c4cd27596c79,":= by
  by_cases c.Rel i' i
  Â· obtain rfl := c.prev_eq' h
    exact (K.sc i).liftCycles_homologyÏ€_eq_zero_of_boundary _ x hx
  Â· have : liftCycles K k j hj (by rw [hx, assoc, K.d_comp_d, comp_zero]) = 0 := by
      rw [K.shape _ _ h, comp_zero] at hx
      rw [â† cancel_mono (K.iCycles i), zero_comp, liftCycles_i, hx]
    rw [this, zero_comp]","error:  unknown identifier 'h'
error:  tactic 'subst' failed, invalid equality proof, it is not of the form (x = t) or (t = x)
  c.prev ?m.31485 = ?m.31484
case pos
C : Type u_1
instâœÂ² : Category.{u_3, u_1} C
instâœÂ¹ : HasZeroMorphisms C
Î¹ : Type u_2
c : ComplexShape Î¹
K L M : HomologicalComplex C c
Ï† : K âŸ¶ L
Ïˆ : L âŸ¶ M
i jâœ kâœ : Î¹
instâœ : K.HasHomology i
A : C
k : A âŸ¶ K.X i
j : Î¹
hj : c.next i = j
i' : Î¹
x : A âŸ¶ K.X i'
hx : k = x â‰« K.d i' i
hâœ : c.Rel i' i
xâœ : c.prev ?m.31485 = ?m.31484
âŠ¢ K.liftCycles k j hj â‹¯ â‰« K.homologyÏ€ i = 0
error:  unknown identifier 'h'","lemma liftCycles_homologyÏ€_eq_zero_of_boundary {A : C} (k : A âŸ¶ K.X i) (j : Î¹)
    (hj : c.next i = j) {i' : Î¹} (x : A âŸ¶ K.X i') (hx : k = x â‰« K.d i' i) :
    K.liftCycles k j hj (by rw [hx, assoc, K.d_comp_d, comp_zero]) â‰« K.homologyÏ€ i = 0 ",":= by
  by_cases h : c.Rel i' i
  Â· obtain rfl := c.prev_eq' h
    exact (K.sc i).liftCycles_homologyÏ€_eq_zero_of_boundary _ x hx
  Â· have : liftCycles K k j hj (by rw [hx, assoc, K.d_comp_d, comp_zero]) = 0 := by
      rw [K.shape _ _ h, comp_zero] at hx
      rw [â† cancel_mono (K.iCycles i), zero_comp, liftCycles_i, hx]
    rw [this, zero_comp]"
Mathlib/Topology/Separation.lean,Specializes.symm,Specializes.symm,ea54eb89c8a123dcfceeb11bd200d459f2f95413,":= by
  simpa only [specializes_iff_not_disjoint, disjoint_comm] using h","error:  unknown identifier 'specializes_iff_not_disjoint'
error:  type mismatch
  hâœ
has type
  x â¤³ y : Prop
but is expected to have type
  y â¤³ x : Prop",theorem Specializes.symm (h : x â¤³ y) : y â¤³ x ,:= specializes_symmetric h
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime_pow,isIntegralClosure_adjoin_singleton_of_prime_pow,2a90eb4867f981311713f9efea480617e45964b9,":= by
  refine' âŸ¨Subtype.val_injective, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, _âŸ©, rflâŸ©, _âŸ©âŸ©
  swap
  Â· rintro âŸ¨y, rflâŸ©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hÎ¶.isIntegral (p ^ k).pos)) _)
  let B := hÎ¶.subOnePowerBasis â„š
  have hint : IsIntegral â„¤ B.gen := isIntegral_sub (hÎ¶.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} â„š K
  have H := discr_mul_isIntegral_mem_adjoin â„š hint h
  obtain âŸ¨u, n, hunâŸ© := discr_prime_pow_eq_unit_mul_pow' hÎ¶
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [â† smul_assoc, â† smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, â† Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, PNat.pow_coe, Nat.cast_pow, smul_def, map_pow] at H
  cases k
  Â· haveI : IsCyclotomicExtension {1} â„š K := by simpa using hcycl
    have : x âˆˆ (âŠ¥ : Subalgebra â„š K) := by
      rw [singleton_one â„š K]
      exact mem_top
    obtain âŸ¨y, rflâŸ© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap â„š K).injective).1 h
    obtain âŸ¨z, hzâŸ© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [â† hz, â† IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  Â· have hmin : (minpoly â„¤ B.gen).IsEisensteinAt (Submodule.span â„¤ {((p : â„•) : â„¤)}) := by
      have hâ‚ := minpoly.isIntegrallyClosed_eq_field_fractions' â„š hint
      have hâ‚‚ := hÎ¶.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at hâ‚
      rw [hâ‚, â† map_cyclotomic_int, show Int.castRingHom â„š = algebraMap â„¤ â„š by rfl,
        show X + 1 = map (algebraMap â„¤ â„š) (X + 1) by simp, â† map_comp] at hâ‚‚
      haveI : CharZero â„š := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap â„¤ â„š) (algebraMap â„¤ â„š).injective_int hâ‚‚]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton â„¤ _) (Subalgebra.one_mem _)","error:  function expected at
  le_integralClosure_iff_isIntegral.mp (adjoin_le_integralClosure (IsPrimitiveRoot.isIntegral hÎ¶ (PNat.pos (p ^ k))))
term has type
  Algebra.IsIntegral â„¤ â†¥(adjoin â„¤ {Î¶})
error:  unknown identifier 'isIntegral_sub'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â†‘(?m ^ ?n)
case refine'_1.intro.intro
p : â„•+
k : â„•
K : Type u
instâœÂ¹ : Field K
instâœ : CharZero K
Î¶ : K
hp : Fact (Nat.Prime â†‘p)
hcycl : IsCyclotomicExtension {p ^ k} â„š K
hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)
x : K
h : IsIntegral â„¤ x
B : PowerBasis â„š K := IsPrimitiveRoot.subOnePowerBasis â„š hÎ¶
hint : IsIntegral â„¤ B.gen
this : FiniteDimensional â„š K := finiteDimensional {p ^ k} â„š K
u : â„¤Ë£
n : â„•
hun : Algebra.discr â„š â‡‘(IsPrimitiveRoot.subOnePowerBasis â„š hÎ¶).basis = â†‘â†‘u * â†‘â†‘p ^ n
H : â†‘â†‘p ^ n â€¢ x âˆˆ adjoin â„¤ {B.gen}
âŠ¢ x âˆˆ adjoin â„¤ {Î¶}","theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} â„š K]
    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)) : IsIntegralClosure (adjoin â„¤ ({Î¶} : Set K)) â„¤ K ",":= by
  refine âŸ¨Subtype.val_injective, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©, ?_âŸ©âŸ©
  swap
  Â· rintro âŸ¨y, rflâŸ©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hÎ¶.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hÎ¶.subOnePowerBasis â„š
  have hint : IsIntegral â„¤ B.gen := (hÎ¶.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} â„š K
  have H := discr_mul_isIntegral_mem_adjoin â„š hint h
  obtain âŸ¨u, n, hunâŸ© := discr_prime_pow_eq_unit_mul_pow' hÎ¶
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [â† smul_assoc, â† smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, â† Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  Â· haveI : IsCyclotomicExtension {1} â„š K := by simpa using hcycl
    have : x âˆˆ (âŠ¥ : Subalgebra â„š K) := by
      rw [singleton_one â„š K]
      exact mem_top
    obtain âŸ¨y, rflâŸ© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap â„š K).injective).1 h
    obtain âŸ¨z, hzâŸ© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [â† hz, â† IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  Â· have hmin : (minpoly â„¤ B.gen).IsEisensteinAt (Submodule.span â„¤ {((p : â„•) : â„¤)}) := by
      have hâ‚ := minpoly.isIntegrallyClosed_eq_field_fractions' â„š hint
      have hâ‚‚ := hÎ¶.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at hâ‚
      rw [hâ‚, â† map_cyclotomic_int, show Int.castRingHom â„š = algebraMap â„¤ â„š by rfl,
        show X + 1 = map (algebraMap â„¤ â„š) (X + 1) by simp, â† map_comp] at hâ‚‚
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap â„¤ â„š) (algebraMap â„¤ â„š).injective_int hâ‚‚]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton â„¤ _) (Subalgebra.one_mem _)"
Mathlib/Data/Rat/Cast/Order.lean,Rat.cast_strictMono,cast_strictMono,73bc871350d19e466d5b8cb7d3d2edb4344a437f,":= fun m n => by
  simpa only [sub_pos, cast_sub] using @cast_pos_of_pos K _ (n - m)","error:  application type mismatch
  @cast_pos_of_pos K
argument
  K
has type
  Type u_5 : Type (u_5 + 1)
but is expected to have type
  â„š : Type
error:  type mismatch
  n - m
has type
  â„š : outParam Type
but is expected to have type
  LinearOrderedField ?m.1639 : Type ?u.1294",theorem cast_strictMono : StrictMono ((â†‘) : â„š â†’ K) ,":= fun p q => by
  simpa only [sub_pos, cast_sub] using cast_pos_of_pos (K := K) (q := q - p)"
Mathlib/Algebra/AlgebraicCard.lean,Algebraic.cardinal_mk_lift_le_mul,cardinal_mk_lift_le_mul,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [â† mk_uLift, â† mk_uLift]
  choose g hgâ‚ hgâ‚‚ using fun x : { x : A | IsAlgebraic R x } => x.coe_prop
  refine lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le g fun f => ?_
  rw [lift_le_aleph0, le_aleph0_iff_set_countable]
  suffices MapsTo (â†‘) (g â»Â¹' {f}) (f.rootSet A) from
    this.countable_of_injOn (Subtype.coe_injective.injOn _) (f.rootSet_finite A).countable
  rintro x (rfl : g x = f)
  exact mem_rootSet.2 âŸ¨hgâ‚ x, hgâ‚‚ xâŸ©","error:  application type mismatch
  MapsTo.countable_of_injOn this (Function.Injective.injOn Subtype.coe_injective ?m.5212)
argument
  Function.Injective.injOn Subtype.coe_injective ?m.5212
has type
  âˆ€ â¦ƒxâ‚‚ : Subtype ?m.5188â¦„, xâ‚‚ âˆˆ ?m.5210 â†’ â†‘?m.5211 = â†‘xâ‚‚ â†’ ?m.5211 = xâ‚‚ : Prop
but is expected to have type
  InjOn Subtype.val (g â»Â¹' {f}) : Prop","theorem cardinal_mk_lift_le_mul :
    Cardinal.lift.{u} #{ x : A // IsAlgebraic R x } â‰¤ Cardinal.lift.{v} #R[X] * â„µâ‚€ ",":= by
  rw [â† mk_uLift, â† mk_uLift]
  choose g hgâ‚ hgâ‚‚ using fun x : { x : A | IsAlgebraic R x } => x.coe_prop
  refine lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le g fun f => ?_
  rw [lift_le_aleph0, le_aleph0_iff_set_countable]
  suffices MapsTo (â†‘) (g â»Â¹' {f}) (f.rootSet A) from
    this.countable_of_injOn Subtype.coe_injective.injOn (f.rootSet_finite A).countable
  rintro x (rfl : g x = f)
  exact mem_rootSet.2 âŸ¨hgâ‚ x, hgâ‚‚ xâŸ©"
Mathlib/Topology/Category/Profinite/EffectiveEpi.lean,Profinite.effectiveEpi_tfae,effectiveEpi_tfae,df63b67fb76899941d920b6834b1fea5b3dc0b7c,":= by
  1 â†’ 2 := fun _ â†¦ inferInstance
  2 â†” 3 := epi_iff_surjective Ï€
  3 â†’ 1 := fun hÏ€ â†¦ âŸ¨âŸ¨struct Ï€ hÏ€âŸ©âŸ©","error:  unexpected token; expected '{' or tactic
error:  unsolved goals
B X : Profinite
Ï€ : X âŸ¶ B
âŠ¢ [EffectiveEpi Ï€, Epi Ï€, Function.Surjective â‡‘Ï€].TFAE","theorem effectiveEpi_tfae
    {B X : Profinite.{u}} (Ï€ : X âŸ¶ B) :
    TFAE
    [ EffectiveEpi Ï€
    , Epi Ï€
    , Function.Surjective Ï€
    ] ",":= by
  tfae_have 1 â†’ 2
  Â· intro; infer_instance
  tfae_have 2 â†” 3
  Â· exact epi_iff_surjective Ï€
  tfae_have 3 â†’ 1
  Â· exact fun hÏ€ â†¦ âŸ¨âŸ¨struct Ï€ hÏ€âŸ©âŸ©
  tfae_finish"
Mathlib/RingTheory/DedekindDomain/Different.lean,FractionalIdeal.dual_le_dual,dual_le_dual,3465d1aaae242475fad59e688648a2285031d19e,":= by
  nth_rewrite 2 [â† dual_dual (A := A) (K := K) I]
  rw [le_dual_iff hJ, le_dual_iff (I := J), mul_comm]
  rwa [dual_ne_zero_iff]","error:  application type mismatch
  le_dual_iff hJ
argument
  hJ
has type
  J â‰  0 : Prop
but is expected to have type
  Type ?u.463655 : Type (?u.463655 + 1)","lemma dual_le_dual :
    dual A K I â‰¤ dual A K J â†” J â‰¤ I ",":= by
  nth_rewrite 2 [â† dual_dual A K I]
  rw [le_dual_iff A K hJ, le_dual_iff A K (I := J) (by rwa [dual_ne_zero_iff]), mul_comm]"
Mathlib/Algebra/DirectSum/Module.lean,DirectSum.linearMap_ext,linearMap_ext,5068808d2b4c25cf905cf7fee10ded8e447c2346,":=
  Dfinsupp.lhom_ext' H",error:  unknown identifier 'Dfinsupp.lhom_ext'',"theorem linearMap_ext â¦ƒÏˆ Ïˆ' : (â¨ i, M i) â†’â‚—[R] Nâ¦„
    (H : âˆ€ i, Ïˆ.comp (lof R Î¹ M i) = Ïˆ'.comp (lof R Î¹ M i)) : Ïˆ = Ïˆ' ",":=
  DFinsupp.lhom_ext' H"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,df80f92cd37291ae10f3efaf1c701700cac70a5d,":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ'
  Â· rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine' Or.inl âŸ¨hs, _âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine' mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, _âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine'
        mem_shadow_iff.2
          âŸ¨(t âŠ” u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, _, _âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine' âŸ¨hus, hsv.symm, âŸ¨x, _, _âŸ©, _âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right _ _, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) _
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  unexpected token 'Â·'; expected 'by' or 'from'","theorem shadow_compression_subset_compression_shadow (u v : Finset Î±)
    (huv : âˆ€ x âˆˆ u, âˆƒ y âˆˆ v, IsCompressed (u.erase x) (v.erase y) ğ’œ) :
    âˆ‚ (ğ“’ u v ğ’œ) âŠ† ğ“’ u v (âˆ‚ ğ’œ) ",":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine Or.inl âŸ¨hs, ?_âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, ?_âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine mem_shadow_iff.2
        âŸ¨(t âŠ” u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine âŸ¨hus, hsv.symm, âŸ¨x, ?_, ?_âŸ©, ?_âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) ?_
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]"
Mathlib/Geometry/Euclidean/Basic.lean,EuclideanGeometry.eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two,eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two,4b292e8968c43193b3dbd022dfbc7ddc03b3a7a8,":= by
  have ho : âŸªcâ‚‚ -áµ¥ câ‚, pâ‚‚ -áµ¥ pâ‚âŸ« = 0 :=
    inner_vsub_vsub_of_dist_eq_of_dist_eq (hpâ‚câ‚.trans hpâ‚‚câ‚.symm) (hpâ‚câ‚‚.trans hpâ‚‚câ‚‚.symm)
  have hop : âŸªcâ‚‚ -áµ¥ câ‚, p -áµ¥ pâ‚âŸ« = 0 :=
    inner_vsub_vsub_of_dist_eq_of_dist_eq (hpâ‚câ‚.trans hpcâ‚.symm) (hpâ‚câ‚‚.trans hpcâ‚‚.symm)
  let b : Fin 2 â†’ V := ![câ‚‚ -áµ¥ câ‚, pâ‚‚ -áµ¥ pâ‚]
  have hb : LinearIndependent â„ b := by
    refine' linearIndependent_of_ne_zero_of_inner_eq_zero _ _
    Â· intro i
      fin_cases i <;> simp [hc.symm, hp.symm]
    Â· intro i j hij
      fin_cases i <;> fin_cases j <;> try exact False.elim (hij rfl)
      Â· exact ho
      Â· rw [real_inner_comm]
        exact ho
  have hbs : Submodule.span â„ (Set.range b) = s.direction := by
    refine' eq_of_le_of_finrank_eq _ _
    Â· rw [Submodule.span_le, Set.range_subset_iff]
      intro i
      fin_cases i
      Â· exact vsub_mem_direction hcâ‚‚s hcâ‚s
      Â· exact vsub_mem_direction hpâ‚‚s hpâ‚s
    Â· rw [finrank_span_eq_card hb, Fintype.card_fin, hd]
  have hv : âˆ€ v âˆˆ s.direction, âˆƒ tâ‚ tâ‚‚ : â„, v = tâ‚ â€¢ (câ‚‚ -áµ¥ câ‚) + tâ‚‚ â€¢ (pâ‚‚ -áµ¥ pâ‚) := by
    intro v hv
    have hr : Set.range b = {câ‚‚ -áµ¥ câ‚, pâ‚‚ -áµ¥ pâ‚} := by
      have hu : (Finset.univ : Finset (Fin 2)) = {0, 1} := by decide
      rw [â† Fintype.coe_image_univ, hu]
      simp
    rw [â† hbs, hr, Submodule.mem_span_insert] at hv
    rcases hv with âŸ¨tâ‚, v', hv', hvâŸ©
    rw [Submodule.mem_span_singleton] at hv'
    rcases hv' with âŸ¨tâ‚‚, rflâŸ©
    exact âŸ¨tâ‚, tâ‚‚, hvâŸ©
  rcases hv (p -áµ¥ pâ‚) (vsub_mem_direction hps hpâ‚s) with âŸ¨tâ‚, tâ‚‚, hptâŸ©
  simp only [hpt, inner_add_right, inner_smul_right, ho, mul_zero, add_zero,
    mul_eq_zero, inner_self_eq_zero, vsub_eq_zero_iff_eq, hc.symm, or_false_iff] at hop
  rw [hop, zero_smul, zero_add, â† eq_vadd_iff_vsub_eq] at hpt
  subst hpt
  have hp' : (pâ‚‚ -áµ¥ pâ‚ : V) â‰  0 := by simp [hp.symm]
  have hpâ‚‚ : dist ((1 : â„) â€¢ (pâ‚‚ -áµ¥ pâ‚) +áµ¥ pâ‚) câ‚ = râ‚ := by simp [hpâ‚‚câ‚]
  rw [â† hpâ‚câ‚, dist_smul_vadd_eq_dist _ _ hp'] at hpcâ‚ hpâ‚‚
  simp only [one_ne_zero, false_or_iff] at hpâ‚‚
  rw [hpâ‚‚.symm] at hpcâ‚
  cases' hpcâ‚ with hpcâ‚ hpcâ‚ <;> simp [hpcâ‚]","error:  unsolved goals
case refine'_1.head
V : Type u_1
P : Type u_2
instâœâ´ : NormedAddCommGroup V
instâœÂ³ : InnerProductSpace â„ V
instâœÂ² : MetricSpace P
instâœÂ¹ : NormedAddTorsor V P
s : AffineSubspace â„ P
instâœ : FiniteDimensional â„ â†¥s.direction
hd : finrank â„ â†¥s.direction = 2
câ‚ câ‚‚ pâ‚ pâ‚‚ p : P
hcâ‚s : câ‚ âˆˆ s
hcâ‚‚s : câ‚‚ âˆˆ s
hpâ‚s : pâ‚ âˆˆ s
hpâ‚‚s : pâ‚‚ âˆˆ s
hps : p âˆˆ s
râ‚ râ‚‚ : â„
hc : câ‚ â‰  câ‚‚
hp : pâ‚ â‰  pâ‚‚
hpâ‚câ‚ : dist pâ‚ câ‚ = râ‚
hpâ‚‚câ‚ : dist pâ‚‚ câ‚ = râ‚
hpcâ‚ : dist p câ‚ = râ‚
hpâ‚câ‚‚ : dist pâ‚ câ‚‚ = râ‚‚
hpâ‚‚câ‚‚ : dist pâ‚‚ câ‚‚ = râ‚‚
hpcâ‚‚ : dist p câ‚‚ = râ‚‚
ho : âŸªcâ‚‚ -áµ¥ câ‚, pâ‚‚ -áµ¥ pâ‚âŸ«_â„ = 0
hop : âŸªcâ‚‚ -áµ¥ câ‚, p -áµ¥ pâ‚âŸ«_â„ = 0
b : Fin 2 â†’ V := ![câ‚‚ -áµ¥ câ‚, pâ‚‚ -áµ¥ pâ‚]
âŠ¢ Â¬b 0 = 0

case refine'_1.tail.head
V : Type u_1
P : Type u_2
instâœâ´ : NormedAddCommGroup V
instâœÂ³ : InnerProductSpace â„ V
instâœÂ² : MetricSpace P
instâœÂ¹ : NormedAddTorsor V P
s : AffineSubspace â„ P
instâœ : FiniteDimensional â„ â†¥s.direction
hd : finrank â„ â†¥s.direction = 2
câ‚ câ‚‚ pâ‚ pâ‚‚ p : P
hcâ‚s : câ‚ âˆˆ s
hcâ‚‚s : câ‚‚ âˆˆ s
hpâ‚s : pâ‚ âˆˆ s
hpâ‚‚s : pâ‚‚ âˆˆ s
hps : p âˆˆ s
râ‚ râ‚‚ : â„
hc : câ‚ â‰  câ‚‚
hp : pâ‚ â‰  pâ‚‚
hpâ‚câ‚ : dist pâ‚ câ‚ = râ‚
hpâ‚‚câ‚ : dist pâ‚‚ câ‚ = râ‚
hpcâ‚ : dist p câ‚ = râ‚
hpâ‚câ‚‚ : dist pâ‚ câ‚‚ = râ‚‚
hpâ‚‚câ‚‚ : dist pâ‚‚ câ‚‚ = râ‚‚
hpcâ‚‚ : dist p câ‚‚ = râ‚‚
ho : âŸªcâ‚‚ -áµ¥ câ‚, pâ‚‚ -áµ¥ pâ‚âŸ«_â„ = 0
hop : âŸªcâ‚‚ -áµ¥ câ‚, p -áµ¥ pâ‚âŸ«_â„ = 0
b : Fin 2 â†’ V := ![câ‚‚ -áµ¥ câ‚, pâ‚‚ -áµ¥ pâ‚]
âŠ¢ Â¬b 1 = 0
error:  unsolved goals
V : Type u_1
P : Type u_2
instâœâ´ : NormedAddCommGroup V
instâœÂ³ : InnerProductSpace â„ V
instâœÂ² : MetricSpace P
instâœÂ¹ : NormedAddTorsor V P
s : AffineSubspace â„ P
instâœ : FiniteDimensional â„ â†¥s.direction
hd : finrank â„ â†¥s.direction = 2
câ‚ câ‚‚ pâ‚ pâ‚‚ p : P
hcâ‚s : câ‚ âˆˆ s
hcâ‚‚s : câ‚‚ âˆˆ s
hpâ‚s : pâ‚ âˆˆ s
hpâ‚‚s : pâ‚‚ âˆˆ s
hps : p âˆˆ s
râ‚ râ‚‚ : â„
hc : câ‚ â‰  câ‚‚
hp : pâ‚ â‰  pâ‚‚
hpâ‚câ‚ : dist pâ‚ câ‚ = râ‚
hpâ‚‚câ‚ : dist pâ‚‚ câ‚ = râ‚
hpcâ‚ : dist p câ‚ = râ‚
hpâ‚câ‚‚ : dist pâ‚ câ‚‚ = râ‚‚
hpâ‚‚câ‚‚ : dist pâ‚‚ câ‚‚ = râ‚‚
hpcâ‚‚ : dist p câ‚‚ = râ‚‚
ho : âŸªcâ‚‚ -áµ¥ câ‚, pâ‚‚ -áµ¥ pâ‚âŸ«_â„ = 0
hop : âŸªcâ‚‚ -áµ¥ câ‚, p -áµ¥ pâ‚âŸ«_â„ = 0
b : Fin 2 â†’ V := ![câ‚‚ -áµ¥ câ‚, pâ‚‚ -áµ¥ pâ‚]
hb : LinearIndependent â„ b
hbs : Submodule.span â„ (Set.range b) = s.direction
v : V
hv : v âˆˆ s.direction
hu : Finset.univ = {0, 1}
âŠ¢ {b 0, b 1} = {câ‚‚ -áµ¥ câ‚, pâ‚‚ -áµ¥ pâ‚}","theorem eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two {s : AffineSubspace â„ P}
    [FiniteDimensional â„ s.direction] (hd : finrank â„ s.direction = 2) {câ‚ câ‚‚ pâ‚ pâ‚‚ p : P}
    (hcâ‚s : câ‚ âˆˆ s) (hcâ‚‚s : câ‚‚ âˆˆ s) (hpâ‚s : pâ‚ âˆˆ s) (hpâ‚‚s : pâ‚‚ âˆˆ s) (hps : p âˆˆ s) {râ‚ râ‚‚ : â„}
    (hc : câ‚ â‰  câ‚‚) (hp : pâ‚ â‰  pâ‚‚) (hpâ‚câ‚ : dist pâ‚ câ‚ = râ‚) (hpâ‚‚câ‚ : dist pâ‚‚ câ‚ = râ‚)
    (hpcâ‚ : dist p câ‚ = râ‚) (hpâ‚câ‚‚ : dist pâ‚ câ‚‚ = râ‚‚) (hpâ‚‚câ‚‚ : dist pâ‚‚ câ‚‚ = râ‚‚)
    (hpcâ‚‚ : dist p câ‚‚ = râ‚‚) : p = pâ‚ âˆ¨ p = pâ‚‚ ",":= by
  have ho : âŸªcâ‚‚ -áµ¥ câ‚, pâ‚‚ -áµ¥ pâ‚âŸ« = 0 :=
    inner_vsub_vsub_of_dist_eq_of_dist_eq (hpâ‚câ‚.trans hpâ‚‚câ‚.symm) (hpâ‚câ‚‚.trans hpâ‚‚câ‚‚.symm)
  have hop : âŸªcâ‚‚ -áµ¥ câ‚, p -áµ¥ pâ‚âŸ« = 0 :=
    inner_vsub_vsub_of_dist_eq_of_dist_eq (hpâ‚câ‚.trans hpcâ‚.symm) (hpâ‚câ‚‚.trans hpcâ‚‚.symm)
  let b : Fin 2 â†’ V := ![câ‚‚ -áµ¥ câ‚, pâ‚‚ -áµ¥ pâ‚]
  have hb : LinearIndependent â„ b := by
    refine linearIndependent_of_ne_zero_of_inner_eq_zero ?_ ?_
    Â· intro i
      fin_cases i <;> simp [b, hc.symm, hp.symm]
    Â· intro i j hij
      fin_cases i <;> fin_cases j <;> try exact False.elim (hij rfl)
      Â· exact ho
      Â· rw [real_inner_comm]
        exact ho
  have hbs : Submodule.span â„ (Set.range b) = s.direction := by
    refine eq_of_le_of_finrank_eq ?_ ?_
    Â· rw [Submodule.span_le, Set.range_subset_iff]
      intro i
      fin_cases i
      Â· exact vsub_mem_direction hcâ‚‚s hcâ‚s
      Â· exact vsub_mem_direction hpâ‚‚s hpâ‚s
    Â· rw [finrank_span_eq_card hb, Fintype.card_fin, hd]
  have hv : âˆ€ v âˆˆ s.direction, âˆƒ tâ‚ tâ‚‚ : â„, v = tâ‚ â€¢ (câ‚‚ -áµ¥ câ‚) + tâ‚‚ â€¢ (pâ‚‚ -áµ¥ pâ‚) := by
    intro v hv
    have hr : Set.range b = {câ‚‚ -áµ¥ câ‚, pâ‚‚ -áµ¥ pâ‚} := by
      have hu : (Finset.univ : Finset (Fin 2)) = {0, 1} := by decide
      rw [â† Fintype.coe_image_univ, hu]
      simp [b]
    rw [â† hbs, hr, Submodule.mem_span_insert] at hv
    rcases hv with âŸ¨tâ‚, v', hv', hvâŸ©
    rw [Submodule.mem_span_singleton] at hv'
    rcases hv' with âŸ¨tâ‚‚, rflâŸ©
    exact âŸ¨tâ‚, tâ‚‚, hvâŸ©
  rcases hv (p -áµ¥ pâ‚) (vsub_mem_direction hps hpâ‚s) with âŸ¨tâ‚, tâ‚‚, hptâŸ©
  simp only [hpt, inner_add_right, inner_smul_right, ho, mul_zero, add_zero,
    mul_eq_zero, inner_self_eq_zero, vsub_eq_zero_iff_eq, hc.symm, or_false_iff] at hop
  rw [hop, zero_smul, zero_add, â† eq_vadd_iff_vsub_eq] at hpt
  subst hpt
  have hp' : (pâ‚‚ -áµ¥ pâ‚ : V) â‰  0 := by simp [hp.symm]
  have hpâ‚‚ : dist ((1 : â„) â€¢ (pâ‚‚ -áµ¥ pâ‚) +áµ¥ pâ‚) câ‚ = râ‚ := by simp [hpâ‚‚câ‚]
  rw [â† hpâ‚câ‚, dist_smul_vadd_eq_dist _ _ hp'] at hpcâ‚ hpâ‚‚
  simp only [one_ne_zero, false_or_iff] at hpâ‚‚
  rw [hpâ‚‚.symm] at hpcâ‚
  cases' hpcâ‚ with hpcâ‚ hpcâ‚ <;> simp [hpcâ‚]"
Mathlib/CategoryTheory/Limits/FilteredColimitCommutesFiniteLimit.lean,CategoryTheory.Limits.colimitLimitToLimitColimit_surjective,colimitLimitToLimitColimit_surjective,031f5489446cf55630d0efe44cc757d7a8aa007a,":= by
  classical
    intro x
    have z := fun j => jointly_surjective'.{v, v} (limit.Ï€ (curry.obj F â‹™ Limits.colim) j x)
    let k : J â†’ K := fun j => (z j).choose
    let y : âˆ€ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : âˆ€ j,
        colimit.Î¹ ((curry.obj F).obj j) (k j) (y j) = limit.Ï€ (curry.obj F â‹™ Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) âˆ…
    have g : âˆ€ j, k j âŸ¶ k' := fun j => IsFiltered.toSup (Finset.univ.image k) âˆ… (by simp)
    clear_value k'
    have w :
      âˆ€ {j j' : J} (f : j âŸ¶ j'),
        colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((ğŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =
          colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ğŸ™ (k j)) : (j, k j) âŸ¶ (j', k j)) â‰« (ğŸ™ j', g j) : (j, k j) âŸ¶ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply', t, FunctorToTypes.map_comp_apply, Colimit.w_apply', e, â†
        Limit.w_apply' f, â† e]
      simp
    simp_rw [colimit_eq_iff.{v, v}] at w
    let kf : âˆ€ {j j'} (_ : j âŸ¶ j'), K := fun f => (w f).choose
    let gf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun f => (w f).choose_spec.choose
    let hf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      âˆ€ {j j'} (f : j âŸ¶ j'),
        F.map ((ğŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j') =
          F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ğŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [â† FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) âˆª {k'}
    have kfO : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âˆˆ O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr âŸ¨j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr âŸ¨j', Finset.mem_univ j',
              Finset.mem_image.mpr âŸ¨f, Finset.mem_univ _, rflâŸ©âŸ©âŸ©))
    have k'O : k' âˆˆ O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Î£' (X Y : K) (_ : X âˆˆ O) (_ : Y âˆˆ O), X âŸ¶ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j âŸ¶ j' =>
            {âŸ¨k', kf f, k'O, kfO f, gf fâŸ©, âŸ¨k', kf f, k'O, kfO f, hf fâŸ©}
    obtain âŸ¨k'', i', s'âŸ© := IsFiltered.sup_exists O H
    let i : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âŸ¶ k'' := fun {j} {j'} f => i' (kfO f)
    have s : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ jâ‚„} (f : jâ‚ âŸ¶ jâ‚‚) (f' : jâ‚ƒ âŸ¶ jâ‚„), gf f â‰« i f = hf f' â‰« i f' := by
      intros jâ‚ jâ‚‚ jâ‚ƒ jâ‚„ f f'
      rw [s', s']
      Â· exact k'O
      Â· exact Finset.mem_biUnion.mpr âŸ¨jâ‚ƒ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr âŸ¨jâ‚„, Finset.mem_univ _,
            Finset.mem_biUnion.mpr âŸ¨f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivialâŸ©âŸ©âŸ©
      Â· exact Finset.mem_biUnion.mpr âŸ¨jâ‚, Finset.mem_univ _,
          Finset.mem_biUnion.mpr âŸ¨jâ‚‚, Finset.mem_univ _,
            Finset.mem_biUnion.mpr âŸ¨f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivialâŸ©âŸ©âŸ©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    Â· 
      apply colimit.Î¹ (curry.obj (swap K J â‹™ F) â‹™ Limits.lim) k'' _
      dsimp
      apply Limit.mk.{v, v}
      swap
      Â·
        exact fun j => F.map (âŸ¨ğŸ™ j, g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j)âŸ© : (j, k j) âŸ¶ (j, k'')) (y j)
      Â· 
        dsimp
        intro j j' f
        simp only [â† FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j)) : (j, k j) âŸ¶ (j', k'')) (y j) =
              F.map ((f, g j â‰« hf f â‰« i f) : (j, k j) âŸ¶ (j', k'')) (y j) :=
            by rw [s (ğŸ™ j) f]
          _ =
              F.map ((ğŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))
                (F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j)) :=
            by rw [â† FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ğŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))
                (F.map ((ğŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j')) :=
            by rw [â† wf f]
          _ = F.map ((ğŸ™ j', g j' â‰« gf f â‰« i f) : (j', k j') âŸ¶ (j', k'')) (y j') := by
            rw [â† FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ğŸ™ j', g j' â‰« gf (ğŸ™ j') â‰« i (ğŸ™ j')) : (j', k j') âŸ¶ (j', k'')) (y j') := by
            rw [s f (ğŸ™ j'), â† s (ğŸ™ j') (ğŸ™ j')]
    Â· 
      apply limit_ext'
      intro j
      simp only [id.def, â† e, Limits.Î¹_colimitLimitToLimitColimit_Ï€_apply,
          colimit_eq_iff.{v, v}, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.Ï€_mk]
      refine âŸ¨k'', ğŸ™ k'', g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j), ?_âŸ©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]","error:  application type mismatch
  jointly_surjective' (limit.Ï€ (curry.obj F â‹™ colim) j x)
argument
  limit.Ï€ (curry.obj F â‹™ colim) j x
has type
  (curry.obj F â‹™ colim).obj j : Type v
but is expected to have type
  colimit ?m.27488 : Type v
error:  unsolved goals
J : Type uâ‚
K : Type uâ‚‚
instâœâ´ : SmallCategory J
instâœÂ³ : Category.{vâ‚‚, uâ‚‚} K
instâœÂ² : Small.{v, uâ‚‚} K
instâœÂ¹ : FinCategory J
F : J Ã— K â¥¤ Type v
instâœ : IsFiltered K
x : limit (curry.obj F â‹™ colim)
âŠ¢ âˆƒ a, colimitLimitToLimitColimit F a = x","theorem colimitLimitToLimitColimit_surjective :
    Function.Surjective (colimitLimitToLimitColimit F) ",":= by
  classical
    intro x
    have z := fun j => jointly_surjective' (limit.Ï€ (curry.obj F â‹™ Limits.colim) j x)
    let k : J â†’ K := fun j => (z j).choose
    let y : âˆ€ j, F.obj (j, k j) := fun j => (z j).choose_spec.choose
    have e : âˆ€ j,
        colimit.Î¹ ((curry.obj F).obj j) (k j) (y j) = limit.Ï€ (curry.obj F â‹™ Limits.colim) j x :=
      fun j => (z j).choose_spec.choose_spec
    clear_value k y
    clear z
    let k' : K := IsFiltered.sup (Finset.univ.image k) âˆ…
    have g : âˆ€ j, k j âŸ¶ k' := fun j => IsFiltered.toSup (Finset.univ.image k) âˆ… (by simp)
    clear_value k'
    have w :
      âˆ€ {j j' : J} (f : j âŸ¶ j'),
        colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((ğŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =
          colimit.Î¹ ((curry.obj F).obj j') k' (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) := by
      intro j j' f
      have t : (f, g j) =
          (((f, ğŸ™ (k j)) : (j, k j) âŸ¶ (j', k j)) â‰« (ğŸ™ j', g j) : (j, k j) âŸ¶ (j', k')) := by
        simp only [id_comp, comp_id, prod_comp]
      erw [Colimit.w_apply, t, FunctorToTypes.map_comp_apply, Colimit.w_apply, e,
        â† Limit.w_apply.{uâ‚, v, uâ‚} f, â† e]
      simp only [Functor.comp_map, Types.Colimit.Î¹_map_apply, curry_obj_map_app]
    simp_rw [colimit_eq_iff] at w
    let kf : âˆ€ {j j'} (_ : j âŸ¶ j'), K := fun f => (w f).choose
    let gf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun f => (w f).choose_spec.choose
    let hf : âˆ€ {j j'} (f : j âŸ¶ j'), k' âŸ¶ kf f := fun f =>
      (w f).choose_spec.choose_spec.choose
    have wf :
      âˆ€ {j j'} (f : j âŸ¶ j'),
        F.map ((ğŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j') =
          F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j) :=
      fun {j j'} f => by
      have q :
        ((curry.obj F).obj j').map (gf f) (F.map ((ğŸ™ j', g j') : (j', k j') âŸ¶ (j', k')) (y j')) =
          ((curry.obj F).obj j').map (hf f) (F.map ((f, g j) : (j, k j) âŸ¶ (j', k')) (y j)) :=
        (w f).choose_spec.choose_spec.choose_spec
      rw [curry_obj_obj_map, curry_obj_obj_map] at q
      simp_rw [â† FunctorToTypes.map_comp_apply, CategoryStruct.comp] at q
      convert q <;> simp only [comp_id]
    clear_value kf gf hf
    clear w
    let O :=
      (Finset.univ.biUnion fun j => Finset.univ.biUnion fun j' => Finset.univ.image
        (@kf j j')) âˆª {k'}
    have kfO : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âˆˆ O := fun {j} {j'} f =>
      Finset.mem_union.mpr
        (Or.inl
          (Finset.mem_biUnion.mpr âŸ¨j, Finset.mem_univ j,
            Finset.mem_biUnion.mpr âŸ¨j', Finset.mem_univ j',
              Finset.mem_image.mpr âŸ¨f, Finset.mem_univ _, rflâŸ©âŸ©âŸ©))
    have k'O : k' âˆˆ O := Finset.mem_union.mpr (Or.inr (Finset.mem_singleton.mpr rfl))
    let H : Finset (Î£' (X Y : K) (_ : X âˆˆ O) (_ : Y âˆˆ O), X âŸ¶ Y) :=
      Finset.univ.biUnion fun j : J =>
        Finset.univ.biUnion fun j' : J =>
          Finset.univ.biUnion fun f : j âŸ¶ j' =>
            {âŸ¨k', kf f, k'O, kfO f, gf fâŸ©, âŸ¨k', kf f, k'O, kfO f, hf fâŸ©}
    obtain âŸ¨k'', i', s'âŸ© := IsFiltered.sup_exists O H
    let i : âˆ€ {j j'} (f : j âŸ¶ j'), kf f âŸ¶ k'' := fun {j} {j'} f => i' (kfO f)
    have s : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ jâ‚„} (f : jâ‚ âŸ¶ jâ‚‚) (f' : jâ‚ƒ âŸ¶ jâ‚„), gf f â‰« i f = hf f' â‰« i f' := by
      intros jâ‚ jâ‚‚ jâ‚ƒ jâ‚„ f f'
      rw [s', s']
      Â· exact k'O
      Â· exact Finset.mem_biUnion.mpr âŸ¨jâ‚ƒ, Finset.mem_univ _,
          Finset.mem_biUnion.mpr âŸ¨jâ‚„, Finset.mem_univ _,
            Finset.mem_biUnion.mpr âŸ¨f', Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                or_true]
              trivialâŸ©âŸ©âŸ©
      Â· exact Finset.mem_biUnion.mpr âŸ¨jâ‚, Finset.mem_univ _,
          Finset.mem_biUnion.mpr âŸ¨jâ‚‚, Finset.mem_univ _,
            Finset.mem_biUnion.mpr âŸ¨f, Finset.mem_univ _, by
              rw [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq,
                PSigma.mk.injEq, heq_eq_eq, PSigma.mk.injEq, heq_eq_eq, eq_self, true_and, eq_self,
                true_and, eq_self, true_and, eq_self, true_and, Finset.mem_singleton, eq_self,
                true_or]
              trivialâŸ©âŸ©âŸ©
    clear_value i
    clear s' i' H kfO k'O O
    fconstructor
    Â· 
      apply colimit.Î¹ (curry.obj (swap K J â‹™ F) â‹™ Limits.lim) k'' _
      dsimp
      apply Limit.mk
      swap
      Â·
        exact fun j => F.map (âŸ¨ğŸ™ j, g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j)âŸ© : (j, k j) âŸ¶ (j, k'')) (y j)
      Â· 
        dsimp
        intro j j' f
        simp only [â† FunctorToTypes.map_comp_apply, prod_comp, id_comp, comp_id]
        calc
          F.map ((f, g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j)) : (j, k j) âŸ¶ (j', k'')) (y j) =
              F.map ((f, g j â‰« hf f â‰« i f) : (j, k j) âŸ¶ (j', k'')) (y j) := by
            rw [s (ğŸ™ j) f]
          _ =
              F.map ((ğŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))
                (F.map ((f, g j â‰« hf f) : (j, k j) âŸ¶ (j', kf f)) (y j)) := by
            rw [â† FunctorToTypes.map_comp_apply, prod_comp, comp_id, assoc]
          _ =
              F.map ((ğŸ™ j', i f) : (j', kf f) âŸ¶ (j', k''))
                (F.map ((ğŸ™ j', g j' â‰« gf f) : (j', k j') âŸ¶ (j', kf f)) (y j')) := by
            rw [â† wf f]
          _ = F.map ((ğŸ™ j', g j' â‰« gf f â‰« i f) : (j', k j') âŸ¶ (j', k'')) (y j') := by
            rw [â† FunctorToTypes.map_comp_apply, prod_comp, id_comp, assoc]
          _ = F.map ((ğŸ™ j', g j' â‰« gf (ğŸ™ j') â‰« i (ğŸ™ j')) : (j', k j') âŸ¶ (j', k'')) (y j') := by
            rw [s f (ğŸ™ j'), â† s (ğŸ™ j') (ğŸ™ j')]
    Â· 
      apply limit_ext
      intro j
      simp only [id, â† e, Limits.Î¹_colimitLimitToLimitColimit_Ï€_apply,
          colimit_eq_iff, Bifunctor.map_id_comp, types_comp_apply, curry_obj_obj_map,
          Functor.comp_obj, colim_obj, Limit.Ï€_mk]
      refine âŸ¨k'', ğŸ™ k'', g j â‰« gf (ğŸ™ j) â‰« i (ğŸ™ j), ?_âŸ©
      rw [Bifunctor.map_id_comp, Bifunctor.map_id_comp, types_comp_apply, types_comp_apply,
        Bifunctor.map_id, types_id_apply]"
Mathlib/AlgebraicTopology/DoldKan/Compatibility.lean,AlgebraicTopology.DoldKan.Compatibility.equivalenceâ‚CounitIso_eq,equivalenceâ‚CounitIso_eq,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  ext Y
  dsimp [equivalenceâ‚, equivalenceâ‚€, Functor.IsEquivalence.inverse,
    Functor.IsEquivalence.ofEquivalence]
  simp","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Functor.IsEquivalence
has type
  ?m.10531 â¥¤ ?m.10551 â†’ Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Functor.IsEquivalence
has type
  ?m.10580 â¥¤ ?m.10600 â†’ Prop",theorem equivalenceâ‚CounitIso_eq : (equivalenceâ‚ hF).counitIso = equivalenceâ‚CounitIso hF ,":= by
  ext Y
  simp [equivalenceâ‚, equivalenceâ‚€]"
Mathlib/Analysis/InnerProductSpace/Projection.lean,LinearIsometryEquiv.reflections_generate_dim,LinearIsometryEquiv.reflections_generate_dim,d925bcb6a40d20ae582767f1a25d9e5251b014c6,":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine' âŸ¨[], rfl.le, show Ï† = 1 from _âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [Nat.zero_eq, le_zero_iff, Submodule.finrank_eq_zero,
        Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by linarith [zero_le n] : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine' reflection_mem_subspace_eq_self _
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      linarith
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine' âŸ¨x::l, Nat.succ_le_succ hl, _âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
ğ•œ : Type u_1
E : Type u_2
F : Type u_3
instâœâµ : _root_.RCLike ğ•œ
instâœâ´ : NormedAddCommGroup E
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : InnerProductSpace ğ•œ E
instâœÂ¹ : InnerProductSpace â„ F
K : Submodule ğ•œ E
instâœ : FiniteDimensional â„ F
Ï† : F â‰ƒâ‚—áµ¢[â„] F
hn :
  finrank â„
      â†¥(LinearMap.ker
            (ContinuousLinearMap.id â„ F -
              â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }))á—® â‰¤
    0
âŠ¢ LinearMap.ker
      (ContinuousLinearMap.id â„ F -
        â†‘{ toLinearEquiv := Ï†.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }) =
    âŠ¤","theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional â„ F] {n : â„•}
    (Ï† : F â‰ƒâ‚—áµ¢[â„] F) (hn : finrank â„ (ker (ContinuousLinearMap.id â„ F - Ï†))á—® â‰¤ n) :
    âˆƒ l : List F, l.length â‰¤ n âˆ§ Ï† = (l.map fun v => reflection (â„ âˆ™ v)á—®).prod ",":= by
  induction' n with n IH generalizing Ï†
  Â· 
    refine âŸ¨[], rfl.le, show Ï† = 1 from ?_âŸ©
    have : ker (ContinuousLinearMap.id â„ F - Ï†) = âŠ¤ := by
      rwa [le_zero_iff, Submodule.finrank_eq_zero, Submodule.orthogonal_eq_bot_iff] at hn
    symm
    ext x
    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x
    simpa only [sub_eq_zero, ContinuousLinearMap.coe_sub, LinearMap.sub_apply,
      LinearMap.zero_apply] using this
  Â· 
    let W := ker (ContinuousLinearMap.id â„ F - Ï†)
    have hW : âˆ€ w âˆˆ W, Ï† w = w := fun w hw => (sub_eq_zero.mp hw).symm
    by_cases hn' : finrank â„ Wá—® â‰¤ n
    Â· obtain âŸ¨V, hVâ‚, hVâ‚‚âŸ© := IH Ï† hn'
      exact âŸ¨V, hVâ‚.trans n.le_succ, hVâ‚‚âŸ©
    haveI : Nontrivial Wá—® := nontrivial_of_finrank_pos (by omega : 0 < finrank â„ Wá—®)
    obtain âŸ¨v, hvâŸ© := exists_ne (0 : Wá—®)
    have hÏ†v : Ï† v âˆˆ Wá—® := by
      intro w hw
      rw [â† hW w hw, LinearIsometryEquiv.inner_map_map]
      exact v.prop w hw
    have hv' : (v : F) âˆ‰ W := by
      intro h
      exact hv ((Submodule.mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)
    let x : F := v - Ï† v
    let Ï := reflection (â„ âˆ™ x)á—®
    let V := ker (ContinuousLinearMap.id â„ F - Ï†.trans Ï)
    have hV : âˆ€ w, Ï (Ï† w) = w â†’ w âˆˆ V := by
      intro w hw
      change w - Ï (Ï† w) = 0
      rw [sub_eq_zero, hw]
    have Hâ‚‚V : W â‰¤ V := by
      intro w hw
      apply hV
      rw [hW w hw]
      refine reflection_mem_subspace_eq_self ?_
      rw [Submodule.mem_orthogonal_singleton_iff_inner_left]
      exact Submodule.sub_mem _ v.prop hÏ†v _ hw
    have Hâ‚V : (v : F) âˆˆ V := by
      apply hV
      have : Ï v = Ï† v := reflection_sub (Ï†.norm_map v).symm
      rw [â† this]
      exact reflection_reflection _ _
    have : finrank â„ Vá—® â‰¤ n := by
      change finrank â„ Wá—® â‰¤ n + 1 at hn
      have : finrank â„ W + 1 â‰¤ finrank â„ V :=
        Submodule.finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 âŸ¨Hâ‚‚V, v, Hâ‚V, hv'âŸ©)
      have : finrank â„ V + finrank â„ Vá—® = finrank â„ F := V.finrank_add_finrank_orthogonal
      have : finrank â„ W + finrank â„ Wá—® = finrank â„ F := W.finrank_add_finrank_orthogonal
      omega
    obtain âŸ¨l, hl, hÏ†lâŸ© := IH (Ï * Ï†) this
    refine âŸ¨x::l, Nat.succ_le_succ hl, ?_âŸ©
    rw [List.map_cons, List.prod_cons]
    have := congr_arg (Ï * Â·) hÏ†l
    dsimp only at this
    rwa [â† mul_assoc, reflection_mul_reflection, one_mul] at this"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,b50a8b2e9760b6f582390d3948a953c553480df1,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine' âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, _âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, âŸ¨_, _, _âŸ©, _âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.nat_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 âˆˆ ?m.116759 âˆª ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120516 â†’ ?m.120516
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.124403 â†’ ?m.124403
error:  unsolved goals
case zero
Î± : Type u_1
instâœâµ : MetricSpace Î±
Î² : Type u
instâœâ´ : SecondCountableTopology Î±
instâœÂ³ : MeasurableSpace Î±
instâœÂ² : OpensMeasurableSpace Î±
instâœÂ¹ : HasBesicovitchCovering Î±
Î¼ : Measure Î±
instâœ : IsFiniteMeasure Î¼
f : Î± â†’ Set â„
s : Set Î±
hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty
N : â„•
Ï„ : â„
hÏ„ : 1 < Ï„
hN : IsEmpty (SatelliteConfig Î± N Ï„)
P : Finset (Î± Ã— â„) â†’ Prop :=
  fun t â†¦ ((â†‘t).PairwiseDisjoint fun p â†¦ closedBall p.1 p.2) âˆ§ (âˆ€ p âˆˆ t, p.1 âˆˆ s) âˆ§ âˆ€ p âˆˆ t, p.2 âˆˆ f p.1
F : Finset (Î± Ã— â„) â†’ Finset (Î± Ã— â„)
hF :
  âˆ€ (t : Finset (Î± Ã— â„)),
    P t â†’
      t âŠ† F t âˆ§ P (F t) âˆ§ Î¼ (s \ â‹ƒ p âˆˆ F t, closedBall p.1 p.2) â‰¤ â†‘N / (â†‘N + 1) * Î¼ (s \ â‹ƒ p âˆˆ t, closedBall p.1 p.2)
u : â„• â†’ Finset (Î± Ã— â„) := fun n â†¦ F^[n] âˆ…
u_succ : âˆ€ (n : â„•), u n.succ = F (u n)
Pu : âˆ€ (n : â„•), P (u n)
A : âˆ€ (n : â„•), Î¼ (s \ â‹ƒ p âˆˆ â‹ƒ n, â†‘(u n), closedBall p.1 p.2) â‰¤ Î¼ (s \ â‹ƒ p âˆˆ u n, closedBall p.1 p.2)
âŠ¢ Î¼ (s \ â‹ƒ p âˆˆ id âˆ…, closedBall p.1 p.2) â‰¤ Î¼ s
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Î¼ : Measure Î±)
    [IsFiniteMeasure Î¼] (f : Î± â†’ Set â„) (s : Set Î±)
    (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty) :
    âˆƒ t : Set (Î± Ã— â„), t.Countable âˆ§ (âˆ€ p âˆˆ t, p.1 âˆˆ s) âˆ§ (âˆ€ p âˆˆ t, p.2 âˆˆ f p.1) âˆ§
      Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) = 0 âˆ§
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, ?_âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, âŸ¨?_, ?_, ?_âŸ©, ?_âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Î¼ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean,contDiffGroupoid_prod,contDiffGroupoid_prod,f41d2e3dd69004ca4172132a94e749b22b59caae,":= by
  cases' he with he he_symm
  cases' he' with he' he'_symm
  simp only at he he_symm he' he'_symm
  constructor <;> simp only [PartialEquiv.prod_source, PartialHomeomorph.prod_toPartialEquiv]
  Â· have h3 := ContDiffOn.prod_map he he'
    rw [â† I.image_eq, â† I'.image_eq, prod_image_image_eq] at h3
    rw [â† (I.prod I').image_eq]
    exact h3
  Â· have h3 := ContDiffOn.prod_map he_symm he'_symm
    rw [â† I.image_eq, â† I'.image_eq, prod_image_image_eq] at h3
    rw [â† (I.prod I').image_eq]
    exact h3","warning:  modelWithCornersSelf does not have a doc string
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â†‘(I.prod I').symm â»Â¹' ?s âˆ© range â†‘(I.prod I')
case intro.intro.left
m n : â„•âˆ
ğ•œ : Type u_1
instâœâ· : NontriviallyNormedField ğ•œ
E : Type u_2
instâœâ¶ : NormedAddCommGroup E
instâœâµ : NormedSpace ğ•œ E
H : Type u_3
instâœâ´ : TopologicalSpace H
Iâœ : ModelWithCorners ğ•œ E H
M : Type u_4
instâœÂ³ : TopologicalSpace M
E' : Type u_5
H' : Type u_6
instâœÂ² : NormedAddCommGroup E'
instâœÂ¹ : NormedSpace ğ•œ E'
instâœ : TopologicalSpace H'
I : ModelWithCorners ğ•œ E H
I' : ModelWithCorners ğ•œ E' H'
e : PartialHomeomorph H H
e' : PartialHomeomorph H' H'
he : (contDiffPregroupoid âŠ¤ I).property (â†‘e) e.source
he_symm : (contDiffPregroupoid âŠ¤ I).property (â†‘e.symm) e.target
he' : (contDiffPregroupoid âŠ¤ I').property (â†‘e') e'.source
he'_symm : (contDiffPregroupoid âŠ¤ I').property (â†‘e'.symm) e'.target
h3 :
  ContDiffOn ğ•œ âŠ¤ (Prod.map (â†‘I âˆ˜ â†‘e âˆ˜ â†‘I.symm) (â†‘I' âˆ˜ â†‘e' âˆ˜ â†‘I'.symm))
    ((fun p â†¦ (â†‘I p.1, â†‘I' p.2)) '' e.source Ã—Ë¢ e'.source)
âŠ¢ (contDiffPregroupoid âŠ¤ (I.prod I')).property (â†‘(e.prod e')) (e.source Ã—Ë¢ e'.source)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  â†‘(I.prod I').symm â»Â¹' ?s âˆ© range â†‘(I.prod I')
case intro.intro.right
m n : â„•âˆ
ğ•œ : Type u_1
instâœâ· : NontriviallyNormedField ğ•œ
E : Type u_2
instâœâ¶ : NormedAddCommGroup E
instâœâµ : NormedSpace ğ•œ E
H : Type u_3
instâœâ´ : TopologicalSpace H
Iâœ : ModelWithCorners ğ•œ E H
M : Type u_4
instâœÂ³ : TopologicalSpace M
E' : Type u_5
H' : Type u_6
instâœÂ² : NormedAddCommGroup E'
instâœÂ¹ : NormedSpace ğ•œ E'
instâœ : TopologicalSpace H'
I : ModelWithCorners ğ•œ E H
I' : ModelWithCorners ğ•œ E' H'
e : PartialHomeomorph H H
e' : PartialHomeomorph H' H'
he : (contDiffPregroupoid âŠ¤ I).property (â†‘e) e.source
he_symm : (contDiffPregroupoid âŠ¤ I).property (â†‘e.symm) e.target
he' : (contDiffPregroupoid âŠ¤ I').property (â†‘e') e'.source
he'_symm : (contDiffPregroupoid âŠ¤ I').property (â†‘e'.symm) e'.target
h3 :
  ContDiffOn ğ•œ âŠ¤ (Prod.map (â†‘I âˆ˜ â†‘e.symm âˆ˜ â†‘I.symm) (â†‘I' âˆ˜ â†‘e'.symm âˆ˜ â†‘I'.symm))
    ((fun p â†¦ (â†‘I p.1, â†‘I' p.2)) '' e.target Ã—Ë¢ e'.target)
âŠ¢ (contDiffPregroupoid âŠ¤ (I.prod I')).property (â†‘(e.prod e').symm) (e.prod e'.toPartialEquiv).target","theorem contDiffGroupoid_prod {I : ModelWithCorners ğ•œ E H} {I' : ModelWithCorners ğ•œ E' H'}
    {e : PartialHomeomorph H H} {e' : PartialHomeomorph H' H'} (he : e âˆˆ contDiffGroupoid âŠ¤ I)
    (he' : e' âˆˆ contDiffGroupoid âŠ¤ I') : e.prod e' âˆˆ contDiffGroupoid âŠ¤ (I.prod I') ",":= by
  cases' he with he he_symm
  cases' he' with he' he'_symm
  simp only at he he_symm he' he'_symm
  constructor <;> simp only [PartialEquiv.prod_source, PartialHomeomorph.prod_toPartialEquiv,
    contDiffPregroupoid]
  Â· have h3 := ContDiffOn.prod_map he he'
    rw [â† I.image_eq, â† I'.image_eq, prod_image_image_eq] at h3
    rw [â† (I.prod I').image_eq]
    exact h3
  Â· have h3 := ContDiffOn.prod_map he_symm he'_symm
    rw [â† I.image_eq, â† I'.image_eq, prod_image_image_eq] at h3
    rw [â† (I.prod I').image_eq]
    exact h3"
Mathlib/MeasureTheory/Integral/CircleIntegral.lean,circleIntegrable_sub_zpow_iff,circleIntegrable_sub_zpow_iff,22561be615987d98bee187e1a4c8faa6e6fc0678,":= by
  constructor
  Â· intro h; contrapose! h; rcases h with âŸ¨hR, hn, hwâŸ©
    simp only [circleIntegrable_iff R, deriv_circleMap]
    rw [â† image_circleMap_Ioc] at hw; rcases hw with âŸ¨Î¸, hÎ¸, rflâŸ©
    replace hÎ¸ : Î¸ âˆˆ [[0, 2 * Ï€]]; exact Icc_subset_uIcc (Ioc_subset_Icc_self hÎ¸)
    refine' not_intervalIntegrable_of_sub_inv_isBigO_punctured _ Real.two_pi_pos.ne hÎ¸
    set f : â„ â†’ â„‚ := fun Î¸' => circleMap c R Î¸' - circleMap c R Î¸
    have : âˆ€á¶  Î¸' in ğ“[â‰ ] Î¸, f Î¸' âˆˆ ball (0 : â„‚) 1 \ {0} := by
      suffices : âˆ€á¶  z in (nhdsWithin (circleMap c R Î¸) {circleMap c R Î¸}á¶œ),
        z - circleMap c R Î¸ âˆˆ ball (0 : â„‚) 1 \ {0}
      exact ((differentiable_circleMap c R Î¸).hasDerivAt.tendsto_punctured_nhds
        (deriv_circleMap_ne_zero hR)).eventually this
      filter_upwards [self_mem_nhdsWithin, mem_nhdsWithin_of_mem_nhds (ball_mem_nhds _ zero_lt_one)]
      simp_all [dist_eq, sub_eq_zero]
    refine' (((hasDerivAt_circleMap c R Î¸).isBigO_sub.mono inf_le_left).inv_rev
      (this.mono fun Î¸' hâ‚ hâ‚‚ => absurd hâ‚‚ hâ‚.2)).trans _
    refine' IsBigO.of_bound |R|â»Â¹ (this.mono fun Î¸' hÎ¸' => _)
    set x := abs (f Î¸')
    suffices xâ»Â¹ â‰¤ x ^ n by
      simpa only [inv_mul_cancel_leftâ‚€, abs_eq_zero.not.2 hR, norm_eq_abs, map_invâ‚€,
        Algebra.id.smul_eq_mul, map_mul, abs_circleMap_zero, abs_I, mul_one, abs_zpow, Ne.def,
        not_false_iff] using this
    have : x âˆˆ Ioo (0 : â„) 1 := by simpa [and_comm] using hÎ¸'
    rw [â† zpow_neg_one]
    refine' (zpow_strictAnti this.1 this.2).le_iff_le.2 (Int.lt_add_one_iff.1 _); exact hn
  Â· rintro (rfl | H)
    exacts [circleIntegrable_zero_radius,
      ((continuousOn_id.sub continuousOn_const).zpowâ‚€ _ fun z hz =>
        H.symm.imp_left fun (hw : w âˆ‰ sphere c |R|) =>
          sub_ne_zero.2 <| ne_of_mem_of_not_mem hz hw).circleIntegrable']","error:  unexpected token ';'; expected '|'
error:  unsolved goals
case mp.intro.intro.intro.intro
E : Type u_1
instâœ : NormedAddCommGroup E
c : â„‚
R : â„
n : â„¤
hR : R â‰  0
hn : n < 0
Î¸ : â„
hÎ¸ : Î¸ âˆˆ [[0, 2 * Ï€]]
âŠ¢ Â¬IntervalIntegrable (fun Î¸_1 â†¦ (circleMap 0 R Î¸_1 * I) â€¢ (circleMap c R Î¸_1 - circleMap c R Î¸) ^ n) volume 0 (2 * Ï€)
error:  unsolved goals
case mpr
E : Type u_1
instâœ : NormedAddCommGroup E
c w : â„‚
R : â„
n : â„¤
âŠ¢ R = 0 âˆ¨ 0 â‰¤ n âˆ¨ w âˆ‰ sphere c |R| â†’ CircleIntegrable (fun z â†¦ (z - w) ^ n) c R","theorem circleIntegrable_sub_zpow_iff {c w : â„‚} {R : â„} {n : â„¤} :
    CircleIntegrable (fun z => (z - w) ^ n) c R â†” R = 0 âˆ¨ 0 â‰¤ n âˆ¨ w âˆ‰ sphere c |R| ",":= by
  constructor
  Â· intro h; contrapose! h; rcases h with âŸ¨hR, hn, hwâŸ©
    simp only [circleIntegrable_iff R, deriv_circleMap]
    rw [â† image_circleMap_Ioc] at hw; rcases hw with âŸ¨Î¸, hÎ¸, rflâŸ©
    replace hÎ¸ : Î¸ âˆˆ [[0, 2 * Ï€]] := Icc_subset_uIcc (Ioc_subset_Icc_self hÎ¸)
    refine not_intervalIntegrable_of_sub_inv_isBigO_punctured ?_ Real.two_pi_pos.ne hÎ¸
    set f : â„ â†’ â„‚ := fun Î¸' => circleMap c R Î¸' - circleMap c R Î¸
    have : âˆ€á¶  Î¸' in ğ“[â‰ ] Î¸, f Î¸' âˆˆ ball (0 : â„‚) 1 \ {0} := by
      suffices âˆ€á¶  z in ğ“[â‰ ] circleMap c R Î¸, z - circleMap c R Î¸ âˆˆ ball (0 : â„‚) 1 \ {0} from
        ((differentiable_circleMap c R Î¸).hasDerivAt.tendsto_punctured_nhds
          (deriv_circleMap_ne_zero hR)).eventually this
      filter_upwards [self_mem_nhdsWithin, mem_nhdsWithin_of_mem_nhds (ball_mem_nhds _ zero_lt_one)]
      simp_all [dist_eq, sub_eq_zero]
    refine (((hasDerivAt_circleMap c R Î¸).isBigO_sub.mono inf_le_left).inv_rev
      (this.mono fun Î¸' hâ‚ hâ‚‚ => absurd hâ‚‚ hâ‚.2)).trans ?_
    refine IsBigO.of_bound |R|â»Â¹ (this.mono fun Î¸' hÎ¸' => ?_)
    set x := abs (f Î¸')
    suffices xâ»Â¹ â‰¤ x ^ n by
      simpa only [inv_mul_cancel_leftâ‚€, abs_eq_zero.not.2 hR, norm_eq_abs, map_invâ‚€,
        Algebra.id.smul_eq_mul, map_mul, abs_circleMap_zero, abs_I, mul_one, abs_zpow, Ne,
        not_false_iff] using this
    have : x âˆˆ Ioo (0 : â„) 1 := by simpa [x, and_comm] using hÎ¸'
    rw [â† zpow_neg_one]
    refine (zpow_strictAnti this.1 this.2).le_iff_le.2 (Int.lt_add_one_iff.1 ?_); exact hn
  Â· rintro (rfl | H)
    exacts [circleIntegrable_zero_radius,
      ((continuousOn_id.sub continuousOn_const).zpowâ‚€ _ fun z hz =>
        H.symm.imp_left fun (hw : w âˆ‰ sphere c |R|) =>
          sub_ne_zero.2 <| ne_of_mem_of_not_mem hz hw).circleIntegrable']"
Mathlib/Algebra/DirectLimit.lean,Module.DirectLimit.map_comp,map_comp,f9a92ed3d67873862051aaeedcedfa1472745048,":=
  DFunLike.ext _ _ fun x â†¦ (isEmpty_or_nonempty Î¹).elim (by subsingleton) fun _ â†¦
    x.induction_on fun i g â†¦ by simp","error:  unknown tactic
error:  unsolved goals
R : Type u
instâœÂ¹Â¹ : Ring R
Î¹ : Type v
instâœÂ¹â° : Preorder Î¹
G : Î¹ â†’ Type w
instâœâ¹ : (i : Î¹) â†’ AddCommGroup (G i)
instâœâ¸ : (i : Î¹) â†’ Module R (G i)
f : (i j : Î¹) â†’ i â‰¤ j â†’ G i â†’â‚—[R] G j
instâœâ· : DecidableEq Î¹
P : Type uâ‚
instâœâ¶ : AddCommGroup P
instâœâµ : Module R P
g : (i : Î¹) â†’ G i â†’â‚—[R] P
Hg : âˆ€ (i j : Î¹) (hij : i â‰¤ j) (x : G i), (g j) ((f i j hij) x) = (g i) x
G' : Î¹ â†’ Type v'
instâœâ´ : (i : Î¹) â†’ AddCommGroup (G' i)
instâœÂ³ : (i : Î¹) â†’ Module R (G' i)
f' : (i j : Î¹) â†’ i â‰¤ j â†’ G' i â†’â‚—[R] G' j
G'' : Î¹ â†’ Type v''
instâœÂ² : (i : Î¹) â†’ AddCommGroup (G'' i)
instâœÂ¹ : (i : Î¹) â†’ Module R (G'' i)
f'' : (i j : Î¹) â†’ i â‰¤ j â†’ G'' i â†’â‚—[R] G'' j
instâœ : IsDirected Î¹ fun x x_1 â†¦ x â‰¤ x_1
gâ‚ : (i : Î¹) â†’ G i â†’â‚—[R] G' i
gâ‚‚ : (i : Î¹) â†’ G' i â†’â‚—[R] G'' i
hgâ‚ : âˆ€ (i j : Î¹) (h : i â‰¤ j), gâ‚ j âˆ˜â‚— f i j h = f' i j h âˆ˜â‚— gâ‚ i
hgâ‚‚ : âˆ€ (i j : Î¹) (h : i â‰¤ j), gâ‚‚ j âˆ˜â‚— f' i j h = f'' i j h âˆ˜â‚— gâ‚‚ i
x : DirectLimit G f
âŠ¢ IsEmpty Î¹ â†’ ?m.223200","lemma map_comp [IsDirected Î¹ (Â· â‰¤ Â·)]
    (gâ‚ : (i : Î¹) â†’ G i â†’â‚—[R] G' i) (gâ‚‚ : (i : Î¹) â†’ G' i â†’â‚—[R] G'' i)
    (hgâ‚ : âˆ€ i j h, gâ‚ j âˆ˜â‚— f i j h = f' i j h âˆ˜â‚— gâ‚ i)
    (hgâ‚‚ : âˆ€ i j h, gâ‚‚ j âˆ˜â‚— f' i j h = f'' i j h âˆ˜â‚— gâ‚‚ i) :
    (map gâ‚‚ hgâ‚‚ âˆ˜â‚— map gâ‚ hgâ‚ :
      DirectLimit G f â†’â‚—[R] DirectLimit G'' f'') =
    (map (fun i â†¦ gâ‚‚ i âˆ˜â‚— gâ‚ i) fun i j h â†¦ by
        rw [LinearMap.comp_assoc, hgâ‚ i, â† LinearMap.comp_assoc, hgâ‚‚ i, LinearMap.comp_assoc] :
      DirectLimit G f â†’â‚—[R] DirectLimit G'' f'') ",":=
  DFunLike.ext _ _ fun x â†¦ (isEmpty_or_nonempty Î¹).elim (fun _ â†¦ Subsingleton.elim _ _) fun _ â†¦
    x.induction_on fun i g â†¦ by simp"
Mathlib/MeasureTheory/Integral/Bochner.lean,MeasureTheory.ae_eq_trim_of_stronglyMeasurable,ae_eq_trim_of_stronglyMeasurable,5c3b19457914190f5f82a4845a908a6fa667ed79,":= by
  rwa [EventuallyEq, @ae_iff _ m, trim_measurableSet_eq hm _]
  exact (hf.measurableSet_eq_fun hg).compl","warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
warning:  @integral does not have a doc string
error:  application type mismatch
  @ae_iff ?m.1321447 m
argument
  m
has type
  MeasurableSpace Î² : Type u_7
but is expected to have type
  Type ?u.1321445 : Type (?u.1321445 + 1)","theorem ae_eq_trim_of_stronglyMeasurable [TopologicalSpace Î³] [MetrizableSpace Î³] (hm : m â‰¤ m0)
    {f g : Î² â†’ Î³} (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g)
    (hfg : f =áµ[Î¼] g) : f =áµ[Î¼.trim hm] g ",":= by
  rwa [EventuallyEq, ae_iff, trim_measurableSet_eq hm]
  exact (hf.measurableSet_eq_fun hg).compl"
Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean,MeasureTheory.FinStronglyMeasurable.exists_set_sigmaFinite,exists_set_sigmaFinite,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rcases hf with âŸ¨fs, hT_lt_top, h_approxâŸ©
  let T n := support (fs n)
  have hT_meas : âˆ€ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)
  let t := â‹ƒ n, T n
  refine' âŸ¨t, MeasurableSet.iUnion hT_meas, _, _âŸ©
  Â· have h_fs_zero : âˆ€ n, âˆ€ x âˆˆ tá¶œ, fs n x = 0 := by
      intro n x hxt
      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt
      simpa [T] using hxt n
    refine' fun x hxt => tendsto_nhds_unique (h_approx x) _
    rw [funext fun n => h_fs_zero n x hxt]
    exact tendsto_const_nhds
  Â· refine' âŸ¨âŸ¨âŸ¨fun n => tá¶œ âˆª T n, fun _ => trivial, fun n => _, _âŸ©âŸ©âŸ©
    Â· rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,
        Set.compl_inter_self t, Set.empty_union]
      exact (measure_mono (Set.inter_subset_left _ _)).trans_lt (hT_lt_top n)
    Â· rw [â† Set.union_iUnion tá¶œ T]
      exact Set.compl_union_self _","error:  function expected at
  inter_subset_left ?m.176273
term has type
  ?m.176272 âˆˆ ?m.176270","theorem exists_set_sigmaFinite [Zero Î²] [TopologicalSpace Î²] [T2Space Î²]
    (hf : FinStronglyMeasurable f Î¼) :
    âˆƒ t, MeasurableSet t âˆ§ (âˆ€ x âˆˆ tá¶œ, f x = 0) âˆ§ SigmaFinite (Î¼.restrict t) ",":= by
  rcases hf with âŸ¨fs, hT_lt_top, h_approxâŸ©
  let T n := support (fs n)
  have hT_meas : âˆ€ n, MeasurableSet (T n) := fun n => SimpleFunc.measurableSet_support (fs n)
  let t := â‹ƒ n, T n
  refine âŸ¨t, MeasurableSet.iUnion hT_meas, ?_, ?_âŸ©
  Â· have h_fs_zero : âˆ€ n, âˆ€ x âˆˆ tá¶œ, fs n x = 0 := by
      intro n x hxt
      rw [Set.mem_compl_iff, Set.mem_iUnion, not_exists] at hxt
      simpa [T] using hxt n
    refine fun x hxt => tendsto_nhds_unique (h_approx x) ?_
    rw [funext fun n => h_fs_zero n x hxt]
    exact tendsto_const_nhds
  Â· refine âŸ¨âŸ¨âŸ¨fun n => tá¶œ âˆª T n, fun _ => trivial, fun n => ?_, ?_âŸ©âŸ©âŸ©
    Â· rw [Measure.restrict_apply' (MeasurableSet.iUnion hT_meas), Set.union_inter_distrib_right,
        Set.compl_inter_self t, Set.empty_union]
      exact (measure_mono Set.inter_subset_left).trans_lt (hT_lt_top n)
    Â· rw [â† Set.union_iUnion tá¶œ T]
      exact Set.compl_union_self _"
Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean,PrimeSpectrum.vanishingIdeal_irreducibleComponents,vanishingIdeal_irreducibleComponents,77a1d382025ec4a716e07b7aa5643b2094e305c8,":= by
  rw [irreducibleComponents_eq_maximals_closed, minimalPrimes_eq_minimals, â† minimals_swap,
    â† PrimeSpectrum.vanishingIdeal_isIrreducibleClosed, image_minimals_of_rel_iff_rel]
  exact fun s t hs _ â†¦ vanishingIdeal_anti_mono_iff hs.2","error:  unknown constant 'PrimeSpectrum.vanishingIdeal_isIrreducibleClosed'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.154218
R : Type u
S : Type v
instâœ : CommSemiring R
âŠ¢ vanishingIdeal '' minimals (Function.swap fun x x_1 â†¦ x â‰¤ x_1) {s | IsClosed s âˆ§ IsIrreducible s} =
    minimals (fun x x_1 â†¦ x â‰¤ x_1) (setOf Ideal.IsPrime)","lemma vanishingIdeal_irreducibleComponents :
    vanishingIdeal '' (irreducibleComponents <| PrimeSpectrum R) =
    minimalPrimes R ",":= by
  rw [irreducibleComponents_eq_maximals_closed, minimalPrimes_eq_minimals, â† minimals_swap,
    â† PrimeSpectrum.vanishingIdeal_isClosed_isIrreducible, image_minimals_of_rel_iff_rel]
  exact fun s t hs _ â†¦ vanishingIdeal_anti_mono_iff hs.1"
Mathlib/Combinatorics/SimpleGraph/Triangle/Counting.lean,SimpleGraph.triangle_counting,triangle_counting,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  classical
  have hâ‚ : (badVertices G Îµ s t).card â‰¤ s.card * Îµ := G.card_badVertices_le dst hst
  have hâ‚‚ : (badVertices G Îµ s u).card â‰¤ s.card * Îµ := G.card_badVertices_le dsu usu
  let X' := s \ (badVertices G Îµ s t âˆª badVertices G Îµ s u)
  have : X'.biUnion _ âŠ† (s Ã—Ë¢ t Ã—Ë¢ u).filter fun (a, b, c) â†¦ G.Adj a b âˆ§ G.Adj a c âˆ§ G.Adj b c := by
    apply triangle_split_helper
  refine le_trans ?_ (Nat.cast_le.2 $ card_le_card this)
  rw [card_biUnion, Nat.cast_sum]
  Â· apply le_trans _ (card_nsmul_le_sum X' _ _ $ G.good_vertices_triangle_card dst dsu dtu utu)
    rw [nsmul_eq_mul]
    have := hst.pos.le
    suffices hX' : (1 - 2 * Îµ) * s.card â‰¤ X'.card by
      exact Eq.trans_le (by ring) (mul_le_mul_of_nonneg_right hX' $ by positivity)
    have i : badVertices G Îµ s t âˆª badVertices G Îµ s u âŠ† s :=
      union_subset (filter_subset _ _) (filter_subset _ _)
    rw [sub_mul, one_mul, card_sdiff i, Nat.cast_sub (card_le_card i), sub_le_sub_iff_left,
      mul_assoc, mul_comm Îµ, two_mul]
    refine (Nat.cast_le.2 $ card_union_le _ _).trans ?_
    rw [Nat.cast_add]
    exact add_le_add hâ‚ hâ‚‚
  rintro a ha b hy t
  rw [disjoint_left]
  simp only [Prod.forall, mem_image, not_exists, exists_prop, mem_filter, Prod.mk.inj_iff,
    exists_imp, and_imp, not_and, mem_product, or_assoc]
  aesop","error:  don't know how to synthesize placeholder for argument 't'
context:
Î± : Type u_1
G G' : SimpleGraph Î±
instâœ : DecidableRel G.Adj
Îµ : â„
s t u : Finset Î±
dst : 2 * Îµ â‰¤ â†‘(G.edgeDensity s t)
hst : G.IsUniform Îµ s t
dsu : 2 * Îµ â‰¤ â†‘(G.edgeDensity s u)
usu : G.IsUniform Îµ s u
dtu : 2 * Îµ â‰¤ â†‘(G.edgeDensity t u)
utu : G.IsUniform Îµ t u
hâ‚ : â†‘(SimpleGraph.badVertices G Îµ s t).card â‰¤ â†‘s.card * Îµ
hâ‚‚ : â†‘(SimpleGraph.badVertices G Îµ s u).card â‰¤ â†‘s.card * Îµ
X' : Finset Î± := s \ (SimpleGraph.badVertices G Îµ s t âˆª SimpleGraph.badVertices G Îµ s u)
âŠ¢ Î± â†’ Finset (Î± Ã— Î± Ã— Î±)
error:  unsolved goals
Î± : Type u_1
G G' : SimpleGraph Î±
instâœ : DecidableRel G.Adj
Îµ : â„
s t u : Finset Î±
dst : 2 * Îµ â‰¤ â†‘(G.edgeDensity s t)
hst : G.IsUniform Îµ s t
dsu : 2 * Îµ â‰¤ â†‘(G.edgeDensity s u)
usu : G.IsUniform Îµ s u
dtu : 2 * Îµ â‰¤ â†‘(G.edgeDensity t u)
utu : G.IsUniform Îµ t u
hâ‚ : â†‘(SimpleGraph.badVertices G Îµ s t).card â‰¤ â†‘s.card * Îµ
hâ‚‚ : â†‘(SimpleGraph.badVertices G Îµ s u).card â‰¤ â†‘s.card * Îµ
X' : Finset Î± := s \ (SimpleGraph.badVertices G Îµ s t âˆª SimpleGraph.badVertices G Îµ s u)
âŠ¢ (1 - 2 * Îµ) * Îµ ^ 3 * â†‘s.card * â†‘t.card * â†‘u.card â‰¤
    â†‘(filter
          (fun x â†¦
            match x with
            | (a, b, c) => G.Adj a b âˆ§ G.Adj a c âˆ§ G.Adj b c)
          (s Ã—Ë¢ t Ã—Ë¢ u)).card","lemma triangle_counting'
    (dst : 2 * Îµ â‰¤ G.edgeDensity s t) (hst : G.IsUniform Îµ s t)
    (dsu : 2 * Îµ â‰¤ G.edgeDensity s u) (usu : G.IsUniform Îµ s u)
    (dtu : 2 * Îµ â‰¤ G.edgeDensity t u) (utu : G.IsUniform Îµ t u) :
    (1 - 2 * Îµ) * Îµ ^ 3 * s.card * t.card * u.card â‰¤
      ((s Ã—Ë¢ t Ã—Ë¢ u).filter fun (a, b, c) â†¦ G.Adj a b âˆ§ G.Adj a c âˆ§ G.Adj b c).card ",":= by
  classical
  have hâ‚ : (badVertices G Îµ s t).card â‰¤ s.card * Îµ := G.card_badVertices_le dst hst
  have hâ‚‚ : (badVertices G Îµ s u).card â‰¤ s.card * Îµ := G.card_badVertices_le dsu usu
  let X' := s \ (badVertices G Îµ s t âˆª badVertices G Îµ s u)
  have : X'.biUnion _ âŠ† (s Ã—Ë¢ t Ã—Ë¢ u).filter fun (a, b, c) â†¦ G.Adj a b âˆ§ G.Adj a c âˆ§ G.Adj b c :=
    triangle_split_helper _
  refine le_trans ?_ (Nat.cast_le.2 $ card_le_card this)
  rw [card_biUnion, Nat.cast_sum]
  Â· apply le_trans _ (card_nsmul_le_sum X' _ _ $ G.good_vertices_triangle_card dst dsu dtu utu)
    rw [nsmul_eq_mul]
    have := hst.pos.le
    suffices hX' : (1 - 2 * Îµ) * s.card â‰¤ X'.card by
      exact Eq.trans_le (by ring) (mul_le_mul_of_nonneg_right hX' $ by positivity)
    have i : badVertices G Îµ s t âˆª badVertices G Îµ s u âŠ† s :=
      union_subset (filter_subset _ _) (filter_subset _ _)
    rw [sub_mul, one_mul, card_sdiff i, Nat.cast_sub (card_le_card i), sub_le_sub_iff_left,
      mul_assoc, mul_comm Îµ, two_mul]
    refine (Nat.cast_le.2 $ card_union_le _ _).trans ?_
    rw [Nat.cast_add]
    exact add_le_add hâ‚ hâ‚‚
  rintro a _ b _ t
  rw [disjoint_left]
  simp only [Prod.forall, mem_image, not_exists, exists_prop, mem_filter, Prod.mk.inj_iff,
    exists_imp, and_imp, not_and, mem_product, or_assoc]
  aesop"
Mathlib/LinearAlgebra/Matrix/PosDef.lean,Matrix.PosSemidef.eq_of_sq_eq_sq,eq_of_sq_eq_sq,cca63e4bc109a0e28a02e4dcccaee621aa9d3a77,":= by
  by_contra h_ne
  let âŸ¨v, t, ht, hv, hv'âŸ© := (hA.1.sub hB.1).exists_eigenvector_of_ne_zero (sub_ne_zero.mpr h_ne)
  have h_sum : 0 = t * (star v â¬áµ¥ A *áµ¥ v + star v â¬áµ¥ B *áµ¥ v)
  Â· calc
      0 = star v â¬áµ¥ (A ^ 2 - B ^ 2) *áµ¥ v := by rw [hAB, sub_self, zero_mulVec, dotProduct_zero]
      _ = star v â¬áµ¥ A *áµ¥ (A - B) *áµ¥ v + star v â¬áµ¥ (A - B) *áµ¥ B *áµ¥ v := by
        rw [mulVec_mulVec, mulVec_mulVec, â† dotProduct_add, â† add_mulVec, mul_sub, sub_mul,
          add_sub, sub_add_cancel, pow_two, pow_two]
      _ = t * (star v â¬áµ¥ A *áµ¥ v) + (star v) áµ¥* (A - B)á´´ â¬áµ¥ B *áµ¥ v := by
        rw [hv', mulVec_smul, dotProduct_smul, IsROrC.real_smul_eq_coe_mul,
          dotProduct_mulVec _ (A - B), hA.1.sub hB.1]
      _ = t * (star v â¬áµ¥ A *áµ¥ v + star v â¬áµ¥ B *áµ¥ v) := by
        simp_rw [â† star_mulVec, hv', mul_add, â† IsROrC.real_smul_eq_coe_mul, â† smul_dotProduct]
        congr 2 with i
        simp only [Pi.star_apply, Pi.smul_apply, IsROrC.real_smul_eq_coe_mul, star_mul',
          IsROrC.star_def, IsROrC.conj_ofReal]
  replace h_sum : star v â¬áµ¥ A *áµ¥ v + star v â¬áµ¥ B *áµ¥ v = 0
  Â· rw [eq_comm, â† mul_zero (t : ğ•œ)] at h_sum
    exact mul_left_cancelâ‚€ (IsROrC.ofReal_ne_zero.mpr ht) h_sum
  have h_van : star v â¬áµ¥ A *áµ¥ v = 0 âˆ§ star v â¬áµ¥ B *áµ¥ v = 0
  Â· refine âŸ¨le_antisymm ?_ (hA.2 v), le_antisymm ?_ (hB.2 v)âŸ©
    Â· rw [add_comm, add_eq_zero_iff_eq_neg] at h_sum
      simpa only [h_sum, neg_nonneg] using hB.2 v
    Â· simpa only [add_eq_zero_iff_eq_neg.mp h_sum, neg_nonneg] using hA.2 v
  have aux : star v â¬áµ¥ (A - B) *áµ¥ v = 0
  Â· rw [sub_mulVec, dotProduct_sub, h_van.1, h_van.2, sub_zero]
  rw [hv', dotProduct_smul, IsROrC.real_smul_eq_coe_mul, â† mul_zero â†‘t] at aux
  exact hv <| Matrix.dotProduct_star_self_eq_zero.mp <| mul_left_cancelâ‚€
    (IsROrC.ofReal_ne_zero.mpr ht) aux","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
m : Type u_1
n : Type u_2
R : Type u_3
ğ•œ : Type u_4
instâœâ· : Fintype m
instâœâ¶ : Fintype n
instâœâµ : CommRing R
instâœâ´ : PartialOrder R
instâœÂ³ : StarRing R
instâœÂ² : StarOrderedRing R
instâœÂ¹ : RCLike ğ•œ
instâœ : DecidableEq n
A : Matrix n n ğ•œ
hA : A.PosSemidef
B : Matrix n n ğ•œ
hB : B.PosSemidef
hAB : A ^ 2 = B ^ 2
h_ne : Â¬A = B
v : n â†’ ğ•œ
t : â„
ht : t â‰  0
hv : v â‰  0
hv' : (A - B) *áµ¥ v = t â€¢ v
h_sum : 0 = â†‘t * (star v â¬áµ¥ A *áµ¥ v + star v â¬áµ¥ B *áµ¥ v)
âŠ¢ False",lemma eq_of_sq_eq_sq {B : Matrix n n ğ•œ} (hB : PosSemidef B) (hAB : A ^ 2 = B ^ 2) : A = B ,":= by
  by_contra h_ne
  let âŸ¨v, t, ht, hv, hv'âŸ© := (hA.1.sub hB.1).exists_eigenvector_of_ne_zero (sub_ne_zero.mpr h_ne)
  have h_sum : 0 = t * (star v â¬áµ¥ A *áµ¥ v + star v â¬áµ¥ B *áµ¥ v) := calc
    0 = star v â¬áµ¥ (A ^ 2 - B ^ 2) *áµ¥ v := by rw [hAB, sub_self, zero_mulVec, dotProduct_zero]
    _ = star v â¬áµ¥ A *áµ¥ (A - B) *áµ¥ v + star v â¬áµ¥ (A - B) *áµ¥ B *áµ¥ v := by
      rw [mulVec_mulVec, mulVec_mulVec, â† dotProduct_add, â† add_mulVec, mul_sub, sub_mul,
        add_sub, sub_add_cancel, pow_two, pow_two]
    _ = t * (star v â¬áµ¥ A *áµ¥ v) + (star v) áµ¥* (A - B)á´´ â¬áµ¥ B *áµ¥ v := by
      rw [hv', mulVec_smul, dotProduct_smul, RCLike.real_smul_eq_coe_mul,
        dotProduct_mulVec _ (A - B), hA.1.sub hB.1]
    _ = t * (star v â¬áµ¥ A *áµ¥ v + star v â¬áµ¥ B *áµ¥ v) := by
      simp_rw [â† star_mulVec, hv', mul_add, â† RCLike.real_smul_eq_coe_mul, â† smul_dotProduct]
      congr 2 with i
      simp only [Pi.star_apply, Pi.smul_apply, RCLike.real_smul_eq_coe_mul, star_mul',
        RCLike.star_def, RCLike.conj_ofReal]
  replace h_sum : star v â¬áµ¥ A *áµ¥ v + star v â¬áµ¥ B *áµ¥ v = 0 := by
    rw [eq_comm, â† mul_zero (t : ğ•œ)] at h_sum
    exact mul_left_cancelâ‚€ (RCLike.ofReal_ne_zero.mpr ht) h_sum
  have h_van : star v â¬áµ¥ A *áµ¥ v = 0 âˆ§ star v â¬áµ¥ B *áµ¥ v = 0 := by
    refine âŸ¨le_antisymm ?_ (hA.2 v), le_antisymm ?_ (hB.2 v)âŸ©
    Â· rw [add_comm, add_eq_zero_iff_eq_neg] at h_sum
      simpa only [h_sum, neg_nonneg] using hB.2 v
    Â· simpa only [add_eq_zero_iff_eq_neg.mp h_sum, neg_nonneg] using hA.2 v
  have aux : star v â¬áµ¥ (A - B) *áµ¥ v = 0 := by
    rw [sub_mulVec, dotProduct_sub, h_van.1, h_van.2, sub_zero]
  rw [hv', dotProduct_smul, RCLike.real_smul_eq_coe_mul, â† mul_zero â†‘t] at aux
  exact hv <| Matrix.dotProduct_star_self_eq_zero.mp <| mul_left_cancelâ‚€
    (RCLike.ofReal_ne_zero.mpr ht) aux"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine' Or.inl âŸ¨hs, _âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine' mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, _âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine'
        mem_shadow_iff.2
          âŸ¨(t âŠ” u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, _, _âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine' âŸ¨hus, hsv.symm, âŸ¨x, _, _âŸ©, _âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right _ _, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) _
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  function expected at
  subset_union_right ?m.92173
term has type
  ?m.92172 âˆˆ ?m.92170 âˆª ?m.92171
error:  function expected at
  subset_union_left ?m.92639
term has type
  ?m.92638 âˆˆ ?m.92636 âˆª ?m.92637
error:  function expected at
  subset_union_right ?m.94506
term has type
  ?m.94505 âˆˆ ?m.94503 âˆª ?m.94504
error:  function expected at
  subset_union_left ?m.97300
term has type
  ?m.97299 âˆˆ ?m.97297 âˆª ?m.97298
error:  ambiguous, possible interpretations 
  _root_.not_imp : Â¬(?m.97719 â†’ ?m.97720) â†” ?m.97719 âˆ§ Â¬?m.97720
  
  Classical.not_imp : Â¬(?m.97721 â†’ ?m.97722) â†” ?m.97721 âˆ§ Â¬?m.97722
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.97724
case neg
Î± : Type u_1
instâœ : DecidableEq Î±
ğ’œ : Finset (Finset Î±)
uâœ vâœ a : Finset Î±
r : â„•
u v : Finset Î±
huv : âˆ€ x âˆˆ u, âˆƒ y âˆˆ v, IsCompressed (u.erase x) (v.erase y) ğ’œ
ğ’œ' : Finset (Finset Î±) := ğ“’ u v ğ’œ
s : Finset Î±
hsğ’œ' : s âˆˆ âˆ‚ ğ’œ'
hsğ’œ : s âˆ‰ âˆ‚ ğ’œ
m : âˆ€ y âˆ‰ s, insert y s âˆ‰ ğ’œ
x : Î±
leftâœ : x âˆ‰ s
rightâœ : insert x s âˆˆ ğ’œ'
husâœ : u âŠ† insert x s
hvs : Disjoint v (insert x s)
thisâœÂ² : (insert x s âˆª v) \ u âˆˆ ğ’œ
hsv : Disjoint s v
hvu : Disjoint v u
hxv : x âˆ‰ v
thisâœÂ¹ : v \ u = v
thisâœ : x âˆ‰ u
hus : u âŠ† s
w : Î±
hwB : Â¬(w âˆˆ s âˆª v âˆ§ w âˆ‰ u)
hwğ’œ' : insert w ((s âˆª v) \ u) âˆˆ ğ’œ'
this : v âŠ† insert w ((s âˆª v) \ u)
hwu : w âˆ‰ u
âŠ¢ False","theorem shadow_compression_subset_compression_shadow (u v : Finset Î±)
    (huv : âˆ€ x âˆˆ u, âˆƒ y âˆˆ v, IsCompressed (u.erase x) (v.erase y) ğ’œ) :
    âˆ‚ (ğ“’ u v ğ’œ) âŠ† ğ“’ u v (âˆ‚ ğ’œ) ",":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine Or.inl âŸ¨hs, ?_âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, ?_âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine mem_shadow_iff.2
        âŸ¨(t âŠ” u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine âŸ¨hus, hsv.symm, âŸ¨x, ?_, ?_âŸ©, ?_âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) ?_
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]"
Mathlib/RingTheory/DedekindDomain/AdicValuation.lean,IsDedekindDomain.HeightOneSpectrum.int_valuation_lt_one_iff_dvd,int_valuation_lt_one_iff_dvd,04cf8c4630518d88c67bf9ba4d4db872ea86f7e2,":= by
  rw [intValuationDef]
  split_ifs with hr
  Â· simp [hr]
  Â· rw [â† WithZero.coe_one, â† ofAdd_zero, WithZero.coe_lt_coe, ofAdd_lt, neg_lt_zero, â†
      Int.ofNat_zero, Int.ofNat_lt, zero_lt_iff]
    have h : (Ideal.span {r} : Ideal R) â‰  0 := by
      rw [Ne.def, Ideal.zero_eq_bot, Ideal.span_singleton_eq_bot]
      exact hr
    apply Associates.count_ne_zero_iff_dvd h (by apply v.irreducible)","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.17686 â†’ ?m.17686 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.17688
R : Type u_1
instâœâ´ : CommRing R
instâœÂ³ : IsDedekindDomain R
K : Type u_2
instâœÂ² : Field K
instâœÂ¹ : Algebra R K
instâœ : IsFractionRing R K
v : HeightOneSpectrum R
r : R
hr : Â¬r = 0
âŠ¢ Ideal.span {r} â‰  0","theorem int_valuation_lt_one_iff_dvd (r : R) :
    v.intValuationDef r < 1 â†” v.asIdeal âˆ£ Ideal.span {r} ",":= by
  rw [intValuationDef]
  split_ifs with hr
  Â· simp [hr]
  Â· rw [â† WithZero.coe_one, â† ofAdd_zero, WithZero.coe_lt_coe, ofAdd_lt, neg_lt_zero, â†
      Int.ofNat_zero, Int.ofNat_lt, zero_lt_iff]
    have h : (Ideal.span {r} : Ideal R) â‰  0 := by
      rw [Ne, Ideal.zero_eq_bot, Ideal.span_singleton_eq_bot]
      exact hr
    apply Associates.count_ne_zero_iff_dvd h (by apply v.irreducible)"
Mathlib/FieldTheory/Finite/Basic.lean,FiniteField.card,card,89feeaaf464cdb346baab6c7adb1bec331fe789a,:= sorry,"warning:  declaration uses 'sorry'
error:  application type mismatch
  exists_root_sum_quadratic g
argument
  g
has type
  (ZMod p)[X] : Type
but is expected to have type
  ?m.131368.degree = 2 : Prop
error:  expected type must not contain free or meta variables
  0 < ?m.131833","theorem card_image_polynomial_eval [DecidableEq R] [Fintype R] {p : R[X]} (hp : 0 < p.degree) :
    Fintype.card R â‰¤ natDegree p * (univ.image fun x => eval x p).card ",":=
  Finset.card_le_mul_card_image _ _ (fun a _ =>
    calc
      _ = (p - C a).roots.toFinset.card :=
        congr_arg card (by simp [Finset.ext_iff, â† mem_roots_sub_C hp])
      _ â‰¤ Multiset.card (p - C a).roots := Multiset.toFinset_card_le _
      _ â‰¤ _ := card_roots_sub_C' hp)"
Mathlib/Order/Interval/Finset/Nat.lean,Nat.Ico_zero_eq_range,Ico_zero_eq_range,596865180ecc63dcd1d95809202e31027ac3ae38,":= by rw [â† bot_eq_zero, â† Iio_eq_Ico, Iio_eq_range]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  0
a b c : â„•
âŠ¢ Ico 0 = range",theorem Ico_zero_eq_range : Ico 0 = range ,":= by rw [â† Nat.bot_eq_zero, â† Iio_eq_Ico, Iio_eq_range]"
Mathlib/Computability/Primrec.lean,Nat.Primrec.add,add,dc0b2fb410ce57ee8ea5b9ce5b357ce030465e7a,":=
  (prec .id ((Primrec.succ.comp right).comp right)).of_eq fun p => by
    simp; induction p.unpair.2 <;> simp [*, â† Nat.add_assoc']","error:  unknown constant 'Nat.add_assoc''
error:  unknown constant 'Nat.add_assoc''
error:  unsolved goals
case succ
p nâœ : â„•
aâœ : Nat.rec (unpair p).1 (fun y IH â†¦ IH + 1) nâœ = (unpair p).1 + nâœ
âŠ¢ (unpair p).1 + nâœ + 1 = (unpair p).1 + (nâœ + 1)",theorem add : Nat.Primrec (unpaired (Â· + Â·)) ,":=
  (prec .id ((Primrec.succ.comp right).comp right)).of_eq fun p => by
    simp; induction p.unpair.2 <;> simp [*, Nat.add_assoc]"
Mathlib/LinearAlgebra/QuadraticForm/Basic.lean,QuadraticForm.polar_zero_left,polar_zero_left,18f1e3ee387a3d040ba88fad8882f979755c163f,":= by
  simp only [polar, zero_add, QuadraticMap.map_zero, sub_zero, sub_self]","error:  unknown identifier 'QuadraticMap.map_zero'
error:  unsolved goals
S : Type u_1
T : Type u_2
R : Type u_3
M : Type u_4
N : Type u_5
instâœÂ² : CommRing R
instâœÂ¹ : AddCommGroup M
instâœ : Module R M
Q : QuadraticForm R M
y : M
âŠ¢ Q y - Q 0 - Q y = 0",theorem polar_zero_left (y : M) : polar Q 0 y = 0 ,":= by
  simp only [polar, zero_add, QuadraticForm.map_zero, sub_zero, sub_self]"
Mathlib/NumberTheory/Modular.lean,ModularGroup.tendsto_normSq_coprime_pair,tendsto_normSq_coprime_pair,079113af31d690223d4821fd5f7a58291d2347e7,":= by
  letI : Module â„ (Fin 2 â†’ â„) := NormedSpace.toModule
  let Ï€â‚€ : (Fin 2 â†’ â„) â†’â‚—[â„] â„ := LinearMap.proj 0
  let Ï€â‚ : (Fin 2 â†’ â„) â†’â‚—[â„] â„ := LinearMap.proj 1
  let f : (Fin 2 â†’ â„) â†’â‚—[â„] â„‚ := Ï€â‚€.smulRight (z : â„‚) + Ï€â‚.smulRight 1
  have f_def : â‡‘f = fun p : Fin 2 â†’ â„ => (p 0 : â„‚) * â†‘z + p 1 := by
    ext1
    dsimp only [Ï€â‚€, Ï€â‚, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,
      LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 â†’ â„¤ => normSq ((p 0 : â„‚) * â†‘z + â†‘(p 1))) =
      normSq âˆ˜ f âˆ˜ fun p : Fin 2 â†’ â„¤ => ((â†‘) : â„¤ â†’ â„) âˆ˜ p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_int_cast, ofReal_int_cast]
  rw [this]
  have hf : LinearMap.ker f = âŠ¥ := by
    let g : â„‚ â†’â‚—[â„] Fin 2 â†’ â„ :=
      LinearMap.pi ![imLm, imLm.comp ((z : â„‚) â€¢ ((conjAe : â„‚ â†’â‚[â„] â„‚) : â„‚ â†’â‚—[â„] â„‚))]
    suffices ((z : â„‚).imâ»Â¹ â€¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : â„‚).im â‰  0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    Â· show (z : â„‚).imâ»Â¹ * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    Â· show (z : â„‚).imâ»Â¹ * ((z : â„‚) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, â† ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mulâ‚€ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have hâ‚‚ : Tendsto (fun p : Fin 2 â†’ â„¤ => ((â†‘) : â„¤ â†’ â„) âˆ˜ p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprodáµ¢ fun _ => Int.tendsto_coe_cofinite
    Â· rw [coprodáµ¢_cofinite]
    Â· rw [coprodáµ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp hâ‚‚)","error:  unknown identifier 'ofReal_int_cast'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.22323
case h
g : SL(2, â„¤)
z : â„
this : Module â„ (Fin 2 â†’ â„) := NormedSpace.toModule
Ï€â‚€ : (Fin 2 â†’ â„) â†’â‚—[â„] â„ := LinearMap.proj 0
Ï€â‚ : (Fin 2 â†’ â„) â†’â‚—[â„] â„ := LinearMap.proj 1
f : (Fin 2 â†’ â„) â†’â‚—[â„] â„‚ := Ï€â‚€.smulRight â†‘z + Ï€â‚.smulRight 1
f_def : â‡‘f = fun p â†¦ â†‘(p 0) * â†‘z + â†‘(p 1)
xâœ : Fin 2 â†’ â„¤
âŠ¢ normSq (â†‘(xâœ 0) * â†‘z + â†‘(xâœ 1)) = normSq (â†‘â†‘(xâœ 0) * â†‘z + â†‘â†‘(xâœ 1))
warning:  fd does not have a doc string
warning:  fdo does not have a doc string","theorem tendsto_normSq_coprime_pair :
    Filter.Tendsto (fun p : Fin 2 â†’ â„¤ => normSq ((p 0 : â„‚) * z + p 1)) cofinite atTop ",":= by
  letI : Module â„ (Fin 2 â†’ â„) := NormedSpace.toModule
  let Ï€â‚€ : (Fin 2 â†’ â„) â†’â‚—[â„] â„ := LinearMap.proj 0
  let Ï€â‚ : (Fin 2 â†’ â„) â†’â‚—[â„] â„ := LinearMap.proj 1
  let f : (Fin 2 â†’ â„) â†’â‚—[â„] â„‚ := Ï€â‚€.smulRight (z : â„‚) + Ï€â‚.smulRight 1
  have f_def : â‡‘f = fun p : Fin 2 â†’ â„ => (p 0 : â„‚) * â†‘z + p 1 := by
    ext1
    dsimp only [Ï€â‚€, Ï€â‚, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,
      LinearMap.add_apply]
    rw [mul_one]
  have :
    (fun p : Fin 2 â†’ â„¤ => normSq ((p 0 : â„‚) * â†‘z + â†‘(p 1))) =
      normSq âˆ˜ f âˆ˜ fun p : Fin 2 â†’ â„¤ => ((â†‘) : â„¤ â†’ â„) âˆ˜ p := by
    ext1
    rw [f_def]
    dsimp only [Function.comp_def]
    rw [ofReal_intCast, ofReal_intCast]
  rw [this]
  have hf : LinearMap.ker f = âŠ¥ := by
    let g : â„‚ â†’â‚—[â„] Fin 2 â†’ â„ :=
      LinearMap.pi ![imLm, imLm.comp ((z : â„‚) â€¢ ((conjAe : â„‚ â†’â‚[â„] â„‚) : â„‚ â†’â‚—[â„] â„‚))]
    suffices ((z : â„‚).imâ»Â¹ â€¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this
    apply LinearMap.ext
    intro c
    have hz : (z : â„‚).im â‰  0 := z.2.ne'
    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]
    ext i
    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]
    fin_cases i
    Â· show (z : â„‚).imâ»Â¹ * (f c).im = c 0
      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel hz,
        mul_one]
    Â· show (z : â„‚).imâ»Â¹ * ((z : â„‚) * conj (f c)).im = c 1
      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,
        conj_ofReal, â† ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mulâ‚€ hz]
      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]
  have hf' : ClosedEmbedding f := f.closedEmbedding_of_injective hf
  have hâ‚‚ : Tendsto (fun p : Fin 2 â†’ â„¤ => ((â†‘) : â„¤ â†’ â„) âˆ˜ p) cofinite (cocompact _) := by
    convert Tendsto.pi_map_coprodáµ¢ fun _ => Int.tendsto_coe_cofinite
    Â· rw [coprodáµ¢_cofinite]
    Â· rw [coprodáµ¢_cocompact]
  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp hâ‚‚)"
Mathlib/Order/SupIndep.lean,CompleteLattice.SetIndependent.pairwiseDisjoint,SetIndependent.pairwiseDisjoint,5d7cd872571356e85fab5268777569443417341b,":= fun _ hx y hy h =>
  disjoint_supâ‚›_right (hs hx) ((mem_diff y).mpr âŸ¨hy, h.symmâŸ©)
  complete_lattice.set_independent.pairwise_disjoint CompleteLattice.SetIndependent.pairwiseDisjoint","error:  unknown identifier 'disjoint_supâ‚›_right'
error:  invalid field notation, function 'CompleteLattice.SetIndependent.pairwiseDisjoint' does not have argument with type (CompleteLattice.SetIndependent ...) that can be used, it must be explicit or implicit with a unique name
error:  application type mismatch
  Iff.intro SetIndependent.pairwiseDisjoint
argument
  SetIndependent.pairwiseDisjoint
has type
  ?m.89547.PairwiseDisjoint id : Prop
but is expected to have type
  SetIndependent s â†’ s.PairwiseDisjoint id : Prop
warning:  declaration uses 'sorry'",theorem SetIndependent.pairwiseDisjoint : s.PairwiseDisjoint id ,":= fun _ hx y hy h =>
  disjoint_sSup_right (hs hx) ((mem_diff y).mpr âŸ¨hy, h.symmâŸ©)"
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.Î´_comp_Ïƒ_of_gt,Î´_comp_Ïƒ_of_gt,d7f8050468d4e16195b721085d9c4536194abc3e,":= by
  ext âŸ¨k, hkâŸ©
  rcases i with âŸ¨i, hiâŸ©
  rcases j with âŸ¨j, hjâŸ©
  simp? at H hk says simp only [Fin.castSucc_mk, Fin.mk_lt_mk, len_mk] at H hk
  dsimp [Î´, Ïƒ, Fin.predAbove, Fin.succAbove]
  simp only [Fin.lt_iff_val_lt_val, Fin.dite_val, Fin.ite_val, Fin.coe_pred, ge_iff_le,
    Fin.coe_castLT, dite_eq_ite, Fin.coe_castSucc, Fin.val_succ]
  split_ifs
  all_goals try simp <;> linarith
  all_goals cases k <;> simp at * <;> linarith","error:  linarith failed to find a contradiction
case neg.zero.h1.h
n i : â„•
hi : i < n + 2
j : â„•
hj : j < n + 1
H : j < i
hk : 0 < n + 1 + 1
hâœÂ¹ : 0 < i + 1
hâœ : Â¬j < 0
aâœ : 0 < if 0 < i then 0 else 1
âŠ¢ False
failed
error:  linarith failed to find a contradiction
case neg.succ.h1.h
n i : â„•
hi : i < n + 2
j : â„•
hj : j < n + 1
H : j < i
nâœ : â„•
hk : nâœ + 1 < n + 1 + 1
hâœÂ¹ : nâœ + 1 < i + 1
hâœ : Â¬j < nâœ + 1
aâœ : nâœ + 1 < if nâœ + 1 < i then nâœ + 1 else nâœ + 1 + 1
âŠ¢ False
failed
error:  unsolved goals
case neg.zero
n i : â„•
hi : i < n + 2
j : â„•
hj : j < n + 1
H : j < i
hk : 0 < n + 1 + 1
hâœÂ¹ : 0 < i + 1
hâœ : Â¬j < 0
âŠ¢ 0 = if 0 < i then 0 else 1

case neg.succ
n i : â„•
hi : i < n + 2
j : â„•
hj : j < n + 1
H : j < i
nâœ : â„•
hk : nâœ + 1 < n + 1 + 1
hâœÂ¹ : nâœ + 1 < i + 1
hâœ : Â¬j < nâœ + 1
âŠ¢ nâœ + 1 = if nâœ + 1 < i then nâœ + 1 else nâœ + 1 + 1","theorem Î´_comp_Ïƒ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    Î´ i.succ â‰« Ïƒ (Fin.castSucc j) = Ïƒ j â‰« Î´ i ",":= by
  ext k : 3
  dsimp [Î´, Ïƒ]
  rcases le_or_lt k i with (hik | hik)
  Â· rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    Â· rw [Fin.predAbove_of_le_castSucc _ _
      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    Â· rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  Â· rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
      (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]"
Mathlib/Data/Set/Finite.lean,Set.Infinite.preimage',Infinite.preimage',596865180ecc63dcd1d95809202e31027ac3ae38,":=
  (hs.preimage <| inter_subset_right _ _).mono <| preimage_mono <| inter_subset_left _ _","error:  function expected at
  inter_subset_right ?m.97203
term has type
  ?m.97202 âˆˆ ?m.97201
error:  function expected at
  inter_subset_left ?m.97281
term has type
  ?m.97280 âˆˆ ?m.97278",lemma Infinite.preimage' (hs : (s âˆ© range f).Infinite) : (f â»Â¹' s).Infinite ,":=
  (hs.preimage inter_subset_right).mono <| preimage_mono inter_subset_left"
Mathlib/CategoryTheory/Limits/HasLimits.lean,CategoryTheory.Limits.colimit.pre_map',colimit.pre_map',4fe814dcb7f2ef6f136833adb16f41f1aa652c61,":= by
  ext1
  #adaptation_note
  simp_rw [comp_obj, Î¹_pre, colim_obj, colim_map, â† assoc, Î¹_colimMap, whiskerRight_app, assoc,
    comp_obj, Î¹_pre, w]","error:  Adaptation notes must be followed by a /-- comment -/
info:  Try this: #adaptation_note /-- comment -/","theorem colimit.pre_map' [HasColimitsOfShape K C] (F : J â¥¤ C) {Eâ‚ Eâ‚‚ : K â¥¤ J} (Î± : Eâ‚ âŸ¶ Eâ‚‚) :
    colimit.pre F Eâ‚ = colim.map (whiskerRight Î± F) â‰« colimit.pre F Eâ‚‚ ",":= by
  ext1
  simp [â† assoc, assoc]"
Mathlib/MeasureTheory/Constructions/Polish.lean,MeasureTheory.measurablySeparable_range_of_disjoint,measurablySeparable_range_of_disjoint,c541ced9974e0e3226a68554503a14a8e29cf1a5,":= by
  by_contra hfg
  have I : âˆ€ n x y, Â¬MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) â†’
      âˆƒ x' y', x' âˆˆ cylinder x n âˆ§ y' âˆˆ cylinder y n âˆ§
      Â¬MeasurablySeparable (f '' cylinder x' (n + 1)) (g '' cylinder y' (n + 1)) := by
    intro n x y
    contrapose!
    intro H
    rw [â† iUnion_cylinder_update x n, â† iUnion_cylinder_update y n, image_iUnion, image_iUnion]
    refine' MeasurablySeparable.iUnion fun i j => _
    exact H _ _ (update_mem_cylinder _ _ _) (update_mem_cylinder _ _ _)
  let A :=
    { p : â„• Ã— (â„• â†’ â„•) Ã— (â„• â†’ â„•) //
      Â¬MeasurablySeparable (f '' cylinder p.2.1 p.1) (g '' cylinder p.2.2 p.1) }
  have : âˆ€ p : A, âˆƒ q : A,
      q.1.1 = p.1.1 + 1 âˆ§ q.1.2.1 âˆˆ cylinder p.1.2.1 p.1.1 âˆ§ q.1.2.2 âˆˆ cylinder p.1.2.2 p.1.1 := by
    rintro âŸ¨âŸ¨n, x, yâŸ©, hpâŸ©
    rcases I n x y hp with âŸ¨x', y', hx', hy', h'âŸ©
    exact âŸ¨âŸ¨âŸ¨n + 1, x', y'âŸ©, h'âŸ©, rfl, hx', hy'âŸ©
  choose F hFn hFx hFy using this
  let p0 : A := âŸ¨âŸ¨0, fun _ => 0, fun _ => 0âŸ©, by simp [hfg]âŸ©
  let p : â„• â†’ A := fun n => F^[n] p0
  have prec : âˆ€ n, p (n + 1) = F (p n) := fun n => by simp only [iterate_succ', Function.comp]
  have pn_fst : âˆ€ n, (p n).1.1 = n := by
    intro n
    induction' n with n IH
    Â· rfl
    Â· simp only [prec, hFn, IH]
  have Ix : âˆ€ m n, m + 1 â‰¤ n â†’ (p n).1.2.1 m = (p (m + 1)).1.2.1 m := by
    intro m
    apply Nat.le_induction
    Â· rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.fst m = (p n).val.snd.fst m := by
      apply hFx (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  have Iy : âˆ€ m n, m + 1 â‰¤ n â†’ (p n).1.2.2 m = (p (m + 1)).1.2.2 m := by
    intro m
    apply Nat.le_induction
    Â· rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.snd m = (p n).val.snd.snd m := by
      apply hFy (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  set x : â„• â†’ â„• := fun n => (p (n + 1)).1.2.1 n with hx
  set y : â„• â†’ â„• := fun n => (p (n + 1)).1.2.2 n with hy
  have M : âˆ€ n, Â¬MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    intro n
    convert(p n).2 using 3
    Â· rw [pn_fst, â† mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hx]
      exact (Ix i n hi).symm
    Â· rw [pn_fst, â† mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hy]
      exact (Iy i n hi).symm
  obtain âŸ¨u, v, u_open, v_open, xu, yv, huvâŸ© :
    âˆƒ u v : Set Î±, IsOpen u âˆ§ IsOpen v âˆ§ f x âˆˆ u âˆ§ g y âˆˆ v âˆ§ Disjoint u v := by
    apply t2_separation
    exact disjoint_iff_forall_ne.1 h (mem_range_self _) (mem_range_self _)
  letI : MetricSpace (â„• â†’ â„•) := metricSpaceNatNat
  obtain âŸ¨Îµx, Îµxpos, hÎµxâŸ© : âˆƒ (Îµx : â„), Îµx > 0 âˆ§ Metric.ball x Îµx âŠ† f â»Â¹' u := by
    apply Metric.mem_nhds_iff.1
    exact hf.continuousAt.preimage_mem_nhds (u_open.mem_nhds xu)
  obtain âŸ¨Îµy, Îµypos, hÎµyâŸ© : âˆƒ (Îµy : â„), Îµy > 0 âˆ§ Metric.ball y Îµy âŠ† g â»Â¹' v := by
    apply Metric.mem_nhds_iff.1
    exact hg.continuousAt.preimage_mem_nhds (v_open.mem_nhds yv)
  obtain âŸ¨n, hnâŸ© : âˆƒ n : â„•, (1 / 2 : â„) ^ n < min Îµx Îµy :=
    exists_pow_lt_of_lt_one (lt_min Îµxpos Îµypos) (by norm_num)
  have B : MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    refine' âŸ¨u, _, _, u_open.measurableSetâŸ©
    Â· rw [image_subset_iff]
      apply Subset.trans _ hÎµx
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_left _ _))
    Â· refine' Disjoint.mono_left _ huv.symm
      change g '' cylinder y n âŠ† v
      rw [image_subset_iff]
      apply Subset.trans _ hÎµy
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_right _ _))
  exact M n B",error:  simp made no progress,"theorem measurablySeparable_range_of_disjoint [T2Space Î±] [MeasurableSpace Î±]
    [OpensMeasurableSpace Î±] {f g : (â„• â†’ â„•) â†’ Î±} (hf : Continuous f) (hg : Continuous g)
    (h : Disjoint (range f) (range g)) : MeasurablySeparable (range f) (range g) ",":= by
  by_contra hfg
  have I : âˆ€ n x y, Â¬MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) â†’
      âˆƒ x' y', x' âˆˆ cylinder x n âˆ§ y' âˆˆ cylinder y n âˆ§
      Â¬MeasurablySeparable (f '' cylinder x' (n + 1)) (g '' cylinder y' (n + 1)) := by
    intro n x y
    contrapose!
    intro H
    rw [â† iUnion_cylinder_update x n, â† iUnion_cylinder_update y n, image_iUnion, image_iUnion]
    refine MeasurablySeparable.iUnion fun i j => ?_
    exact H _ _ (update_mem_cylinder _ _ _) (update_mem_cylinder _ _ _)
  let A :=
    { p : â„• Ã— (â„• â†’ â„•) Ã— (â„• â†’ â„•) //
      Â¬MeasurablySeparable (f '' cylinder p.2.1 p.1) (g '' cylinder p.2.2 p.1) }
  have : âˆ€ p : A, âˆƒ q : A,
      q.1.1 = p.1.1 + 1 âˆ§ q.1.2.1 âˆˆ cylinder p.1.2.1 p.1.1 âˆ§ q.1.2.2 âˆˆ cylinder p.1.2.2 p.1.1 := by
    rintro âŸ¨âŸ¨n, x, yâŸ©, hpâŸ©
    rcases I n x y hp with âŸ¨x', y', hx', hy', h'âŸ©
    exact âŸ¨âŸ¨âŸ¨n + 1, x', y'âŸ©, h'âŸ©, rfl, hx', hy'âŸ©
  choose F hFn hFx hFy using this
  let p0 : A := âŸ¨âŸ¨0, fun _ => 0, fun _ => 0âŸ©, by simp [hfg]âŸ©
  let p : â„• â†’ A := fun n => F^[n] p0
  have prec : âˆ€ n, p (n + 1) = F (p n) := fun n => by simp only [p, iterate_succ', Function.comp]
  have pn_fst : âˆ€ n, (p n).1.1 = n := by
    intro n
    induction' n with n IH
    Â· rfl
    Â· simp only [prec, hFn, IH]
  have Ix : âˆ€ m n, m + 1 â‰¤ n â†’ (p n).1.2.1 m = (p (m + 1)).1.2.1 m := by
    intro m
    apply Nat.le_induction
    Â· rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.fst m = (p n).val.snd.fst m := by
      apply hFx (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  have Iy : âˆ€ m n, m + 1 â‰¤ n â†’ (p n).1.2.2 m = (p (m + 1)).1.2.2 m := by
    intro m
    apply Nat.le_induction
    Â· rfl
    intro n hmn IH
    have I : (F (p n)).val.snd.snd m = (p n).val.snd.snd m := by
      apply hFy (p n) m
      rw [pn_fst]
      exact hmn
    rw [prec, I, IH]
  set x : â„• â†’ â„• := fun n => (p (n + 1)).1.2.1 n with hx
  set y : â„• â†’ â„• := fun n => (p (n + 1)).1.2.2 n with hy
  have M : âˆ€ n, Â¬MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    intro n
    convert (p n).2 using 3
    Â· rw [pn_fst, â† mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hx]
      exact (Ix i n hi).symm
    Â· rw [pn_fst, â† mem_cylinder_iff_eq, mem_cylinder_iff]
      intro i hi
      rw [hy]
      exact (Iy i n hi).symm
  obtain âŸ¨u, v, u_open, v_open, xu, yv, huvâŸ© :
      âˆƒ u v : Set Î±, IsOpen u âˆ§ IsOpen v âˆ§ f x âˆˆ u âˆ§ g y âˆˆ v âˆ§ Disjoint u v := by
    apply t2_separation
    exact disjoint_iff_forall_ne.1 h (mem_range_self _) (mem_range_self _)
  letI : MetricSpace (â„• â†’ â„•) := metricSpaceNatNat
  obtain âŸ¨Îµx, Îµxpos, hÎµxâŸ© : âˆƒ (Îµx : â„), Îµx > 0 âˆ§ Metric.ball x Îµx âŠ† f â»Â¹' u := by
    apply Metric.mem_nhds_iff.1
    exact hf.continuousAt.preimage_mem_nhds (u_open.mem_nhds xu)
  obtain âŸ¨Îµy, Îµypos, hÎµyâŸ© : âˆƒ (Îµy : â„), Îµy > 0 âˆ§ Metric.ball y Îµy âŠ† g â»Â¹' v := by
    apply Metric.mem_nhds_iff.1
    exact hg.continuousAt.preimage_mem_nhds (v_open.mem_nhds yv)
  obtain âŸ¨n, hnâŸ© : âˆƒ n : â„•, (1 / 2 : â„) ^ n < min Îµx Îµy :=
    exists_pow_lt_of_lt_one (lt_min Îµxpos Îµypos) (by norm_num)
  have B : MeasurablySeparable (f '' cylinder x n) (g '' cylinder y n) := by
    refine âŸ¨u, ?_, ?_, u_open.measurableSetâŸ©
    Â· rw [image_subset_iff]
      apply Subset.trans _ hÎµx
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_left _ _))
    Â· refine Disjoint.mono_left ?_ huv.symm
      change g '' cylinder y n âŠ† v
      rw [image_subset_iff]
      apply Subset.trans _ hÎµy
      intro z hz
      rw [mem_cylinder_iff_dist_le] at hz
      exact hz.trans_lt (hn.trans_le (min_le_right _ _))
  exact M n B"
Mathlib/Analysis/Calculus/ContDiff/Basic.lean,ContDiffWithinAt.iteratedFderivWithin_right,ContDiffWithinAt.iteratedFderivWithin_right,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' i with i hi generalizing m
  Â· rw [Nat.zero_eq, ENat.coe_zero, add_zero] at hmn
    exact (hf.of_le hmn).continuousLinearMap_comp
      ((continuousMultilinearCurryFin0 ğ•œ E F).symm : _ â†’L[ğ•œ] E [Ã—0]â†’L[ğ•œ] F)
  Â· rw [Nat.cast_succ, add_comm _ 1, â† add_assoc] at hmn
    exact ((hi hmn).fderivWithin_right hs le_rfl hxâ‚€s).continuousLinearMap_comp
      (continuousMultilinearCurryLeftEquiv ğ•œ (fun _ : Fin (i+1) â†¦ E) F : _ â†’L[ğ•œ] E [Ã—(i+1)]â†’L[ğ•œ] F)","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
case zero
ğ•œ : Type u_1
instâœÂ¹â° : NontriviallyNormedField ğ•œ
D : Type uD
instâœâ¹ : NormedAddCommGroup D
instâœâ¸ : NormedSpace ğ•œ D
E : Type uE
instâœâ· : NormedAddCommGroup E
instâœâ¶ : NormedSpace ğ•œ E
F : Type uF
instâœâµ : NormedAddCommGroup F
instâœâ´ : NormedSpace ğ•œ F
G : Type uG
instâœÂ³ : NormedAddCommGroup G
instâœÂ² : NormedSpace ğ•œ G
X : Type u_2
instâœÂ¹ : NormedAddCommGroup X
instâœ : NormedSpace ğ•œ X
s sâ‚ t u : Set E
f fâ‚ : E â†’ F
g : F â†’ G
x xâ‚€ : E
c : F
b : E Ã— F â†’ G
n : â„•âˆ
p : E â†’ FormalMultilinearSeries ğ•œ E F
hf : ContDiffWithinAt ğ•œ n f s xâ‚€
hs : UniqueDiffOn ğ•œ s
hxâ‚€s : xâ‚€ âˆˆ s
m : â„•âˆ
hmn : m + â†‘0 â‰¤ n
âŠ¢ ContDiffWithinAt ğ•œ m (iteratedFDerivWithin ğ•œ 0 f s) s xâ‚€","theorem ContDiffWithinAt.iteratedFderivWithin_right {i : â„•} (hf : ContDiffWithinAt ğ•œ n f s xâ‚€)
    (hs : UniqueDiffOn ğ•œ s) (hmn : (m + i : â„•âˆ) â‰¤ n) (hxâ‚€s : xâ‚€ âˆˆ s) :
    ContDiffWithinAt ğ•œ m (iteratedFDerivWithin ğ•œ i f s) s xâ‚€ ",":= by
  induction' i with i hi generalizing m
  Â· rw [ENat.coe_zero, add_zero] at hmn
    exact (hf.of_le hmn).continuousLinearMap_comp
      ((continuousMultilinearCurryFin0 ğ•œ E F).symm : _ â†’L[ğ•œ] E [Ã—0]â†’L[ğ•œ] F)
  Â· rw [Nat.cast_succ, add_comm _ 1, â† add_assoc] at hmn
    exact ((hi hmn).fderivWithin_right hs le_rfl hxâ‚€s).continuousLinearMap_comp
      (continuousMultilinearCurryLeftEquiv ğ•œ (fun _ : Fin (i+1) â†¦ E) F : _ â†’L[ğ•œ] E [Ã—(i+1)]â†’L[ğ•œ] F)"
Mathlib/RingTheory/Localization/Integral.lean,isIntegral_localization',isIntegral_localization',3a31aabe59645ce291dedbcbdd3f949a56d5178f,":=
  let _ := f.toSMul
  let _ := f.toAlgebra
  have : Algebra.IsIntegral R S := âŸ¨hfâŸ©
  have : IsLocalization (Algebra.algebraMapSubmonoid S M)
    (Localization (Submonoid.map (f : R â†’* S) M)) := Localization.isLocalization
  isIntegral_localization","error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  f
has type
  R â†’+* S","theorem isIntegral_localization' {R S : Type*} [CommRing R] [CommRing S] {f : R â†’+* S}
    (hf : f.IsIntegral) (M : Submonoid R) :
    (map (Localization (M.map (f : R â†’* S))) f
          (M.le_comap_map : _ â‰¤ Submonoid.comap (f : R â†’* S) _) :
        Localization M â†’+* _).IsIntegral ",":=
  let _ := f.toAlgebra
  have : Algebra.IsIntegral R S := âŸ¨hfâŸ©
  have : IsLocalization (Algebra.algebraMapSubmonoid S M)
    (Localization (Submonoid.map (f : R â†’* S) M)) := Localization.isLocalization
  isIntegral_localization"
Mathlib/Computability/TuringMachine.lean,Turing.BlankExtends.below_of_le,BlankExtends.below_of_le,0ef23fba776dbe5bb848bbfc3337bedef4a59c82,":= by
  rintro âŸ¨i, rflâŸ© âŸ¨j, rflâŸ© h; use j - i
  simp only [List.length_append, add_le_add_iff_left, List.length_replicate] at h
  simp only [â† List.replicate_add, add_tsub_cancel_of_le h, List.append_assoc]","error:  failed to synthesize
  ExistsAddOfLE â„•
use `set_option diagnostics true` to get diagnostic information
error:  unsolved goals
case h
Î“ : Type u_1
instâœ : Inhabited Î“
l : List Î“
i j : â„•
h : l.length + i â‰¤ l.length + j
âŠ¢ l ++ List.replicate j default = l ++ List.replicate (i + (j - i)) default
warning:  `List.get_append` has been deprecated, use `List.getElem_append` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get_replicate` has been deprecated, use `List.getElem_replicate` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  unused variable `M`
note: this linter can be disabled with `set_option linter.unusedVariables false`
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead","theorem BlankExtends.below_of_le {Î“} [Inhabited Î“] {l lâ‚ lâ‚‚ : List Î“} :
    BlankExtends l lâ‚ â†’ BlankExtends l lâ‚‚ â†’ lâ‚.length â‰¤ lâ‚‚.length â†’ BlankExtends lâ‚ lâ‚‚ ",":= by
  rintro âŸ¨i, rflâŸ© âŸ¨j, rflâŸ© h; use j - i
  simp only [List.length_append, Nat.add_le_add_iff_left, List.length_replicate] at h
  simp only [â† List.replicate_add, Nat.add_sub_cancel' h, List.append_assoc]"
Mathlib/GroupTheory/GroupAction/Blocks.lean,MulAction.IsBlock.isBlockSystem,IsBlock.isBlockSystem,136957ac82beac101e5f1ca9001a19b64087d22c,":= by
  constructor
  constructor
  Â· simp only [Set.mem_range, not_exists]
    intro x hx; apply Set.Nonempty.ne_empty hBe
    rw [â† Set.image_eq_empty]
    exact hx
  Â· intro a
    obtain âŸ¨b : X, hb : b âˆˆ BâŸ© := hBe
    obtain âŸ¨g, habâŸ© := exists_smul_eq G b a
    have hg : a âˆˆ g â€¢ B := by
      change a âˆˆ (fun b => g â€¢ b) '' B
      rw [Set.mem_image]
      use b
    use g â€¢ B
    constructor
    Â· simp only [Set.mem_range, exists_apply_eq_apply, true_and, hg]
    Â· simp only [Set.mem_range, exists_unique_iff_exists, exists_prop, and_imp, forall_exists_index,
        forall_apply_eq_imp_iff']
      intro B' g' hg' ha
      rw [â† hg']
      apply symm
      apply Or.resolve_right (IsBlock.def.mp hB g g')
      rw [Set.not_disjoint_iff]
      use a
      rw [hg']
      exact âŸ¨hg, haâŸ©
  rintro B' âŸ¨g, rflâŸ©; exact hB.smul g","error:  invalid field 'smul', the environment does not contain 'MulAction.IsBlock.smul'
  hB
has type
  IsBlock G B
error:  invalid field 'smul', the environment does not contain 'Set.PairwiseDisjoint.smul'
  hB
has type
  (Set.range fun g â†¦ g â€¢ B).PairwiseDisjoint id
error:  invalid field 'smul', the environment does not contain 'Set.Pairwise.smul'
  hB
has type
  (Set.range fun g â†¦ g â€¢ B).Pairwise (Disjoint on id)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hB
has type
  (?m.104839 âˆˆ Set.range fun g â†¦ g â€¢ B) â†’
    âˆ€ â¦ƒy : Set Xâ¦„, (y âˆˆ Set.range fun g â†¦ g â€¢ B) â†’ ?m.104839 â‰  y â†’ (Disjoint on id) ?m.104839 y","theorem IsBlock.isBlockSystem [hGX : MulAction.IsPretransitive G X]
    {B : Set X} (hB : IsBlock G B) (hBe : B.Nonempty) :
    IsBlockSystem G (Set.range fun g : G => g â€¢ B) ",":= by
  refine âŸ¨âŸ¨?nonempty, ?coverâŸ©, ?mem_blocksâŸ©
  case mem_blocks => rintro B' âŸ¨g, rflâŸ©; exact hB.translate g
  Â· simp only [Set.mem_range, not_exists]
    intro g hg
    apply hBe.ne_empty
    simpa only [Set.smul_set_eq_empty] using hg
  Â· intro a
    obtain âŸ¨b : X, hb : b âˆˆ BâŸ© := hBe
    obtain âŸ¨g, rflâŸ© := exists_smul_eq G b a
    use g â€¢ B
    simp only [Set.smul_mem_smul_set_iff, hb, exists_unique_iff_exists, Set.mem_range,
      exists_apply_eq_apply, exists_const, exists_prop, and_imp, forall_exists_index,
      forall_apply_eq_imp_iff, true_and]
    intro g' ha
    apply (IsBlock.def.mp hB g' g).resolve_right
    rw [Set.not_disjoint_iff]
    refine âŸ¨g â€¢ b, ha, âŸ¨b, hb, rflâŸ©âŸ©"
Mathlib/GroupTheory/GroupAction/Blocks.lean,MulAction.IsBlock.def,IsBlock.def,61b2edea0cfd9b92838f6f2968a40f582d0a7f5a,":=
  by
  constructor
  Â· intro hB g g'
    by_cases (g â€¢ B = g' â€¢ B) 
    Â· refine' Or.intro_left _ h
    Â· apply Or.intro_right
      exact hB (Set.mem_range_self g) (Set.mem_range_self g') h
  Â· intro hB
    unfold IsBlock
    intro C hC C' hC'
    obtain âŸ¨g, rflâŸ© := hC
    obtain âŸ¨g', rflâŸ© := hC'
    intro hgg'
    cases hB g g' with
    | inl h => exfalso; exact hgg' h
    | inr h => exact h","error:  unknown identifier 'h'
error:  unknown identifier 'h'","theorem IsBlock.def {B : Set X} :
    IsBlock G B â†” âˆ€ g g' : G, g â€¢ B = g' â€¢ B âˆ¨ Disjoint (g â€¢ B) (g' â€¢ B) ",":= by
  apply Set.pairwiseDisjoint_range_iff"
Mathlib/Order/SuccPred/LinearLocallyFinite.lean,toZ_iterate_succ_of_not_isMax,toZ_iterate_succ_of_not_isMax,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  let m := (toZ i0 (succ^[n] i0)).toNat
  have h_eq : succ^[m] i0 = succ^[n] i0 := iterate_succ_toZ _ (le_succ_iterate _ _)
  by_cases hmn : m = n
  Â· nth_rw 2 [â† hmn]
    rw [Int.toNat_eq_max, toZ_of_ge (le_succ_iterate _ _), max_eq_left]
    exact Nat.cast_nonneg _
  suffices IsMax (succ^[n] i0) from absurd this hn
  exact isMax_iterate_succ_of_eq_of_ne h_eq.symm (Ne.symm hmn)",error:  unknown constant 'Nat.cast_nonneg',"theorem toZ_iterate_succ_of_not_isMax (n : â„•) (hn : Â¬IsMax (succ^[n] i0)) :
    toZ i0 (succ^[n] i0) = n ",":= by
  let m := (toZ i0 (succ^[n] i0)).toNat
  have h_eq : succ^[m] i0 = succ^[n] i0 := iterate_succ_toZ _ (le_succ_iterate _ _)
  by_cases hmn : m = n
  Â· nth_rw 2 [â† hmn]
    rw [Int.toNat_eq_max, toZ_of_ge (le_succ_iterate _ _), max_eq_left]
    exact Int.natCast_nonneg _
  suffices IsMax (succ^[n] i0) from absurd this hn
  exact isMax_iterate_succ_of_eq_of_ne h_eq.symm (Ne.symm hmn)"
Mathlib/MeasureTheory/Measure/Haar/Unique.lean,MeasureTheory.Measure.integral_isMulLeftInvariant_isMulRightInvariant_combo,integral_isMulLeftInvariant_isMulRightInvariant_combo,6c4e9e7eddf0aaf531f6e6aaac63cca62fcfbf92,":= by
  rcases h'f.eq_zero_or_locallyCompactSpace_of_group hf with Hf|Hf
  Â· simp [Hf]
  let D : G â†’ â„ := fun (x : G) â†¦ âˆ« y, g (yâ»Â¹ * x) âˆ‚Î½
  have D_cont : Continuous D := continuous_integral_apply_inv_mul hg h'g
  have D_pos : âˆ€ x, 0 < D x := by
    intro x
    have C : Continuous (fun y â†¦ g (yâ»Â¹ * x)) := hg.comp (continuous_inv.mul continuous_const)
    apply (integral_pos_iff_support_of_nonneg _ _).2
    Â· apply C.isOpen_support.measure_pos Î½
      exact âŸ¨x * xâ‚€â»Â¹, by simpa using g_posâŸ©
    Â· exact fun y â†¦ g_nonneg (yâ»Â¹ * x)
    Â· apply C.integrable_of_hasCompactSupport
      exact h'g.comp_homeomorph ((Homeomorph.inv G).trans (Homeomorph.mulRight x))
  calc
  âˆ« x, f x âˆ‚Î¼ = âˆ« x, f x * (D x)â»Â¹ * D x âˆ‚Î¼ := by
    congr with x; rw [mul_assoc, inv_mul_cancel (D_pos x).ne', mul_one]
  _ = âˆ« x, (âˆ« y, f x * (D x)â»Â¹ * g (yâ»Â¹ * x) âˆ‚Î½) âˆ‚Î¼ := by simp_rw [integral_mul_left]
  _ = âˆ« y, (âˆ« x, f x * (D x)â»Â¹ * g (yâ»Â¹ * x) âˆ‚Î¼) âˆ‚Î½ := by
      apply integral_integral_swap_of_hasCompactSupport
      Â· apply Continuous.mul
        Â· exact (hf.comp continuous_fst).mul
            ((D_cont.comp continuous_fst).invâ‚€ (fun x â†¦ (D_pos _).ne'))
        Â· exact hg.comp (continuous_snd.inv.mul continuous_fst)
      Â· let K := tsupport f
        have K_comp : IsCompact K := h'f
        let L := tsupport g
        have L_comp : IsCompact L := h'g
        let M := (fun (p : G Ã— G) â†¦ p.1 * p.2â»Â¹) '' (K Ã—Ë¢ L)
        have M_comp : IsCompact M :=
          (K_comp.prod L_comp).image (continuous_fst.mul continuous_snd.inv)
        have M'_comp : IsCompact (closure M) := M_comp.closure
        have : âˆ€ (p : G Ã— G), p âˆ‰ K Ã—Ë¢ closure M â†’ f p.1 * (D p.1)â»Â¹ * g (p.2â»Â¹ * p.1) = 0 := by
          rintro âŸ¨x, yâŸ© hxy
          by_cases H : x âˆˆ K; swap
          Â· simp [image_eq_zero_of_nmem_tsupport H]
          have : g (yâ»Â¹ * x) = 0 := by
            apply image_eq_zero_of_nmem_tsupport
            contrapose! hxy
            simp only [mem_prod, H, true_and]
            apply subset_closure
            simp only [mem_image, mem_prod, Prod.exists]
            exact âŸ¨x, yâ»Â¹ * x, âŸ¨H, hxyâŸ©, by groupâŸ©
          simp [this]
        apply HasCompactSupport.intro' (K_comp.prod M'_comp) ?_ this
        exact (isClosed_tsupport f).prod isClosed_closure
  _ = âˆ« y, (âˆ« x, f (y * x) * (D (y * x))â»Â¹ * g x âˆ‚Î¼) âˆ‚Î½ := by
      congr with y
      rw [â† integral_mul_left_eq_self _ y]
      simp
  _ = âˆ« x, (âˆ« y, f (y * x) * (D (y * x))â»Â¹ * g x âˆ‚Î½) âˆ‚Î¼ := by
      apply (integral_integral_swap_of_hasCompactSupport _ _).symm
      Â· apply Continuous.mul ?_ (hg.comp continuous_fst)
        exact (hf.comp (continuous_snd.mul continuous_fst)).mul
          ((D_cont.comp (continuous_snd.mul continuous_fst)).invâ‚€ (fun x â†¦ (D_pos _).ne'))
      Â· let K := tsupport f
        have K_comp : IsCompact K := h'f
        let L := tsupport g
        have L_comp : IsCompact L := h'g
        let M := (fun (p : G Ã— G) â†¦ p.1 * p.2â»Â¹) '' (K Ã—Ë¢ L)
        have M_comp : IsCompact M :=
          (K_comp.prod L_comp).image (continuous_fst.mul continuous_snd.inv)
        have M'_comp : IsCompact (closure M) := M_comp.closure
        have : âˆ€ (p : G Ã— G), p âˆ‰ L Ã—Ë¢ closure M â†’
            f (p.2 * p.1) * (D (p.2 * p.1))â»Â¹ * g p.1 = 0 := by
          rintro âŸ¨x, yâŸ© hxy
          by_cases H : x âˆˆ L; swap
          Â· simp [image_eq_zero_of_nmem_tsupport H]
          have : f (y * x) = 0 := by
            apply image_eq_zero_of_nmem_tsupport
            contrapose! hxy
            simp only [mem_prod, H, true_and]
            apply subset_closure
            simp only [mem_image, mem_prod, Prod.exists]
            exact âŸ¨y * x, x, âŸ¨hxy, HâŸ©, by groupâŸ©
          simp [this]
        apply HasCompactSupport.intro' (L_comp.prod M'_comp) ?_ this
        exact (isClosed_tsupport g).prod isClosed_closure
  _ = âˆ« x, (âˆ« y, f y * (D y)â»Â¹ âˆ‚Î½) * g x âˆ‚Î¼ := by
      simp_rw [integral_mul_right]
      congr with x
      conv_rhs => rw [â† integral_mul_right_eq_self _ x]
  _ = (âˆ« y, f y * (D y)â»Â¹ âˆ‚Î½) * âˆ« x, g x âˆ‚Î¼ := integral_mul_left _ _","error:  simp made no progress
error:  simp made no progress","lemma integral_isMulLeftInvariant_isMulRightInvariant_combo
    {Î¼ Î½ : Measure G} [IsFiniteMeasureOnCompacts Î¼] [IsFiniteMeasureOnCompacts Î½]
    [IsMulLeftInvariant Î¼] [IsMulRightInvariant Î½] [IsOpenPosMeasure Î½]
    {f g : G â†’ â„} (hf : Continuous f) (h'f : HasCompactSupport f)
    (hg : Continuous g) (h'g : HasCompactSupport g) (g_nonneg : 0 â‰¤ g) {xâ‚€ : G} (g_pos : g xâ‚€ â‰  0) :
    âˆ« x, f x âˆ‚Î¼ = (âˆ« y, f y * (âˆ« z, g (zâ»Â¹ * y) âˆ‚Î½)â»Â¹ âˆ‚Î½) * âˆ« x, g x âˆ‚Î¼ ",":= by
  rcases h'f.eq_zero_or_locallyCompactSpace_of_group hf with Hf|Hf
  Â· simp [Hf]
  let D : G â†’ â„ := fun (x : G) â†¦ âˆ« y, g (yâ»Â¹ * x) âˆ‚Î½
  have D_cont : Continuous D := continuous_integral_apply_inv_mul hg h'g
  have D_pos : âˆ€ x, 0 < D x := by
    intro x
    have C : Continuous (fun y â†¦ g (yâ»Â¹ * x)) := hg.comp (continuous_inv.mul continuous_const)
    apply (integral_pos_iff_support_of_nonneg _ _).2
    Â· apply C.isOpen_support.measure_pos Î½
      exact âŸ¨x * xâ‚€â»Â¹, by simpa using g_posâŸ©
    Â· exact fun y â†¦ g_nonneg (yâ»Â¹ * x)
    Â· apply C.integrable_of_hasCompactSupport
      exact h'g.comp_homeomorph ((Homeomorph.inv G).trans (Homeomorph.mulRight x))
  calc
  âˆ« x, f x âˆ‚Î¼ = âˆ« x, f x * (D x)â»Â¹ * D x âˆ‚Î¼ := by
    congr with x; rw [mul_assoc, inv_mul_cancel (D_pos x).ne', mul_one]
  _ = âˆ« x, (âˆ« y, f x * (D x)â»Â¹ * g (yâ»Â¹ * x) âˆ‚Î½) âˆ‚Î¼ := by simp_rw [integral_mul_left]
  _ = âˆ« y, (âˆ« x, f x * (D x)â»Â¹ * g (yâ»Â¹ * x) âˆ‚Î¼) âˆ‚Î½ := by
      apply integral_integral_swap_of_hasCompactSupport
      Â· apply Continuous.mul
        Â· exact (hf.comp continuous_fst).mul
            ((D_cont.comp continuous_fst).invâ‚€ (fun x â†¦ (D_pos _).ne'))
        Â· exact hg.comp (continuous_snd.inv.mul continuous_fst)
      Â· let K := tsupport f
        have K_comp : IsCompact K := h'f
        let L := tsupport g
        have L_comp : IsCompact L := h'g
        let M := (fun (p : G Ã— G) â†¦ p.1 * p.2â»Â¹) '' (K Ã—Ë¢ L)
        have M_comp : IsCompact M :=
          (K_comp.prod L_comp).image (continuous_fst.mul continuous_snd.inv)
        have M'_comp : IsCompact (closure M) := M_comp.closure
        have : âˆ€ (p : G Ã— G), p âˆ‰ K Ã—Ë¢ closure M â†’ f p.1 * (D p.1)â»Â¹ * g (p.2â»Â¹ * p.1) = 0 := by
          rintro âŸ¨x, yâŸ© hxy
          by_cases H : x âˆˆ K; swap
          Â· simp [image_eq_zero_of_nmem_tsupport H]
          have : g (yâ»Â¹ * x) = 0 := by
            apply image_eq_zero_of_nmem_tsupport
            contrapose! hxy
            simp only [mem_prod, H, true_and]
            apply subset_closure
            simp only [M, mem_image, mem_prod, Prod.exists]
            exact âŸ¨x, yâ»Â¹ * x, âŸ¨H, hxyâŸ©, by groupâŸ©
          simp [this]
        apply HasCompactSupport.intro' (K_comp.prod M'_comp) ?_ this
        exact (isClosed_tsupport f).prod isClosed_closure
  _ = âˆ« y, (âˆ« x, f (y * x) * (D (y * x))â»Â¹ * g x âˆ‚Î¼) âˆ‚Î½ := by
      congr with y
      rw [â† integral_mul_left_eq_self _ y]
      simp
  _ = âˆ« x, (âˆ« y, f (y * x) * (D (y * x))â»Â¹ * g x âˆ‚Î½) âˆ‚Î¼ := by
      apply (integral_integral_swap_of_hasCompactSupport _ _).symm
      Â· apply Continuous.mul ?_ (hg.comp continuous_fst)
        exact (hf.comp (continuous_snd.mul continuous_fst)).mul
          ((D_cont.comp (continuous_snd.mul continuous_fst)).invâ‚€ (fun x â†¦ (D_pos _).ne'))
      Â· let K := tsupport f
        have K_comp : IsCompact K := h'f
        let L := tsupport g
        have L_comp : IsCompact L := h'g
        let M := (fun (p : G Ã— G) â†¦ p.1 * p.2â»Â¹) '' (K Ã—Ë¢ L)
        have M_comp : IsCompact M :=
          (K_comp.prod L_comp).image (continuous_fst.mul continuous_snd.inv)
        have M'_comp : IsCompact (closure M) := M_comp.closure
        have : âˆ€ (p : G Ã— G), p âˆ‰ L Ã—Ë¢ closure M â†’
            f (p.2 * p.1) * (D (p.2 * p.1))â»Â¹ * g p.1 = 0 := by
          rintro âŸ¨x, yâŸ© hxy
          by_cases H : x âˆˆ L; swap
          Â· simp [image_eq_zero_of_nmem_tsupport H]
          have : f (y * x) = 0 := by
            apply image_eq_zero_of_nmem_tsupport
            contrapose! hxy
            simp only [mem_prod, H, true_and]
            apply subset_closure
            simp only [M, mem_image, mem_prod, Prod.exists]
            exact âŸ¨y * x, x, âŸ¨hxy, HâŸ©, by groupâŸ©
          simp [this]
        apply HasCompactSupport.intro' (L_comp.prod M'_comp) ?_ this
        exact (isClosed_tsupport g).prod isClosed_closure
  _ = âˆ« x, (âˆ« y, f y * (D y)â»Â¹ âˆ‚Î½) * g x âˆ‚Î¼ := by
      simp_rw [integral_mul_right]
      congr with x
      conv_rhs => rw [â† integral_mul_right_eq_self _ x]
  _ = (âˆ« y, f y * (D y)â»Â¹ âˆ‚Î½) * âˆ« x, g x âˆ‚Î¼ := integral_mul_left _ _"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.addHaar_image_le_mul_of_det_lt,addHaar_image_le_mul_of_det_lt,61ddcfa78d90f5773ac5739822ee3721851aa662,":= by
  apply nhdsWithin_le_nhds
  let d := ENNReal.ofReal |A.det|
  obtain âŸ¨Îµ, hÎµ, ÎµposâŸ© :
    âˆƒ Îµ : â„, Î¼ (closedBall 0 Îµ + A '' closedBall 0 1) < m * Î¼ (closedBall 0 1) âˆ§ 0 < Îµ := by
    have HC : IsCompact (A '' closedBall 0 1) :=
      (ProperSpace.isCompact_closedBall _ _).image A.continuous
    have L0 :
      Tendsto (fun Îµ => Î¼ (cthickening Îµ (A '' closedBall 0 1))) (ğ“[>] 0)
        (ğ“ (Î¼ (A '' closedBall 0 1))) := by
      apply Tendsto.mono_left _ nhdsWithin_le_nhds
      exact tendsto_measure_cthickening_of_isCompact HC
    have L1 :
      Tendsto (fun Îµ => Î¼ (closedBall 0 Îµ + A '' closedBall 0 1)) (ğ“[>] 0)
        (ğ“ (Î¼ (A '' closedBall 0 1))) := by
      apply L0.congr' _
      filter_upwards [self_mem_nhdsWithin] with r hr
      rw [â† HC.add_closedBall_zero (le_of_lt hr), add_comm]
    have L2 :
      Tendsto (fun Îµ => Î¼ (closedBall 0 Îµ + A '' closedBall 0 1)) (ğ“[>] 0)
        (ğ“ (d * Î¼ (closedBall 0 1))) := by
      convert L1
      exact (addHaar_image_continuousLinearMap _ _ _).symm
    have I : d * Î¼ (closedBall 0 1) < m * Î¼ (closedBall 0 1) :=
      (ENNReal.mul_lt_mul_right (measure_closedBall_pos Î¼ _ zero_lt_one).ne'
            measure_closedBall_lt_top.ne).2
        hm
    have H :
      âˆ€á¶  b : â„ in ğ“[>] 0, Î¼ (closedBall 0 b + A '' closedBall 0 1) < m * Î¼ (closedBall 0 1) :=
      (tendsto_order.1 L2).2 _ I
    exact (H.and self_mem_nhdsWithin).exists
  have : Iio (âŸ¨Îµ, Îµpos.leâŸ© : â„â‰¥0) âˆˆ ğ“ (0 : â„â‰¥0) := by apply Iio_mem_nhds; exact Îµpos
  filter_upwards [this]
  intro Î´ hÎ´ s f hf
  simp only [mem_Iio, â† NNReal.coe_lt_coe, NNReal.coe_mk] at hÎ´
  have I : âˆ€ x r, x âˆˆ s â†’ 0 â‰¤ r â†’ Î¼ (f '' (s âˆ© closedBall x r)) â‰¤ m * Î¼ (closedBall x r) := by
    intro x r xs r0
    have K : f '' (s âˆ© closedBall x r) âŠ† A '' closedBall 0 r + closedBall (f x) (Îµ * r) := by
      rintro y âŸ¨z, âŸ¨zs, zrâŸ©, rflâŸ©
      rw [mem_closedBall_iff_norm] at zr
      apply Set.mem_add.2 âŸ¨A (z - x), _, f z - f x - A (z - x) + f x, _, _âŸ©
      Â· apply mem_image_of_mem
        simpa only [dist_eq_norm, mem_closedBall, mem_closedBall_zero_iff, sub_zero] using zr
      Â· rw [mem_closedBall_iff_norm, add_sub_cancel_right]
        calc
          â€–f z - f x - A (z - x)â€– â‰¤ Î´ * â€–z - xâ€– := hf _ zs _ xs
          _ â‰¤ Îµ * r := by gcongr
      Â· simp only [map_sub, Pi.sub_apply]
        abel
    have :
      A '' closedBall 0 r + closedBall (f x) (Îµ * r) =
        {f x} + r â€¢ (A '' closedBall 0 1 + closedBall 0 Îµ) := by
      rw [smul_add, â† add_assoc, add_comm {f x}, add_assoc, smul_closedBall _ _ Îµpos.le, smul_zero,
        singleton_add_closedBall_zero, â† image_smul_set â„ E E A, smul_closedBall _ _ zero_le_one,
        smul_zero, Real.norm_eq_abs, abs_of_nonneg r0, mul_one, mul_comm]
    rw [this] at K
    calc
      Î¼ (f '' (s âˆ© closedBall x r)) â‰¤ Î¼ ({f x} + r â€¢ (A '' closedBall 0 1 + closedBall 0 Îµ)) :=
        measure_mono K
      _ = ENNReal.ofReal (r ^ finrank â„ E) * Î¼ (A '' closedBall 0 1 + closedBall 0 Îµ) := by
        simp only [abs_of_nonneg r0, addHaar_smul, image_add_left, abs_pow, singleton_add,
          measure_preimage_add]
      _ â‰¤ ENNReal.ofReal (r ^ finrank â„ E) * (m * Î¼ (closedBall 0 1)) := by
        rw [add_comm]; exact mul_le_mul_left' hÎµ.le _
      _ = m * Î¼ (closedBall x r) := by simp only [addHaar_closedBall' Î¼ _ r0]; ring
  have J : âˆ€á¶  a in ğ“[>] (0 : â„â‰¥0âˆ), Î¼ (f '' s) â‰¤ m * (Î¼ s + a) := by
    filter_upwards [self_mem_nhdsWithin] with a ha
    rw [mem_Ioi] at ha
    obtain âŸ¨t, r, t_count, ts, rpos, st, Î¼tâŸ© :
      âˆƒ (t : Set E) (r : E â†’ â„),
        t.Countable âˆ§
          t âŠ† s âˆ§
            (âˆ€ x : E, x âˆˆ t â†’ 0 < r x) âˆ§
              (s âŠ† â‹ƒ x âˆˆ t, closedBall x (r x)) âˆ§
                (âˆ‘' x : â†¥t, Î¼ (closedBall (â†‘x) (r â†‘x))) â‰¤ Î¼ s + a :=
      Besicovitch.exists_closedBall_covering_tsum_measure_le Î¼ ha.ne' (fun _ => Ioi 0) s
        fun x _ Î´ Î´pos => âŸ¨Î´ / 2, by simp [half_pos Î´pos, Î´pos]âŸ©
    haveI : Encodable t := t_count.toEncodable
    calc
      Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ x : t, f '' (s âˆ© closedBall x (r x))) := by
        rw [biUnion_eq_iUnion] at st
        apply measure_mono
        rw [â† image_iUnion, â† inter_iUnion]
        exact image_subset _ (subset_inter (Subset.refl _) st)
      _ â‰¤ âˆ‘' x : t, Î¼ (f '' (s âˆ© closedBall x (r x))) := (measure_iUnion_le _)
      _ â‰¤ âˆ‘' x : t, m * Î¼ (closedBall x (r x)) :=
        (ENNReal.tsum_le_tsum fun x => I x (r x) (ts x.2) (rpos x x.2).le)
      _ â‰¤ m * (Î¼ s + a) := by rw [ENNReal.tsum_mul_left]; exact mul_le_mul_left' Î¼t _
  have L : Tendsto (fun a => (m : â„â‰¥0âˆ) * (Î¼ s + a)) (ğ“[>] 0) (ğ“ (m * (Î¼ s + 0))) := by
    apply Tendsto.mono_left _ nhdsWithin_le_nhds
    apply ENNReal.Tendsto.const_mul (tendsto_const_nhds.add tendsto_id)
    simp only [ENNReal.coe_ne_top, Ne.def, or_true_iff, not_false_iff]
  rw [add_zero] at L
  exact ge_of_tendsto L J","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.159456 â†’ ?m.159456 â†’ Prop
error:  simp made no progress","theorem addHaar_image_le_mul_of_det_lt (A : E â†’L[â„] E) {m : â„â‰¥0}
    (hm : ENNReal.ofReal |A.det| < m) :
    âˆ€á¶  Î´ in ğ“[>] (0 : â„â‰¥0),
      âˆ€ (s : Set E) (f : E â†’ E), ApproximatesLinearOn f A s Î´ â†’ Î¼ (f '' s) â‰¤ m * Î¼ s ",":= by
  apply nhdsWithin_le_nhds
  let d := ENNReal.ofReal |A.det|
  obtain âŸ¨Îµ, hÎµ, ÎµposâŸ© :
    âˆƒ Îµ : â„, Î¼ (closedBall 0 Îµ + A '' closedBall 0 1) < m * Î¼ (closedBall 0 1) âˆ§ 0 < Îµ := by
    have HC : IsCompact (A '' closedBall 0 1) :=
      (ProperSpace.isCompact_closedBall _ _).image A.continuous
    have L0 :
      Tendsto (fun Îµ => Î¼ (cthickening Îµ (A '' closedBall 0 1))) (ğ“[>] 0)
        (ğ“ (Î¼ (A '' closedBall 0 1))) := by
      apply Tendsto.mono_left _ nhdsWithin_le_nhds
      exact tendsto_measure_cthickening_of_isCompact HC
    have L1 :
      Tendsto (fun Îµ => Î¼ (closedBall 0 Îµ + A '' closedBall 0 1)) (ğ“[>] 0)
        (ğ“ (Î¼ (A '' closedBall 0 1))) := by
      apply L0.congr' _
      filter_upwards [self_mem_nhdsWithin] with r hr
      rw [â† HC.add_closedBall_zero (le_of_lt hr), add_comm]
    have L2 :
      Tendsto (fun Îµ => Î¼ (closedBall 0 Îµ + A '' closedBall 0 1)) (ğ“[>] 0)
        (ğ“ (d * Î¼ (closedBall 0 1))) := by
      convert L1
      exact (addHaar_image_continuousLinearMap _ _ _).symm
    have I : d * Î¼ (closedBall 0 1) < m * Î¼ (closedBall 0 1) :=
      (ENNReal.mul_lt_mul_right (measure_closedBall_pos Î¼ _ zero_lt_one).ne'
            measure_closedBall_lt_top.ne).2
        hm
    have H :
      âˆ€á¶  b : â„ in ğ“[>] 0, Î¼ (closedBall 0 b + A '' closedBall 0 1) < m * Î¼ (closedBall 0 1) :=
      (tendsto_order.1 L2).2 _ I
    exact (H.and self_mem_nhdsWithin).exists
  have : Iio (âŸ¨Îµ, Îµpos.leâŸ© : â„â‰¥0) âˆˆ ğ“ (0 : â„â‰¥0) := by apply Iio_mem_nhds; exact Îµpos
  filter_upwards [this]
  intro Î´ hÎ´ s f hf
  simp only [mem_Iio, â† NNReal.coe_lt_coe, NNReal.coe_mk] at hÎ´
  have I : âˆ€ x r, x âˆˆ s â†’ 0 â‰¤ r â†’ Î¼ (f '' (s âˆ© closedBall x r)) â‰¤ m * Î¼ (closedBall x r) := by
    intro x r xs r0
    have K : f '' (s âˆ© closedBall x r) âŠ† A '' closedBall 0 r + closedBall (f x) (Îµ * r) := by
      rintro y âŸ¨z, âŸ¨zs, zrâŸ©, rflâŸ©
      rw [mem_closedBall_iff_norm] at zr
      apply Set.mem_add.2 âŸ¨A (z - x), _, f z - f x - A (z - x) + f x, _, _âŸ©
      Â· apply mem_image_of_mem
        simpa only [dist_eq_norm, mem_closedBall, mem_closedBall_zero_iff, sub_zero] using zr
      Â· rw [mem_closedBall_iff_norm, add_sub_cancel_right]
        calc
          â€–f z - f x - A (z - x)â€– â‰¤ Î´ * â€–z - xâ€– := hf _ zs _ xs
          _ â‰¤ Îµ * r := by gcongr
      Â· simp only [map_sub, Pi.sub_apply]
        abel
    have :
      A '' closedBall 0 r + closedBall (f x) (Îµ * r) =
        {f x} + r â€¢ (A '' closedBall 0 1 + closedBall 0 Îµ) := by
      rw [smul_add, â† add_assoc, add_comm {f x}, add_assoc, smul_closedBall _ _ Îµpos.le, smul_zero,
        singleton_add_closedBall_zero, â† image_smul_set â„ E E A, smul_closedBall _ _ zero_le_one,
        smul_zero, Real.norm_eq_abs, abs_of_nonneg r0, mul_one, mul_comm]
    rw [this] at K
    calc
      Î¼ (f '' (s âˆ© closedBall x r)) â‰¤ Î¼ ({f x} + r â€¢ (A '' closedBall 0 1 + closedBall 0 Îµ)) :=
        measure_mono K
      _ = ENNReal.ofReal (r ^ finrank â„ E) * Î¼ (A '' closedBall 0 1 + closedBall 0 Îµ) := by
        simp only [abs_of_nonneg r0, addHaar_smul, image_add_left, abs_pow, singleton_add,
          measure_preimage_add]
      _ â‰¤ ENNReal.ofReal (r ^ finrank â„ E) * (m * Î¼ (closedBall 0 1)) := by
        rw [add_comm]; gcongr
      _ = m * Î¼ (closedBall x r) := by simp only [addHaar_closedBall' Î¼ _ r0]; ring
  have J : âˆ€á¶  a in ğ“[>] (0 : â„â‰¥0âˆ), Î¼ (f '' s) â‰¤ m * (Î¼ s + a) := by
    filter_upwards [self_mem_nhdsWithin] with a ha
    rw [mem_Ioi] at ha
    obtain âŸ¨t, r, t_count, ts, rpos, st, Î¼tâŸ© :
      âˆƒ (t : Set E) (r : E â†’ â„),
        t.Countable âˆ§
          t âŠ† s âˆ§
            (âˆ€ x : E, x âˆˆ t â†’ 0 < r x) âˆ§
              (s âŠ† â‹ƒ x âˆˆ t, closedBall x (r x)) âˆ§
                (âˆ‘' x : â†¥t, Î¼ (closedBall (â†‘x) (r â†‘x))) â‰¤ Î¼ s + a :=
      Besicovitch.exists_closedBall_covering_tsum_measure_le Î¼ ha.ne' (fun _ => Ioi 0) s
        fun x _ Î´ Î´pos => âŸ¨Î´ / 2, by simp [half_pos Î´pos, Î´pos]âŸ©
    haveI : Encodable t := t_count.toEncodable
    calc
      Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ x : t, f '' (s âˆ© closedBall x (r x))) := by
        rw [biUnion_eq_iUnion] at st
        apply measure_mono
        rw [â† image_iUnion, â† inter_iUnion]
        exact image_subset _ (subset_inter (Subset.refl _) st)
      _ â‰¤ âˆ‘' x : t, Î¼ (f '' (s âˆ© closedBall x (r x))) := measure_iUnion_le _
      _ â‰¤ âˆ‘' x : t, m * Î¼ (closedBall x (r x)) :=
        (ENNReal.tsum_le_tsum fun x => I x (r x) (ts x.2) (rpos x x.2).le)
      _ â‰¤ m * (Î¼ s + a) := by rw [ENNReal.tsum_mul_left]; gcongr
  have L : Tendsto (fun a => (m : â„â‰¥0âˆ) * (Î¼ s + a)) (ğ“[>] 0) (ğ“ (m * (Î¼ s + 0))) := by
    apply Tendsto.mono_left _ nhdsWithin_le_nhds
    apply ENNReal.Tendsto.const_mul (tendsto_const_nhds.add tendsto_id)
    simp only [ENNReal.coe_ne_top, Ne, or_true_iff, not_false_iff]
  rw [add_zero] at L
  exact ge_of_tendsto L J"
Mathlib/Computability/TuringMachine.lean,Turing.ListBlank.ext,ListBlank.ext,c861dd6cd08bd7df736e7bd108071ed1e6be9ee8,":= by
  refine' ListBlank.induction_on Lâ‚ fun lâ‚ â†¦ ListBlank.induction_on Lâ‚‚ fun lâ‚‚ H â†¦ _
  wlog h : lâ‚.length â‰¤ lâ‚‚.length
  Â· cases le_total lâ‚.length lâ‚‚.length <;> [skip; symm] <;> apply this <;> try assumption
    intro
    rw [H]
  refine Quotient.sound' (Or.inl âŸ¨lâ‚‚.length - lâ‚.length, ?_âŸ©)
  refine' List.ext_get _ fun i h hâ‚‚ â†¦ Eq.symm _
  Â· simp only [add_tsub_cancel_of_le h, List.length_append, List.length_replicate]
  simp only [ListBlank.nth_mk] at H
  cases' lt_or_le i lâ‚.length with h' h'
  Â· simp only [List.get_append _ h', List.get?_eq_get h, List.get?_eq_get h',
      â† List.getI_eq_get _ h, â† List.getI_eq_get _ h', H]
  Â· simp only [List.get_append_right' h', List.get_replicate, List.get?_eq_get h,
      List.get?_len_le h', â† List.getI_eq_default _ h', H, List.getI_eq_get _ h]","error:  failed to synthesize
  ExistsAddOfLE â„•
use `set_option diagnostics true` to get diagnostic information
error:  unsolved goals
case refine'_1
Î“ : Type u_1
i : Inhabited Î“
Lâ‚ Lâ‚‚ : ListBlank Î“
lâ‚ lâ‚‚ : List Î“
H : âˆ€ (i_1 : â„•), (mk lâ‚).nth i_1 = (mk lâ‚‚).nth i_1
h : lâ‚.length â‰¤ lâ‚‚.length
âŠ¢ lâ‚‚.length = lâ‚.length + (lâ‚‚.length - lâ‚.length)
warning:  `List.get_append` has been deprecated, use `List.getElem_append` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get_replicate` has been deprecated, use `List.getElem_replicate` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  unused variable `M`
note: this linter can be disabled with `set_option linter.unusedVariables false`
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead","theorem ListBlank.ext {Î“} [i : Inhabited Î“] {Lâ‚ Lâ‚‚ : ListBlank Î“} :
    (âˆ€ i, Lâ‚.nth i = Lâ‚‚.nth i) â†’ Lâ‚ = Lâ‚‚ ",":= by
  refine ListBlank.induction_on Lâ‚ fun lâ‚ â†¦ ListBlank.induction_on Lâ‚‚ fun lâ‚‚ H â†¦ ?_
  wlog h : lâ‚.length â‰¤ lâ‚‚.length
  Â· cases le_total lâ‚.length lâ‚‚.length <;> [skip; symm] <;> apply this <;> try assumption
    intro
    rw [H]
  refine Quotient.sound' (Or.inl âŸ¨lâ‚‚.length - lâ‚.length, ?_âŸ©)
  refine List.ext_get ?_ fun i h hâ‚‚ â†¦ Eq.symm ?_
  Â· simp only [Nat.add_sub_cancel' h, List.length_append, List.length_replicate]
  simp only [ListBlank.nth_mk] at H
  cases' lt_or_le i lâ‚.length with h' h'
  Â· simp only [List.get_append _ h', List.get?_eq_get h, List.get?_eq_get h',
      â† List.getI_eq_get _ h, â† List.getI_eq_get _ h', H]
  Â· simp only [List.get_append_right' h', List.get_replicate, List.get?_eq_get h,
      List.get?_len_le h', â† List.getI_eq_default _ h', H, List.getI_eq_get _ h]"
Mathlib/Analysis/Calculus/LagrangeMultipliers.lean,IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d,IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d,c480a87bf98e8eb1bd5a2eec1b3b1369bfff595d,":= by
  obtain âŸ¨Î›, Î›â‚€, hÎ›, hfÎ›âŸ© := hextr.exists_linear_map_of_hasStrictFDerivAt hf' hÏ†'
  refine' âŸ¨Î› 1, Î›â‚€, _, _âŸ©
  Â· contrapose! hÎ›
    simp only [Prod.mk_eq_zero] at hÎ› âŠ¢
    refine' âŸ¨LinearMap.ext fun x => _, hÎ›.2âŸ©
    simpa [hÎ›.1] using Î›.map_smul x 1
  Â· ext x
    have Hâ‚ : Î› (f' x) = f' x * Î› 1 := by
      simpa only [mul_one, Algebra.id.smul_eq_mul] using Î›.map_smul (f' x) 1
    have Hâ‚‚ : f' x * Î› 1 + Î›â‚€ * Ï†' x = 0 := by simpa only [Algebra.id.smul_eq_mul, Hâ‚] using hfÎ› x
    convert Hâ‚‚
    simp
    rw [Pi.smul_apply,smul_eq_mul,Pi.smul_apply,smul_eq_mul]
    ac_rfl","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?b â€¢ ?x) ?i
case h.e'_2
E : Type u_1
F : Type u_2
instâœâµ : NormedAddCommGroup E
instâœâ´ : NormedSpace â„ E
instâœÂ³ : CompleteSpace E
instâœÂ² : NormedAddCommGroup F
instâœÂ¹ : NormedSpace â„ F
instâœ : CompleteSpace F
fâœ : E â†’ F
Ï† : E â†’ â„
xâ‚€ : E
f'âœ : E â†’L[â„] F
Ï†' : E â†’L[â„] â„
f : E â†’ â„
f' : E â†’L[â„] â„
hextr : IsLocalExtrOn Ï† {x | f x = f xâ‚€} xâ‚€
hf' : HasStrictFDerivAt f f' xâ‚€
hÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€
Î› : Module.Dual â„ â„
Î›â‚€ : â„
hÎ› : (Î›, Î›â‚€) â‰  0
hfÎ› : âˆ€ (x : E), Î› (f' x) + Î›â‚€ â€¢ Ï†' x = 0
x : E
Hâ‚ : Î› (f' x) = f' x * Î› 1
Hâ‚‚ : f' x * Î› 1 + Î›â‚€ * Ï†' x = 0
âŠ¢ Î› (f' x) = f' x * Î› 1","theorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d {f : E â†’ â„} {f' : E â†’L[â„] â„}
    (hextr : IsLocalExtrOn Ï† {x | f x = f xâ‚€} xâ‚€) (hf' : HasStrictFDerivAt f f' xâ‚€)
    (hÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€) : âˆƒ a b : â„, (a, b) â‰  0 âˆ§ a â€¢ f' + b â€¢ Ï†' = 0 ",":= by
  obtain âŸ¨Î›, Î›â‚€, hÎ›, hfÎ›âŸ© := hextr.exists_linear_map_of_hasStrictFDerivAt hf' hÏ†'
  refine âŸ¨Î› 1, Î›â‚€, ?_, ?_âŸ©
  Â· contrapose! hÎ›
    simp only [Prod.mk_eq_zero] at hÎ› âŠ¢
    refine âŸ¨LinearMap.ext fun x => ?_, hÎ›.2âŸ©
    simpa [hÎ›.1] using Î›.map_smul x 1
  Â· ext x
    have Hâ‚ : Î› (f' x) = f' x * Î› 1 := by
      simpa only [mul_one, Algebra.id.smul_eq_mul] using Î›.map_smul (f' x) 1
    have Hâ‚‚ : f' x * Î› 1 + Î›â‚€ * Ï†' x = 0 := by simpa only [Algebra.id.smul_eq_mul, Hâ‚] using hfÎ› x
    simpa [mul_comm] using Hâ‚‚"
Mathlib/Algebra/Polynomial/Eval.lean,Polynomial.eval_comp,eval_comp,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction p with
  | h_add r s hr hs =>
    simp [add_comp, hr, hs]
  | h_monomial n a =>
    simp","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
error:  invalid alternative name 'h_add'",theorem eval_comp : (p.comp q).eval x = p.eval (q.eval x) ,":= by
  induction p using Polynomial.induction_on' with
  | h_add r s hr hs =>
    simp [add_comp, hr, hs]
  | h_monomial n a =>
    simp"
Mathlib/Topology/UniformSpace/Equicontinuity.lean,uniformEquicontinuous_restrict_iff,uniformEquicontinuous_restrict_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [UniformEquicontinuous, UniformEquicontinuousOn]
  conv in _ âŠ“ _ => rw [â† Subtype.range_val (s := S), â† range_prod_map, â† map_comap]","error:  unsolved goals
Î¹ : Type u_1
Îº : Type u_2
X : Type u_3
X' : Type u_4
Y : Type u_5
Z : Type u_6
Î± : Type u_7
Î±' : Type u_8
Î² : Type u_9
Î²' : Type u_10
Î³ : Type u_11
ğ“• : Type u_12
tX : TopologicalSpace X
tY : TopologicalSpace Y
tZ : TopologicalSpace Z
uÎ± : UniformSpace Î±
uÎ² : UniformSpace Î²
uÎ³ : UniformSpace Î³
F : Î¹ â†’ Î² â†’ Î±
S : Set Î²
âŠ¢ (âˆ€ U âˆˆ ğ“¤ Î±, âˆ€á¶  (xy : â†‘S Ã— â†‘S) in ğ“¤ â†‘S, âˆ€ (i : Î¹), ((S.restrict âˆ˜ F) i xy.1, (S.restrict âˆ˜ F) i xy.2) âˆˆ U) â†”
    âˆ€ U âˆˆ ğ“¤ Î±,
      âˆ€á¶  (xy : Î² Ã— Î²) in map (Prod.map Subtype.val Subtype.val) (Filter.comap (Prod.map Subtype.val Subtype.val) (ğ“¤ Î²)),
        âˆ€ (i : Î¹), (F i xy.1, F i xy.2) âˆˆ U","lemma uniformEquicontinuous_restrict_iff (F : Î¹ â†’ Î² â†’ Î±) {S : Set Î²} :
    UniformEquicontinuous (S.restrict âˆ˜ F) â†” UniformEquicontinuousOn F S ",":= by
  rw [UniformEquicontinuous, UniformEquicontinuousOn]
  conv in _ âŠ“ _ => rw [â† Subtype.range_val (s := S), â† range_prod_map, â† map_comap]
  rfl"
Mathlib/NumberTheory/Liouville/LiouvilleWith.lean,LiouvilleWith.mul_rat,mul_rat,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  rcases h.exists_pos with âŸ¨C, _hCâ‚€, hCâŸ©
  refine âŸ¨r.den ^ p * (|r| * C), (tendsto_id.nsmul_atTop r.pos).frequently (hC.mono ?_)âŸ©
  rintro n âŸ¨_hn, m, hne, hltâŸ©
  have A : (â†‘(r.num * m) : â„) / â†‘(r.den â€¢ id n) = m / n * r := by
    simp [â† div_mul_div_comm, â† r.cast_def, mul_comm]
  refine âŸ¨r.num * m, ?_, ?_âŸ©
  Â· rw [A]; simp [hne, hr]
  Â· rw [A, â† sub_mul, abs_mul]
    simp only [smul_eq_mul, id.def, Nat.cast_mul]
    calc _ < C / â†‘n ^ p * |â†‘r| := by gcongr
      _ = â†‘r.den ^ p * (â†‘|r| * C) / (â†‘r.den * â†‘n) ^ p := ?_
    rw [mul_rpow, mul_div_mul_left, mul_comm, mul_div_assoc]
    Â· simp only [Rat.cast_abs, le_refl]
    have := r.pos
    all_goals positivity","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.28728 â†’ ?m.28728",theorem mul_rat (h : LiouvilleWith p x) (hr : r â‰  0) : LiouvilleWith p (x * r) ,":= by
  rcases h.exists_pos with âŸ¨C, _hCâ‚€, hCâŸ©
  refine âŸ¨r.den ^ p * (|r| * C), (tendsto_id.nsmul_atTop r.pos).frequently (hC.mono ?_)âŸ©
  rintro n âŸ¨_hn, m, hne, hltâŸ©
  have A : (â†‘(r.num * m) : â„) / â†‘(r.den â€¢ id n) = m / n * r := by
    simp [â† div_mul_div_comm, â† r.cast_def, mul_comm]
  refine âŸ¨r.num * m, ?_, ?_âŸ©
  Â· rw [A]; simp [hne, hr]
  Â· rw [A, â† sub_mul, abs_mul]
    simp only [smul_eq_mul, id, Nat.cast_mul]
    calc _ < C / â†‘n ^ p * |â†‘r| := by gcongr
      _ = â†‘r.den ^ p * (â†‘|r| * C) / (â†‘r.den * â†‘n) ^ p := ?_
    rw [mul_rpow, mul_div_mul_left, mul_comm, mul_div_assoc]
    Â· simp only [Rat.cast_abs, le_refl]
    all_goals positivity"
Mathlib/GroupTheory/Perm/Sign.lean,Equiv.Perm.swap_induction_on,swap_induction_on,0b593c4cac2f2b5f72ecc13e661b05ddd6c61a94,":= by
  cases nonempty_fintype Î±
  cases' (truncSwapFactors f).out with l hl
  induction' l with g l ih generalizing f
  Â· simp (config := { contextual := true }) only [hl.left.symm, List.prod_nil, forall_true_iff]
  Â· intro h1 hmul_swap
    rcases hl.2 g (by simp) with âŸ¨x, y, hxyâŸ©
    rw [â† hl.1, List.prod_cons', hxy.2]
    exact
      hmul_swap _ _ _ hxy.1
        (ih _ âŸ¨rfl, fun v hv => hl.2 _ (List.mem_cons_of_mem _ hv)âŸ© h1 hmul_swap)","error:  unknown constant 'List.prod_cons''
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.12121
case intro.mk.cons.intro.intro
Î± : Type u
instâœÂ¹ : DecidableEq Î±
Î² : Type v
instâœ : Finite Î±
P : Perm Î± â†’ Prop
valâœ : Fintype Î±
g : Perm Î±
l : List (Perm Î±)
ih :
  âˆ€ (f : Perm Î±),
    (l.prod = f âˆ§ âˆ€ g âˆˆ l, g.IsSwap) â†’ P 1 â†’ (âˆ€ (f : Perm Î±) (x y : Î±), x â‰  y â†’ P f â†’ P (swap x y * f)) â†’ P f
f : Perm Î±
hl : (g :: l).prod = f âˆ§ âˆ€ g_1 âˆˆ g :: l, g_1.IsSwap
h1 : P 1
hmul_swap : âˆ€ (f : Perm Î±) (x y : Î±), x â‰  y â†’ P f â†’ P (swap x y * f)
x y : Î±
hxy : x â‰  y âˆ§ g = swap x y
âŠ¢ P (g :: l).prod","theorem swap_induction_on [Finite Î±] {P : Perm Î± â†’ Prop} (f : Perm Î±) :
    P 1 â†’ (âˆ€ f x y, x â‰  y â†’ P f â†’ P (swap x y * f)) â†’ P f ",":= by
  cases nonempty_fintype Î±
  cases' (truncSwapFactors f).out with l hl
  induction' l with g l ih generalizing f
  Â· simp (config := { contextual := true }) only [hl.left.symm, List.prod_nil, forall_true_iff]
  Â· intro h1 hmul_swap
    rcases hl.2 g (by simp) with âŸ¨x, y, hxyâŸ©
    rw [â† hl.1, List.prod_cons, hxy.2]
    exact
      hmul_swap _ _ _ hxy.1
        (ih _ âŸ¨rfl, fun v hv => hl.2 _ (List.mem_cons_of_mem _ hv)âŸ© h1 hmul_swap)"
Mathlib/MeasureTheory/Integral/IntervalIntegral.lean,intervalIntegral.intervalIntegral_eq_integral_uIoc,intervalIntegral_eq_integral_uIoc,66caaeed4dccada03ce195a3f9db1c0009ee8118,":= by
  split_ifs with h
  Â· simp only [integral_of_le h, uIoc_of_le h, one_smul]
  Â· simp only [integral_of_ge (not_le.1 h).le, uIoc_of_lt (not_le.1 h), neg_one_smul]","error:  unknown identifier 'uIoc_of_lt'
error:  unsolved goals
case neg
Î¹ : Type u_1
ğ•œ : Type u_2
E : Type u_3
F : Type u_4
A : Type u_5
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : CompleteSpace E
instâœ : NormedSpace â„ E
aâœ bâœ : â„
fâœ g : â„ â†’ E
Î¼âœ : Measure â„
f : â„ â†’ E
a b : â„
Î¼ : Measure â„
h : Â¬a â‰¤ b
âŠ¢ -âˆ« (x : â„) in Ioc b a, f x âˆ‚Î¼ = -âˆ« (x : â„) in Î™ a b, f x âˆ‚Î¼","theorem intervalIntegral_eq_integral_uIoc (f : â„ â†’ E) (a b : â„) (Î¼ : Measure â„) :
    âˆ« x in a..b, f x âˆ‚Î¼ = (if a â‰¤ b then 1 else -1 : â„) â€¢ âˆ« x in Î™ a b, f x âˆ‚Î¼ ",":= by
  split_ifs with h
  Â· simp only [integral_of_le h, uIoc_of_le h, one_smul]
  Â· simp only [integral_of_ge (not_le.1 h).le, uIoc_of_ge (not_le.1 h).le, neg_one_smul]"
Mathlib/MeasureTheory/Function/SimpleFunc.lean,Measurable.add_simpleFunc,_root_.Measurable.add_simpleFunc,0a9bb39c356a429bfc1e9e10af35f15fc6b79fff,":= by
  classical
  induction' f using SimpleFunc.induction with c s hs f f' hff' hf hf'
  Â· simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,
      SimpleFunc.coe_zero]
    change Measurable (g + s.piecewise (Function.const Î± c) (0 : Î± â†’ E))
    rw [â† s.piecewise_same g, â† piecewise_add]
    exact Measurable.piecewise hs (hg.add_const _) (hg.add_const _)
  Â· have : (g + â†‘(f + f'))
        = (Function.support f).piecewise (g + (f : Î± â†’ E)) (g + f') := by
      ext x
      by_cases hx : x âˆˆ Function.support f
      Â· simpa only [SimpleFunc.coe_add, Pi.add_apply, Function.mem_support, ne_eq, not_not,
          Set.piecewise_eq_of_mem _ _ _ hx, add_right_inj, add_right_eq_self]
          using Set.disjoint_left.1 hff' hx
      Â· simpa only [SimpleFunc.coe_add, Pi.add_apply, Function.mem_support, ne_eq, not_not,
          Set.piecewise_eq_of_not_mem _ _ _ hx, add_right_inj, add_left_eq_self] using hx
    rw [this]
    exact Measurable.piecewise f.measurableSet_support hf hf'","error:  ambiguous, possible interpretations 
  _root_.add_right_inj : âˆ€ (a : ?m.261149) {b c : ?m.261149}, a + b = a + c â†” b = c
  
  ENNReal.add_right_inj : ?m.261249 â‰  âŠ¤ â†’ (?m.261249 + ?m.261250 = ?m.261249 + ?m.261251 â†” ?m.261250 = ?m.261251)
error:  type mismatch
  hâœ
has type
  â†‘f' x = 0 : Prop
but is expected to have type
  g x + (â†‘f x + â†‘f' x) = g x + â†‘f x : Prop
error:  ambiguous, possible interpretations 
  _root_.add_right_inj : âˆ€ (a : ?m.262297) {b c : ?m.262297}, a + b = a + c â†” b = c
  
  ENNReal.add_right_inj : ?m.262397 â‰  âŠ¤ â†’ (?m.262397 + ?m.262398 = ?m.262397 + ?m.262399 â†” ?m.262398 = ?m.262399)
error:  type mismatch
  hâœ
has type
  â†‘f x = 0 : Prop
but is expected to have type
  g x + (â†‘f x + â†‘f' x) = g x + â†‘f' x : Prop","theorem _root_.Measurable.add_simpleFunc
    {E : Type*} {_ : MeasurableSpace Î±} [MeasurableSpace E] [AddGroup E] [MeasurableAdd E]
    {g : Î± â†’ E} (hg : Measurable g) (f : SimpleFunc Î± E) :
    Measurable (g + (f : Î± â†’ E)) ",":= by
  classical
  induction' f using SimpleFunc.induction with c s hs f f' hff' hf hf'
  Â· simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,
      SimpleFunc.coe_zero]
    change Measurable (g + s.piecewise (Function.const Î± c) (0 : Î± â†’ E))
    rw [â† s.piecewise_same g, â† piecewise_add]
    exact Measurable.piecewise hs (hg.add_const _) (hg.add_const _)
  Â· have : (g + â†‘(f + f'))
        = (Function.support f).piecewise (g + (f : Î± â†’ E)) (g + f') := by
      ext x
      by_cases hx : x âˆˆ Function.support f
      Â· simpa only [SimpleFunc.coe_add, Pi.add_apply, Function.mem_support, ne_eq, not_not,
          Set.piecewise_eq_of_mem _ _ _ hx, _root_.add_right_inj, add_right_eq_self]
          using Set.disjoint_left.1 hff' hx
      Â· simpa only [SimpleFunc.coe_add, Pi.add_apply, Function.mem_support, ne_eq, not_not,
          Set.piecewise_eq_of_not_mem _ _ _ hx, _root_.add_right_inj, add_left_eq_self] using hx
    rw [this]
    exact Measurable.piecewise f.measurableSet_support hf hf'"
Mathlib/LinearAlgebra/FreeModule/PID.lean,Basis.SmithNormalForm.repr_eq_zero_of_nmem_range,repr_eq_zero_of_nmem_range,1fa13fb0c5b2b03073245ecc37ab5748f4cc0358,":= by
  obtain âŸ¨m, hmâŸ© := m
  obtain âŸ¨c, rflâŸ© := snf.bN.mem_submodule_iff.mp hm
  replace hi : âˆ€ j, snf.f j â‰  i := by simpa using hi
  simp [Finsupp.single_apply, hi, snf.snf]","error:  unsolved goals
case mk.intro
Î¹ : Type u_1
R : Type u_2
instâœâ´ : CommRing R
instâœÂ³ : IsDomain R
instâœÂ² : IsPrincipalIdealRing R
M : Type u_3
instâœÂ¹ : AddCommGroup M
instâœ : Module R M
b : Î¹ â†’ M
n : â„•
N : Submodule R M
snf : SmithNormalForm N Î¹ n
i : Î¹
c : Fin n â†’â‚€ R
hm : (c.sum fun i x â†¦ x â€¢ â†‘(snf.bN i)) âˆˆ N
hi : âˆ€ (j : Fin n), snf.f j â‰  i
âŠ¢ (snf.bM.repr (c.sum fun i x â†¦ x â€¢ snf.a i â€¢ snf.bM (snf.f i))) i = 0","lemma repr_eq_zero_of_nmem_range {i : Î¹} (hi : i âˆ‰ Set.range snf.f) :
    snf.bM.repr m i = 0 ",":= by
  obtain âŸ¨m, hmâŸ© := m
  obtain âŸ¨c, rflâŸ© := snf.bN.mem_submodule_iff.mp hm
  replace hi : âˆ€ j, snf.f j â‰  i := by simpa using hi
  simp [Finsupp.single_apply, hi, snf.snf, map_finsupp_sum]"
Mathlib/Data/Seq/Computation.lean,Computation.liftRel_pure_left,liftRel_pure_left,3c930599229893e1b6a931304cf4efff4a01b172,":=
  âŸ¨fun âŸ¨l, _âŸ© => l (mem_pure _), fun âŸ¨b, mb, abâŸ© =>
    âŸ¨fun {a'} ma' => by rw [â† eq_of_mem_pure ma']; exact âŸ¨b, mb, abâŸ©, fun {b'} mb' =>
      âŸ¨_, mem_pure _, by rw [mem_unique mb' mb]; exact abâŸ©âŸ©âŸ©","error:  unknown identifier 'mem_pure'
error:  unknown identifier 'mem_pure'
error:  unknown identifier 'eq_of_mem_pure'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.59893
Î± : Type u
Î² : Type v
Î³ : Type w
R : Î± â†’ Î² â†’ Prop
a : Î±
cb : Computation Î²
xâœ : âˆƒ b, b âˆˆ cb âˆ§ R a b
b : Î²
mb : b âˆˆ cb
ab : R a b
a' : Î±
ma' : a' âˆˆ pure a
âŠ¢ âˆƒ b, b âˆˆ cb âˆ§ R a' b
error:  tactic 'rewrite' failed, motive is not type correct
Î± : Type u
Î² : Type v
Î³ : Type w
R : Î± â†’ Î² â†’ Prop
a : Î±
cb : Computation Î²
xâœ : âˆƒ b, b âˆˆ cb âˆ§ R a b
b : Î²
mb : b âˆˆ cb
ab : R a b
b' : Î²
mb' : b' âˆˆ cb
âŠ¢ R (?m.59886 xâœ b mb ab mb') b'","theorem liftRel_pure_left (R : Î± â†’ Î² â†’ Prop) (a : Î±) (cb : Computation Î²) :
    LiftRel R (pure a) cb â†” âˆƒ b, b âˆˆ cb âˆ§ R a b ",":=
  âŸ¨fun âŸ¨l, _âŸ© => l (ret_mem _), fun âŸ¨b, mb, abâŸ© =>
    âŸ¨fun {a'} ma' => by rw [eq_of_pure_mem ma']; exact âŸ¨b, mb, abâŸ©, fun {b'} mb' =>
      âŸ¨_, ret_mem _, by rw [mem_unique mb' mb]; exact abâŸ©âŸ©âŸ©"
Mathlib/Data/Fin/Tuple/Sort.lean,Tuple.unique_monotone,unique_monotone,977263ade15c4d82a6812c7a41d02864f9f79761,":=
  ofFn_injective <|
    eq_of_perm_of_sorted ((Ïƒ.ofFn_comp_perm f).trans (Ï„.ofFn_comp_perm f).symm)
      (List.Monotone.ofFn_sorted hfÏƒ)
      (List.Monotone.ofFn_sorted hfÏ„)","error:  unknown constant 'List.Monotone.ofFn_sorted'
error:  unknown constant 'List.Monotone.ofFn_sorted'","theorem unique_monotone [PartialOrder Î±] {f : Fin n â†’ Î±} {Ïƒ Ï„ : Equiv.Perm (Fin n)}
    (hfÏƒ : Monotone (f âˆ˜ Ïƒ)) (hfÏ„ : Monotone (f âˆ˜ Ï„)) : f âˆ˜ Ïƒ = f âˆ˜ Ï„ ",":=
  ofFn_injective <|
    eq_of_perm_of_sorted ((Ïƒ.ofFn_comp_perm f).trans (Ï„.ofFn_comp_perm f).symm)
      hfÏƒ.ofFn_sorted hfÏ„.ofFn_sorted"
Mathlib/Data/Nat/Fib/Basic.lean,Nat.fib_two_mul,fib_two_mul,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  cases n
  Â· simp
  Â· rw [Nat.succ_eq_add_one, two_mul, â† add_assoc, fib_add, fib_add_two, two_mul]
    simp only [â† add_assoc, add_tsub_cancel_right]
    ring","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ
nâœ : â„•
âŠ¢ fib (2 * (nâœ + 1)) = fib (nâœ + 1) * (2 * fib (nâœ + 1 + 1) - fib (nâœ + 1))
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated",theorem fib_two_mul (n : â„•) : fib (2 * n) = fib n * (2 * fib (n + 1) - fib n) ,":= by
  cases n
  Â· simp
  Â· rw [two_mul, â† add_assoc, fib_add, fib_add_two, two_mul]
    simp only [â† add_assoc, add_tsub_cancel_right]
    ring"
Mathlib/Analysis/Analytic/Constructions.lean,AnalyticAt.pow,AnalyticAt.pow,5fb9beab28702fb284701d494bc9b7c5f52fef53,":= by
  induction' n with m hm
  Â· simp only [Nat.zero_eq, pow_zero]
    apply analyticAt_const
  Â· simp only [pow_succ]
    exact hf.mul hm","error:  type mismatch
  mul hf hm
has type
  AnalyticAt ğ•œ (fun x â†¦ f x * f x ^ m) z : Prop
but is expected to have type
  AnalyticAt ğ•œ (fun x â†¦ f x ^ m * f x) z : Prop","lemma AnalyticAt.pow {f : E â†’ A} {z : E} (hf : AnalyticAt ğ•œ f z) (n : â„•) :
    AnalyticAt ğ•œ (fun x â†¦ f x ^ n) z ",":= by
  induction n with
  | zero =>
    simp only [Nat.zero_eq, pow_zero]
    apply analyticAt_const
  | succ m hm =>
    simp only [pow_succ]
    exact hm.mul hf"
Mathlib/Algebra/GroupWithZero/Units/Basic.lean,GroupWithZero.eq_zero_or_unit,_root_.GroupWithZero.eq_zero_or_unit,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  by_cases h : a = 0
  Â· left
    exact h
  Â· right
    simpa only [eq_comm] using Units.exists_iff_ne_zero.mpr h","error:  application type mismatch
  exists_iff_ne_zero.mpr h
argument
  h
has type
  Â¬a = 0 : Prop
but is expected to have type
  âˆƒ x, x â‰  0 âˆ§ ?m.17130 x : Prop
warning:  `IsUnit.div_mul_left` has been deprecated, use `div_mul_cancel_right` instead
warning:  `IsUnit.div_mul_right` has been deprecated, use `div_mul_cancel_left` instead","theorem _root_.GroupWithZero.eq_zero_or_unit (a : Gâ‚€) : a = 0 âˆ¨ âˆƒ u : Gâ‚€Ë£, a = u ",":= by
  simpa using em _"
Mathlib/Analysis/Convex/Combination.lean,Set.Finite.convexHull_eq_image,Set.Finite.convexHull_eq_image,9b142a34ca7f54087659561fbf3f33a84286fd96,":= by
  letI := hs.fintype
  rw [â† convexHull_basis_eq_stdSimplex, â† LinearMap.convexHull_image, â† Set.range_comp]
  apply congr_arg
  simp_rw [Function.comp]
  convert Subtype.range_coe.symm
  simp [LinearMap.sum_apply, ite_smul, Finset.filter_eq, Finset.mem_univ]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.568565 â†’+* ?m.568566) â†’
    (M : Type ?u.568562) â†’
      (Mâ‚‚ : Type ?u.568561) â†’
        [inst : AddCommMonoid M] â†’
          [inst_1 : AddCommMonoid Mâ‚‚] â†’
            [inst : Module ?m.568565 M] â†’ [inst : Module ?m.568566 Mâ‚‚] â†’ Type (max ?u.568562 ?u.568561)
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.568634
R : Type u_1
R' : Type u_2
E : Type u_3
F : Type u_4
Î¹ : Type u_5
Î¹' : Type u_6
Î± : Type u_7
instâœâ¹ : LinearOrderedField R
instâœâ¸ : LinearOrderedField R'
instâœâ· : AddCommGroup E
instâœâ¶ : AddCommGroup F
instâœâµ : LinearOrderedAddCommGroup Î±
instâœâ´ : Module R E
instâœÂ³ : Module R F
instâœÂ² : Module R Î±
instâœÂ¹ : OrderedSMul R Î±
sâœ : Set E
i j : Î¹
c : R
t : Finset Î¹
w : Î¹ â†’ R
z : Î¹ â†’ E
instâœ : Fintype Î¹
f : Î¹ â†’ R
s : Set E
hs : s.Finite
this : Fintype â†‘s := hs.fintype
âŠ¢ (convexHull R) s =
    â‡‘(âˆ‘ x : â†‘s, (LinearMap.proj x).smulRight â†‘x) '' (convexHull R) (range fun i j â†¦ if i = j then 1 else 0)","theorem Set.Finite.convexHull_eq_image {s : Set E} (hs : s.Finite) : convexHull R s =
    haveI := hs.fintype
    (â‡‘(âˆ‘ x : s, (@LinearMap.proj R s _ (fun _ => R) _ _ x).smulRight x.1)) '' stdSimplex R s ",":= by
  letI := hs.fintype
  rw [â† convexHull_basis_eq_stdSimplex, LinearMap.image_convexHull, â† Set.range_comp]
  apply congr_arg
  simp_rw [Function.comp]
  convert Subtype.range_coe.symm
  simp [LinearMap.sum_apply, ite_smul, Finset.filter_eq, Finset.mem_univ]"
Mathlib/MeasureTheory/Measure/Haar/Unique.lean,MeasureTheory.Measure.haarScalarFactor_eq_mul,haarScalarFactor_eq_mul,63aaa8cc21050b7a5cb193c6764569918728723b,":= by
  by_cases hG : LocallyCompactSpace G; swap
  Â· simp [haarScalarFactor, hG]
  obtain âŸ¨âŸ¨g, g_contâŸ©, g_comp, g_nonneg, g_oneâŸ© :
    âˆƒ (g : C(G, â„)), HasCompactSupport g âˆ§ 0 â‰¤ g âˆ§ g 1 â‰  0 := exists_continuous_nonneg_pos 1
  have Z := integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼' Î¼ g_cont g_comp
  simp only [integral_smul_nnreal_measure, smul_smul,
    integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼' Î½ g_cont g_comp,
    integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼ Î½ g_cont g_comp] at Z
  have int_g_pos : 0 < âˆ« x, g x âˆ‚Î½ := by
    apply (integral_pos_iff_support_of_nonneg g_nonneg _).2
    Â· exact IsOpen.measure_pos Î½ g_cont.isOpen_support âŸ¨1, g_oneâŸ©
    Â· exact g_cont.integrable_of_hasCompactSupport g_comp
  change (haarScalarFactor Î¼' Î½ : â„) * âˆ« (x : G), g x âˆ‚Î½ =
    (haarScalarFactor Î¼' Î¼ * haarScalarFactor Î¼ Î½ : â„â‰¥0) * âˆ« (x : G), g x âˆ‚Î½ at Z
  simpa only [mul_eq_mul_right_iff (Mâ‚€ := â„), int_g_pos.ne', or_false, NNReal.eq_iff] using Z","error:  unknown constant 'addHaarScalarFactor_pos_of_isAddHaarMeasure'
error:  application type mismatch
  @haarScalarFactor_pos_of_isHaarMeasure G instâœâ· instâœâ¶
argument has type
  AddGroup G
but function has type
  âˆ€ [inst : Group G] [inst_1 : TopologicalGroup G] [inst_2 : MeasurableSpace G] [inst_3 : BorelSpace G]
    (Î¼' Î¼ : Measure G) [inst_4 : Î¼.IsHaarMeasure] [inst_5 : Î¼'.IsHaarMeasure], 0 < Î¼'.haarScalarFactor Î¼
error:  @[to_additive] failed. Type mismatch in additive declaration. For help, see the docstring of `to_additive.attr`, section `Troubleshooting`. Failed to add declaration
MeasureTheory.Measure.measure_isAddHaarMeasure_eq_smul_of_isOpen:
unknown constant 'MeasureTheory.Measure.measure_isAddHaarMeasure_eq_smul_of_isEverywherePos'","lemma haarScalarFactor_eq_mul (Î¼' Î¼ Î½ : Measure G)
    [IsHaarMeasure Î¼] [IsHaarMeasure Î½] [IsFiniteMeasureOnCompacts Î¼'] [IsMulLeftInvariant Î¼'] :
    haarScalarFactor Î¼' Î½ = haarScalarFactor Î¼' Î¼ * haarScalarFactor Î¼ Î½ ",":= by
  by_cases hG : LocallyCompactSpace G; swap
  Â· simp [haarScalarFactor, hG]
  obtain âŸ¨âŸ¨g, g_contâŸ©, g_comp, g_nonneg, g_oneâŸ© :
    âˆƒ (g : C(G, â„)), HasCompactSupport g âˆ§ 0 â‰¤ g âˆ§ g 1 â‰  0 := exists_continuous_nonneg_pos 1
  have Z := integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼' Î¼ g_cont g_comp
  simp only [integral_smul_nnreal_measure, smul_smul,
    integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼' Î½ g_cont g_comp,
    integral_isMulLeftInvariant_eq_smul_of_hasCompactSupport Î¼ Î½ g_cont g_comp] at Z
  have int_g_pos : 0 < âˆ« x, g x âˆ‚Î½ := by
    apply (integral_pos_iff_support_of_nonneg g_nonneg _).2
    Â· exact IsOpen.measure_pos Î½ g_cont.isOpen_support âŸ¨1, g_oneâŸ©
    Â· exact g_cont.integrable_of_hasCompactSupport g_comp
  change (haarScalarFactor Î¼' Î½ : â„) * âˆ« (x : G), g x âˆ‚Î½ =
    (haarScalarFactor Î¼' Î¼ * haarScalarFactor Î¼ Î½ : â„â‰¥0) * âˆ« (x : G), g x âˆ‚Î½ at Z
  simpa only [mul_eq_mul_right_iff (Mâ‚€ := â„), int_g_pos.ne', or_false, NNReal.eq_iff] using Z

  @[to_additive]"
Mathlib/Analysis/NormedSpace/Exponential.lean,NormedSpace.expSeries_radius_eq_top,expSeries_radius_eq_top,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  refine (expSeries ğ•‚ ğ”¸).radius_eq_top_of_summable_norm fun r => ?_
  refine' .of_norm_bounded_eventually _ (Real.summable_pow_div_factorial r) _
  filter_upwards [eventually_cofinite_ne 0] with n hn
  rw [norm_mul, norm_norm (expSeries ğ•‚ ğ”¸ n), expSeries]
  rw [norm_smul (n ! : ğ•‚)â»Â¹ (ContinuousMultilinearMap.mkPiAlgebraFin ğ•‚ n ğ”¸)]
  rw [norm_inv, norm_pow, NNReal.norm_eq, norm_natCast, mul_comm, â† mul_assoc, â† div_eq_mul_inv]
  have : â€–ContinuousMultilinearMap.mkPiAlgebraFin ğ•‚ n ğ”¸â€– â‰¤ 1 :=
    norm_mkPiAlgebraFin_le_of_pos (Ei := fun _ => ğ”¸) (Nat.pos_of_ne_zero hn)
  exact mul_le_of_le_one_right (div_nonneg (pow_nonneg r.coe_nonneg n) n !.cast_nonneg) this",error:  invalid argument name 'Ei' for function 'ContinuousMultilinearMap.norm_mkPiAlgebraFin_le_of_pos',theorem expSeries_radius_eq_top : (expSeries ğ•‚ ğ”¸).radius = âˆ ,":= by
  refine (expSeries ğ•‚ ğ”¸).radius_eq_top_of_summable_norm fun r => ?_
  refine .of_norm_bounded_eventually _ (Real.summable_pow_div_factorial r) ?_
  filter_upwards [eventually_cofinite_ne 0] with n hn
  rw [norm_mul, norm_norm (expSeries ğ•‚ ğ”¸ n), expSeries]
  rw [norm_smul (n ! : ğ•‚)â»Â¹ (ContinuousMultilinearMap.mkPiAlgebraFin ğ•‚ n ğ”¸)]
  rw [norm_inv, norm_pow, NNReal.norm_eq, norm_natCast, mul_comm, â† mul_assoc, â† div_eq_mul_inv]
  have : â€–ContinuousMultilinearMap.mkPiAlgebraFin ğ•‚ n ğ”¸â€– â‰¤ 1 :=
    norm_mkPiAlgebraFin_le_of_pos (Nat.pos_of_ne_zero hn)
  exact mul_le_of_le_one_right (div_nonneg (pow_nonneg r.coe_nonneg n) n !.cast_nonneg) this"
Mathlib/CategoryTheory/Limits/Final.lean,CategoryTheory.Functor.cofinal_of_colimit_comp_coyoneda_iso_pUnit,cofinal_of_colimit_comp_coyoneda_iso_pUnit,a5cef87aa45fd4df3a366b971573bc689d2095a2,":=
  âŸ¨fun d => by
    have : Nonempty (StructuredArrow d F) := by
      have := (I d).inv PUnit.unit
      obtain âŸ¨j, y, rflâŸ© := Limits.Types.jointly_surjective'.{v, v} this
      exact âŸ¨StructuredArrow.mk yâŸ©
    apply zigzag_isConnected
    rintro âŸ¨âŸ¨âŸ¨âŸ©âŸ©, Xâ‚, fâ‚âŸ© âŸ¨âŸ¨âŸ¨âŸ©âŸ©, Xâ‚‚, fâ‚‚âŸ©
    dsimp at *
    let yâ‚ := colimit.Î¹ (F â‹™ coyoneda.obj (op d)) Xâ‚ fâ‚
    let yâ‚‚ := colimit.Î¹ (F â‹™ coyoneda.obj (op d)) Xâ‚‚ fâ‚‚
    have e : yâ‚ = yâ‚‚ := by
      apply (I d).toEquiv.injective
      ext
    have t := Types.colimit_eq.{v, v} e
    clear e yâ‚ yâ‚‚
    exact zigzag_of_eqvGen_quot_rel tâŸ©",error:  dsimp made no progress,"theorem cofinal_of_colimit_comp_coyoneda_iso_pUnit
    (I : âˆ€ d, colimit (F â‹™ coyoneda.obj (op d)) â‰… PUnit) : Final F ",":=
  âŸ¨fun d => by
    have : Nonempty (StructuredArrow d F) := by
      have := (I d).inv PUnit.unit
      obtain âŸ¨j, y, rflâŸ© := Limits.Types.jointly_surjective'.{v, v} this
      exact âŸ¨StructuredArrow.mk yâŸ©
    apply zigzag_isConnected
    rintro âŸ¨âŸ¨âŸ¨âŸ©âŸ©, Xâ‚, fâ‚âŸ© âŸ¨âŸ¨âŸ¨âŸ©âŸ©, Xâ‚‚, fâ‚‚âŸ©
    let yâ‚ := colimit.Î¹ (F â‹™ coyoneda.obj (op d)) Xâ‚ fâ‚
    let yâ‚‚ := colimit.Î¹ (F â‹™ coyoneda.obj (op d)) Xâ‚‚ fâ‚‚
    have e : yâ‚ = yâ‚‚ := by
      apply (I d).toEquiv.injective
      ext
    have t := Types.colimit_eq.{v, v} e
    clear e yâ‚ yâ‚‚
    exact Final.zigzag_of_eqvGen_quot_rel tâŸ©"
Mathlib/Computability/Primrec.lean,PrimrecPred.and,_root_.PrimrecPred.and,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  (Primrec.and.compâ‚‚ hp hq).of_eq fun n => by simp","error:  application type mismatch
  Primrecâ‚‚.compâ‚‚ Primrec.and hp
argument
  hp
has type
  PrimrecPred p : Prop
but is expected to have type
  Primrecâ‚‚ ?m.92602 : Prop
error:  simp made no progress","theorem _root_.PrimrecPred.and {p q : Î± â†’ Prop} [DecidablePred p] [DecidablePred q]
    (hp : PrimrecPred p) (hq : PrimrecPred q) : PrimrecPred fun a => p a âˆ§ q a ",":=
  (Primrec.and.comp hp hq).of_eq fun n => by simp"
Mathlib/Analysis/Analytic/Composition.lean,FormalMultilinearSeries.comp_summable_nnreal,comp_summable_nnreal,4968eba95a704a4a58e8b3735dc3733ee6d46c0d,":= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hp) with âŸ¨rp, rp_pos, hrpâŸ©
  simp only [lt_min_iff, ENNReal.coe_lt_one_iff, ENNReal.coe_pos] at hrp hrq rp_pos rq_pos
  obtain âŸ¨Cq, _hCq0, hCqâŸ© : âˆƒ Cq > 0, âˆ€ n, â€–q nâ€–â‚Š * rq ^ n â‰¤ Cq :=
    q.nnnorm_mul_pow_le_of_lt_radius hrq.2
  obtain âŸ¨Cp, hCp1, hCpâŸ© : âˆƒ Cp â‰¥ 1, âˆ€ n, â€–p nâ€–â‚Š * rp ^ n â‰¤ Cp := by
    rcases p.nnnorm_mul_pow_le_of_lt_radius hrp.2 with âŸ¨Cp, -, hCpâŸ©
    exact âŸ¨max Cp 1, le_max_right _ _, fun n => (hCp n).trans (le_max_left _ _)âŸ©
  let r0 : â„â‰¥0 := (4 * Cp)â»Â¹
  have r0_pos : 0 < r0 := inv_pos.2 (mul_pos zero_lt_four (zero_lt_one.trans_le hCp1))
  set r : â„â‰¥0 := rp * rq * r0
  have r_pos : 0 < r := mul_pos (mul_pos rp_pos rq_pos) r0_pos
  have I :
    âˆ€ i : Î£ n : â„•, Composition n, â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 â‰¤ Cq / 4 ^ i.1 := by
    rintro âŸ¨n, câŸ©
    have A := calc
      â€–q c.lengthâ€–â‚Š * rq ^ n â‰¤ â€–q c.lengthâ€–â‚Š * rq ^ c.length :=
        mul_le_mul' le_rfl (pow_le_pow_of_le_one rq.2 hrq.1.le c.length_le)
      _ â‰¤ Cq := hCq _
    have B := calc
      (âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n = âˆ i, â€–p (c.blocksFun i)â€–â‚Š * rp ^ c.blocksFun i := by
        simp only [Finset.prod_mul_distrib, Finset.prod_pow_eq_pow_sum, c.sum_blocksFun]
      _ â‰¤ âˆ _i : Fin c.length, Cp := (Finset.prod_le_prod' fun i _ => hCp _)
      _ = Cp ^ c.length := by simp
      _ â‰¤ Cp ^ n := pow_le_pow_right hCp1 c.length_le
    calc
      â€–q.compAlongComposition p câ€–â‚Š * r ^ n â‰¤
          (â€–q c.lengthâ€–â‚Š * âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * r ^ n :=
        mul_le_mul' (q.compAlongComposition_nnnorm p c) le_rfl
      _ = â€–q c.lengthâ€–â‚Š * rq ^ n * ((âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n) * r0 ^ n := by
        simp only [mul_pow]; ring
      _ â‰¤ Cq * Cp ^ n * r0 ^ n := (mul_le_mul' (mul_le_mul' A B) le_rfl)
      _ = Cq / 4 ^ n := by
        simp only [r0]
        field_simp [mul_pow, (zero_lt_one.trans_le hCp1).ne']
        ring
  refine' âŸ¨r, r_pos, NNReal.summable_of_le I _âŸ©
  simp_rw [div_eq_mul_inv]
  refine' Summable.mul_left _ _
  have : âˆ€ n : â„•, HasSum (fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹) (2 ^ (n - 1) / 4 ^ n) := by
    intro n
    convert hasSum_fintype fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹
    simp [Finset.card_univ, composition_card, div_eq_mul_inv]
  refine' NNReal.summable_sigma.2 âŸ¨fun n => (this n).summable, (NNReal.summable_nat_add_iff 1).1 _âŸ©
  convert (NNReal.summable_geometric (NNReal.div_lt_one_of_lt one_lt_two)).mul_left (1 / 4) using 1
  ext1 n
  rw [(this _).tsum_eq, add_tsub_cancel_right]
  field_simp [â† mul_assoc, pow_succ, mul_pow, show (4 : â„â‰¥0) = 2 * 2 by norm_num,
    mul_right_comm]","error:  simp made no progress
warning:  `List.get_splitWrtComposition` has been deprecated, use `List.getElem_splitWrtComposition` instead
warning:  `List.get_drop'` has been deprecated, use `List.getElem_drop'` instead
warning:  `List.get_take'` has been deprecated, use `List.getElem_take` instead","theorem comp_summable_nnreal (q : FormalMultilinearSeries ğ•œ F G) (p : FormalMultilinearSeries ğ•œ E F)
    (hq : 0 < q.radius) (hp : 0 < p.radius) :
    âˆƒ r > (0 : â„â‰¥0),
      Summable fun i : Î£ n, Composition n => â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 ",":= by
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hq) with âŸ¨rq, rq_pos, hrqâŸ©
  rcases ENNReal.lt_iff_exists_nnreal_btwn.1 (lt_min zero_lt_one hp) with âŸ¨rp, rp_pos, hrpâŸ©
  simp only [lt_min_iff, ENNReal.coe_lt_one_iff, ENNReal.coe_pos] at hrp hrq rp_pos rq_pos
  obtain âŸ¨Cq, _hCq0, hCqâŸ© : âˆƒ Cq > 0, âˆ€ n, â€–q nâ€–â‚Š * rq ^ n â‰¤ Cq :=
    q.nnnorm_mul_pow_le_of_lt_radius hrq.2
  obtain âŸ¨Cp, hCp1, hCpâŸ© : âˆƒ Cp â‰¥ 1, âˆ€ n, â€–p nâ€–â‚Š * rp ^ n â‰¤ Cp := by
    rcases p.nnnorm_mul_pow_le_of_lt_radius hrp.2 with âŸ¨Cp, -, hCpâŸ©
    exact âŸ¨max Cp 1, le_max_right _ _, fun n => (hCp n).trans (le_max_left _ _)âŸ©
  let r0 : â„â‰¥0 := (4 * Cp)â»Â¹
  have r0_pos : 0 < r0 := inv_pos.2 (mul_pos zero_lt_four (zero_lt_one.trans_le hCp1))
  set r : â„â‰¥0 := rp * rq * r0
  have r_pos : 0 < r := mul_pos (mul_pos rp_pos rq_pos) r0_pos
  have I :
    âˆ€ i : Î£ n : â„•, Composition n, â€–q.compAlongComposition p i.2â€–â‚Š * r ^ i.1 â‰¤ Cq / 4 ^ i.1 := by
    rintro âŸ¨n, câŸ©
    have A := calc
      â€–q c.lengthâ€–â‚Š * rq ^ n â‰¤ â€–q c.lengthâ€–â‚Š * rq ^ c.length :=
        mul_le_mul' le_rfl (pow_le_pow_of_le_one rq.2 hrq.1.le c.length_le)
      _ â‰¤ Cq := hCq _
    have B := calc
      (âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n = âˆ i, â€–p (c.blocksFun i)â€–â‚Š * rp ^ c.blocksFun i := by
        simp only [Finset.prod_mul_distrib, Finset.prod_pow_eq_pow_sum, c.sum_blocksFun]
      _ â‰¤ âˆ _i : Fin c.length, Cp := Finset.prod_le_prod' fun i _ => hCp _
      _ = Cp ^ c.length := by simp
      _ â‰¤ Cp ^ n := pow_le_pow_right hCp1 c.length_le
    calc
      â€–q.compAlongComposition p câ€–â‚Š * r ^ n â‰¤
          (â€–q c.lengthâ€–â‚Š * âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * r ^ n :=
        mul_le_mul' (q.compAlongComposition_nnnorm p c) le_rfl
      _ = â€–q c.lengthâ€–â‚Š * rq ^ n * ((âˆ i, â€–p (c.blocksFun i)â€–â‚Š) * rp ^ n) * r0 ^ n := by
        ring
      _ â‰¤ Cq * Cp ^ n * r0 ^ n := mul_le_mul' (mul_le_mul' A B) le_rfl
      _ = Cq / 4 ^ n := by
        simp only [r0]
        field_simp [mul_pow, (zero_lt_one.trans_le hCp1).ne']
        ring
  refine âŸ¨r, r_pos, NNReal.summable_of_le I ?_âŸ©
  simp_rw [div_eq_mul_inv]
  refine Summable.mul_left _ ?_
  have : âˆ€ n : â„•, HasSum (fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹) (2 ^ (n - 1) / 4 ^ n) := by
    intro n
    convert hasSum_fintype fun c : Composition n => (4 ^ n : â„â‰¥0)â»Â¹
    simp [Finset.card_univ, composition_card, div_eq_mul_inv]
  refine NNReal.summable_sigma.2 âŸ¨fun n => (this n).summable, (NNReal.summable_nat_add_iff 1).1 ?_âŸ©
  convert (NNReal.summable_geometric (NNReal.div_lt_one_of_lt one_lt_two)).mul_left (1 / 4) using 1
  ext1 n
  rw [(this _).tsum_eq, add_tsub_cancel_right]
  field_simp [â† mul_assoc, pow_succ, mul_pow, show (4 : â„â‰¥0) = 2 * 2 by norm_num,
    mul_right_comm]"
Mathlib/Algebra/DirectLimit.lean,AddCommGroup.DirectLimit.map_comp,map_comp,f9a92ed3d67873862051aaeedcedfa1472745048,":=
  DFunLike.ext _ _ fun x â†¦ (isEmpty_or_nonempty Î¹).elim (by subsingleton) fun _ â†¦
    x.induction_on fun i g â†¦ by simp","error:  unknown tactic
error:  unsolved goals
R : Type u
instâœÂ¹Â¹ : Ring R
Î¹ : Type v
instâœÂ¹â° : Preorder Î¹
G : Î¹ â†’ Type w
instâœâ¹ : (i : Î¹) â†’ AddCommGroup (G i)
instâœâ¸ : (i : Î¹) â†’ Module R (G i)
f : (i j : Î¹) â†’ i â‰¤ j â†’ G i â†’â‚—[R] G j
instâœâ· : DecidableEq Î¹
P : Type uâ‚
instâœâ¶ : AddCommGroup P
instâœâµ : Module R P
g : (i : Î¹) â†’ G i â†’â‚—[R] P
Hg : âˆ€ (i j : Î¹) (hij : i â‰¤ j) (x : G i), (g j) ((f i j hij) x) = (g i) x
G' : Î¹ â†’ Type v'
instâœâ´ : (i : Î¹) â†’ AddCommGroup (G' i)
instâœÂ³ : (i : Î¹) â†’ Module R (G' i)
f' : (i j : Î¹) â†’ i â‰¤ j â†’ G' i â†’â‚—[R] G' j
G'' : Î¹ â†’ Type v''
instâœÂ² : (i : Î¹) â†’ AddCommGroup (G'' i)
instâœÂ¹ : (i : Î¹) â†’ Module R (G'' i)
f'' : (i j : Î¹) â†’ i â‰¤ j â†’ G'' i â†’â‚—[R] G'' j
instâœ : IsDirected Î¹ fun x x_1 â†¦ x â‰¤ x_1
gâ‚ : (i : Î¹) â†’ G i â†’â‚—[R] G' i
gâ‚‚ : (i : Î¹) â†’ G' i â†’â‚—[R] G'' i
hgâ‚ : âˆ€ (i j : Î¹) (h : i â‰¤ j), gâ‚ j âˆ˜â‚— f i j h = f' i j h âˆ˜â‚— gâ‚ i
hgâ‚‚ : âˆ€ (i j : Î¹) (h : i â‰¤ j), gâ‚‚ j âˆ˜â‚— f' i j h = f'' i j h âˆ˜â‚— gâ‚‚ i
x : DirectLimit G f
âŠ¢ IsEmpty Î¹ â†’ ?m.223200","lemma map_comp [IsDirected Î¹ (Â· â‰¤ Â·)]
    (gâ‚ : (i : Î¹) â†’ G i â†’â‚—[R] G' i) (gâ‚‚ : (i : Î¹) â†’ G' i â†’â‚—[R] G'' i)
    (hgâ‚ : âˆ€ i j h, gâ‚ j âˆ˜â‚— f i j h = f' i j h âˆ˜â‚— gâ‚ i)
    (hgâ‚‚ : âˆ€ i j h, gâ‚‚ j âˆ˜â‚— f' i j h = f'' i j h âˆ˜â‚— gâ‚‚ i) :
    (map gâ‚‚ hgâ‚‚ âˆ˜â‚— map gâ‚ hgâ‚ :
      DirectLimit G f â†’â‚—[R] DirectLimit G'' f'') =
    (map (fun i â†¦ gâ‚‚ i âˆ˜â‚— gâ‚ i) fun i j h â†¦ by
        rw [LinearMap.comp_assoc, hgâ‚ i, â† LinearMap.comp_assoc, hgâ‚‚ i, LinearMap.comp_assoc] :
      DirectLimit G f â†’â‚—[R] DirectLimit G'' f'') ",":=
  DFunLike.ext _ _ fun x â†¦ (isEmpty_or_nonempty Î¹).elim (fun _ â†¦ Subsingleton.elim _ _) fun _ â†¦
    x.induction_on fun i g â†¦ by simp"
Mathlib/Topology/Separation.lean,isPreirreducible_iff_subsingleton,isPreirreducible_iff_subsingleton,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine' âŸ¨fun h x hx y hy => _, Set.Subsingleton.isPreirreducibleâŸ©
  by_contra e
  obtain âŸ¨U, V, hU, hV, hxU, hyV, h'âŸ© := t2_separation e
  exact ((h U V hU hV âŸ¨x, hx, hxUâŸ© âŸ¨y, hy, hyVâŸ©).mono <| inter_subset_right _ _).not_disjoint h'","error:  function expected at
  inter_subset_right ?m.167339
term has type
  ?m.167338 âˆˆ ?m.167337","theorem isPreirreducible_iff_subsingleton [T2Space X] {S : Set X} :
    IsPreirreducible S â†” S.Subsingleton ",":= by
  refine âŸ¨fun h x hx y hy => ?_, Set.Subsingleton.isPreirreducibleâŸ©
  by_contra e
  obtain âŸ¨U, V, hU, hV, hxU, hyV, h'âŸ© := t2_separation e
  exact ((h U V hU hV âŸ¨x, hx, hxUâŸ© âŸ¨y, hy, hyVâŸ©).mono inter_subset_right).not_disjoint h'"
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.getD_leftInvSeq_mul_self,getD_leftInvSeq_mul_self,5549e23620db2b17d4924bff0c4de45d992f0b8d,":= by
  simp [getD_leftInvSeq, mul_assoc]
  rcases em (j < Ï‰.length) with hj | nhj
  Â· rw [get?_eq_get hj]
    simp [â† mul_assoc]
  Â· rw [get?_eq_none.mpr (by linarith)]
    simp","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Ï‰.get? j
case inl
B : Type u_1
W : Type u_2
instâœ : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
Ï‰ : List B
j : â„•
hj : j < Ï‰.length
âŠ¢ (cs.leftInvSeq Ï‰)[j]?.getD 1 * (cs.leftInvSeq Ï‰)[j]?.getD 1 = 1
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.99687.get? ?m.99688
case inr
B : Type u_1
W : Type u_2
instâœ : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
Ï‰ : List B
j : â„•
nhj : Â¬j < Ï‰.length
âŠ¢ (cs.leftInvSeq Ï‰)[j]?.getD 1 * (cs.leftInvSeq Ï‰)[j]?.getD 1 = 1","theorem getD_leftInvSeq_mul_self (Ï‰ : List B) (j : â„•) :
    ((lis Ï‰).getD j 1) * ((lis Ï‰).getD j 1) = 1 ",":= by
  simp_rw [getD_leftInvSeq, mul_assoc]
  rcases em (j < Ï‰.length) with hj | nhj
  Â· rw [get?_eq_get hj]
    simp [â† mul_assoc]
  Â· rw [get?_eq_none.mpr (by omega)]
    simp"
Mathlib/Data/Finset/Card.lean,Finset.card_eq_succ,card_eq_succ,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  âŸ¨fun h =>
    let âŸ¨a, hasâŸ© := card_pos.mp (h.symm â–¸ Nat.zero_lt_succ _ : 0 < s.card)
    âŸ¨a, s.erase a, s.not_mem_erase a, insert_erase has, by
      simp only [h, card_erase_of_mem has, add_tsub_cancel_right]âŸ©,
    fun âŸ¨a, t, hat, s_eq, n_eqâŸ© => s_eq â–¸ n_eq â–¸ card_insert_of_not_mem hatâŸ©","error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
R : Type u_3
s t u : Finset Î±
f : Î± â†’ Î²
n : â„•
instâœ : DecidableEq Î±
h : s.card = n + 1
a : Î±
has : a âˆˆ s
âŠ¢ n + 1 - 1 = n","theorem card_eq_succ : s.card = n + 1 â†” âˆƒ a t, a âˆ‰ t âˆ§ insert a t = s âˆ§ t.card = n ",":=
  âŸ¨fun h =>
    let âŸ¨a, hasâŸ© := card_pos.mp (h.symm â–¸ Nat.zero_lt_succ _ : 0 < s.card)
    âŸ¨a, s.erase a, s.not_mem_erase a, insert_erase has, by
      simp only [h, card_erase_of_mem has, Nat.add_sub_cancel_right]âŸ©,
    fun âŸ¨a, t, hat, s_eq, n_eqâŸ© => s_eq â–¸ n_eq â–¸ card_insert_of_not_mem hatâŸ©"
Mathlib/Order/RelSeries.lean,RelSeries.toList_chain',toList_chain',d705233f5ad595aa0eff7360af49f3887a0181f4,":= by
  rw [List.chain'_iff_get]
  intros i h
  have h' : i < x.length := by simpa [List.length_ofFn] using h
  convert x.step âŸ¨i, h'âŸ© <;>
  . rw [List.get_ofFn]
    congr 1","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (List.ofFn ?f).get ?i
case h.e'_1
Î± : Type u_1
r : Rel Î± Î±
Î² : Type u_2
s : Rel Î² Î²
x : RelSeries r
i : â„•
h : i < x.toList.length - 1
h' : i < x.length
âŠ¢ x.toList.get âŸ¨i, â‹¯âŸ© = x.toFun âŸ¨i, h'âŸ©.castSucc
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (List.ofFn ?f).get ?i
case h.e'_2
Î± : Type u_1
r : Rel Î± Î±
Î² : Type u_2
s : Rel Î² Î²
x : RelSeries r
i : â„•
h : i < x.toList.length - 1
h' : i < x.length
âŠ¢ x.toList.get âŸ¨i + 1, â‹¯âŸ© = x.toFun âŸ¨i, h'âŸ©.succ",lemma toList_chain' (x : RelSeries r) : x.toList.Chain' r ,":= by
  rw [List.chain'_iff_get]
  intros i h
  convert x.step âŸ¨i, by simpa [toList] using hâŸ© <;> apply List.get_ofFn"
Mathlib/Analysis/NormedSpace/Star/GelfandDuality.lean,gelfandTransform_bijective,gelfandTransform_bijective,8b24b7412473ebe3dfb3396b9609b7817f5d3868,":= by
  refine' âŸ¨(gelfandTransform_isometry A).injective, _âŸ©
  suffices (gelfandTransform â„‚ A).range = âŠ¤ by
    exact fun x => ((gelfandTransform â„‚ A).mem_range).mp (this.symm â–¸ Algebra.mem_top)
  have h : (gelfandTransform â„‚ A).range.topologicalClosure = (gelfandTransform â„‚ A).range :=
    le_antisymm
      (Subalgebra.topologicalClosure_minimal _ le_rfl
        (gelfandTransform_isometry A).closedEmbedding.closed_range)
      (Subalgebra.le_topologicalClosure _)
  refine' h â–¸ ContinuousMap.subalgebra_isROrC_topologicalClosure_eq_top_of_separatesPoints
    _ (fun _ _ => _) fun f hf => _
  Â· contrapose!
    exact fun h => Subtype.ext (ContinuousLinearMap.ext fun a =>
      h (gelfandTransform â„‚ A a) âŸ¨gelfandTransform â„‚ A a, âŸ¨a, rflâŸ©, rflâŸ©)
  Â· obtain âŸ¨f, âŸ¨a, rflâŸ©, rflâŸ© := Subalgebra.mem_map.mp hf
    refine' âŸ¨star a, ContinuousMap.ext fun Ïˆ => _âŸ©
    simp only [AlgHom.toRingHom_eq_coe, RingHom.coe_coe, gelfandTransform_apply_apply,
      AlgEquiv.toAlgHom_eq_coe, AlgHom.compLeftContinuous_apply_apply, AlgHom.coe_coe,
      IsROrC.conjAe_coe, map_star, starRingEnd_apply]","error:  invalid field 'closed_range', the environment does not contain 'ClosedEmbedding.closed_range'
  Isometry.closedEmbedding (gelfandTransform_isometry A)
has type
  ClosedEmbedding â‡‘(gelfandTransform â„‚ A)
error:  unknown constant 'ContinuousMap.subalgebra_isROrC_topologicalClosure_eq_top_of_separatesPoints'
error:  no goals to be solved",theorem gelfandTransform_bijective : Function.Bijective (gelfandTransform â„‚ A) ,":= by
  refine âŸ¨(gelfandTransform_isometry A).injective, ?_âŸ©
  let rng : StarSubalgebra â„‚ C(characterSpace â„‚ A, â„‚) :=
    { toSubalgebra := (gelfandTransform â„‚ A).range
      star_mem' := by
        rintro - âŸ¨a, rflâŸ©
        use star a
        ext1 Ï†
        dsimp
        simp only [map_star, RCLike.star_def] }
  suffices rng = âŠ¤ from
    fun x => show x âˆˆ rng from this.symm â–¸ StarSubalgebra.mem_top
  have h : rng.topologicalClosure = rng := le_antisymm
    (StarSubalgebra.topologicalClosure_minimal le_rfl
      (gelfandTransform_isometry A).closedEmbedding.isClosed_range)
    (StarSubalgebra.le_topologicalClosure _)
  refine h â–¸ ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints
    _ (fun _ _ => ?_)
  contrapose!
  exact fun h => Subtype.ext (ContinuousLinearMap.ext fun a =>
    h (gelfandTransform â„‚ A a) âŸ¨gelfandTransform â„‚ A a, âŸ¨a, rflâŸ©, rflâŸ©)"
Mathlib/Analysis/Analytic/Constructions.lean,Finset.analyticAt_prod,Finset.analyticAt_prod,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction' N with a B aB hB
  Â· simp only [Finset.prod_empty]
    exact analyticAt_const
  Â· simp_rw [Finset.prod_insert aB]
    simp only [Finset.mem_insert] at h
    exact (h a (Or.inl rfl)).mul (hB fun b m â†¦ h b (Or.inr m))","error:  simp made no progress
error:  no goals to be solved","theorem Finset.analyticAt_prod {A : Type*} [NormedCommRing A] [NormedAlgebra ğ•œ A]
    {f : Î± â†’ E â†’ A} {c : E} (N : Finset Î±) (h : âˆ€ n âˆˆ N, AnalyticAt ğ•œ (f n) c) :
    AnalyticAt ğ•œ (fun z â†¦ âˆ n âˆˆ N, f n z) c ",":= by
  induction' N using Finset.induction with a B aB hB
  Â· simp only [Finset.prod_empty]
    exact analyticAt_const
  Â· simp_rw [Finset.prod_insert aB]
    simp only [Finset.mem_insert] at h
    exact (h a (Or.inl rfl)).mul (hB fun b m â†¦ h b (Or.inr m))"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.liftRel_think_left,liftRel_think_left,88f252d9ef6777980e9cb4396094e178f3ed4acb,":= by
  rw [liftRel_dest_iff, liftRel_dest_iff]; simp","error:  unknown identifier 'liftRel_dest_iff'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.57715
Î± : Type u
Î² : Type v
Î³ : Type w
R : Î± â†’ Î² â†’ Prop
s : WSeq Î±
t : WSeq Î²
âŠ¢ LiftRel R s.think t â†” LiftRel R s t",theorem liftRel_think_left (R : Î± â†’ Î² â†’ Prop) (s t) : LiftRel R (think s) t â†” LiftRel R s t ,":= by
  rw [liftRel_destruct_iff, liftRel_destruct_iff]; simp"
Mathlib/NumberTheory/Bernoulli.lean,bernoulli'_odd_eq_zero,bernoulli'_odd_eq_zero,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  let B := mk fun n => bernoulli' n / (n ! : â„š)
  suffices (B - evalNegHom B) * (exp â„š - 1) = X * (exp â„š - 1) by
    cases' mul_eq_mul_right_iff.mp this with h h <;>
      simp only [PowerSeries.ext_iff, evalNegHom, coeff_X] at h
    Â· apply eq_zero_of_neg_eq
      specialize h n
      split_ifs at h <;> simp_all [h_odd.neg_one_pow, factorial_ne_zero]
    Â· simpa using h 1
  have h : B * (exp â„š - 1) = X * exp â„š := by
    simpa [bernoulli'PowerSeries] using bernoulli'PowerSeries_mul_exp_sub_one â„š
  rw [sub_mul, h, mul_sub X, sub_right_inj, â† neg_sub, mul_neg, neg_eq_iff_eq_neg]
  suffices evalNegHom (B * (exp â„š - 1)) * exp â„š = evalNegHom (X * exp â„š) * exp â„š by
    rw [map_mul, map_mul] at this 
    simpa [mul_assoc, sub_mul, mul_comm (evalNegHom (exp â„š)), exp_mul_exp_neg_eq_one]
  congr","error:  unsolved goals
case neg
A : Type u_1
instâœÂ¹ : CommRing A
instâœ : Algebra â„š A
n : â„•
B : â„šâŸ¦XâŸ§ := PowerSeries.mk fun n â†¦ bernoulli' n / â†‘n !
h_odd : Â¬Even n
hlt : 1 < n
this : B - evalNegHom B = X âˆ¨ exp â„š - 1 = 0
hâœ : Â¬n = 1
h : (coeff â„š n) B = 0
âŠ¢ bernoulli' n = 0",theorem bernoulli'_odd_eq_zero {n : â„•} (h_odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0 ,":= by
  let B := mk fun n => bernoulli' n / (n ! : â„š)
  suffices (B - evalNegHom B) * (exp â„š - 1) = X * (exp â„š - 1) by
    cases' mul_eq_mul_right_iff.mp this with h h <;>
      simp only [PowerSeries.ext_iff, evalNegHom, coeff_X] at h
    Â· apply eq_zero_of_neg_eq
      specialize h n
      split_ifs at h <;> simp_all [B, h_odd.neg_one_pow, factorial_ne_zero]
    Â· simpa (config := {decide := true}) [Nat.factorial] using h 1
  have h : B * (exp â„š - 1) = X * exp â„š := by
    simpa [bernoulli'PowerSeries] using bernoulli'PowerSeries_mul_exp_sub_one â„š
  rw [sub_mul, h, mul_sub X, sub_right_inj, â† neg_sub, mul_neg, neg_eq_iff_eq_neg]
  suffices evalNegHom (B * (exp â„š - 1)) * exp â„š = evalNegHom (X * exp â„š) * exp â„š by
    rw [map_mul, map_mul] at this 
    simpa [mul_assoc, sub_mul, mul_comm (evalNegHom (exp â„š)), exp_mul_exp_neg_eq_one]
  congr"
Mathlib/Data/List/Chain.lean,Acc.list_chain',Acc.list_chain',20100f1475ea197bf6dea643b6ee137219455a51,":= by
  obtain âŸ¨_ | âŸ¨a, lâŸ©, hlâŸ© := l
  Â· apply Acc.intro; rintro âŸ¨_âŸ© âŸ¨_âŸ©
  specialize acc a _
  Â· rw [List.head?_cons, Option.mem_some_iff]
  induction acc generalizing l with
  | intro a _ ih =>
    have hl' := (List.chain'_cons'.1 hl).2
    let l' : List.chains r := âŸ¨l, hl'âŸ©
    have : Acc (List.lex_chains r) l'
    Â· cases' l with b l
      Â· apply Acc.intro; rintro âŸ¨_âŸ© âŸ¨_âŸ©
      Â· apply ih b (List.chain'_cons.1 hl).1
    revert hl
    rw [(by rfl : l = l'.1)]
    clear_value l'
    induction this with
    | intro l _ ihl =>
      intro hl
      apply Acc.intro
      rintro âŸ¨_ | âŸ¨b, mâŸ©, hmâŸ© (_ | hr | hr)
      Â· apply Acc.intro; rintro âŸ¨_âŸ© âŸ¨_âŸ©
      Â· apply ihl âŸ¨m, (List.chain'_cons'.1 hm).2âŸ© hr
      Â· apply ih b hr","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case mk.cons.intro
Î± : Type u_1
r : Î± â†’ Î± â†’ Prop
aâœ a : Î±
hâœ : âˆ€ (y : Î±), r y a â†’ Acc r y
ih : âˆ€ (y : Î±), r y a â†’ âˆ€ (l : List Î±) (hl : List.Chain' (flip r) (y :: l)), Acc (List.lex_chains r) âŸ¨y :: l, hlâŸ©
l : List Î±
hl : List.Chain' (flip r) (a :: l)
hl' : List.Chain' (flip r) l
l' : List.chains r := âŸ¨l, hl'âŸ©
this : Acc (List.lex_chains r) l'
âŠ¢ Acc (List.lex_chains r) âŸ¨a :: l, hlâŸ©","theorem Acc.list_chain' {l : List.chains r} (acc : âˆ€ a âˆˆ l.val.head?, Acc r a) :
    Acc (List.lex_chains r) l ",":= by
  obtain âŸ¨_ | âŸ¨a, lâŸ©, hlâŸ© := l
  Â· apply Acc.intro; rintro âŸ¨_âŸ© âŸ¨_âŸ©
  specialize acc a _
  Â· rw [List.head?_cons, Option.mem_some_iff]
  induction acc generalizing l with
  | intro a _ ih =>
    have hl' := (List.chain'_cons'.1 hl).2
    let l' : List.chains r := âŸ¨l, hl'âŸ©
    have : Acc (List.lex_chains r) l' := by
      cases' l with b l
      Â· apply Acc.intro; rintro âŸ¨_âŸ© âŸ¨_âŸ©
      Â· apply ih b (List.chain'_cons.1 hl).1
    revert hl
    rw [(by rfl : l = l'.1)]
    clear_value l'
    induction this with
    | intro l _ ihl =>
      intro hl
      apply Acc.intro
      rintro âŸ¨_ | âŸ¨b, mâŸ©, hmâŸ© (_ | hr | hr)
      Â· apply Acc.intro; rintro âŸ¨_âŸ© âŸ¨_âŸ©
      Â· apply ihl âŸ¨m, (List.chain'_cons'.1 hm).2âŸ© hr
      Â· apply ih b hr"
Mathlib/Combinatorics/SimpleGraph/AdjMatrix.lean,SimpleGraph.toGraph_adjMatrix_eq,toGraph_adjMatrix_eq,b7aaed65e3f8b92b0b19e13ac3ab414f2515af38,":= by
  ext
  simp only [IsAdjMatrix.toGraph_Adj, adjMatrix_apply, ite_eq_left_iff, zero_ne_one]
  apply Classical.not_not","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsAdjMatrix
has type
  Matrix ?m.22765 ?m.22765 ?m.22766 â†’ Prop
error:  simp made no progress","theorem toGraph_adjMatrix_eq [MulZeroOneClass Î±] [Nontrivial Î±] :
    (G.isAdjMatrix_adjMatrix Î±).toGraph = G ",":= by
  ext
  simp only [IsAdjMatrix.toGraph_adj, adjMatrix_apply, ite_eq_left_iff, zero_ne_one]
  apply Classical.not_not"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,Isometry.hausdorffMeasure_image,hausdorffMeasure_image,ced4d3c0af763b9fd00166e49cf999cf46c891cc,":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => _
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), _, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, _âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => _
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left s) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","error:  don't know how to synthesize placeholder
context:
Î¹ : Type u_1
X : Type u_2
Y : Type u_3
instâœâµ : EMetricSpace X
instâœâ´ : EMetricSpace Y
instâœÂ³ : MeasurableSpace X
instâœÂ² : BorelSpace X
instâœÂ¹ : MeasurableSpace Y
instâœ : BorelSpace Y
C r : â„â‰¥0
f : X â†’ Y
s t : Set X
h : HolderOnWith C r f s
hr : 0 < r
d : â„
hd : 0 â‰¤ d
hC0 : 0 < C
hCd0 : â†‘C ^ d â‰  0
hCd : â†‘C ^ d â‰  âŠ¤
R : â„â‰¥0âˆ
hR : 0 < R
âŠ¢ â¨… t,
      â¨… (_ : f '' s âŠ† â‹ƒ n, t n), â¨… (_ : âˆ€ (n : â„•), diam (t n) â‰¤ R), âˆ‘' (n : â„•), â¨† (_ : (t n).Nonempty), diam (t n) ^ d â‰¤
    â¨† i,
      â¨† (_ : 0 < i),
        â¨… i_1,
          â¨… (_ : s âŠ† â‹ƒ n, i_1 n),
            â¨… (_ : âˆ€ (n : â„•), diam (i_1 n) â‰¤ i), âˆ‘' (i : â„•), â¨† (_ : (i_1 i).Nonempty), â†‘C ^ d * diam (i_1 i) ^ (â†‘r * d)","theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s ",":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd"
Mathlib/Algebra/Group/Equiv/Basic.lean,MulEquiv.toMonoidHom_injective,toMonoidHom_injective,04dc8a0816de055344ee2a2881b2b56d9ef8e426,":=
  fun _ _ h => MulEquiv.ext (MonoidHom.ext_iff.1 h)",error:  unknown constant 'MonoidHom.ext_iff',theorem toMonoidHom_injective : Injective (toMonoidHom : M â‰ƒ* N â†’ M â†’* N) ,":=
  Injective.of_comp (f := DFunLike.coe) DFunLike.coe_injective"
Mathlib/SetTheory/Ordinal/Topology.lean,Ordinal.mem_closure_tfae,mem_closure_tfae,58de6a1c33e964db25c184d0d1809e6b5b414b50,":= by
  tfae_have : 1 â†’ 2
  Â· simp only [mem_closure_iff_nhdsWithin_neBot, inter_comm s, nhdsWithin_inter', nhds_left_eq_nhds]
    exact id
  tfae_have : 2 â†’ 3
  | h => by
    rcases (s âˆ© Iic a).eq_empty_or_nonempty with he | hne
    Â· simp [he] at h
    Â· refine âŸ¨hne, (isLUB_of_mem_closure ?_ h).csSup_eq hneâŸ©
      exact fun x hx => hx.2
  tfae_have : 3 â†’ 4 :=
    fun h => âŸ¨_, inter_subset_left _ _, h.1, bddAbove_Iic.mono (inter_subset_right _ _), h.2âŸ©
  tfae_have : 4 â†’ 5
  Â· rintro âŸ¨t, hts, hne, hbdd, rflâŸ©
    have hlub : IsLUB t (sSup t) := isLUB_csSup hne hbdd
    let âŸ¨y, hytâŸ© := hne
    classical
      refine âŸ¨succ (sSup t), succ_ne_zero _, fun x _ => if x âˆˆ t then x else y, fun x _ => ?_, ?_âŸ©
      Â· simp only
        split_ifs with h <;> exact hts â€¹_â€º
      Â· refine le_antisymm (bsup_le fun x _ => ?_) (csSup_le hne fun x hx => ?_)
        Â· split_ifs <;> exact hlub.1 â€¹_â€º
        Â· refine (if_pos hx).symm.trans_le (le_bsup _ _ <| (hlub.1 hx).trans_lt (lt_succ _))
  tfae_have : 5 â†’ 6
  Â· rintro âŸ¨o, hâ‚€, f, hfs, rflâŸ©
    exact âŸ¨_, out_nonempty_iff_ne_zero.2 hâ‚€, familyOfBFamily o f, fun _ => hfs _ _, rflâŸ©
  tfae_have : 6 â†’ 1
  Â· rintro âŸ¨Î¹, hne, f, hfs, rflâŸ©
    rw [sup, iSup]
    exact closure_mono (range_subset_iff.2 hfs) <| csSup_mem_closure (range_nonempty f)
      (bddAbove_range.{u, u} f)
  tfae_finish",error:  unexpected token ':'; expected numeral,"theorem mem_closure_tfae (a : Ordinal.{u}) (s : Set Ordinal) :
    TFAE [a âˆˆ closure s,
      a âˆˆ closure (s âˆ© Iic a),
      (s âˆ© Iic a).Nonempty âˆ§ sSup (s âˆ© Iic a) = a,
      âˆƒ t, t âŠ† s âˆ§ t.Nonempty âˆ§ BddAbove t âˆ§ sSup t = a,
      âˆƒ (o : Ordinal.{u}), o â‰  0 âˆ§ âˆƒ (f : âˆ€ x < o, Ordinal),
        (âˆ€ x hx, f x hx âˆˆ s) âˆ§ bsup.{u, u} o f = a,
      âˆƒ (Î¹ : Type u), Nonempty Î¹ âˆ§ âˆƒ f : Î¹ â†’ Ordinal, (âˆ€ i, f i âˆˆ s) âˆ§ sup.{u, u} f = a] ",":= by
  tfae_have 1 â†’ 2
  Â· simp only [mem_closure_iff_nhdsWithin_neBot, inter_comm s, nhdsWithin_inter', nhds_left_eq_nhds]
    exact id
  tfae_have 2 â†’ 3
  Â· intro h
    rcases (s âˆ© Iic a).eq_empty_or_nonempty with he | hne
    Â· simp [he] at h
    Â· refine âŸ¨hne, (isLUB_of_mem_closure ?_ h).csSup_eq hneâŸ©
      exact fun x hx => hx.2
  tfae_have 3 â†’ 4
  Â· exact fun h => âŸ¨_, inter_subset_left, h.1, bddAbove_Iic.mono inter_subset_right, h.2âŸ©
  tfae_have 4 â†’ 5
  Â· rintro âŸ¨t, hts, hne, hbdd, rflâŸ©
    have hlub : IsLUB t (sSup t) := isLUB_csSup hne hbdd
    let âŸ¨y, hytâŸ© := hne
    classical
      refine âŸ¨succ (sSup t), succ_ne_zero _, fun x _ => if x âˆˆ t then x else y, fun x _ => ?_, ?_âŸ©
      Â· simp only
        split_ifs with h <;> exact hts â€¹_â€º
      Â· refine le_antisymm (bsup_le fun x _ => ?_) (csSup_le hne fun x hx => ?_)
        Â· split_ifs <;> exact hlub.1 â€¹_â€º
        Â· refine (if_pos hx).symm.trans_le (le_bsup _ _ <| (hlub.1 hx).trans_lt (lt_succ _))
  tfae_have 5 â†’ 6
  Â· rintro âŸ¨o, hâ‚€, f, hfs, rflâŸ©
    exact âŸ¨_, out_nonempty_iff_ne_zero.2 hâ‚€, familyOfBFamily o f, fun _ => hfs _ _, rflâŸ©
  tfae_have 6 â†’ 1
  Â· rintro âŸ¨Î¹, hne, f, hfs, rflâŸ©
    rw [sup, iSup]
    exact closure_mono (range_subset_iff.2 hfs) <| csSup_mem_closure (range_nonempty f)
      (bddAbove_range.{u, u} f)
  tfae_finish"
Mathlib/Topology/Sheaves/Presheaf.lean,TopCat.Presheaf.id_pushforward,id_pushforward,c64a8cc65b547d6c3abd420df4b8923dee790c78,":= by
  apply CategoryTheory.Functor.ext
  Â· intros a b f
    ext U
    Â· erw [NatTrans.congr f (Opens.op_map_id_obj (op U))]
      Â· simp only [Functor.op_obj, eqToHom_refl, CategoryTheory.Functor.map_id,
          Category.comp_id, Category.id_comp, Functor.id_obj, Functor.id_map]
      apply Pushforward.id_eq","error:  no goals to be solved
error:  unsolved goals
case h_obj
C : Type u
instâœ : Category.{v, u} C
X : TopCat
âŠ¢ âˆ€ (X_1 : Presheaf C X), (pushforward C (ğŸ™ X)).obj X_1 = (ğŸ­ (Presheaf C X)).obj X_1",theorem id_pushforward {X : TopCat.{w}} : pushforward C (ğŸ™ X) = ğŸ­ (X.Presheaf C) ,":= by
  apply CategoryTheory.Functor.ext
  Â· intros a b f
    ext U
    Â· erw [NatTrans.congr f (Opens.op_map_id_obj (op U))]
      Â· simp only [Functor.op_obj, eqToHom_refl, CategoryTheory.Functor.map_id,
          Category.comp_id, Category.id_comp, Functor.id_obj, Functor.id_map]
  Â· apply Pushforward.id_eq"
Mathlib/RingTheory/IntegralRestrict.lean,algebraMap_galRestrictHom_apply,algebraMap_galRestrictHom_apply,fc0107e21675a8298fc7ac3cc6e26f680430b1b5,":= by
  simp [galRestrictHom, Subalgebra.algebraMap_eq]; sorry",error:  no goals to be solved,"lemma algebraMap_galRestrictHom_apply (Ïƒ : L â†’â‚[K] L) (x : B) :
    algebraMap B L (galRestrictHom A K L B Ïƒ x) = Ïƒ (algebraMap B L x) ",":= by
  simp [galRestrictHom, Subalgebra.algebraMap_eq]"
Mathlib/FieldTheory/SeparableClosure.lean,separableClosure.le_restrictScalars,separableClosure.le_restrictScalars,4e8bae583b52e0844d277a19d99ae61e70771989,:= fun _ h â†¦ IsSeparable.of_isScalarTower E h,error:  unknown constant 'IsSeparable.of_isScalarTower',"theorem separableClosure.le_restrictScalars [Algebra E K] [IsScalarTower F E K] :
    separableClosure F K â‰¤ (separableClosure E K).restrictScalars F ",:= fun _ h â†¦ h.map_minpoly E
Mathlib/FieldTheory/NormalClosure.lean,Algebra.IsAlgebraic.isNormalClosure_normalClosure,isNormalClosure_normalClosure,b6646ed18d484fd9cfc0bc2c2b195a4fcfbddb05,":= by
  rw [alg.isNormalClosure_iff]; constructor
  Â· rw [alg.normalClosure_eq_iSup_adjoin_of_splits splits]
    exact fun x â†¦ splits_of_splits (splits x) ((IntermediateField.subset_adjoin F _).trans <|
      SetLike.coe_subset_coe.mpr <| by apply le_iSup _ x)
  simp_rw [normalClosure, â† top_le_iff]
  refine fun x _ â†¦ (IntermediateField.val _).injective.mem_set_image.mp ?_
  change x.val âˆˆ IntermediateField.map (IntermediateField.val _) _
  rw [IntermediateField.map_iSup]
  refine (iSup_le fun f â†¦ ?_ : normalClosure F K L â‰¤ _) x.2
  refine le_iSup_of_le (f.codRestrict _ fun x â†¦ f.fieldRange_le_normalClosure âŸ¨x, rflâŸ©) ?_
  erw [AlgHom.map_fieldRange, AlgHom.val_comp_codRestrict]","error:  unknown identifier 'alg.isNormalClosure_iff'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.30684
F : Type u_1
K : Type u_2
L : Type u_3
instâœâµ : Field F
instâœâ´ : Field K
instâœÂ³ : Field L
instâœÂ² : Algebra F K
instâœÂ¹ : Algebra F L
instâœ : Algebra.IsAlgebraic F K
splits : âˆ€ (x : K), Splits (algebraMap F L) (minpoly F x)
âŠ¢ IsNormalClosure F K â†¥(normalClosure F K L)
error:  invalid field notation, function 'Algebra.IsAlgebraic.isNormalClosure_normalClosure' does not have argument with type (Algebra.IsAlgebraic ...) that can be used, it must be explicit or implicit with a unique name",lemma isNormalClosure_normalClosure : IsNormalClosure F K (normalClosure F K L) ,":= by
  rw [isNormalClosure_iff]; constructor
  Â· rw [normalClosure_eq_iSup_adjoin_of_splits splits]
    exact fun x â†¦ splits_of_splits (splits x) ((IntermediateField.subset_adjoin F _).trans <|
      SetLike.coe_subset_coe.mpr <| by apply le_iSup _ x)
  simp_rw [normalClosure, â† top_le_iff]
  refine fun x _ â†¦ (IntermediateField.val _).injective.mem_set_image.mp ?_
  change x.val âˆˆ IntermediateField.map (IntermediateField.val _) _
  rw [IntermediateField.map_iSup]
  refine (iSup_le fun f â†¦ ?_ : normalClosure F K L â‰¤ _) x.2
  refine le_iSup_of_le (f.codRestrict _ fun x â†¦ f.fieldRange_le_normalClosure âŸ¨x, rflâŸ©) ?_
  rw [AlgHom.map_fieldRange, val, AlgHom.val_comp_codRestrict]"
Mathlib/RingTheory/PowerSeries/Basic.lean,PowerSeries.coeff_zero_C,coeff_zero_C,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":=
  coeff_monomial_same 0 a","error:  type mismatch
  coeff_monomial_same 0 a
has type
  (coeff R 0) ((monomial R 0) a) = a : Prop
but is expected to have type
  (coeff R 0) ((C R) a) = a : Prop
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated",theorem coeff_zero_C (a : R) : coeff R 0 (C R a) = a ,":= by
  rw [coeff_C, if_pos rfl]"
Mathlib/Probability/Kernel/MeasurableIntegral.lean,ProbabilityTheory.kernel.measurable_kernel_prod_mk_left_of_finite,measurable_kernel_prod_mk_left_of_finite,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine MeasurableSpace.induction_on_inter
    (C := fun t => Measurable fun a => Îº a (Prod.mk a â»Â¹' t))
    generateFrom_prod.symm isPiSystem_prod ?_ ?_? _? _ ht
  Â·
    simp only [preimage_empty, measure_empty, measurable_const]
  Â· 
    intro t' ht'
    simp only [Set.mem_image2, Set.mem_setOf_eq, exists_and_left] at ht'
    obtain âŸ¨tâ‚, htâ‚, tâ‚‚, htâ‚‚, rflâŸ© := ht'
    classical
    simp_rw [mk_preimage_prod_right_eq_if]
    have h_eq_ite : (fun a => Îº a (ite (a âˆˆ tâ‚) tâ‚‚ âˆ…)) = fun a => ite (a âˆˆ tâ‚) (Îº a tâ‚‚) 0 := by
      ext1 a
      split_ifs
      exacts [rfl, measure_empty]
    rw [h_eq_ite]
    exact Measurable.ite htâ‚ (kernel.measurable_coe Îº htâ‚‚) measurable_const
  Â· 
    intro t' ht' h_meas
    have h_eq_sdiff : âˆ€ a, Prod.mk a â»Â¹' t'á¶œ = Set.univ \ Prod.mk a â»Â¹' t' := by
      intro a
      ext1 b
      simp only [mem_compl_iff, mem_preimage, mem_diff, mem_univ, true_and_iff]
    simp_rw [h_eq_sdiff]
    have :
      (fun a => Îº a (Set.univ \ Prod.mk a â»Â¹' t')) = fun a =>
        Îº a Set.univ - Îº a (Prod.mk a â»Â¹' t') := by
      ext1 a
      rw [â† Set.diff_inter_self_eq_diff, Set.inter_univ, measure_diff (Set.subset_univ _)]
      Â· exact (@measurable_prod_mk_left Î± Î² _ _ a) ht'
      Â· exact measure_ne_top _ _
    rw [this]
    exact Measurable.sub (kernel.measurable_coe Îº MeasurableSet.univ) h_meas
  Â· 
    intro f h_disj hf_meas hf
    have h_Union :
      (fun a => Îº a (Prod.mk a â»Â¹' â‹ƒ i, f i)) = fun a => Îº a (â‹ƒ i, Prod.mk a â»Â¹' f i) := by
      ext1 a
      congr with b
      simp only [mem_iUnion, mem_preimage]
    rw [h_Union]
    have h_tsum :
      (fun a => Îº a (â‹ƒ i, Prod.mk a â»Â¹' f i)) = fun a => âˆ‘' i, Îº a (Prod.mk a â»Â¹' f i) := by
      ext1 a
      rw [measure_iUnion]
      Â· intro i j hij s hsi hsj b hbs
        have habi : {(a, b)} âŠ† f i := by rw [Set.singleton_subset_iff]; exact hsi hbs
        have habj : {(a, b)} âŠ† f j := by rw [Set.singleton_subset_iff]; exact hsj hbs
        simpa only [Set.bot_eq_empty, Set.le_eq_subset, Set.singleton_subset_iff,
          Set.mem_empty_iff_false] using h_disj hij habi habj
      Â· exact fun i => (@measurable_prod_mk_left Î± Î² _ _ a) (hf_meas i)
    rw [h_tsum]
    exact Measurable.ennreal_tsum hf","error:  unknown identifier '_?'
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
mÎ± : MeasurableSpace Î±
mÎ² : MeasurableSpace Î²
mÎ³ : MeasurableSpace Î³
Îº : â†¥(kernel Î± Î²)
Î· : â†¥(kernel (Î± Ã— Î²) Î³)
a : Î±
t : Set (Î± Ã— Î²)
ht : MeasurableSet t
hÎºs : âˆ€ (a : Î±), IsFiniteMeasure (Îº a)
âŠ¢ Measurable fun a â†¦ (Îº a) (Prod.mk a â»Â¹' t)","theorem measurable_kernel_prod_mk_left_of_finite {t : Set (Î± Ã— Î²)} (ht : MeasurableSet t)
    (hÎºs : âˆ€ a, IsFiniteMeasure (Îº a)) : Measurable fun a => Îº a (Prod.mk a â»Â¹' t) ",":= by
  refine MeasurableSpace.induction_on_inter
    (C := fun t => Measurable fun a => Îº a (Prod.mk a â»Â¹' t))
    generateFrom_prod.symm isPiSystem_prod ?_ ?_ ?_ ?_ ht
  Â·
    simp only [preimage_empty, measure_empty, measurable_const]
  Â· 
    intro t' ht'
    simp only [Set.mem_image2, Set.mem_setOf_eq, exists_and_left] at ht'
    obtain âŸ¨tâ‚, htâ‚, tâ‚‚, htâ‚‚, rflâŸ© := ht'
    classical
    simp_rw [mk_preimage_prod_right_eq_if]
    have h_eq_ite : (fun a => Îº a (ite (a âˆˆ tâ‚) tâ‚‚ âˆ…)) = fun a => ite (a âˆˆ tâ‚) (Îº a tâ‚‚) 0 := by
      ext1 a
      split_ifs
      exacts [rfl, measure_empty]
    rw [h_eq_ite]
    exact Measurable.ite htâ‚ (kernel.measurable_coe Îº htâ‚‚) measurable_const
  Â· 
    intro t' ht' h_meas
    have h_eq_sdiff : âˆ€ a, Prod.mk a â»Â¹' t'á¶œ = Set.univ \ Prod.mk a â»Â¹' t' := by
      intro a
      ext1 b
      simp only [mem_compl_iff, mem_preimage, mem_diff, mem_univ, true_and_iff]
    simp_rw [h_eq_sdiff]
    have :
      (fun a => Îº a (Set.univ \ Prod.mk a â»Â¹' t')) = fun a =>
        Îº a Set.univ - Îº a (Prod.mk a â»Â¹' t') := by
      ext1 a
      rw [â† Set.diff_inter_self_eq_diff, Set.inter_univ, measure_diff (Set.subset_univ _)]
      Â· exact (@measurable_prod_mk_left Î± Î² _ _ a) ht'
      Â· exact measure_ne_top _ _
    rw [this]
    exact Measurable.sub (kernel.measurable_coe Îº MeasurableSet.univ) h_meas
  Â· 
    intro f h_disj hf_meas hf
    have h_Union :
      (fun a => Îº a (Prod.mk a â»Â¹' â‹ƒ i, f i)) = fun a => Îº a (â‹ƒ i, Prod.mk a â»Â¹' f i) := by
      ext1 a
      congr with b
      simp only [mem_iUnion, mem_preimage]
    rw [h_Union]
    have h_tsum :
      (fun a => Îº a (â‹ƒ i, Prod.mk a â»Â¹' f i)) = fun a => âˆ‘' i, Îº a (Prod.mk a â»Â¹' f i) := by
      ext1 a
      rw [measure_iUnion]
      Â· intro i j hij s hsi hsj b hbs
        have habi : {(a, b)} âŠ† f i := by rw [Set.singleton_subset_iff]; exact hsi hbs
        have habj : {(a, b)} âŠ† f j := by rw [Set.singleton_subset_iff]; exact hsj hbs
        simpa only [Set.bot_eq_empty, Set.le_eq_subset, Set.singleton_subset_iff,
          Set.mem_empty_iff_false] using h_disj hij habi habj
      Â· exact fun i => (@measurable_prod_mk_left Î± Î² _ _ a) (hf_meas i)
    rw [h_tsum]
    exact Measurable.ennreal_tsum hf"
Mathlib/Analysis/Complex/Schwarz.lean,Complex.schwarz_aux,schwarz_aux,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  have hRâ‚ : 0 < Râ‚ := nonempty_ball.1 âŸ¨z, hzâŸ©
  suffices âˆ€á¶  r in ğ“[<] Râ‚, â€–dslope f c zâ€– â‰¤ Râ‚‚ / r by
    refine' ge_of_tendsto _ this
    exact (tendsto_const_nhds.div tendsto_id hRâ‚.ne').mono_left nhdsWithin_le_nhds
  rw [mem_ball] at hz
  filter_upwards [Ioo_mem_nhdsWithin_Iio âŸ¨hz, le_rflâŸ©] with r hr
  have hrâ‚€ : 0 < r := dist_nonneg.trans_lt hr.1
  replace hd : DiffContOnCl â„‚ (dslope f c) (ball c r)
  Â· refine' DifferentiableOn.diffContOnCl _
    rw [closure_ball c hrâ‚€.ne']
    exact ((differentiableOn_dslope <| ball_mem_nhds _ hRâ‚).mpr hd).mono
      (closedBall_subset_ball hr.2)
  refine' norm_le_of_forall_mem_frontier_norm_le isBounded_ball hd _ _
  Â· rw [frontier_ball c hrâ‚€.ne']
    intro z hz
    have hz' : z â‰  c := ne_of_mem_sphere hz hrâ‚€.ne'
    rw [dslope_of_ne _ hz', slope_def_module, norm_smul, norm_inv, mem_sphere_iff_norm.1 hz, â†
      div_eq_inv_mul, div_le_div_right hrâ‚€, â† dist_eq_norm]
    exact le_of_lt (h_maps (mem_ball.2 (by rw [mem_sphere.1 hz]; exact hr.2)))
  Â· rw [closure_ball c hrâ‚€.ne', mem_closedBall]
    exact hr.1.le","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case h
E : Type u_1
instâœÂ¹ : NormedAddCommGroup E
instâœ : NormedSpace â„‚ E
R Râ‚ Râ‚‚ : â„
fâœ : â„‚ â†’ E
c z zâ‚€ : â„‚
f : â„‚ â†’ â„‚
h_maps : MapsTo f (ball c Râ‚) (ball (f c) Râ‚‚)
hz : dist z c < Râ‚
hRâ‚ : 0 < Râ‚
r : â„
hr : r âˆˆ Ioo (dist z c) Râ‚
hrâ‚€ : 0 < r
hd : DiffContOnCl â„‚ (dslope f c) (ball c r)
âŠ¢ â€–dslope f c zâ€– â‰¤ Râ‚‚ / r","theorem schwarz_aux {f : â„‚ â†’ â„‚} (hd : DifferentiableOn â„‚ f (ball c Râ‚))
    (h_maps : MapsTo f (ball c Râ‚) (ball (f c) Râ‚‚)) (hz : z âˆˆ ball c Râ‚) :
    â€–dslope f c zâ€– â‰¤ Râ‚‚ / Râ‚ ",":= by
  have hRâ‚ : 0 < Râ‚ := nonempty_ball.1 âŸ¨z, hzâŸ©
  suffices âˆ€á¶  r in ğ“[<] Râ‚, â€–dslope f c zâ€– â‰¤ Râ‚‚ / r by
    refine ge_of_tendsto ?_ this
    exact (tendsto_const_nhds.div tendsto_id hRâ‚.ne').mono_left nhdsWithin_le_nhds
  rw [mem_ball] at hz
  filter_upwards [Ioo_mem_nhdsWithin_Iio âŸ¨hz, le_rflâŸ©] with r hr
  have hrâ‚€ : 0 < r := dist_nonneg.trans_lt hr.1
  replace hd : DiffContOnCl â„‚ (dslope f c) (ball c r) := by
    refine DifferentiableOn.diffContOnCl ?_
    rw [closure_ball c hrâ‚€.ne']
    exact ((differentiableOn_dslope <| ball_mem_nhds _ hRâ‚).mpr hd).mono
      (closedBall_subset_ball hr.2)
  refine norm_le_of_forall_mem_frontier_norm_le isBounded_ball hd ?_ ?_
  Â· rw [frontier_ball c hrâ‚€.ne']
    intro z hz
    have hz' : z â‰  c := ne_of_mem_sphere hz hrâ‚€.ne'
    rw [dslope_of_ne _ hz', slope_def_module, norm_smul, norm_inv, mem_sphere_iff_norm.1 hz, â†
      div_eq_inv_mul, div_le_div_right hrâ‚€, â† dist_eq_norm]
    exact le_of_lt (h_maps (mem_ball.2 (by rw [mem_sphere.1 hz]; exact hr.2)))
  Â· rw [closure_ball c hrâ‚€.ne', mem_closedBall]
    exact hr.1.le"
Mathlib/Probability/Cdf.lean,ProbabilityTheory.ofReal_cdf,ofReal_cdf,c4988d10a696972769fd676cb9977e896bf0a01b,":= by
  have := IsProbabilityMeasure.toIsFiniteMeasure (Measure.prod (Measure.dirac ()) Î¼)
  have h := lintegral_condCdf ((Measure.dirac Unit.unit).prod Î¼) x
  simpa only [MeasureTheory.Measure.fst_prod, Measure.prod_prod, measure_univ, one_mul,
    lintegral_dirac] using h","error:  unknown identifier 'lintegral_condCdf'
error:  unsolved goals
Î¼ : Measure â„
instâœ : IsProbabilityMeasure Î¼
x : â„
this : IsFiniteMeasure ((Measure.dirac ()).prod Î¼)
âŠ¢ ENNReal.ofReal (â†‘(cdf Î¼) x) = Î¼ (Iic x)",lemma ofReal_cdf [IsProbabilityMeasure Î¼] (x : â„) : ENNReal.ofReal (cdf Î¼ x) = Î¼ (Iic x) ,":= by
  have := IsProbabilityMeasure.toIsFiniteMeasure (Measure.prod (Measure.dirac ()) Î¼)
  have h := lintegral_condCDF ((Measure.dirac Unit.unit).prod Î¼) x
  simpa only [MeasureTheory.Measure.fst_prod, Measure.prod_prod, measure_univ, one_mul,
    lintegral_dirac] using h"
Mathlib/Geometry/Euclidean/Angle/Unoriented/RightAngle.lean,InnerProductGeometry.cos_angle_add_mul_norm_of_inner_eq_zero,cos_angle_add_mul_norm_of_inner_eq_zero,40fb63d88b0cfe9058c25ddcc4bc76603c755e2e,":= by
  rw [cos_angle_add_of_inner_eq_zero h]
  by_cases hxy : â€–x + yâ€– = 0
  Â· have h' := norm_add_sq_eq_norm_sq_add_norm_sq_real h
    rw [hxy, zero_mul, eq_comm,
      add_eq_zero_iff_of_nonneg (mul_self_nonneg â€–xâ€–) (mul_self_nonneg â€–yâ€–), mul_self_eq_zero] at h'
    simp [h'.1]
  Â· exact div_mul_cancel _ hxy","error:  unknown identifier 'add_eq_zero_iff_of_nonneg'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.48010
case pos
V : Type u_1
instâœÂ¹ : NormedAddCommGroup V
instâœ : InnerProductSpace â„ V
x y : V
h : âŸªx, yâŸ«_â„ = 0
hxy : â€–x + yâ€– = 0
h' : â€–xâ€– * â€–xâ€– + â€–yâ€– * â€–yâ€– = 0
âŠ¢ â€–xâ€– / â€–x + yâ€– * â€–x + yâ€– = â€–xâ€–
error:  application type mismatch
  div_mul_cancel ?m.48014 hxy
argument
  hxy
has type
  Â¬â€–x + yâ€– = 0 : Prop
but is expected to have type
  ?m.48012 : Type ?u.48011","theorem cos_angle_add_mul_norm_of_inner_eq_zero {x y : V} (h : âŸªx, yâŸ« = 0) :
    Real.cos (angle x (x + y)) * â€–x + yâ€– = â€–xâ€– ",":= by
  rw [cos_angle_add_of_inner_eq_zero h]
  by_cases hxy : â€–x + yâ€– = 0
  Â· have h' := norm_add_sq_eq_norm_sq_add_norm_sq_real h
    rw [hxy, zero_mul, eq_comm,
      add_eq_zero_iff' (mul_self_nonneg â€–xâ€–) (mul_self_nonneg â€–yâ€–), mul_self_eq_zero] at h'
    simp [h'.1]
  Â· exact div_mul_cancelâ‚€ _ hxy"
Mathlib/FieldTheory/IntermediateField.lean,IntermediateField.coe_prod,coe_prod,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
    induction' (Finset.univ : Finset Î¹) with i s hi H
    Â· simp
    Â· rw [Finset.prod_insert hi, MulMemClass.coe_mul, H, Finset.prod_insert hi]",error:  no goals to be solved,"theorem coe_prod {Î¹ : Type*} [Fintype Î¹] (f : Î¹ â†’ S) : (â†‘(âˆ i, f i) : L) = âˆ i, (f i : L) ",":= by
  classical
    induction' (Finset.univ : Finset Î¹) using Finset.induction_on with i s hi H
    Â· simp
    Â· rw [Finset.prod_insert hi, MulMemClass.coe_mul, H, Finset.prod_insert hi]"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,65f7857d510e130142dbb111786341d695ac399b,":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine Or.inl âŸ¨hs, ?_âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine' mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, _âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine'
        mem_shadow_iff.2
          âŸ¨(t âŠ” u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, _, _âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine' âŸ¨hus, hsv.symm, âŸ¨x, _, _âŸ©, _âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right _ _, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) _
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  function expected at
  subset_union_right ?m.92173
term has type
  ?m.92172 âˆˆ ?m.92170 âˆª ?m.92171
error:  function expected at
  subset_union_left ?m.92639
term has type
  ?m.92638 âˆˆ ?m.92636 âˆª ?m.92637
error:  function expected at
  subset_union_right ?m.94506
term has type
  ?m.94505 âˆˆ ?m.94503 âˆª ?m.94504
error:  function expected at
  subset_union_left ?m.97300
term has type
  ?m.97299 âˆˆ ?m.97297 âˆª ?m.97298
error:  ambiguous, possible interpretations 
  _root_.not_imp : Â¬(?m.97719 â†’ ?m.97720) â†” ?m.97719 âˆ§ Â¬?m.97720
  
  Classical.not_imp : Â¬(?m.97721 â†’ ?m.97722) â†” ?m.97721 âˆ§ Â¬?m.97722
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.97724
case neg
Î± : Type u_1
instâœ : DecidableEq Î±
ğ’œ : Finset (Finset Î±)
uâœ vâœ a : Finset Î±
r : â„•
u v : Finset Î±
huv : âˆ€ x âˆˆ u, âˆƒ y âˆˆ v, IsCompressed (u.erase x) (v.erase y) ğ’œ
ğ’œ' : Finset (Finset Î±) := ğ“’ u v ğ’œ
s : Finset Î±
hsğ’œ' : s âˆˆ âˆ‚ ğ’œ'
hsğ’œ : s âˆ‰ âˆ‚ ğ’œ
m : âˆ€ y âˆ‰ s, insert y s âˆ‰ ğ’œ
x : Î±
leftâœ : x âˆ‰ s
rightâœ : insert x s âˆˆ ğ’œ'
husâœ : u âŠ† insert x s
hvs : Disjoint v (insert x s)
thisâœÂ² : (insert x s âˆª v) \ u âˆˆ ğ’œ
hsv : Disjoint s v
hvu : Disjoint v u
hxv : x âˆ‰ v
thisâœÂ¹ : v \ u = v
thisâœ : x âˆ‰ u
hus : u âŠ† s
w : Î±
hwB : Â¬(w âˆˆ s âˆª v âˆ§ w âˆ‰ u)
hwğ’œ' : insert w ((s âˆª v) \ u) âˆˆ ğ’œ'
this : v âŠ† insert w ((s âˆª v) \ u)
hwu : w âˆ‰ u
âŠ¢ False","theorem shadow_compression_subset_compression_shadow (u v : Finset Î±)
    (huv : âˆ€ x âˆˆ u, âˆƒ y âˆˆ v, IsCompressed (u.erase x) (v.erase y) ğ’œ) :
    âˆ‚ (ğ“’ u v ğ’œ) âŠ† ğ“’ u v (âˆ‚ ğ’œ) ",":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine Or.inl âŸ¨hs, ?_âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, ?_âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine mem_shadow_iff.2
        âŸ¨(t âŠ” u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine âŸ¨hus, hsv.symm, âŸ¨x, ?_, ?_âŸ©, ?_âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) ?_
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]"
Mathlib/Probability/Distributions/Exponential.lean,ProbabilityTheory.lintegral_exponentialPDF_eq_antiDeriv,lintegral_exponentialPDF_eq_antiDeriv,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  split_ifs with h
  case neg =>
    simp only [exponentialPDF_eq]
    rw [set_lintegral_congr_fun measurableSet_Iic, lintegral_zero, ENNReal.ofReal_zero]
    exact ae_of_all _ fun a (_ : a â‰¤ _) â†¦ by rw [if_neg (by linarith), ENNReal.ofReal_eq_zero]
  case pos =>
    rw [lintegral_Iic_eq_lintegral_Iio_add_Icc _ h, lintegral_exponentialPDF_of_nonpos (le_refl 0),
      zero_add]
    simp only [exponentialPDF_eq]
    rw [set_lintegral_congr_fun measurableSet_Icc (ae_of_all _
        (by intro a âŸ¨(hle : _ â‰¤ a), _âŸ©; rw [if_pos hle]))]
    rw [â† ENNReal.toReal_eq_toReal _ ENNReal.ofReal_ne_top, â† integral_eq_lintegral_of_nonneg_ae
        (eventually_of_forall fun _ â†¦ le_of_lt (mul_pos hr (exp_pos _)))]
    have : âˆ« a in uIoc 0 x, r * rexp (-(r * a)) = âˆ« a in (0)..x, r * rexp (-(r * a)) := by
      rw [intervalIntegral.intervalIntegral_eq_integral_uIoc, smul_eq_mul, if_pos h, one_mul]
    rw [integral_Icc_eq_integral_Ioc, â† uIoc_of_le h, this]
    rw [intervalIntegral.integral_eq_sub_of_hasDeriv_right_of_le h
      (f := fun a â†¦ -1 * rexp (-(r * a))) _ _]
    rw [ENNReal.toReal_ofReal_eq_iff.2 (by norm_num; positivity)]
    Â· norm_num; ring
    Â· simp only [intervalIntegrable_iff, uIoc_of_le h]
      exact Integrable.const_mul (exp_neg_integrableOn_Ioc hr) _
    Â· have : Continuous (fun a â†¦ rexp (-(r * a))) := by
        simp only [â† neg_mul]; exact (continuous_mul_left (-r)).exp
      exact Continuous.continuousOn (Continuous.comp' (continuous_mul_left (-1)) this)
    Â· simp only [neg_mul, one_mul]
      exact fun _ _ â†¦ HasDerivAt.hasDerivWithinAt hasDerivAt_neg_exp_mul_exp
    Â· apply Integrable.aestronglyMeasurable (Integrable.const_mul _ _)
      rw [â† integrableOn_def, integrableOn_Icc_iff_integrableOn_Ioc]
      exact exp_neg_integrableOn_Ioc hr
    Â· refine ne_of_lt (IntegrableOn.set_lintegral_lt_top ?_)
      rw [integrableOn_Icc_iff_integrableOn_Ioc]
      exact Integrable.const_mul (exp_neg_integrableOn_Ioc hr) _","warning:  `MeasureTheory.set_lintegral_congr_fun` has been deprecated, use `MeasureTheory.setLIntegral_congr_fun` instead
warning:  `MeasureTheory.set_lintegral_congr_fun` has been deprecated, use `MeasureTheory.setLIntegral_congr_fun` instead
warning:  `Continuous.exp` has been deprecated, use `Continuous.rexp` instead
error:  unknown identifier 'integrableOn_def'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.27581
r : â„
hr : 0 < r
x : â„
h : 0 â‰¤ x
âŠ¢ Integrable (fun x â†¦ rexp (-(r * x))) (â„™.restrict (Icc 0 x))
warning:  `MeasureTheory.IntegrableOn.set_lintegral_lt_top` has been deprecated, use `MeasureTheory.IntegrableOn.setLIntegral_lt_top` instead","lemma lintegral_exponentialPDF_eq_antiDeriv {r : â„} (hr : 0 < r) (x : â„) :
    âˆ«â» y in Iic x, exponentialPDF r y
    = ENNReal.ofReal (if 0 â‰¤ x then 1 - exp (-(r * x)) else 0) ",":= by
  split_ifs with h
  case neg =>
    simp only [exponentialPDF_eq]
    rw [setLIntegral_congr_fun measurableSet_Iic, lintegral_zero, ENNReal.ofReal_zero]
    exact ae_of_all _ fun a (_ : a â‰¤ _) â†¦ by rw [if_neg (by linarith), ENNReal.ofReal_eq_zero]
  case pos =>
    rw [lintegral_Iic_eq_lintegral_Iio_add_Icc _ h, lintegral_exponentialPDF_of_nonpos (le_refl 0),
      zero_add]
    simp only [exponentialPDF_eq]
    rw [setLIntegral_congr_fun measurableSet_Icc (ae_of_all _
        (by intro a âŸ¨(hle : _ â‰¤ a), _âŸ©; rw [if_pos hle]))]
    rw [â† ENNReal.toReal_eq_toReal _ ENNReal.ofReal_ne_top, â† integral_eq_lintegral_of_nonneg_ae
        (eventually_of_forall fun _ â†¦ le_of_lt (mul_pos hr (exp_pos _)))]
    Â· have : âˆ« a in uIoc 0 x, r * rexp (-(r * a)) = âˆ« a in (0)..x, r * rexp (-(r * a)) := by
        rw [intervalIntegral.intervalIntegral_eq_integral_uIoc, smul_eq_mul, if_pos h, one_mul]
      rw [integral_Icc_eq_integral_Ioc, â† uIoc_of_le h, this]
      rw [intervalIntegral.integral_eq_sub_of_hasDeriv_right_of_le h
        (f := fun a â†¦ -1 * rexp (-(r * a))) _ _]
      Â· rw [ENNReal.toReal_ofReal_eq_iff.2 (by norm_num; positivity)]
        norm_num; ring
      Â· simp only [intervalIntegrable_iff, uIoc_of_le h]
        exact Integrable.const_mul (exp_neg_integrableOn_Ioc hr) _
      Â· have : Continuous (fun a â†¦ rexp (-(r * a))) := by
          simp only [â† neg_mul]; exact (continuous_mul_left (-r)).rexp
        exact Continuous.continuousOn (Continuous.comp' (continuous_mul_left (-1)) this)
      Â· simp only [neg_mul, one_mul]
        exact fun _ _ â†¦ HasDerivAt.hasDerivWithinAt hasDerivAt_neg_exp_mul_exp
    Â· apply Integrable.aestronglyMeasurable (Integrable.const_mul _ _)
      rw [â† IntegrableOn, integrableOn_Icc_iff_integrableOn_Ioc]
      exact exp_neg_integrableOn_Ioc hr
    Â· refine ne_of_lt (IntegrableOn.setLIntegral_lt_top ?_)
      rw [integrableOn_Icc_iff_integrableOn_Ioc]
      exact Integrable.const_mul (exp_neg_integrableOn_Ioc hr) _"
Mathlib/Data/Set/Image.lean,Set.image_inter_subset,image_inter_subset,ea1b2576466eb49ae109b64acf312f52285dafce,":=
  subset_inter (image_subset _ <| inter_subset_left _ _) (image_subset _ <| inter_subset_right _ _)","error:  function expected at
  inter_subset_left ?m.19790
term has type
  ?m.19789 âˆˆ ?m.19787
error:  function expected at
  inter_subset_right ?m.19842
term has type
  ?m.19841 âˆˆ ?m.19840",theorem image_inter_subset (f : Î± â†’ Î²) (s t : Set Î±) : f '' (s âˆ© t) âŠ† f '' s âˆ© f '' t ,":=
  subset_inter (image_subset _ inter_subset_left) (image_subset _ inter_subset_right)"
Mathlib/Data/List/Indexes.lean,List.indexesValues_eq_filter_enum,indexesValues_eq_filter_enum,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp (config := { unfoldPartialApp := true }) [indexesValues, foldrIdx_eq_foldr_enum, uncurry,
    filter_eq_foldr]","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
error:  unsolved goals
Î± : Type u
Î² : Type v
p : Î± â†’ Prop
instâœ : DecidablePred p
as : List Î±
âŠ¢ foldr (fun a l â†¦ if p a.2 then a :: l else l) [] as.enum =
    foldr (fun a out â†¦ bif decide (p a.2) then a :: out else out) [] as.enum","theorem indexesValues_eq_filter_enum (p : Î± â†’ Prop) [DecidablePred p] (as : List Î±) :
    indexesValues p as = filter (p âˆ˜ Prod.snd) (enum as) ",":= by
  simp (config := { unfoldPartialApp := true }) [indexesValues, foldrIdx_eq_foldr_enum, uncurry,
    filter_eq_foldr, cond_eq_if]"
Mathlib/RingTheory/FreeCommRing.lean,FreeCommRing.exists_finite_support,exists_finite_support,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  FreeCommRing.induction_on x âŸ¨âˆ…, Set.finite_empty, isSupported_neg isSupported_oneâŸ©
    (fun p => âŸ¨{p}, Set.finite_singleton p, isSupported_of.2 <| Set.mem_singleton _âŸ©)
    (fun _ _ âŸ¨s, hfs, hxsâŸ© âŸ¨t, hft, hxtâŸ© =>
      âŸ¨s âˆª t, hfs.union hft,
        isSupported_add (isSupported_upwards hxs <| Set.subset_union_left s t)
          (isSupported_upwards hxt <| Set.subset_union_right s t)âŸ©)
    fun _ _ âŸ¨s, hfs, hxsâŸ© âŸ¨t, hft, hxtâŸ© =>
    âŸ¨s âˆª t, hfs.union hft,
      isSupported_mul (isSupported_upwards hxs <| Set.subset_union_left s t)
        (isSupported_upwards hxt <| Set.subset_union_right s t)âŸ©","error:  application type mismatch
  Set.subset_union_left s
argument
  s
has type
  Set Î± : Type u
but is expected to have type
  ?m.29529 âˆˆ ?m.29527 : Prop
error:  application type mismatch
  Set.subset_union_right s
argument
  s
has type
  Set Î± : Type u
but is expected to have type
  ?m.29935 âˆˆ ?m.29934 : Prop
error:  application type mismatch
  Set.subset_union_left s
argument
  s
has type
  Set Î± : Type u
but is expected to have type
  ?m.30643 âˆˆ ?m.30641 : Prop
error:  application type mismatch
  Set.subset_union_right s
argument
  s
has type
  Set Î± : Type u
but is expected to have type
  ?m.31049 âˆˆ ?m.31048 : Prop","theorem exists_finite_support (x : FreeCommRing Î±) : âˆƒ s : Set Î±, Set.Finite s âˆ§ IsSupported x s ",":=
  FreeCommRing.induction_on x âŸ¨âˆ…, Set.finite_empty, isSupported_neg isSupported_oneâŸ©
    (fun p => âŸ¨{p}, Set.finite_singleton p, isSupported_of.2 <| Set.mem_singleton _âŸ©)
    (fun _ _ âŸ¨s, hfs, hxsâŸ© âŸ¨t, hft, hxtâŸ© =>
      âŸ¨s âˆª t, hfs.union hft,
        isSupported_add (isSupported_upwards hxs Set.subset_union_left)
          (isSupported_upwards hxt Set.subset_union_right)âŸ©)
    fun _ _ âŸ¨s, hfs, hxsâŸ© âŸ¨t, hft, hxtâŸ© =>
    âŸ¨s âˆª t, hfs.union hft,
      isSupported_mul (isSupported_upwards hxs Set.subset_union_left)
        (isSupported_upwards hxt Set.subset_union_right)âŸ©"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.exists_of_mem_join,exists_of_mem_join,938069ac7c83a4980c46ca108d9947ab788c12ee,":= by
  suffices
    âˆ€ ss : WSeq Î±,
      a âˆˆ ss â†’ âˆ€ s S, append s (join S) = ss â†’ a âˆˆ append s (join S) â†’ a âˆˆ s âˆ¨ âˆƒ s, s âˆˆ S âˆ§ a âˆˆ s
    from fun S h => (this _ h nil S (by simp) (by simp [h])).resolve_left (not_mem_nil _)
  intro ss h; induction' h using mem_rec_on with ss b ss _ IH ss _ IH <;> intro s S
  Â· induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq'.destruct ej <;>
      simp at this; cases this
    substs b' ss
    simp at m âŠ¢
  Â· induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq'.destruct ej <;>
      simp at this; cases this
    substs b' ss
    simp only [cons_append, mem_cons_iff] at m âŠ¢
    cases' m with e m
    Â· simp [e]
    exact Or.imp_left Or.inr (IH _ _ rfl m)
  Â· induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq'.destruct ej <;> simp at this <;>
      subst ss
    Â· apply Or.inr
      simp [-exists_eq_or_imp] at m âŠ¢
      cases' IH s S rfl m with as ex
      Â· exact âŸ¨s, Or.inl rfl, asâŸ©
      Â· rcases ex with âŸ¨s', sS, asâŸ©
        exact âŸ¨s', Or.inr sS, asâŸ©
    Â· apply Or.inr
      simp? at m says simp only [join_think, nil_append, mem_think] at m
      rcases (IH nil S (by simp) (by simp [m])).resolve_left (not_mem_nil _) with âŸ¨s, sS, asâŸ©
      exact âŸ¨s, by simp [sS], asâŸ©
    Â· simp only [think_append, mem_think] at m IH âŠ¢
      apply IH _ _ rfl m",error:  failed to infer implicit target s,"theorem exists_of_mem_join {a : Î±} : âˆ€ {S : WSeq (WSeq Î±)}, a âˆˆ join S â†’ âˆƒ s, s âˆˆ S âˆ§ a âˆˆ s ",":= by
  suffices
    âˆ€ ss : WSeq Î±,
      a âˆˆ ss â†’ âˆ€ s S, append s (join S) = ss â†’ a âˆˆ append s (join S) â†’ a âˆˆ s âˆ¨ âˆƒ s, s âˆˆ S âˆ§ a âˆˆ s
    from fun S h => (this _ h nil S (by simp) (by simp [h])).resolve_left (not_mem_nil _)
  intro ss h; apply mem_rec_on h <;> [intro b ss o; intro ss IH] <;> intro s S
  Â· induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq.destruct ej <;>
      simp at this; cases this
    substs b' ss
    simp? at m âŠ¢ says simp only [cons_append, mem_cons_iff] at m âŠ¢
    cases' o with e IH
    Â· simp [e]
    cases' m with e m
    Â· simp [e]
    exact Or.imp_left Or.inr (IH _ _ rfl m)
  Â· induction' s using WSeq.recOn with b' s s <;>
      [induction' S using WSeq.recOn with s S S; skip; skip] <;>
      intro ej m <;> simp at ej <;> have := congr_arg Seq.destruct ej <;> simp at this <;>
      subst ss
    Â· apply Or.inr
      simp [-exists_eq_or_imp] at m âŠ¢
      cases' IH s S rfl m with as ex
      Â· exact âŸ¨s, Or.inl rfl, asâŸ©
      Â· rcases ex with âŸ¨s', sS, asâŸ©
        exact âŸ¨s', Or.inr sS, asâŸ©
    Â· apply Or.inr
      simp? at m says simp only [join_think, nil_append, mem_think] at m
      rcases (IH nil S (by simp) (by simp [m])).resolve_left (not_mem_nil _) with âŸ¨s, sS, asâŸ©
      exact âŸ¨s, by simp [sS], asâŸ©
    Â· simp only [think_append, mem_think] at m IH âŠ¢
      apply IH _ _ rfl m"
Mathlib/Topology/Separation.lean,Dense.diff_singleton,Dense.diff_singleton,71880da883b383ac13b9beb76b1bd41a0f023582,":=
  hs.inter_of_open_right (dense_compl_singleton x) isOpen_compl_singleton","error:  invalid field 'inter_of_open_right', the environment does not contain 'Dense.inter_of_open_right'
  hs
has type
  Dense s
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  hs
has type
  âˆ€ (x : X), x âˆˆ closure s","theorem Dense.diff_singleton [T1Space X] {s : Set X} (hs : Dense s) (x : X) [NeBot (ğ“[â‰ ] x)] :
    Dense (s \ {x}) ",":=
  hs.inter_of_isOpen_right (dense_compl_singleton x) isOpen_compl_singleton"
Mathlib/RingTheory/Polynomial/Hermite/Basic.lean,Polynomial.coeff_hermite_explicit,coeff_hermite_explicit,0d488aff5c71d9247c91fc20e57eeab349138ff5,"  | 0, _ => by simp
  | n + 1, 0 => by
    convert coeff_hermite_succ_zero (2 * n + 1) using 1
    rw [coeff_hermite_explicit n 1, (by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] :
      2 * (n + 1) - 1 = 2 * n + 1), Nat.doubleFactorial_add_one, Nat.choose_zero_right,
      Nat.choose_one_right, pow_succ]
    push_cast
    ring
  | n + 1, k + 1 => by
    let hermite_explicit : â„• â†’ â„• â†’ â„¤ := fun n k =>
      (-1) ^ n * (2 * n - 1)â€¼ * Nat.choose (2 * n + k) k
    have hermite_explicit_recur :
      âˆ€ n k : â„•,
        hermite_explicit (n + 1) (k + 1) =
          hermite_explicit (n + 1) k - (k + 2) * hermite_explicit n (k + 2) := by
      intro n k
      simp only
      rw [mul_comm (â†‘k + _ : â„¤), sub_eq_add_neg]
      nth_rw 4 [neg_eq_neg_one_mul]
      simp only [mul_assoc, â† mul_add, pow_succ]
      congr 2
      norm_cast
      rw [(by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] : 2 * (n + 1) - 1 = 2 * n + 1),
        Nat.doubleFactorial_add_one, mul_comm (2 * n + 1)]
      simp only [mul_assoc, â† mul_add]
      congr 1
      rw [(by ring : 2 * (n + 1) + (k + 1) = 2 * n + 1 + (k + 1) + 1),
        (by ring : 2 * (n + 1) + k = 2 * n + 1 + (k + 1)),
        (by ring : 2 * n + (k + 2) = 2 * n + 1 + (k + 1))]
      rw [Nat.choose, Nat.choose_succ_right_eq (2 * n + 1 + (k + 1)) (k + 1), Nat.add_sub_cancel,
        Int.negSucc_eq]
      ring_nf
      simp only [sub_eq_add_neg, â† neg_mul, â† right_distrib _ _ ((-(1 : â„¤)) ^ n), â† neg_add]
      norm_cast
      simp only [â† add_assoc, add_comm]
    change _ = hermite_explicit _ _
    rw [â† add_assoc, coeff_hermite_succ_succ, hermite_explicit_recur]
    congr
    Â· rw [coeff_hermite_explicit (n + 1) k]
    Â· rw [(by ring : 2 * (n + 1) + k = 2 * n + (k + 2)), coeff_hermite_explicit n (k + 2)]",error:  simp made no progress,"theorem coeff_hermite_explicit :
    âˆ€ n k : â„•, coeff (hermite (2 * n + k)) k = (-1) ^ n * (2 * n - 1)â€¼ * Nat.choose (2 * n + k) k
","  | 0, _ => by simp
  | n + 1, 0 => by
    convert coeff_hermite_succ_zero (2 * n + 1) using 1
    rw [coeff_hermite_explicit n 1, (by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] :
      2 * (n + 1) - 1 = 2 * n + 1), Nat.doubleFactorial_add_one, Nat.choose_zero_right,
      Nat.choose_one_right, pow_succ]
    push_cast
    ring
  | n + 1, k + 1 => by
    let hermite_explicit : â„• â†’ â„• â†’ â„¤ := fun n k =>
      (-1) ^ n * (2 * n - 1)â€¼ * Nat.choose (2 * n + k) k
    have hermite_explicit_recur :
      âˆ€ n k : â„•,
        hermite_explicit (n + 1) (k + 1) =
          hermite_explicit (n + 1) k - (k + 2) * hermite_explicit n (k + 2) := by
      intro n k
      simp only [hermite_explicit]
      rw [mul_comm (â†‘k + _ : â„¤), sub_eq_add_neg]
      nth_rw 3 [neg_eq_neg_one_mul]
      simp only [mul_assoc, â† mul_add, pow_succ']
      congr 2
      norm_cast
      rw [(by rw [Nat.left_distrib, mul_one, Nat.add_one_sub_one] : 2 * (n + 1) - 1 = 2 * n + 1),
        Nat.doubleFactorial_add_one, mul_comm (2 * n + 1)]
      simp only [mul_assoc, â† mul_add]
      congr 1
      rw [(by ring : 2 * (n + 1) + (k + 1) = 2 * n + 1 + (k + 1) + 1),
        (by ring : 2 * (n + 1) + k = 2 * n + 1 + (k + 1)),
        (by ring : 2 * n + (k + 2) = 2 * n + 1 + (k + 1))]
      rw [Nat.choose, Nat.choose_succ_right_eq (2 * n + 1 + (k + 1)) (k + 1), Nat.add_sub_cancel]
      ring
    change _ = hermite_explicit _ _
    rw [â† add_assoc, coeff_hermite_succ_succ, hermite_explicit_recur]
    congr
    Â· rw [coeff_hermite_explicit (n + 1) k]
    Â· rw [(by ring : 2 * (n + 1) + k = 2 * n + (k + 2)), coeff_hermite_explicit n (k + 2)]"
Mathlib/Topology/Sheaves/LocallySurjective.lean,TopCat.Presheaf.locally_surjective_iff_surjective_on_stalks,locally_surjective_iff_surjective_on_stalks,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  constructor <;> intro hT
  Â· 
    intro x g
    obtain âŸ¨U, hxU, t, rflâŸ© := ğ’¢.germ_exist x g
    rcases hT U t x hxU with âŸ¨V, Î¹, âŸ¨s, h_eqâŸ©, hxVâŸ©
    use â„±.germ âŸ¨x, hxVâŸ© s
    convert stalkFunctor_map_germ_apply V âŸ¨x, hxVâŸ© T s using 1
    simpa [h_eq] using (germ_res_apply ğ’¢ Î¹ âŸ¨x, hxVâŸ© t).symm
  Â· intro U t x hxU
    set t_x := ğ’¢.germ âŸ¨x, hxUâŸ© t with ht_x
    obtain âŸ¨s_x, hs_x : ((stalkFunctor C x).map T) s_x = t_xâŸ© := hT x t_x
    obtain âŸ¨V, hxV, s, rflâŸ© := â„±.germ_exist x s_x
    have key_W := ğ’¢.germ_eq x hxV hxU (T.app _ s) t <| by
      convert hs_x using 1
      symm
      convert stalkFunctor_map_germ_apply _ _ _ s
    obtain âŸ¨W, hxW, hWV, hWU, h_eqâŸ© := key_W
    refine' âŸ¨W, hWU, âŸ¨â„±.map hWV.op s, _âŸ©, hxWâŸ©
    convert h_eq using 1
    simp only [â† comp_apply, T.naturality]","error:  function expected at
  hT
term has type
  IsLocallySurjective T
error:  rcases tactic failed: xâœ : ?m.4085 is not an inductive datatype
error:  tactic 'introN' failed, insufficient number of binders
case mpr
C : Type u
instâœÂ³ : Category.{v, u} C
instâœÂ² : ConcreteCategory C
X : TopCat
â„± ğ’¢ : Presheaf C X
instâœÂ¹ : Limits.HasColimits C
instâœ : Limits.PreservesFilteredColimits (forget C)
T : â„± âŸ¶ ğ’¢
hT : âˆ€ (x : â†‘X), Function.Surjective â‡‘((stalkFunctor C x).map T)
âŠ¢ IsLocallySurjective T","theorem locally_surjective_iff_surjective_on_stalks (T : â„± âŸ¶ ğ’¢) :
    IsLocallySurjective T â†” âˆ€ x : X, Function.Surjective ((stalkFunctor C x).map T) ",":= by
  constructor <;> intro hT
  Â· 
    intro x g
    obtain âŸ¨U, hxU, t, rflâŸ© := ğ’¢.germ_exist x g
    rcases hT.imageSieve_mem t x hxU with âŸ¨V, Î¹, âŸ¨s, h_eqâŸ©, hxVâŸ©
    use â„±.germ âŸ¨x, hxVâŸ© s
    convert stalkFunctor_map_germ_apply V âŸ¨x, hxVâŸ© T s using 1
    simpa [h_eq] using (germ_res_apply ğ’¢ Î¹ âŸ¨x, hxVâŸ© t).symm
  Â· constructor
    intro U t x hxU
    set t_x := ğ’¢.germ âŸ¨x, hxUâŸ© t with ht_x
    obtain âŸ¨s_x, hs_x : ((stalkFunctor C x).map T) s_x = t_xâŸ© := hT x t_x
    obtain âŸ¨V, hxV, s, rflâŸ© := â„±.germ_exist x s_x
    have key_W := ğ’¢.germ_eq x hxV hxU (T.app _ s) t <| by
      convert hs_x using 1
      symm
      convert stalkFunctor_map_germ_apply _ _ _ s
    obtain âŸ¨W, hxW, hWV, hWU, h_eqâŸ© := key_W
    refine âŸ¨W, hWU, âŸ¨â„±.map hWV.op s, ?_âŸ©, hxWâŸ©
    convert h_eq using 1
    simp only [â† comp_apply, T.naturality]"
Mathlib/Data/ZMod/Basic.lean,ZMod.neg_eq_self_iff,neg_eq_self_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [neg_eq_iff_add_eq_zero, â† two_mul]
  cases n
  Â· erw [@mul_eq_zero â„¤, @mul_eq_zero â„•, val_eq_zero]
    exact
      âŸ¨fun h => h.elim (by simp) Or.inl, fun h =>
        Or.inr (h.elim id fun h => h.elim (by simp) id)âŸ©
  conv_lhs =>
    rw [â† a.natCast_zmod_val, â† Nat.cast_two, â† Nat.cast_mul, natCast_zmod_eq_zero_iff_dvd]
  constructor
  Â· rintro âŸ¨m, heâŸ©
    cases' m with m
    Â· erw [mul_zero, mul_eq_zero] at he
      rcases he with (âŸ¨âŸ¨âŸ©âŸ© | he)
      exact Or.inl (a.val_eq_zero.1 he)
    cases m
    Â· right
      rwa [show Nat.succ Nat.zero = 1 from rfl, mul_one] at he
    refine' (a.val_lt.not_le <| Nat.le_of_mul_le_mul_left _ zero_lt_two).elim
    rw [he, mul_comm]
    apply Nat.mul_le_mul_left
    erw [Nat.succ_le_succ_iff, Nat.succ_le_succ_iff]; simp
  Â· rintro (rfl | h)
    Â· rw [val_zero, mul_zero]
      apply dvd_zero
    Â· rw [h]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero.succ
case succ.mp.intro.succ.zero.h
nâœ : â„•
a : ZMod (nâœ + 1)
he : 2 * a.val = (nâœ + 1) * (0 + 1)
âŠ¢ 2 * a.val = nâœ + 1",theorem neg_eq_self_iff {n : â„•} (a : ZMod n) : -a = a â†” a = 0 âˆ¨ 2 * a.val = n ,":= by
  rw [neg_eq_iff_add_eq_zero, â† two_mul]
  cases n
  Â· erw [@mul_eq_zero â„¤, @mul_eq_zero â„•, val_eq_zero]
    exact
      âŸ¨fun h => h.elim (by simp) Or.inl, fun h =>
        Or.inr (h.elim id fun h => h.elim (by simp) id)âŸ©
  conv_lhs =>
    rw [â† a.natCast_zmod_val, â† Nat.cast_two, â† Nat.cast_mul, natCast_zmod_eq_zero_iff_dvd]
  constructor
  Â· rintro âŸ¨m, heâŸ©
    cases' m with m
    Â· erw [mul_zero, mul_eq_zero] at he
      rcases he with (âŸ¨âŸ¨âŸ©âŸ© | he)
      exact Or.inl (a.val_eq_zero.1 he)
    cases m
    Â· right
      rwa [show 0 + 1 = 1 from rfl, mul_one] at he
    refine (a.val_lt.not_le <| Nat.le_of_mul_le_mul_left ?_ zero_lt_two).elim
    rw [he, mul_comm]
    apply Nat.mul_le_mul_left
    erw [Nat.succ_le_succ_iff, Nat.succ_le_succ_iff]; simp
  Â· rintro (rfl | h)
    Â· rw [val_zero, mul_zero]
      apply dvd_zero
    Â· rw [h]"
Mathlib/Topology/Category/Stonean/Basic.lean,Stonean.epi_iff_surjective,epi_iff_surjective,5b2e142323b7a721e3ae2adce3b172f93a82f823,":= by
  refine âŸ¨?_, ConcreteCategory.epi_of_surjective _âŸ©
  dsimp [Function.Surjective]
  intro h y
  by_contra! hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := Cá¶œ
  have hUy : U âˆˆ ğ“ y := by
    simp only [Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain âŸ¨V, hV, hyV, hVUâŸ© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy
  classical
  let g : Y âŸ¶ mkFinite (ULift (Fin 2)) :=
    âŸ¨(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _âŸ©
  let h : Y âŸ¶ mkFinite (ULift (Fin 2)) := âŸ¨fun _ => âŸ¨1âŸ©, continuous_constâŸ©
  have H : h = g := by
    rw [â† cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU Â·) ?_ 
    simpa only [Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H","error:  simp made no progress
error:  type mismatch
  hâœ
has type
  âˆƒ a, f a = f x : Prop
but is expected to have type
  f x âˆ‰ U : Prop","lemma epi_iff_surjective {X Y : Stonean} (f : X âŸ¶ Y) :
    Epi f â†” Function.Surjective f ",":= by
  refine âŸ¨?_, ConcreteCategory.epi_of_surjective _âŸ©
  dsimp [Function.Surjective]
  intro h y
  by_contra! hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := Cá¶œ
  have hUy : U âˆˆ ğ“ y := by
    simp only [C, Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain âŸ¨V, hV, hyV, hVUâŸ© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy
  classical
  let g : Y âŸ¶ mkFinite (ULift (Fin 2)) :=
    âŸ¨(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _âŸ©
  let h : Y âŸ¶ mkFinite (ULift (Fin 2)) := âŸ¨fun _ => âŸ¨1âŸ©, continuous_constâŸ©
  have H : h = g := by
    rw [â† cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU Â·) ?_ 
    simpa only [U, Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H"
Mathlib/Algebra/Lie/Weights/Basic.lean,LieModule.independent_weightSpaceOf,independent_weightSpaceOf,61e05975727e0b1a19d0075b994c53596adb3405,":= by
  rw [LieSubmodule.independent_iff_coe_toSubmodule]
  exact (toEnd R L M x).independent_generalizedEigenspace","error:  invalid field 'independent_generalizedEigenspace', the environment does not contain 'Module.End.independent_generalizedEigenspace'
  (toEnd R L M) x
has type
  Module.End R M
error:  invalid field 'independent_generalizedEigenspace', the environment does not contain 'LinearMap.independent_generalizedEigenspace'
  (toEnd R L M) x
has type
  M â†’â‚—[R] M","lemma independent_weightSpaceOf [NoZeroSMulDivisors R M] (x : L) :
    CompleteLattice.Independent fun (Ï‡ : R) â†¦ weightSpaceOf M Ï‡ x ",":= by
  rw [LieSubmodule.independent_iff_coe_toSubmodule]
  exact (toEnd R L M x).independent_genEigenspace"
Mathlib/GroupTheory/GroupAction/Defs.lean,smul_ite_zero,smul_ite_zero,4f9521601e74c84eb376c21958a12b707aa0fb83,":= by rw [smul_ite, smul_zero]","error:  unknown identifier 'smul_ite'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.635
M : Type u_1
N : Type u_2
G : Type u_3
A : Type u_4
B : Type u_5
Î± : Type u_6
Î² : Type u_7
Î³ : Type u_8
Î´ : Type u_9
instâœÂ² : Zero A
instâœÂ¹ : SMulZeroClass M A
p : Prop
instâœ : Decidable p
a : M
b : A
âŠ¢ (a â€¢ if p then b else 0) = if p then a â€¢ b else 0","lemma smul_ite_zero (p : Prop) [Decidable p] (a : M) (b : A) :
    (a â€¢ if p then b else 0) = if p then a â€¢ b else 0 ",:= by split_ifs <;> simp
Mathlib/Topology/PartitionOfUnity.lean,BumpCovering.exists_isSubordinate,exists_isSubordinate,47189ba3b5745e8b76312e34fe4a6c87e0d76e90,":= by
  rcases exists_subset_unionáµ¢_closure_subset hs ho (fun x _ => hf.point_finite x) hU with
    âŸ¨V, hsV, hVo, hVUâŸ©
  have hVU' : âˆ€ i, V i âŠ† U i := fun i => Subset.trans subset_closure (hVU i)
  rcases exists_subset_unionáµ¢_closure_subset hs hVo (fun x _ => (hf.subset hVU').point_finite x)
      hsV with
    âŸ¨W, hsW, hWo, hWVâŸ©
  choose f hfp hf0 hf1 hf01 using fun i =>
    h01 _ _ (isClosed_compl_iff.2 <| hVo i) isClosed_closure
      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))
  have hsupp : âˆ€ i, support (f i) âŠ† V i := fun i => support_subset_iff'.2 (hf0 i)
  refine' âŸ¨âŸ¨f, hf.subset fun i => Subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1,
      fun i x => (hf01 i x).2, fun x hx => _âŸ©,
    hfp, fun i => Subset.trans (closure_mono (hsupp i)) (hVU i)âŸ©
  rcases mem_unionáµ¢.1 (hsW hx) with âŸ¨i, hiâŸ©
  exact âŸ¨i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)âŸ©","error:  unknown identifier 'exists_subset_unionáµ¢_closure_subset'
error:  rcases tactic failed: xâœ : ?m.93115 is not an inductive datatype","theorem exists_isSubordinate_of_locallyFinite_of_prop [NormalSpace X] (p : (X â†’ â„) â†’ Prop)
    (h01 : âˆ€ s t, IsClosed s â†’ IsClosed t â†’ Disjoint s t â†’
      âˆƒ f : C(X, â„), p f âˆ§ EqOn f 0 s âˆ§ EqOn f 1 t âˆ§ âˆ€ x, f x âˆˆ Icc (0 : â„) 1)
    (hs : IsClosed s) (U : Î¹ â†’ Set X) (ho : âˆ€ i, IsOpen (U i)) (hf : LocallyFinite U)
    (hU : s âŠ† â‹ƒ i, U i) : âˆƒ f : BumpCovering Î¹ X s, (âˆ€ i, p (f i)) âˆ§ f.IsSubordinate U ",":= by
  rcases exists_subset_iUnion_closure_subset hs ho (fun x _ => hf.point_finite x) hU with
    âŸ¨V, hsV, hVo, hVUâŸ©
  have hVU' : âˆ€ i, V i âŠ† U i := fun i => Subset.trans subset_closure (hVU i)
  rcases exists_subset_iUnion_closure_subset hs hVo (fun x _ => (hf.subset hVU').point_finite x)
      hsV with
    âŸ¨W, hsW, hWo, hWVâŸ©
  choose f hfp hf0 hf1 hf01 using fun i =>
    h01 _ _ (isClosed_compl_iff.2 <| hVo i) isClosed_closure
      (disjoint_right.2 fun x hx => Classical.not_not.2 (hWV i hx))
  have hsupp : âˆ€ i, support (f i) âŠ† V i := fun i => support_subset_iff'.2 (hf0 i)
  refine âŸ¨âŸ¨f, hf.subset fun i => Subset.trans (hsupp i) (hVU' i), fun i x => (hf01 i x).1,
      fun i x => (hf01 i x).2, fun x hx => ?_âŸ©,
    hfp, fun i => Subset.trans (closure_mono (hsupp i)) (hVU i)âŸ©
  rcases mem_iUnion.1 (hsW hx) with âŸ¨i, hiâŸ©
  exact âŸ¨i, ((hf1 i).mono subset_closure).eventuallyEq_of_mem ((hWo i).mem_nhds hi)âŸ©"
Mathlib/Analysis/Convex/Combination.lean,Set.Finite.convexHull_eq_image,Set.Finite.convexHull_eq_image,67a30f55cabb8ddd087043d4900eb7947be27d10,":= by
  letI := hs.fintype
  rw [â† convexHull_basis_eq_stdSimplex, â† LinearMap.convexHull_image, â† Set.range_comp]
  apply congr_arg
  simp_rw [Function.comp]
  convert Subtype.range_coe.symm
  simp [LinearMap.sum_apply, ite_smul _ _ (1 : R), Finset.filter_eq, Finset.mem_univ]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  LinearMap
has type
  (?m.568565 â†’+* ?m.568566) â†’
    (M : Type ?u.568562) â†’
      (Mâ‚‚ : Type ?u.568561) â†’
        [inst : AddCommMonoid M] â†’
          [inst_1 : AddCommMonoid Mâ‚‚] â†’
            [inst : Module ?m.568565 M] â†’ [inst : Module ?m.568566 Mâ‚‚] â†’ Type (max ?u.568562 ?u.568561)
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.568634
R : Type u_1
R' : Type u_2
E : Type u_3
F : Type u_4
Î¹ : Type u_5
Î¹' : Type u_6
Î± : Type u_7
instâœâ¹ : LinearOrderedField R
instâœâ¸ : LinearOrderedField R'
instâœâ· : AddCommGroup E
instâœâ¶ : AddCommGroup F
instâœâµ : LinearOrderedAddCommGroup Î±
instâœâ´ : Module R E
instâœÂ³ : Module R F
instâœÂ² : Module R Î±
instâœÂ¹ : OrderedSMul R Î±
sâœ : Set E
i j : Î¹
c : R
t : Finset Î¹
w : Î¹ â†’ R
z : Î¹ â†’ E
instâœ : Fintype Î¹
f : Î¹ â†’ R
s : Set E
hs : s.Finite
this : Fintype â†‘s := hs.fintype
âŠ¢ (convexHull R) s =
    â‡‘(âˆ‘ x : â†‘s, (LinearMap.proj x).smulRight â†‘x) '' (convexHull R) (range fun i j â†¦ if i = j then 1 else 0)","theorem Set.Finite.convexHull_eq_image {s : Set E} (hs : s.Finite) : convexHull R s =
    haveI := hs.fintype
    (â‡‘(âˆ‘ x : s, (@LinearMap.proj R s _ (fun _ => R) _ _ x).smulRight x.1)) '' stdSimplex R s ",":= by
  letI := hs.fintype
  rw [â† convexHull_basis_eq_stdSimplex, LinearMap.image_convexHull, â† Set.range_comp]
  apply congr_arg
  simp_rw [Function.comp]
  convert Subtype.range_coe.symm
  simp [LinearMap.sum_apply, ite_smul, Finset.filter_eq, Finset.mem_univ]"
Mathlib/LinearAlgebra/ExteriorAlgebra/Basic.lean,ExteriorAlgebra.Î¹Inv_comp_map,Î¹Inv_comp_map,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  letI : Module Ráµáµ’áµ– M := Module.compHom _ ((RingHom.id R).fromOpposite mul_comm)
  haveI : IsCentralScalar R M := âŸ¨fun r m => rflâŸ©
  letI : Module Ráµáµ’áµ– N := Module.compHom _ ((RingHom.id R).fromOpposite mul_comm)
  haveI : IsCentralScalar R N := âŸ¨fun r m => rflâŸ©
  unfold Î¹Inv
  conv_lhs => rw [LinearMap.comp_assoc, â† AlgHom.comp_toLinearMap, toTrivSqZeroExt_comp_map,
                AlgHom.comp_toLinearMap, â† LinearMap.comp_assoc, TrivSqZeroExt.sndHom_comp_map]","warning:  exteriorPower does not have a doc string
error:  unsolved goals
R : Type u1
instâœâ¸ : CommRing R
M : Type u2
instâœâ· : AddCommGroup M
instâœâ¶ : Module R M
A : Type u_1
instâœâµ : Semiring A
instâœâ´ : Algebra R A
N : Type u4
N' : Type u5
instâœÂ³ : AddCommGroup N
instâœÂ² : Module R N
instâœÂ¹ : AddCommGroup N'
instâœ : Module R N'
f : M â†’â‚—[R] N
thisâœÂ² : Module Ráµáµ’áµ– M := Module.compHom M ((RingHom.id R).fromOpposite â‹¯)
thisâœÂ¹ : IsCentralScalar R M
thisâœ : Module Ráµáµ’áµ– N := Module.compHom N ((RingHom.id R).fromOpposite â‹¯)
this : IsCentralScalar R N
âŠ¢ (f âˆ˜â‚— TrivSqZeroExt.sndHom R M) âˆ˜â‚— toTrivSqZeroExt.toLinearMap =
    f âˆ˜â‚— TrivSqZeroExt.sndHom R M âˆ˜â‚— toTrivSqZeroExt.toLinearMap","theorem Î¹Inv_comp_map (f : M â†’â‚—[R] N) :
    Î¹Inv.comp (map f).toLinearMap = f.comp Î¹Inv ",":= by
  letI : Module Ráµáµ’áµ– M := Module.compHom _ ((RingHom.id R).fromOpposite mul_comm)
  haveI : IsCentralScalar R M := âŸ¨fun r m => rflâŸ©
  letI : Module Ráµáµ’áµ– N := Module.compHom _ ((RingHom.id R).fromOpposite mul_comm)
  haveI : IsCentralScalar R N := âŸ¨fun r m => rflâŸ©
  unfold Î¹Inv
  conv_lhs => rw [LinearMap.comp_assoc, â† AlgHom.comp_toLinearMap, toTrivSqZeroExt_comp_map,
                AlgHom.comp_toLinearMap, â† LinearMap.comp_assoc, TrivSqZeroExt.sndHom_comp_map]
  rfl"
Mathlib/RepresentationTheory/GroupCohomology/LowDegree.lean,groupCohomology.isoTwoCocycles_hom_comp_subtype,isoTwoCocycles_hom_comp_subtype,271f33c9ecf64c52194de2b2788e28d51066790b,":= by
  dsimp [isoTwoCocycles]
  rw [Category.assoc, Category.assoc]
  erw [(shortComplexH2 A).moduleCatCyclesIso_hom_subtype]
  rw [cyclesMap_i, HomologicalComplex.cyclesIsoSc'_hom_iCycles_assoc]
  rfl",error:  no goals to be solved,"lemma isoTwoCocycles_hom_comp_subtype :
    (isoTwoCocycles A).hom â‰« ModuleCat.ofHom (twoCocycles A).subtype =
      iCocycles A 2 â‰« (twoCochainsLequiv A).toModuleIso.hom ",":= by
  dsimp [isoTwoCocycles]
  rw [Category.assoc, Category.assoc]
  erw [(shortComplexH2 A).moduleCatCyclesIso_hom_subtype]
  rw [cyclesMap_i, HomologicalComplex.cyclesIsoSc'_hom_iCycles_assoc]"
Mathlib/RingTheory/PowerSeries/Basic.lean,PowerSeries.X_pow_dvd_iff,X_pow_dvd_iff,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":= by
  classical
  constructor
  Â· rintro âŸ¨Ï†, rflâŸ© m h
    rw [coeff_mul, Finset.sum_eq_zero]
    rintro âŸ¨i, jâŸ© hij
    rw [coeff_X_pow, if_neg, zero_mul]
    contrapose! h
    dsimp at h
    subst i
    rw [mem_antidiagonal] at hij
    rw [â† hij, Finsupp.add_apply, Finsupp.single_eq_same]
    exact Nat.le_add_right n _
  Â· intro h
    refine' âŸ¨fun m => coeff R (m + single s n) Ï†, _âŸ©
    ext m
    by_cases H : m - single s n + single s n = m
    Â· rw [coeff_mul, Finset.sum_eq_single (single s n, m - single s n)]
      Â· rw [coeff_X_pow, if_pos rfl, one_mul]
        simpa using congr_arg (fun m : Ïƒ â†’â‚€ â„• => coeff R m Ï†) H.symm
      Â· rintro âŸ¨i, jâŸ© hij hne
        rw [mem_antidiagonal] at hij
        rw [coeff_X_pow]
        split_ifs with hi
        Â· exfalso
          apply hne
          rw [â† hij, â† hi, Prod.mk.inj_iff]
          refine' âŸ¨rfl, _âŸ©
          ext t
          simp only [add_tsub_cancel_left, Finsupp.add_apply, Finsupp.tsub_apply]
        Â· exact zero_mul _
      Â· intro hni
        exfalso
        apply hni
        rwa [mem_antidiagonal, add_comm]
    Â· rw [h, coeff_mul, Finset.sum_eq_zero]
      Â· rintro âŸ¨i, jâŸ© hij
        rw [mem_antidiagonal] at hij
        rw [coeff_X_pow]
        split_ifs with hi
        Â· exfalso
          apply H
          rw [â† hij, hi]
          ext
          rw [coe_add, coe_add, Pi.add_apply, Pi.add_apply, add_tsub_cancel_left, add_comm]
        Â· exact zero_mul _
      Â· contrapose! H
        ext t
        by_cases hst : s = t
        Â· subst t
          simpa using tsub_add_cancel_of_le H
        Â· simp [Finsupp.single_apply, hst]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?gâ‚ + ?gâ‚‚) ?a
case mp.intro.mk.hnc
R : Type u_1
instâœ : Semiring R
n : â„•
Ï† : RâŸ¦XâŸ§
m j : â„•
hij : (n, j).1 + (n, j).2 = m
âŠ¢ n â‰¤ (n, j).1 + (n, j).2
error:  unknown identifier 's'
error:  applyExtTheorem only applies to equations, not
  (Unit â†’â‚€ â„•) â†’ Type ?u.122528
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated","theorem X_pow_dvd_iff {n : â„•} {Ï† : RâŸ¦XâŸ§} :
    (X : RâŸ¦XâŸ§) ^ n âˆ£ Ï† â†” âˆ€ m, m < n â†’ coeff R m Ï† = 0 ",":= by
  convert@MvPowerSeries.X_pow_dvd_iff Unit R _ () n Ï†
  constructor <;> intro h m hm
  Â· rw [Finsupp.unique_single m]
    convert h _ hm
  Â· apply h
    simpa only [Finsupp.single_eq_same] using hm"
Mathlib/RingTheory/Norm.lean,Algebra.norm_eq_one_of_not_exists_basis,norm_eq_one_of_not_exists_basis,02180b5481ba753a8248c0a7c377655a5010dc6b,":= by rw [norm_apply, LinearMap.det]; split_ifs; trivial","error:  unsolved goals
case neg
R : Type u_1
S : Type u_2
T : Type u_3
instâœâ· : CommRing R
instâœâ¶ : Ring S
instâœâµ : Algebra R S
K : Type u_4
L : Type u_5
F : Type u_6
instâœâ´ : Field K
instâœÂ³ : Field L
instâœÂ² : Field F
instâœÂ¹ : Algebra K L
instâœ : Algebra K F
Î¹ : Type w
h : Â¬âˆƒ s, Nonempty (Basis { x // x âˆˆ s } R S)
x : S
hâœ : Â¬âˆƒ s, Nonempty (Basis { x // x âˆˆ s } R S)
âŠ¢ 1 ((lmul R S) x) = 1","theorem norm_eq_one_of_not_exists_basis (h : Â¬âˆƒ s : Finset S, Nonempty (Basis s R S)) (x : S) :
    norm R x = 1 ",":= by rw [norm_apply, LinearMap.det]; split_ifs <;> trivial"
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.unifIntegrable_const,unifIntegrable_const,ff33d25c791a3fac407c782b49018fcb63700d0d,":= by
  intro Îµ hÎµ
  obtain âŸ¨Î´, hÎ´_pos, hgÎ´âŸ© := hg.snorm_indicator_le Î¼ hp hp_ne_top hÎµ
  exact âŸ¨Î´, hÎ´_pos, fun _ => hgÎ´âŸ©","error:  application type mismatch
  Memâ„’p.snorm_indicator_le Î¼
argument
  Î¼
has type
  Measure Î± : Type u_1
but is expected to have type
  1 â‰¤ ?m.100310 : Prop
error:  rcases tactic failed: xâœ : ?m.101969 is not an inductive datatype","theorem unifIntegrable_const {g : Î± â†’ Î²} (hp : 1 â‰¤ p) (hp_ne_top : p â‰  âˆ) (hg : Memâ„’p g p Î¼) :
    UnifIntegrable (fun _ : Î¹ => g) p Î¼ ",":= by
  intro Îµ hÎµ
  obtain âŸ¨Î´, hÎ´_pos, hgÎ´âŸ© := hg.snorm_indicator_le hp hp_ne_top hÎµ
  exact âŸ¨Î´, hÎ´_pos, fun _ => hgÎ´âŸ©"
Mathlib/GroupTheory/OrderOfElement.lean,orderOf_one,orderOf_one,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  rw [orderOf, â† minimalPeriod_id (x : = (1 : G)), â† one_mul_eq_id]",error:  unexpected token '='; expected ')',theorem orderOf_one : orderOf (1 : G) = 1 ,":= by
  rw [orderOf, â† minimalPeriod_id (x := (1:G)), â† one_mul_eq_id]"
Mathlib/Data/Nat/MaxPowDiv.lean,Nat.maxPowDiv.pow_dvd,pow_dvd,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  dsimp [maxPowDiv]
  rw [go_eq]
  by_cases h : (1 < p âˆ§ 0 < n âˆ§ n % p = 0)
  Â· have : n / p < n := by apply Nat.div_lt_self <;> aesop
    rw [if_pos h]
    have âŸ¨c,hcâŸ© := pow_dvd p (n / p)
    rw [go_succ, pow_succ]
    nth_rw 2 [â† mod_add_div' n p]
    rw [h.right.right, zero_add]
    exact âŸ¨c,by nth_rw 1 [hc]; ac_rflâŸ©
  Â· rw [if_neg h]
    simp","warning:  maxPowDiv does not have a doc string
error:  unknown identifier 'go_eq'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.5740
p n : â„•
âŠ¢ p ^ go 0 p n âˆ£ n",theorem pow_dvd (p n : â„•) : p ^ (p.maxPowDiv n) âˆ£ n ,":= by
  dsimp [maxPowDiv]
  rw [go]
  by_cases h : (1 < p âˆ§ 0 < n âˆ§ n % p = 0)
  Â· have : n / p < n := by apply Nat.div_lt_self <;> aesop
    rw [if_pos h]
    have âŸ¨c,hcâŸ© := pow_dvd p (n / p)
    rw [go_succ, pow_succ]
    nth_rw 2 [â† mod_add_div' n p]
    rw [h.right.right, zero_add]
    exact âŸ¨c,by nth_rw 1 [hc]; ac_rflâŸ©
  Â· rw [if_neg h]
    simp"
Mathlib/Computability/Primrec.lean,Primrec.nat_bodd,nat_bodd,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  (Primrec.beq.compâ‚‚ (nat_mod.compâ‚‚ .id (const 2)) (const 1)).of_eq fun n => by
    cases H : n.bodd <;> simp [Nat.mod_two_of_bodd, H]","error:  application type mismatch
  Primrecâ‚‚.compâ‚‚ nat_mod Primrec.id
argument
  Primrec.id
has type
  Primrec id : Prop
but is expected to have type
  Primrecâ‚‚ ?m.113624 : Prop
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  n
has type
  ?m.120669
error:  tactic 'induction' failed, major premise type is not an inductive type 
  ?m.123354
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
Î´ : Type u_4
Ïƒ : Type u_5
instâœâ´ : Primcodable Î±
instâœÂ³ : Primcodable Î²
instâœÂ² : Primcodable Î³
instâœÂ¹ : Primcodable Î´
instâœ : Primcodable Ïƒ
n : ?m.120669
xâœ : ?m.123354
H : sorryAx ?m.123354 true = xâœ
âŠ¢ âˆ€ (b : ?m.120670), (?m.113624 n b % ?m.113625 n b == ?m.113579 n b) = ?m.120676 n b",theorem nat_bodd : Primrec Nat.bodd ,":=
  (Primrec.beq.comp (nat_mod.comp .id (const 2)) (const 1)).of_eq fun n => by
    cases H : n.bodd <;> simp [Nat.mod_two_of_bodd, H]"
Mathlib/MeasureTheory/Decomposition/Lebesgue.lean,MeasureTheory.Measure.eq_singularPart,eq_singularPart,a2d4b97db742cef33d7ce3404f92ab85330707e5,":= by
  have : HaveLebesgueDecomposition Î¼ Î½ := âŸ¨âŸ¨âŸ¨s, fâŸ©, hf, hs, haddâŸ©âŸ©
  obtain âŸ¨hmeas, hsing, hadd'âŸ© := haveLebesgueDecomposition_spec Î¼ Î½
  obtain âŸ¨âŸ¨S, hSâ‚, hSâ‚‚, hSâ‚ƒâŸ©, âŸ¨T, hTâ‚, hTâ‚‚, hTâ‚ƒâŸ©âŸ© := hs, hsing
  rw [hadd'] at hadd
  have hÎ½inter : Î½ (S âˆ© T)á¶œ = 0 := by
    rw [compl_inter]
    refine' nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) _)
    rw [hTâ‚ƒ, hSâ‚ƒ, add_zero]
  have heq : s.restrict (S âˆ© T)á¶œ = (Î¼.singularPart Î½).restrict (S âˆ© T)á¶œ := by
    ext1 A hA
    have hf : Î½.withDensity f (A âˆ© (S âˆ© T)á¶œ) = 0 := by
      refine' withDensity_absolutelyContinuous Î½ _ _
      rw [â† nonpos_iff_eq_zero]
      exact hÎ½inter â–¸ measure_mono (inter_subset_right _ _)
    have hrn : Î½.withDensity (Î¼.rnDeriv Î½) (A âˆ© (S âˆ© T)á¶œ) = 0 := by
      refine' withDensity_absolutelyContinuous Î½ _ _
      rw [â† nonpos_iff_eq_zero]
      exact hÎ½inter â–¸ measure_mono (inter_subset_right _ _)
    rw [restrict_apply hA, restrict_apply hA, â† add_zero (s (A âˆ© (S âˆ© T)á¶œ)), â† hf, â† add_apply, â†
      hadd, add_apply, hrn, add_zero]
  have heq' : âˆ€ A : Set Î±, MeasurableSet A â†’ s A = s.restrict (S âˆ© T)á¶œ A := by
    intro A hA
    have hsinter : s (A âˆ© (S âˆ© T)) = 0 := by
      rw [â† nonpos_iff_eq_zero]
      exact hSâ‚‚ â–¸ measure_mono ((inter_subset_right _ _).trans (inter_subset_left _ _))
    rw [restrict_apply hA, â† diff_eq, AEDisjoint.measure_diff_left hsinter]
  ext1 A hA
  have hÎ¼inter : Î¼.singularPart Î½ (A âˆ© (S âˆ© T)) = 0 := by
    rw [â† nonpos_iff_eq_zero]
    exact hTâ‚‚ â–¸ measure_mono ((inter_subset_right _ _).trans (inter_subset_right _ _))
  rw [heq' A hA, heq, restrict_apply hA, â† diff_eq, AEDisjoint.measure_diff_left hÎ¼inter]","error:  function expected at
  inter_subset_right ?m.52103
term has type
  ?m.52102 âˆˆ ?m.52101
error:  function expected at
  inter_subset_right ?m.52720
term has type
  ?m.52719 âˆˆ ?m.52718
error:  function expected at
  inter_subset_right ?m.53949
term has type
  ?m.53948 âˆˆ ?m.53947
error:  function expected at
  inter_subset_right ?m.54737
term has type
  ?m.54736 âˆˆ ?m.54735","theorem eq_singularPart {s : Measure Î±} {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) (hs : s âŸ‚â‚˜ Î½)
    (hadd : Î¼ = s + Î½.withDensity f) : s = Î¼.singularPart Î½ ",":= by
  have : HaveLebesgueDecomposition Î¼ Î½ := âŸ¨âŸ¨âŸ¨s, fâŸ©, hf, hs, haddâŸ©âŸ©
  obtain âŸ¨hmeas, hsing, hadd'âŸ© := haveLebesgueDecomposition_spec Î¼ Î½
  obtain âŸ¨âŸ¨S, hSâ‚, hSâ‚‚, hSâ‚ƒâŸ©, âŸ¨T, hTâ‚, hTâ‚‚, hTâ‚ƒâŸ©âŸ© := hs, hsing
  rw [hadd'] at hadd
  have hÎ½inter : Î½ (S âˆ© T)á¶œ = 0 := by
    rw [compl_inter]
    refine nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) ?_)
    rw [hTâ‚ƒ, hSâ‚ƒ, add_zero]
  have heq : s.restrict (S âˆ© T)á¶œ = (Î¼.singularPart Î½).restrict (S âˆ© T)á¶œ := by
    ext1 A hA
    have hf : Î½.withDensity f (A âˆ© (S âˆ© T)á¶œ) = 0 := by
      refine withDensity_absolutelyContinuous Î½ _ ?_
      rw [â† nonpos_iff_eq_zero]
      exact hÎ½inter â–¸ measure_mono inter_subset_right
    have hrn : Î½.withDensity (Î¼.rnDeriv Î½) (A âˆ© (S âˆ© T)á¶œ) = 0 := by
      refine withDensity_absolutelyContinuous Î½ _ ?_
      rw [â† nonpos_iff_eq_zero]
      exact hÎ½inter â–¸ measure_mono inter_subset_right
    rw [restrict_apply hA, restrict_apply hA, â† add_zero (s (A âˆ© (S âˆ© T)á¶œ)), â† hf, â† add_apply, â†
      hadd, add_apply, hrn, add_zero]
  have heq' : âˆ€ A : Set Î±, MeasurableSet A â†’ s A = s.restrict (S âˆ© T)á¶œ A := by
    intro A hA
    have hsinter : s (A âˆ© (S âˆ© T)) = 0 := by
      rw [â† nonpos_iff_eq_zero]
      exact hSâ‚‚ â–¸ measure_mono (inter_subset_right.trans inter_subset_left)
    rw [restrict_apply hA, â† diff_eq, AEDisjoint.measure_diff_left hsinter]
  ext1 A hA
  have hÎ¼inter : Î¼.singularPart Î½ (A âˆ© (S âˆ© T)) = 0 := by
    rw [â† nonpos_iff_eq_zero]
    exact hTâ‚‚ â–¸ measure_mono (inter_subset_right.trans inter_subset_right)
  rw [heq' A hA, heq, restrict_apply hA, â† diff_eq, AEDisjoint.measure_diff_left hÎ¼inter]"
Mathlib/NumberTheory/Cyclotomic/Discriminant.lean,IsCyclotomicExtension.discr_prime_pow_ne_two,discr_prime_pow_ne_two,693fd79515903b10b1d31f10dccfc49e633cf7ee,":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hÎ¶.powerBasis_gen _, â†
    hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), succ_sub_one]
  have coe_two : ((2 : â„•+) : â„•) = 2 := rfl
  have hp2 : p = 2 â†’ k â‰  0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  Â· rcases eq_or_ne p 2 with (rfl | hp2)
    Â· rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with âŸ¨k, rflâŸ©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ]
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      Â· simp
      Â· norm_num; simp_rw [_root_.pow_succ, (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    Â· replace hp2 : (p : â„•) â‰  2
      Â· rwa [Ne.def, â† coe_two, PNat.coe_inj]
      have hpo : Odd (p : â„•) := hp.out.odd_of_ne_two hp2
      obtain âŸ¨a, haâŸ© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine' Nat.Even.sub_odd _ (even_two_mul _) odd_one
      rw [mul_left_comm, â† ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  Â· have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_nat_cast, â† PNat.pow_coe,
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Î¶ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_nat_cast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Î¶ ^ (p : â„•) ^ k - 1) = (p : K) ^ (p : â„•) ^ k := by
      by_cases hp : p = 2
      Â· exact mod_cast hÎ¶.pow_sub_one_norm_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      Â· exact mod_cast hÎ¶.pow_sub_one_norm_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, â† map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, â† succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hÎ¶.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, â† pow_mul, â† mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [â† succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : â„•) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    Â· simp only [H, mul_comm _ (k + 1)]; norm_cast
    Â· 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne.def, pow_eq_zero_iff (by linarith)] at this
      exact absurd (pow_eq_zero h) this","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case e_a.inr
p : â„•+
k : â„•
K : Type u
L : Type v
Î¶ : L
instâœÂ³ : Field K
instâœÂ² : Field L
instâœÂ¹ : Algebra K L
instâœ : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime â†‘p)
hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))
hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1))) K)
hk : p ^ (k + 1) â‰  2
hne : NeZero â†‘â†‘(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : â†‘2 = 2
hp2âœ : p = 2 â†’ k â‰  0
hp2 : â†‘p â‰  2
âŠ¢ (-1) ^ (â†‘p ^ k * (â†‘p - 1) * (â†‘p ^ k * (â†‘p - 1) - 1) / 2) = (-1) ^ (â†‘p ^ k * (â†‘p - 1) / 2)
error:  unsolved goals
case e_a
p : â„•+
k : â„•
K : Type u
L : Type v
Î¶ : L
instâœÂ³ : Field K
instâœÂ² : Field L
instâœÂ¹ : Algebra K L
instâœ : IsCyclotomicExtension {p ^ (k + 1)} K L
hp : Fact (Nat.Prime â†‘p)
hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))
hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1))) K)
hk : p ^ (k + 1) â‰  2
hne : NeZero â†‘â†‘(p ^ (k + 1))
mf : Module.Finite K L
se : IsSeparable K L
coe_two : â†‘2 = 2
hp2 : p = 2 â†’ k â‰  0
âŠ¢ (Algebra.norm K) ((aeval Î¶) (derivative (cyclotomic (â†‘p ^ (k + 1)) K))) = â†‘â†‘p ^ (â†‘p ^ k * ((â†‘p - 1) * (k + 1) - 1))","theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : â„•).Prime]
    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (â†‘(p ^ (k + 1)) : â„•) K))
    (hk : p ^ (k + 1) â‰  2) : discr K (hÎ¶.powerBasis K).basis =
      (-1) ^ ((p ^ (k + 1) : â„•).totient / 2) * p ^ ((p : â„•) ^ k * ((p - 1) * (k + 1) - 1)) ",":= by
  haveI hne := IsCyclotomicExtension.neZero' (p ^ (k + 1)) K L
  haveI mf : Module.Finite K L := finiteDimensional {p ^ (k + 1)} K L
  haveI se : IsSeparable K L := (isGalois (p ^ (k + 1)) K L).to_isSeparable
  rw [discr_powerBasis_eq_norm, finrank L hirr, hÎ¶.powerBasis_gen _, â†
    hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, PNat.pow_coe,
    totient_prime_pow hp.out (succ_pos k), Nat.add_one_sub_one]
  have coe_two : ((2 : â„•+) : â„•) = 2 := rfl
  have hp2 : p = 2 â†’ k â‰  0 := by
    rintro rfl rfl
    exact absurd rfl hk
  congr 1
  Â· rcases eq_or_ne p 2 with (rfl | hp2)
    Â· rcases Nat.exists_eq_succ_of_ne_zero (hp2 rfl) with âŸ¨k, rflâŸ©
      rw [coe_two, succ_sub_succ_eq_sub, tsub_zero, mul_one]; simp only [_root_.pow_succ']
      rw [mul_assoc, Nat.mul_div_cancel_left _ zero_lt_two, Nat.mul_div_cancel_left _ zero_lt_two]
      cases k
      Â· simp
      Â· simp_rw [_root_.pow_succ', (even_two.mul_right _).neg_one_pow,
          ((even_two.mul_right _).mul_right _).neg_one_pow]
    Â· replace hp2 : (p : â„•) â‰  2 := by rwa [Ne, â† coe_two, PNat.coe_inj]
      have hpo : Odd (p : â„•) := hp.out.odd_of_ne_two hp2
      obtain âŸ¨a, haâŸ© := (hp.out.even_sub_one hp2).two_dvd
      rw [ha, mul_left_comm, mul_assoc, Nat.mul_div_cancel_left _ two_pos,
        Nat.mul_div_cancel_left _ two_pos, mul_right_comm, pow_mul, (hpo.pow.mul _).neg_one_pow,
        pow_mul, hpo.pow.neg_one_pow]
      refine Nat.Even.sub_odd ?_ (even_two_mul _) odd_one
      rw [mul_left_comm, â† ha]
      exact one_le_mul (one_le_pow _ _ hp.1.pos) (succ_le_iff.2 <| tsub_pos_of_lt hp.1.one_lt)
  Â· have H := congr_arg (@derivative K _) (cyclotomic_prime_pow_mul_X_pow_sub_one K p k)
    rw [derivative_mul, derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast,
      derivative_sub, derivative_one, sub_zero, derivative_X_pow, C_eq_natCast, â† PNat.pow_coe,
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr] at H
    replace H := congr_arg (fun P => aeval Î¶ P) H
    simp only [aeval_add, aeval_mul, minpoly.aeval, zero_mul, add_zero, aeval_natCast,
      _root_.map_sub, aeval_one, aeval_X_pow] at H
    replace H := congr_arg (Algebra.norm K) H
    have hnorm : (norm K) (Î¶ ^ (p : â„•) ^ k - 1) = (p : K) ^ (p : â„•) ^ k := by
      by_cases hp : p = 2
      Â· exact mod_cast hÎ¶.norm_pow_sub_one_eq_prime_pow_of_ne_zero hirr le_rfl (hp2 hp)
      Â· exact mod_cast hÎ¶.norm_pow_sub_one_of_prime_ne_two hirr le_rfl hp
    rw [MonoidHom.map_mul, hnorm, MonoidHom.map_mul, â† map_natCast (algebraMap K L),
      Algebra.norm_algebraMap, finrank L hirr] at H
    conv_rhs at H => 
      enter [1, 2]
      rw [PNat.pow_coe, â† succ_eq_add_one, totient_prime_pow hp.out (succ_pos k), Nat.sub_one,
        Nat.pred_succ]
    rw [â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, map_pow, hÎ¶.norm_eq_one hk hirr, one_pow,
      mul_one, PNat.pow_coe, cast_pow, â† pow_mul, â† mul_assoc, mul_comm (k + 1), mul_assoc] at H
    have := mul_pos (succ_pos k) (tsub_pos_of_lt hp.out.one_lt)
    rw [â† succ_pred_eq_of_pos this, mul_succ, pow_add _ _ ((p : â„•) ^ k)] at H
    replace H := (mul_left_inj' fun h => ?_).1 H
    Â· simp only [H, mul_comm _ (k + 1)]; norm_cast
    Â· 
      have := hne.1
      rw [PNat.pow_coe, Nat.cast_pow, Ne, pow_eq_zero_iff (by omega)] at this
      exact absurd (pow_eq_zero h) this"
Mathlib/Analysis/Complex/Schwarz.lean,Complex.affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div,affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  set g := dslope f c
  rintro z hz
  by_cases h : z = c; Â· simp [h]
  have h_Râ‚ : 0 < Râ‚ := nonempty_ball.mp âŸ¨_, h_zâ‚€âŸ©
  have g_le_div : âˆ€ z âˆˆ ball c Râ‚, â€–g zâ€– â‰¤ Râ‚‚ / Râ‚ := fun z hz =>
    norm_dslope_le_div_of_mapsTo_ball hd h_maps hz
  have g_max : IsMaxOn (norm âˆ˜ g) (ball c Râ‚) zâ‚€ :=
    isMaxOn_iff.mpr fun z hz => by simpa [h_eq] using g_le_div z hz
  have g_diff : DifferentiableOn â„‚ g (ball c Râ‚) :=
    (differentiableOn_dslope (isOpen_ball.mem_nhds (mem_ball_self h_Râ‚))).mpr hd
  have : g z = g zâ‚€ := eqOn_of_isPreconnected_of_isMaxOn_norm (convex_ball c Râ‚).isPreconnected
    isOpen_ball g_diff h_zâ‚€ g_max hz
  simp [â† this]","error:  unsolved goals
case neg
E : Type u_1
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace â„‚ E
R Râ‚ Râ‚‚ : â„
f : â„‚ â†’ E
c zâœ zâ‚€ : â„‚
instâœÂ¹ : CompleteSpace E
instâœ : StrictConvexSpace â„ E
hd : DifferentiableOn â„‚ f (ball c Râ‚)
h_maps : MapsTo f (ball c Râ‚) (ball (f c) Râ‚‚)
h_zâ‚€ : zâ‚€ âˆˆ ball c Râ‚
g : â„‚ â†’ E := dslope f c
h_eq : â€–g zâ‚€â€– = Râ‚‚ / Râ‚
z : â„‚
hz : z âˆˆ ball c Râ‚
h : Â¬z = c
h_Râ‚ : 0 < Râ‚
g_le_div : âˆ€ z âˆˆ ball c Râ‚, â€–g zâ€– â‰¤ Râ‚‚ / Râ‚
g_max : IsMaxOn (norm âˆ˜ g) (ball c Râ‚) zâ‚€
g_diff : DifferentiableOn â„‚ g (ball c Râ‚)
this : g z = g zâ‚€
âŠ¢ f z = f c + (z - c) â€¢ g z","theorem affine_of_mapsTo_ball_of_exists_norm_dslope_eq_div [CompleteSpace E] [StrictConvexSpace â„ E]
    (hd : DifferentiableOn â„‚ f (ball c Râ‚)) (h_maps : Set.MapsTo f (ball c Râ‚) (ball (f c) Râ‚‚))
    (h_zâ‚€ : zâ‚€ âˆˆ ball c Râ‚) (h_eq : â€–dslope f c zâ‚€â€– = Râ‚‚ / Râ‚) :
    Set.EqOn f (fun z => f c + (z - c) â€¢ dslope f c zâ‚€) (ball c Râ‚) ",":= by
  set g := dslope f c
  rintro z hz
  by_cases h : z = c; Â· simp [h]
  have h_Râ‚ : 0 < Râ‚ := nonempty_ball.mp âŸ¨_, h_zâ‚€âŸ©
  have g_le_div : âˆ€ z âˆˆ ball c Râ‚, â€–g zâ€– â‰¤ Râ‚‚ / Râ‚ := fun z hz =>
    norm_dslope_le_div_of_mapsTo_ball hd h_maps hz
  have g_max : IsMaxOn (norm âˆ˜ g) (ball c Râ‚) zâ‚€ :=
    isMaxOn_iff.mpr fun z hz => by simpa [h_eq] using g_le_div z hz
  have g_diff : DifferentiableOn â„‚ g (ball c Râ‚) :=
    (differentiableOn_dslope (isOpen_ball.mem_nhds (mem_ball_self h_Râ‚))).mpr hd
  have : g z = g zâ‚€ := eqOn_of_isPreconnected_of_isMaxOn_norm (convex_ball c Râ‚).isPreconnected
    isOpen_ball g_diff h_zâ‚€ g_max hz
  simp [g] at this
  simp [g, â† this]"
Mathlib/Data/Fin/Basic.lean,Fin.pred_one',pred_one',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp_rw [Fin.ext_iff, coe_pred, val_one', val_zero', tsub_eq_zero_iff_le, Nat.mod_le]","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Fin.val_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  unknown identifier 'tsub_eq_zero_iff_le'
error:  simp made no progress","theorem pred_one' [NeZero n] (h := (zero_ne_one' (n := n)).symm) :
    Fin.pred (1 : Fin (n + 1)) h = 0 ",":= by
  simp_rw [Fin.ext_iff, coe_pred, val_one', val_zero', Nat.sub_eq_zero_iff_le, Nat.mod_le]"
Mathlib/Analysis/LocallyConvex/Bounded.lean,NormedSpace.vonNBornology_eq,vonNBornology_eq,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [Bornology.ext_iff_isBounded]
  intro s
  rw [Bornology.isBounded_iff_isVonNBounded]
  exact isVonNBounded_iff ğ•œ E s","error:  function expected at
  isVonNBounded_iff ğ•œ
term has type
  Bornology.IsVonNBounded ğ•œ ?m.238569 â†” Bornology.IsBounded ?m.238569",theorem vonNBornology_eq : Bornology.vonNBornology ğ•œ E = PseudoMetricSpace.toBornology ,":= by
  rw [Bornology.ext_iff_isBounded]
  intro s
  rw [Bornology.isBounded_iff_isVonNBounded]
  exact isVonNBounded_iff _"
Mathlib/Analysis/NormedSpace/Banach.lean,ContinuousLinearMap.exists_approx_preimage_norm_le,exists_approx_preimage_norm_le,04d2f7d820511fda372fed336de9258da13b6254,":= by
  have A : â‹ƒ n : â„•, closure (f '' ball 0 n) = Set.univ := by
    refine' Subset.antisymm (subset_univ _) fun y _ => _
    rcases surj y with âŸ¨x, hxâŸ©
    rcases exists_nat_gt â€–xâ€– with âŸ¨n, hnâŸ©
    refine' mem_iUnion.2 âŸ¨n, subset_closure _âŸ©
    refine' (mem_image _ _ _).2 âŸ¨x, âŸ¨_, hxâŸ©âŸ©
    rwa [mem_ball, dist_eq_norm, sub_zero]
  have : âˆƒ (n : â„•) (x : _), x âˆˆ interior (closure (f '' ball 0 n)) :=
    nonempty_interior_of_iUnion_of_closed (fun n => isClosed_closure) A
  simp only [mem_interior_iff_mem_nhds, Metric.mem_nhds_iff] at this
  rcases this with âŸ¨n, a, Îµ, âŸ¨Îµpos, HâŸ©âŸ©
  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©
  refine' âŸ¨(Îµ / 2)â»Â¹ * â€–câ€– * 2 * n, _, fun y => _âŸ©
  Â· refine' mul_nonneg (mul_nonneg (mul_nonneg _ (norm_nonneg _)) (by norm_num)) _
    exacts [inv_nonneg.2 (div_nonneg (le_of_lt Îµpos) (by norm_num)), n.cast_nonneg]
  Â· by_cases hy : y = 0
    Â· use 0
      simp [hy]
    Â· rcases rescale_to_shell hc (half_pos Îµpos) hy with âŸ¨d, hd, ydlt, -, dinvâŸ©
      let Î´ := â€–dâ€– * â€–yâ€– / 4
      have Î´pos : 0 < Î´ := div_pos (mul_pos (norm_pos_iff.2 hd) (norm_pos_iff.2 hy)) (by norm_num)
      have : a + d â€¢ y âˆˆ ball a Îµ := by
        simp [dist_eq_norm, lt_of_le_of_lt ydlt.le (half_lt_self Îµpos)]
      rcases Metric.mem_closure_iff.1 (H this) _ Î´pos with âŸ¨zâ‚, zâ‚im, hâ‚âŸ©
      rcases(mem_image _ _ _).1 zâ‚im with âŸ¨xâ‚, hxâ‚, xzâ‚âŸ©
      rw [â† xzâ‚] at hâ‚
      rw [mem_ball, dist_eq_norm, sub_zero] at hxâ‚
      have : a âˆˆ ball a Îµ := by
        simp
        exact Îµpos
      rcases Metric.mem_closure_iff.1 (H this) _ Î´pos with âŸ¨zâ‚‚, zâ‚‚im, hâ‚‚âŸ©
      rcases(mem_image _ _ _).1 zâ‚‚im with âŸ¨xâ‚‚, hxâ‚‚, xzâ‚‚âŸ©
      rw [â† xzâ‚‚] at hâ‚‚
      rw [mem_ball, dist_eq_norm, sub_zero] at hxâ‚‚
      let x := xâ‚ - xâ‚‚
      have I : â€–f x - d â€¢ yâ€– â‰¤ 2 * Î´ :=
        calc
          â€–f x - d â€¢ yâ€– = â€–f xâ‚ - (a + d â€¢ y) - (f xâ‚‚ - a)â€– := by
            congr 1
            simp only [f.map_sub]
            abel
          _ â‰¤ â€–f xâ‚ - (a + d â€¢ y)â€– + â€–f xâ‚‚ - aâ€– := (norm_sub_le _ _)
          _ â‰¤ Î´ + Î´ := by
            apply add_le_add
            Â· rw [â† dist_eq_norm, dist_comm]
              exact le_of_lt hâ‚
            Â· rw [â† dist_eq_norm, dist_comm]
              exact le_of_lt hâ‚‚
          _ = 2 * Î´ := (two_mul _).symm
      have J : â€–f (dâ»Â¹ â€¢ x) - yâ€– â‰¤ 1 / 2 * â€–yâ€– :=
        calc
          â€–f (dâ»Â¹ â€¢ x) - yâ€– = â€–dâ»Â¹ â€¢ f x - (dâ»Â¹ * d) â€¢ yâ€– := by
            rwa [f.map_smul _, inv_mul_cancel, one_smul]
          _ = â€–dâ»Â¹ â€¢ (f x - d â€¢ y)â€– := by rw [mul_smul, smul_sub]
          _ = â€–dâ€–â»Â¹ * â€–f x - d â€¢ yâ€– := by rw [norm_smul, norm_inv]
          _ â‰¤ â€–dâ€–â»Â¹ * (2 * Î´) := by
            apply mul_le_mul_of_nonneg_left I
            rw [inv_nonneg]
            exact norm_nonneg _
          _ = â€–dâ€–â»Â¹ * â€–dâ€– * â€–yâ€– / 2 := by
            simp only
            ring
          _ = â€–yâ€– / 2 := by
            rw [inv_mul_cancel, one_mul]
            simp [norm_eq_zero, hd]
          _ = 1 / 2 * â€–yâ€– := by ring
      rw [â† dist_eq_norm] at J
      have K : â€–dâ»Â¹ â€¢ xâ€– â‰¤ (Îµ / 2)â»Â¹ * â€–câ€– * 2 * â†‘n * â€–yâ€– :=
        calc
          â€–dâ»Â¹ â€¢ xâ€– = â€–dâ€–â»Â¹ * â€–xâ‚ - xâ‚‚â€– := by rw [norm_smul, norm_inv]
          _ â‰¤ (Îµ / 2)â»Â¹ * â€–câ€– * â€–yâ€– * (n + n) := by
            refine' mul_le_mul dinv _ (norm_nonneg _) _
            Â· exact le_trans (norm_sub_le _ _) (add_le_add (le_of_lt hxâ‚) (le_of_lt hxâ‚‚))
            Â· apply mul_nonneg (mul_nonneg _ (norm_nonneg _)) (norm_nonneg _)
              exact inv_nonneg.2 (le_of_lt (half_pos Îµpos))
          _ = (Îµ / 2)â»Â¹ * â€–câ€– * 2 * â†‘n * â€–yâ€– := by ring

      exact âŸ¨dâ»Â¹ â€¢ x, J, KâŸ©","error:  failed to synthesize
  NormedSpace ğ•œ F
use `set_option diagnostics true` to get diagnostic information
error:  rcases tactic failed: xâœ : ?m.71381 is not an inductive datatype","theorem exists_approx_preimage_norm_le (surj : Surjective f) :
    âˆƒ C â‰¥ 0, âˆ€ y, âˆƒ x, dist (f x) y â‰¤ 1 / 2 * â€–yâ€– âˆ§ â€–xâ€– â‰¤ C * â€–yâ€– ",":= by
  have A : â‹ƒ n : â„•, closure (f '' ball 0 n) = Set.univ := by
    refine Subset.antisymm (subset_univ _) fun y _ => ?_
    rcases surj y with âŸ¨x, hxâŸ©
    rcases exists_nat_gt â€–xâ€– with âŸ¨n, hnâŸ©
    refine mem_iUnion.2 âŸ¨n, subset_closure ?_âŸ©
    refine (mem_image _ _ _).2 âŸ¨x, âŸ¨?_, hxâŸ©âŸ©
    rwa [mem_ball, dist_eq_norm, sub_zero]
  have : âˆƒ (n : â„•) (x : _), x âˆˆ interior (closure (f '' ball 0 n)) :=
    nonempty_interior_of_iUnion_of_closed (fun n => isClosed_closure) A
  simp only [mem_interior_iff_mem_nhds, Metric.mem_nhds_iff] at this
  rcases this with âŸ¨n, a, Îµ, âŸ¨Îµpos, HâŸ©âŸ©
  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©
  refine âŸ¨(Îµ / 2)â»Â¹ * â€–câ€– * 2 * n, by positivity, fun y => ?_âŸ©
  rcases eq_or_ne y 0 with rfl | hy
  Â· use 0
    simp
  Â· have hc' : 1 < â€–Ïƒ câ€– := by simp only [RingHomIsometric.is_iso, hc]
    rcases rescale_to_shell hc' (half_pos Îµpos) hy with âŸ¨d, hd, ydlt, -, dinvâŸ©
    let Î´ := â€–dâ€– * â€–yâ€– / 4
    have Î´pos : 0 < Î´ := div_pos (mul_pos (norm_pos_iff.2 hd) (norm_pos_iff.2 hy)) (by norm_num)
    have : a + d â€¢ y âˆˆ ball a Îµ := by
      simp [dist_eq_norm, lt_of_le_of_lt ydlt.le (half_lt_self Îµpos)]
    rcases Metric.mem_closure_iff.1 (H this) _ Î´pos with âŸ¨zâ‚, zâ‚im, hâ‚âŸ©
    rcases (mem_image _ _ _).1 zâ‚im with âŸ¨xâ‚, hxâ‚, xzâ‚âŸ©
    rw [â† xzâ‚] at hâ‚
    rw [mem_ball, dist_eq_norm, sub_zero] at hxâ‚
    have : a âˆˆ ball a Îµ := by
      simp only [mem_ball, dist_self]
      exact Îµpos
    rcases Metric.mem_closure_iff.1 (H this) _ Î´pos with âŸ¨zâ‚‚, zâ‚‚im, hâ‚‚âŸ©
    rcases (mem_image _ _ _).1 zâ‚‚im with âŸ¨xâ‚‚, hxâ‚‚, xzâ‚‚âŸ©
    rw [â† xzâ‚‚] at hâ‚‚
    rw [mem_ball, dist_eq_norm, sub_zero] at hxâ‚‚
    let x := xâ‚ - xâ‚‚
    have I : â€–f x - d â€¢ yâ€– â‰¤ 2 * Î´ :=
      calc
        â€–f x - d â€¢ yâ€– = â€–f xâ‚ - (a + d â€¢ y) - (f xâ‚‚ - a)â€– := by
          congr 1
          simp only [f.map_sub]
          abel
        _ â‰¤ â€–f xâ‚ - (a + d â€¢ y)â€– + â€–f xâ‚‚ - aâ€– := norm_sub_le _ _
        _ â‰¤ Î´ + Î´ := by rw [dist_eq_norm'] at hâ‚ hâ‚‚; gcongr
        _ = 2 * Î´ := (two_mul _).symm
    have J : â€–f (Ïƒ' dâ»Â¹ â€¢ x) - yâ€– â‰¤ 1 / 2 * â€–yâ€– :=
      calc
        â€–f (Ïƒ' dâ»Â¹ â€¢ x) - yâ€– = â€–dâ»Â¹ â€¢ f x - (dâ»Â¹ * d) â€¢ yâ€– := by
          rwa [f.map_smulâ‚›â‚— _, inv_mul_cancel, one_smul, map_invâ‚€, map_invâ‚€,
            RingHomCompTriple.comp_apply, RingHom.id_apply]
        _ = â€–dâ»Â¹ â€¢ (f x - d â€¢ y)â€– := by rw [mul_smul, smul_sub]
        _ = â€–dâ€–â»Â¹ * â€–f x - d â€¢ yâ€– := by rw [norm_smul, norm_inv]
        _ â‰¤ â€–dâ€–â»Â¹ * (2 * Î´) := by gcongr
        _ = â€–dâ€–â»Â¹ * â€–dâ€– * â€–yâ€– / 2 := by
          simp only [Î´]
          ring
        _ = â€–yâ€– / 2 := by
          rw [inv_mul_cancel, one_mul]
          simp [norm_eq_zero, hd]
        _ = 1 / 2 * â€–yâ€– := by ring
    rw [â† dist_eq_norm] at J
    have K : â€–Ïƒ' dâ»Â¹ â€¢ xâ€– â‰¤ (Îµ / 2)â»Â¹ * â€–câ€– * 2 * â†‘n * â€–yâ€– :=
      calc
        â€–Ïƒ' dâ»Â¹ â€¢ xâ€– = â€–dâ€–â»Â¹ * â€–xâ‚ - xâ‚‚â€– := by rw [norm_smul, RingHomIsometric.is_iso, norm_inv]
        _ â‰¤ (Îµ / 2)â»Â¹ * â€–câ€– * â€–yâ€– * (n + n) := by
          gcongr
          Â· simpa using dinv
          Â· exact le_trans (norm_sub_le _ _) (by gcongr)
        _ = (Îµ / 2)â»Â¹ * â€–câ€– * 2 * â†‘n * â€–yâ€– := by ring
    exact âŸ¨Ïƒ' dâ»Â¹ â€¢ x, J, KâŸ©"
Mathlib/NumberTheory/Cyclotomic/Gal.lean,IsPrimitiveRoot.autToPow_injective,autToPow_injective,9e34a191034458a56331f976ff7400a26407c888,":= by
  intro f g hfg
  apply_fun Units.val at hfg
  simp only [IsPrimitiveRoot.coe_autToPow_apply] at hfg
  revert hfg
  generalize_proofs hf' hg'
  intro hfg
  have hf := hf'.choose_spec
  have hg := hg'.choose_spec
  revert hf hg
  generalize_proofs hÎ¶
  intro hf hg
  suffices f (hÎ¼.toRootsOfUnity : LË£) = g (hÎ¼.toRootsOfUnity : LË£) by
    apply AlgEquiv.coe_algHom_injective
    apply (hÎ¼.powerBasis K).algHom_ext
    exact this
  rw [ZMod.eq_iff_modEq_nat] at hfg
  refine' (hf.trans _).trans hg.symm
  rw [â† rootsOfUnity.coe_pow _ hf'.choose, â† rootsOfUnity.coe_pow _ hg'.choose]
  congr 2
  rw [pow_eq_pow_iff_modEq]
  convert hfg
  rw [hÎ¼.eq_orderOf]
  conv_rhs => rw [â† hÎ¼.toRootsOfUnity_coe_val]
  rw [orderOf_units, orderOf_subgroup]","error:  invalid field 'toRootsOfUnity_coe_val', the environment does not contain 'IsPrimitiveRoot.toRootsOfUnity_coe_val'
  hÎ¼
has type
  IsPrimitiveRoot Î¼ â†‘n
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.6700
n : â„•+
K : Type u_1
instâœâ´ : Field K
L : Type u_2
Î¼ : L
instâœÂ³ : CommRing L
instâœÂ² : IsDomain L
hÎ¼ : IsPrimitiveRoot Î¼ â†‘n
instâœÂ¹ : Algebra K L
instâœ : IsCyclotomicExtension {n} K L
f g : L â‰ƒâ‚[K] L
hf' : âˆƒ m, f â†‘â†‘hÎ¼.toRootsOfUnity = â†‘â†‘hÎ¼.toRootsOfUnity ^ m
hg' : âˆƒ m, g â†‘â†‘hÎ¼.toRootsOfUnity = â†‘â†‘hÎ¼.toRootsOfUnity ^ m
hfg : hf'.choose â‰¡ hg'.choose [MOD â†‘n]
hf : f â†‘â†‘hÎ¼.toRootsOfUnity = â†‘â†‘hÎ¼.toRootsOfUnity ^ hf'.choose
hg : g â†‘â†‘hÎ¼.toRootsOfUnity = â†‘â†‘hÎ¼.toRootsOfUnity ^ hg'.choose
| orderOf Î¼",theorem autToPow_injective : Function.Injective <| hÎ¼.autToPow K ,":= by
  intro f g hfg
  apply_fun Units.val at hfg
  simp only [IsPrimitiveRoot.coe_autToPow_apply] at hfg
  generalize_proofs hf' hg' at hfg
  have hf := hf'.choose_spec
  have hg := hg'.choose_spec
  generalize_proofs hÎ¶ at hf hg
  suffices f (hÎ¼.toRootsOfUnity : LË£) = g (hÎ¼.toRootsOfUnity : LË£) by
    apply AlgEquiv.coe_algHom_injective
    apply (hÎ¼.powerBasis K).algHom_ext
    exact this
  rw [ZMod.eq_iff_modEq_nat] at hfg
  refine (hf.trans ?_).trans hg.symm
  rw [â† rootsOfUnity.coe_pow _ hf'.choose, â† rootsOfUnity.coe_pow _ hg'.choose]
  congr 2
  rw [pow_eq_pow_iff_modEq]
  convert hfg
  rw [hÎ¼.eq_orderOf]
  conv_rhs => rw [â† hÎ¼.val_toRootsOfUnity_coe]
  rw [orderOf_units, Subgroup.orderOf_coe]"
Mathlib/RingTheory/LocalProperties.lean,finite_ofLocalizationSpan,finite_ofLocalizationSpan,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  rw [RingHom.ofLocalizationSpan_iff_finite]
  introv R hs H
  letI := f.toSMul
  letI := f.toAlgebra
  letI := fun r : s => (Localization.awayMap f r).toSMul
  letI := fun r : s => (Localization.awayMap f r).toAlgebra
  have : âˆ€ r : s,
      IsLocalization ((Submonoid.powers (r : R)).map (algebraMap R S)) (Localization.Away (f r)) :=
    by intro r; rw [Submonoid.map_powers]; exact Localization.isLocalization
  haveI : âˆ€ r : s, IsScalarTower R (Localization.Away (r : R)) (Localization.Away (f r)) :=
    fun r => IsScalarTower.of_algebraMap_eq'
      (IsLocalization.map_comp (Submonoid.powers (r : R)).le_comap_map).symm
  constructor
  replace H := fun r => (H r).1
  choose sâ‚ sâ‚‚ using H
  let sf := fun x : s => IsLocalization.finsetIntegerMultiple (Submonoid.powers (f x)) (sâ‚ x)
  use s.attach.biUnion sf
  rw [Submodule.span_attach_biUnion, eq_top_iff]
  rintro x -
  apply Submodule.mem_of_span_eq_top_of_smul_pow_mem _ (s : Set R) hs _ _
  intro r
  obtain âŸ¨âŸ¨_, nâ‚, rflâŸ©, hnâ‚âŸ© :=
    multiple_mem_span_of_mem_localization_span (Submonoid.powers (r : R))
      (Localization.Away (r : R)) (sâ‚ r : Set (Localization.Away (f r))) (algebraMap S _ x)
      (by rw [sâ‚‚ r]; trivial)
  dsimp only at hnâ‚
  rw [Submonoid.smul_def, Algebra.smul_def, IsScalarTower.algebraMap_apply R S, â† map_mul] at hnâ‚
  obtain âŸ¨âŸ¨_, nâ‚‚, rflâŸ©, hnâ‚‚âŸ© :=
    IsLocalization.smul_mem_finsetIntegerMultiple_span (Submonoid.powers (r : R))
      (Localization.Away (f r)) _ (sâ‚ r) hnâ‚
  rw [Submonoid.smul_def, â† Algebra.smul_def, smul_smul, Subtype.coe_mk, â† pow_add] at hnâ‚‚
  simp_rw [Submonoid.map_powers] at hnâ‚‚
  use nâ‚‚ + nâ‚
  exact le_iSup (fun x : s => Submodule.span R (sf x : Set S)) r hnâ‚‚","error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  f
has type
  R â†’+* S
error:  unsolved goals
Râœ Sâœ : Type u
instâœâ· : CommRing Râœ
instâœâ¶ : CommRing Sâœ
M : Submonoid Râœ
N : Submonoid Sâœ
R' S' : Type u
instâœâµ : CommRing R'
instâœâ´ : CommRing S'
fâœ : Râœ â†’+* Sâœ
instâœÂ³ : Algebra Râœ R'
instâœÂ² : Algebra Sâœ S'
R S : Type u_1
instâœÂ¹ : CommRing R
instâœ : CommRing S
f : R â†’+* S
s : Finset R
hs : Ideal.span â†‘s = âŠ¤
H : âˆ€ (r : { x // x âˆˆ s }), (Localization.awayMap f â†‘r).Finite
âŠ¢ f.Finite",theorem finite_ofLocalizationSpan : RingHom.OfLocalizationSpan @RingHom.Finite ,":= by
  rw [RingHom.ofLocalizationSpan_iff_finite]
  introv R hs H
  letI := f.toAlgebra
  letI := fun r : s => (Localization.awayMap f r).toAlgebra
  have : âˆ€ r : s,
      IsLocalization ((Submonoid.powers (r : R)).map (algebraMap R S)) (Localization.Away (f r)) :=
    by intro r; rw [Submonoid.map_powers]; exact Localization.isLocalization
  haveI : âˆ€ r : s, IsScalarTower R (Localization.Away (r : R)) (Localization.Away (f r)) :=
    fun r => IsScalarTower.of_algebraMap_eq'
      (IsLocalization.map_comp (Submonoid.powers (r : R)).le_comap_map).symm
  constructor
  replace H := fun r => (H r).1
  choose sâ‚ sâ‚‚ using H
  let sf := fun x : s => IsLocalization.finsetIntegerMultiple (Submonoid.powers (f x)) (sâ‚ x)
  use s.attach.biUnion sf
  rw [Submodule.span_attach_biUnion, eq_top_iff]
  rintro x -
  apply Submodule.mem_of_span_eq_top_of_smul_pow_mem _ (s : Set R) hs _ _
  intro r
  obtain âŸ¨âŸ¨_, nâ‚, rflâŸ©, hnâ‚âŸ© :=
    multiple_mem_span_of_mem_localization_span (Submonoid.powers (r : R))
      (Localization.Away (r : R)) (sâ‚ r : Set (Localization.Away (f r))) (algebraMap S _ x)
      (by rw [sâ‚‚ r]; trivial)
  dsimp only at hnâ‚
  rw [Submonoid.smul_def, Algebra.smul_def, IsScalarTower.algebraMap_apply R S, â† map_mul] at hnâ‚
  obtain âŸ¨âŸ¨_, nâ‚‚, rflâŸ©, hnâ‚‚âŸ© :=
    IsLocalization.smul_mem_finsetIntegerMultiple_span (Submonoid.powers (r : R))
      (Localization.Away (f r)) _ (sâ‚ r) hnâ‚
  rw [Submonoid.smul_def, â† Algebra.smul_def, smul_smul, Subtype.coe_mk, â† pow_add] at hnâ‚‚
  simp_rw [Submonoid.map_powers] at hnâ‚‚
  use nâ‚‚ + nâ‚
  exact le_iSup (fun x : s => Submodule.span R (sf x : Set S)) r hnâ‚‚"
Mathlib/LinearAlgebra/TensorProduct/RightExactness.lean,Ideal.map_includeLeft_eq,Ideal.map_includeLeft_eq,7fa386b9c1d5f5e8344fb34659b062d90996f3f0,":= by
  rw [â† Submodule.carrier_inj]
  apply le_antisymm
  Â· intro x
    simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,
      Submodule.mem_toAddSubmonoid, Submodule.restrictScalars_mem, LinearMap.mem_range]
    intro hx
    rw [Ideal.map, â† submodule_span_eq] at hx
    refine' Submodule.span_induction hx _ _ _ _
    Â· intro x
      simp only [includeLeft_apply, Set.mem_image, SetLike.mem_coe]
      rintro âŸ¨y, hy, rflâŸ©
      use âŸ¨y, hyâŸ© âŠ—â‚œ[R] 1
      rfl
    Â· use 0
      simp only [map_zero]
    Â· rintro x y âŸ¨x, hx, rflâŸ© âŸ¨y, hy, rflâŸ©
      use x + y
      simp only [map_add]
    Â· rintro a x âŸ¨x, hx, rflâŸ©
      induction a with
      | zero =>
        use 0
        simp only [map_zero, smul_eq_mul, zero_mul]
      | tmul a b =>
        induction x with
        | zero =>
          use 0
          simp only [map_zero, smul_eq_mul, mul_zero]
        | tmul x y =>
          use (a â€¢ x) âŠ—â‚œ[R] (b * y)
          simp only [LinearMap.lTensor_tmul, Submodule.coeSubtype, smul_eq_mul, tmul_mul_tmul]
          rfl
        | add x y hx hy =>
          obtain âŸ¨x', hx'âŸ© := hx
          obtain âŸ¨y', hy'âŸ© := hy
          use x' + y'
          simp only [map_add, hx', smul_add, hy']
      | add a b ha hb =>
        obtain âŸ¨x', ha'âŸ© := ha
        obtain âŸ¨y', hb'âŸ© := hb
        use x' + y'
        simp only [map_add, ha', add_smul, hb']

  Â· rintro x âŸ¨y, rflâŸ©
    induction y with
    | zero =>
        rw [map_zero]
        apply zero_mem
    | tmul a b =>
        simp only [LinearMap.rTensor_tmul, Submodule.coeSubtype]
        suffices (a : A) âŠ—â‚œ[R] b = ((1 : A) âŠ—â‚œ[R] b) * ((a : A) âŠ—â‚œ[R] (1 : B)) by
          simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,
            Submodule.mem_toAddSubmonoid, Submodule.restrictScalars_mem]
          rw [this]
          apply Ideal.mul_mem_left
          apply Ideal.mem_map_of_mem includeLeft
          exact Submodule.coe_mem a
        simp only [Submodule.coe_restrictScalars, Algebra.TensorProduct.tmul_mul_tmul,
          mul_one, one_mul]
    | add x y hx hy =>
        rw [map_add]
        apply Submodule.add_mem _ hx hy","error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case h
R : Type u_1
instâœâ´ : CommSemiring R
A : Type u_2
B : Type u_3
instâœÂ³ : Semiring A
instâœÂ² : Semiring B
instâœÂ¹ : Algebra R A
instâœ : Algebra R B
I : Ideal A
xâœ : A âŠ—[R] B
hx : xâœ âˆˆ Submodule.span (A âŠ—[R] B) (â‡‘includeLeft '' â†‘I)
a : A
b : B
x : â†¥(Submodule.restrictScalars R I)
y : B
âŠ¢ (LinearMap.rTensor B (Submodule.restrictScalars R I).subtype) ((a â€¢ x) âŠ—â‚œ[R] (b * y)) =
    a âŠ—â‚œ[R] b * (LinearMap.rTensor B (Submodule.restrictScalars R I).subtype) (x âŠ—â‚œ[R] y)","lemma Ideal.map_includeLeft_eq (I : Ideal A) :
    (I.map (Algebra.TensorProduct.includeLeft : A â†’â‚[R] A âŠ—[R] B)).restrictScalars R
      = LinearMap.range (LinearMap.rTensor B (Submodule.subtype (I.restrictScalars R))) ",":= by
  rw [â† Submodule.carrier_inj]
  apply le_antisymm
  Â· intro x
    simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,
      Submodule.mem_toAddSubmonoid, Submodule.restrictScalars_mem, LinearMap.mem_range]
    intro hx
    rw [Ideal.map, â† submodule_span_eq] at hx
    refine Submodule.span_induction hx ?_ ?_ ?_ ?_
    Â· intro x
      simp only [includeLeft_apply, Set.mem_image, SetLike.mem_coe]
      rintro âŸ¨y, hy, rflâŸ©
      use âŸ¨y, hyâŸ© âŠ—â‚œ[R] 1
      rfl
    Â· use 0
      simp only [map_zero]
    Â· rintro x y âŸ¨x, hx, rflâŸ© âŸ¨y, hy, rflâŸ©
      use x + y
      simp only [map_add]
    Â· rintro a x âŸ¨x, hx, rflâŸ©
      induction a with
      | zero =>
        use 0
        simp only [map_zero, smul_eq_mul, zero_mul]
      | tmul a b =>
        induction x with
        | zero =>
          use 0
          simp only [map_zero, smul_eq_mul, mul_zero]
        | tmul x y =>
          use (a â€¢ x) âŠ—â‚œ[R] (b * y)
          simp only [LinearMap.lTensor_tmul, Submodule.coeSubtype, smul_eq_mul, tmul_mul_tmul]
          with_unfolding_all rfl
        | add x y hx hy =>
          obtain âŸ¨x', hx'âŸ© := hx
          obtain âŸ¨y', hy'âŸ© := hy
          use x' + y'
          simp only [map_add, hx', smul_add, hy']
      | add a b ha hb =>
        obtain âŸ¨x', ha'âŸ© := ha
        obtain âŸ¨y', hb'âŸ© := hb
        use x' + y'
        simp only [map_add, ha', add_smul, hb']

  Â· rintro x âŸ¨y, rflâŸ©
    induction y with
    | zero =>
        rw [map_zero]
        apply zero_mem
    | tmul a b =>
        simp only [LinearMap.rTensor_tmul, Submodule.coeSubtype]
        suffices (a : A) âŠ—â‚œ[R] b = ((1 : A) âŠ—â‚œ[R] b) * ((a : A) âŠ—â‚œ[R] (1 : B)) by
          simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,
            Submodule.mem_toAddSubmonoid, Submodule.restrictScalars_mem]
          rw [this]
          apply Ideal.mul_mem_left
          apply Ideal.mem_map_of_mem includeLeft
          exact Submodule.coe_mem a
        simp only [Submodule.coe_restrictScalars, Algebra.TensorProduct.tmul_mul_tmul,
          mul_one, one_mul]
    | add x y hx hy =>
        rw [map_add]
        apply Submodule.add_mem _ hx hy"
Mathlib/Combinatorics/SetFamily/Compression/Down.lean,Down.card_compression,card_compression,54af049843f24ae9c260ba1f8a2726cc2a897e6e,":=
  by
  rw [compression, card_disjUnion, image_filter,
    card_image_of_injOn ((erase_injOn' _).mono fun s hs => _), â† card_disjoint_union]
  Â· conv_rhs => rw [â† filter_union_filter_neg_eq (fun s => (erase s a âˆˆ ğ’œ)) ğ’œ]
  Â· convert disjoint_filter_filter_neg ğ’œ ğ’œ (fun s => (erase s a âˆˆ ğ’œ))
  intro s hs
  rw [mem_coe, mem_filter, Function.comp_apply] at hs
  convert not_imp_comm.1 erase_eq_of_not_mem (ne_of_mem_of_not_mem hs.1 hs.2).symm","warning:  @Down.compression does not have a doc string
warning:  `Finset.image_filter` has been deprecated, use `Finset.filter_image` instead
warning:  `Finset.card_disjoint_union` has been deprecated, use `Finset.card_union_of_disjoint` instead
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?m.30491 âˆ˜ ?m.30492) ?m.30493
Î± : Type u_1
instâœ : DecidableEq Î±
ğ’œâœ â„¬ : Finset (Finset Î±)
sâœ : Finset Î±
aâœ a : Î±
ğ’œ : Finset (Finset Î±)
s : Finset Î±
hs : s âˆˆ ğ’œ âˆ§ s.erase a âˆ‰ ğ’œ
âŠ¢ s âˆˆ {s | a âˆˆ s}",theorem card_compression (a : Î±) (ğ’œ : Finset (Finset Î±)) : (ğ““ a ğ’œ).card = ğ’œ.card ,":= by
  rw [compression, card_disjUnion, filter_image,
    card_image_of_injOn ((erase_injOn' _).mono fun s hs => _), â† card_union_of_disjoint]
  Â· conv_rhs => rw [â† filter_union_filter_neg_eq (fun s => (erase s a âˆˆ ğ’œ)) ğ’œ]
  Â· exact disjoint_filter_filter_neg ğ’œ ğ’œ (fun s => (erase s a âˆˆ ğ’œ))
  intro s hs
  rw [mem_coe, mem_filter] at hs
  exact not_imp_comm.1 erase_eq_of_not_mem (ne_of_mem_of_not_mem hs.1 hs.2).symm"
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.uniformIntegrable_finite,uniformIntegrable_finite,ff33d25c791a3fac407c782b49018fcb63700d0d,":= by
  cases nonempty_fintype Î¹
  refine' âŸ¨fun n => (hf n).1, unifIntegrable_finite Î¼ hp_one hp_top hf, _âŸ©
  by_cases hÎ¹ : Nonempty Î¹
  Â· choose _ hf using hf
    set C := (Finset.univ.image fun i : Î¹ => snorm (f i) p Î¼).max'
      âŸ¨snorm (f hÎ¹.some) p Î¼, Finset.mem_image.2 âŸ¨hÎ¹.some, Finset.mem_univ _, rflâŸ©âŸ©
    refine' âŸ¨C.toNNReal, fun i => _âŸ©
    rw [ENNReal.coe_toNNReal]
    Â· exact Finset.le_max' (Î± := â„â‰¥0âˆ) _ _ (Finset.mem_image.2 âŸ¨i, Finset.mem_univ _, rflâŸ©)
    Â· refine' ne_of_lt ((Finset.max'_lt_iff _ _).2 fun y hy => _)
      rw [Finset.mem_image] at hy
      obtain âŸ¨i, -, rflâŸ© := hy
      exact hf i
  Â· exact âŸ¨0, fun i => False.elim <| hÎ¹ <| Nonempty.intro iâŸ©","error:  application type mismatch
  unifIntegrable_finite Î¼
argument
  Î¼
has type
  Measure Î± : Type u_1
but is expected to have type
  1 â‰¤ ?m.248340 : Prop","theorem uniformIntegrable_finite [Finite Î¹] (hp_one : 1 â‰¤ p) (hp_top : p â‰  âˆ)
    (hf : âˆ€ i, Memâ„’p (f i) p Î¼) : UniformIntegrable f p Î¼ ",":= by
  cases nonempty_fintype Î¹
  refine âŸ¨fun n => (hf n).1, unifIntegrable_finite hp_one hp_top hf, ?_âŸ©
  by_cases hÎ¹ : Nonempty Î¹
  Â· choose _ hf using hf
    set C := (Finset.univ.image fun i : Î¹ => snorm (f i) p Î¼).max'
      âŸ¨snorm (f hÎ¹.some) p Î¼, Finset.mem_image.2 âŸ¨hÎ¹.some, Finset.mem_univ _, rflâŸ©âŸ©
    refine âŸ¨C.toNNReal, fun i => ?_âŸ©
    rw [ENNReal.coe_toNNReal]
    Â· exact Finset.le_max' (Î± := â„â‰¥0âˆ) _ _ (Finset.mem_image.2 âŸ¨i, Finset.mem_univ _, rflâŸ©)
    Â· refine ne_of_lt ((Finset.max'_lt_iff _ _).2 fun y hy => ?_)
      rw [Finset.mem_image] at hy
      obtain âŸ¨i, -, rflâŸ© := hy
      exact hf i
  Â· exact âŸ¨0, fun i => False.elim <| hÎ¹ <| Nonempty.intro iâŸ©"
Mathlib/MeasureTheory/Measure/Haar/Basic.lean,MeasureTheory.Measure.haar.index_union_eq,index_union_eq,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  apply le_antisymm (index_union_le Kâ‚ Kâ‚‚ hV)
  rcases index_elim (Kâ‚.2.union Kâ‚‚.2) hV with âŸ¨s, h1s, h2sâŸ©; rw [â† h2s]
  have :
    âˆ€ K : Set G,
      (K âŠ† â‹ƒ g âˆˆ s, (fun h => g * h) â»Â¹' V) â†’
        index K V â‰¤ (s.filter fun g => ((fun h : G => g * h) â»Â¹' V âˆ© K).Nonempty).card := by
    intro K hK; apply Nat.sInf_le; refine âŸ¨_, ?_, rflâŸ©; rw [mem_setOf_eq]
    intro g hg; rcases hK hg with âŸ¨_, âŸ¨gâ‚€, rflâŸ©, _, âŸ¨h1gâ‚€, rflâŸ©, h2gâ‚€âŸ©
    simp only [mem_preimage] at h2gâ‚€
    simp only [mem_iUnion]; use gâ‚€; constructor; swap
    Â· simp only [Finset.mem_filter, h1gâ‚€, true_and_iff]; use g
      simp only [hg, h2gâ‚€, mem_inter_iff, mem_preimage, and_self_iff]
    exact h2gâ‚€
  refine
    le_trans
      (add_le_add (this Kâ‚.1 <| Subset.trans (subset_union_left _ _) h1s)
        (this Kâ‚‚.1 <| Subset.trans (subset_union_right _ _) h1s)) ?_
  rw [â† Finset.card_union_of_disjoint, Finset.filter_union_right]
  Â· exact s.card_filter_le _
  apply Finset.disjoint_filter.mpr
  rintro gâ‚ _ âŸ¨gâ‚‚, h1gâ‚‚, h2gâ‚‚âŸ© âŸ¨gâ‚ƒ, h1gâ‚ƒ, h2gâ‚ƒâŸ©
  simp only [mem_preimage] at h1gâ‚ƒ h1gâ‚‚
  refine h.le_bot (?_ : gâ‚â»Â¹ âˆˆ _)
  constructor <;> simp only [Set.mem_inv, Set.mem_mul, exists_exists_and_eq_and, exists_and_left]
  Â· refine âŸ¨_, h2gâ‚‚, (gâ‚ * gâ‚‚)â»Â¹, ?_, ?_âŸ©
    Â· simp only [inv_inv, h1gâ‚‚]
    Â· simp only [mul_inv_rev, mul_inv_cancel_left]
  Â· refine âŸ¨_, h2gâ‚ƒ, (gâ‚ * gâ‚ƒ)â»Â¹, ?_, ?_âŸ©
    Â· simp only [inv_inv, h1gâ‚ƒ]
    Â· simp only [mul_inv_rev, mul_inv_cancel_left]","error:  function expected at
  subset_union_left ?m.22234
term has type
  ?m.22233 âˆˆ ?m.22231 âˆª ?m.22232
error:  function expected at
  subset_union_right ?m.22288
term has type
  ?m.22287 âˆˆ ?m.22285 âˆª ?m.22286","theorem index_union_eq (Kâ‚ Kâ‚‚ : Compacts G) {V : Set G} (hV : (interior V).Nonempty)
    (h : Disjoint (Kâ‚.1 * Vâ»Â¹) (Kâ‚‚.1 * Vâ»Â¹)) :
    index (Kâ‚.1 âˆª Kâ‚‚.1) V = index Kâ‚.1 V + index Kâ‚‚.1 V ",":= by
  apply le_antisymm (index_union_le Kâ‚ Kâ‚‚ hV)
  rcases index_elim (Kâ‚.2.union Kâ‚‚.2) hV with âŸ¨s, h1s, h2sâŸ©; rw [â† h2s]
  have :
    âˆ€ K : Set G,
      (K âŠ† â‹ƒ g âˆˆ s, (fun h => g * h) â»Â¹' V) â†’
        index K V â‰¤ (s.filter fun g => ((fun h : G => g * h) â»Â¹' V âˆ© K).Nonempty).card := by
    intro K hK; apply Nat.sInf_le; refine âŸ¨_, ?_, rflâŸ©; rw [mem_setOf_eq]
    intro g hg; rcases hK hg with âŸ¨_, âŸ¨gâ‚€, rflâŸ©, _, âŸ¨h1gâ‚€, rflâŸ©, h2gâ‚€âŸ©
    simp only [mem_preimage] at h2gâ‚€
    simp only [mem_iUnion]; use gâ‚€; constructor; swap
    Â· simp only [Finset.mem_filter, h1gâ‚€, true_and_iff]; use g
      simp only [hg, h2gâ‚€, mem_inter_iff, mem_preimage, and_self_iff]
    exact h2gâ‚€
  refine
    le_trans
      (add_le_add (this Kâ‚.1 <| Subset.trans subset_union_left h1s)
        (this Kâ‚‚.1 <| Subset.trans subset_union_right h1s)) ?_
  rw [â† Finset.card_union_of_disjoint, Finset.filter_union_right]
  Â· exact s.card_filter_le _
  apply Finset.disjoint_filter.mpr
  rintro gâ‚ _ âŸ¨gâ‚‚, h1gâ‚‚, h2gâ‚‚âŸ© âŸ¨gâ‚ƒ, h1gâ‚ƒ, h2gâ‚ƒâŸ©
  simp only [mem_preimage] at h1gâ‚ƒ h1gâ‚‚
  refine h.le_bot (?_ : gâ‚â»Â¹ âˆˆ _)
  constructor <;> simp only [Set.mem_inv, Set.mem_mul, exists_exists_and_eq_and, exists_and_left]
  Â· refine âŸ¨_, h2gâ‚‚, (gâ‚ * gâ‚‚)â»Â¹, ?_, ?_âŸ©
    Â· simp only [inv_inv, h1gâ‚‚]
    Â· simp only [mul_inv_rev, mul_inv_cancel_left]
  Â· refine âŸ¨_, h2gâ‚ƒ, (gâ‚ * gâ‚ƒ)â»Â¹, ?_, ?_âŸ©
    Â· simp only [inv_inv, h1gâ‚ƒ]
    Â· simp only [mul_inv_rev, mul_inv_cancel_left]"
Mathlib/Topology/Category/Stonean/Basic.lean,Stonean.epi_iff_surjective,epi_iff_surjective,592e720e2651f6e8a7faf0968b75697c3bcd3b55,":= by
  refine âŸ¨?_, ConcreteCategory.epi_of_surjective _âŸ©
  dsimp [Function.Surjective]
  intro h y
  by_contra' hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := Cá¶œ
  have hUy : U âˆˆ nhds y := by
    simp only [Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain âŸ¨V, hV, hyV, hVUâŸ© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy
  classical
  let g : Y âŸ¶ mkFinite (ULift (Fin 2)) :=
    âŸ¨(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _âŸ©
  let h : Y âŸ¶ mkFinite (ULift (Fin 2)) := âŸ¨fun _ => âŸ¨1âŸ©, continuous_constâŸ©
  have H : h = g := by
    rw [â† cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU Â·) ?_ 
    simpa only [Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H","error:  unknown tactic
error:  unsolved goals
X Y : Stonean
f : X âŸ¶ Y
h : Epi f
y : CoeSort.coe Y
âŠ¢ âˆƒ a, f a = y","lemma epi_iff_surjective {X Y : Stonean} (f : X âŸ¶ Y) :
    Epi f â†” Function.Surjective f ",":= by
  refine âŸ¨?_, ConcreteCategory.epi_of_surjective _âŸ©
  dsimp [Function.Surjective]
  intro h y
  by_contra! hy
  let C := Set.range f
  have hC : IsClosed C := (isCompact_range f.continuous).isClosed
  let U := Cá¶œ
  have hUy : U âˆˆ ğ“ y := by
    simp only [C, Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]
  obtain âŸ¨V, hV, hyV, hVUâŸ© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy
  classical
  let g : Y âŸ¶ mkFinite (ULift (Fin 2)) :=
    âŸ¨(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _âŸ©
  let h : Y âŸ¶ mkFinite (ULift (Fin 2)) := âŸ¨fun _ => âŸ¨1âŸ©, continuous_constâŸ©
  have H : h = g := by
    rw [â† cancel_epi f]
    ext x
    apply ULift.ext 
    change 1 = ite _ _ _ 
    rw [if_neg]
    refine mt (hVU Â·) ?_ 
    simpa only [U, Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]
      using exists_apply_eq_apply f x
  apply_fun fun e => (e y).down at H
  change 1 = ite _ _ _ at H 
  rw [if_pos hyV] at H
  exact one_ne_zero H"
Mathlib/Computability/TuringMachine.lean,Turing.TM2to1.tr_respects_auxâ‚‚,tr_respects_auxâ‚‚,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  dsimp only; simp; cases o with simp only [stWrite, stVar, trStAct, TM1.stepAux]
  | push f =>
    have := Tape.write_move_right_n fun a : Î“' â†¦ (a.1, update a.2 k (some (f v)))
    refine'
      âŸ¨_, fun k' â†¦ _, by
        erw [Tape.move_right_n_head, List.length, Tape.mk'_nth_nat, this,
          addBottom_modifyNth fun a â†¦ update a k (some (f v)), Nat.add_one, iterate_succ']
        rflâŸ©
    refine' ListBlank.ext fun i â†¦ _
    rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
    by_cases h' : k' = k
    Â· subst k'
      split_ifs with h
        <;> simp only [List.reverse_cons, Function.update_same, ListBlank.nth_mk, List.map]
      Â· rw [List.getI_eq_get, List.get_append_right'] <;>
          simp only [h, List.get_singleton, List.length_map, List.length_reverse, Nat.succ_pos',
            List.length_append, lt_add_iff_pos_right, List.length, le_refl]
      rw [â† proj_map_nth, hL, ListBlank.nth_mk]
      cases' lt_or_gt_of_ne h with h h
      Â· rw [List.getI_append]
        simpa only [List.length_map, List.length_reverse] using h
      Â· rw [gt_iff_lt] at h
        rw [List.getI_eq_default, List.getI_eq_default] <;>
          simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
            List.length_append, List.length_map]
    Â· split_ifs <;> rw [Function.update_noteq h', â† proj_map_nth, hL]
      rw [Function.update_noteq h']
  | peek f =>
    rw [Function.update_eq_self]
    use L, hL; rw [Tape.move_left_right]; congr
    cases e : S k; Â· rfl
    rw [List.length_cons, iterate_succ', Function.comp, Tape.move_right_left,
      Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_snd, stk_nth_val _ (hL k), e,
      List.reverse_cons, â† List.length_reverse, List.get?_concat_length]
    rfl
  | pop f =>
    cases' e : S k with hd tl
    Â· simp only [Tape.mk'_head, ListBlank.head_cons, Tape.move_left_mk', List.length,
        Tape.write_mk', List.head?, iterate_zero_apply, List.tail_nil]
      rw [â† e, Function.update_eq_self]
      exact âŸ¨L, hL, by rw [addBottom_head_fst, cond]âŸ©
    Â· refine'
        âŸ¨_, fun k' â†¦ _, by
          erw [List.length_cons, Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_succ_fst,
            cond, iterate_succ', Function.comp, Tape.move_right_left, Tape.move_right_n_head,
            Tape.mk'_nth_nat, Tape.write_move_right_n fun a : Î“' â†¦ (a.1, update a.2 k none),
            addBottom_modifyNth fun a â†¦ update a k none, addBottom_nth_snd,
            stk_nth_val _ (hL k), e,
            show (List.cons hd tl).reverse.get? tl.length = some hd by
              rw [List.reverse_cons, â† List.length_reverse, List.get?_concat_length],
            List.head?, List.tail]âŸ©
      refine' ListBlank.ext fun i â†¦ _
      rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
      by_cases h' : k' = k
      Â· subst k'
        split_ifs with h <;> simp only [Function.update_same, ListBlank.nth_mk, List.tail]
        Â· rw [List.getI_eq_default]
          Â· rfl
          rw [h, List.length_reverse, List.length_map]
        rw [â† proj_map_nth, hL, ListBlank.nth_mk, e, List.map, List.reverse_cons]
        cases' lt_or_gt_of_ne h with h h
        Â· rw [List.getI_append]
          simpa only [List.length_map, List.length_reverse] using h
        Â· rw [gt_iff_lt] at h
          rw [List.getI_eq_default, List.getI_eq_default] <;>
            simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
              List.length_append, List.length_map]
      Â· split_ifs <;> rw [Function.update_noteq h', â† proj_map_nth, hL]
        rw [Function.update_noteq h']","warning:  `List.get_append` has been deprecated, use `List.getElem_append` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get_replicate` has been deprecated, use `List.getElem_replicate` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  `List.cons_bind` has been deprecated, use `List.bind_cons` instead
warning:  unused variable `M`
note: this linter can be disabled with `set_option linter.unusedVariables false`
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
error:  unsolved goals
case pos.hâ‚‚
K : Type u_1
instâœÂ² : DecidableEq K
Î“ : K â†’ Type u_2
Î› : Type u_3
instâœÂ¹ : Inhabited Î›
Ïƒ : Type u_4
instâœ : Inhabited Ïƒ
k : K
q : TM1.Stmt Î“' Î›' Ïƒ
v : Ïƒ
S : (k : K) â†’ List (Î“ k)
L : ListBlank ((k : K) â†’ Option (Î“ k))
hL : âˆ€ (k : K), ListBlank.map (proj k) L = ListBlank.mk (List.map some (S k)).reverse
f : Ïƒ â†’ Î“ k
this :
  âˆ€ (L R : ListBlank Î“') (n : â„•),
    Tape.write ((R.nth n).1, update (R.nth n).2 k (some (f v))) ((Tape.move Dir.right)^[n] (Tape.mk' L R)) =
      (Tape.move Dir.right)^[n] (Tape.mk' L (ListBlank.modifyNth (fun a â†¦ (a.1, update a.2 k (some (f v)))) n R))
i : â„•
h : i = (S k).length
âŠ¢ (S k).length < (S k).length + (0 + 1)
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_concat_length` has been deprecated, use `List.getElem?_concat_length` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead
warning:  `List.get?_map` has been deprecated, use `List.getElem?_map` instead","theorem tr_respects_auxâ‚‚ {k : K} {q : Stmtâ‚‚â‚} {v : Ïƒ} {S : âˆ€ k, List (Î“ k)}
    {L : ListBlank (âˆ€ k, Option (Î“ k))}
    (hL : âˆ€ k, L.map (proj k) = ListBlank.mk ((S k).map some).reverse) (o : StActâ‚‚ k) :
    let v' := stVar v (S k) o
    let Sk' := stWrite v (S k) o
    let S' := update S k Sk'
    âˆƒ L' : ListBlank (âˆ€ k, Option (Î“ k)),
      (âˆ€ k, L'.map (proj k) = ListBlank.mk ((S' k).map some).reverse) âˆ§
        TM1.stepAux (trStAct q o) v
            ((Tape.move Dir.right)^[(S k).length] (Tape.mk' âˆ… (addBottom L))) =
          TM1.stepAux q v' ((Tape.move Dir.right)^[(S' k).length] (Tape.mk' âˆ… (addBottom L'))) ",":= by
  dsimp only; simp; cases o with simp only [stWrite, stVar, trStAct, TM1.stepAux]
  | push f =>
    have := Tape.write_move_right_n fun a : Î“' â†¦ (a.1, update a.2 k (some (f v)))
    refine
      âŸ¨_, fun k' â†¦ ?_, by
        erw [Tape.move_right_n_head, List.length, Tape.mk'_nth_nat, this,
          addBottom_modifyNth fun a â†¦ update a k (some (f v)), Nat.add_one, iterate_succ']
        rflâŸ©
    refine ListBlank.ext fun i â†¦ ?_
    rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
    by_cases h' : k' = k
    Â· subst k'
      split_ifs with h
        <;> simp only [List.reverse_cons, Function.update_same, ListBlank.nth_mk, List.map]
      Â· rw [List.getI_eq_get, List.get_append_right'] <;>
          simp only [List.length_singleton, h, List.length_reverse, List.length_map, Nat.sub_self,
            Fin.zero_eta, List.get_cons_zero, le_refl, List.length_append, Nat.lt_succ_self]
      rw [â† proj_map_nth, hL, ListBlank.nth_mk]
      cases' lt_or_gt_of_ne h with h h
      Â· rw [List.getI_append]
        simpa only [List.length_map, List.length_reverse] using h
      Â· rw [gt_iff_lt] at h
        rw [List.getI_eq_default, List.getI_eq_default] <;>
          simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
            List.length_append, List.length_map]
    Â· split_ifs <;> rw [Function.update_noteq h', â† proj_map_nth, hL]
      rw [Function.update_noteq h']
  | peek f =>
    rw [Function.update_eq_self]
    use L, hL; rw [Tape.move_left_right]; congr
    cases e : S k; Â· rfl
    rw [List.length_cons, iterate_succ', Function.comp, Tape.move_right_left,
      Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_snd, stk_nth_val _ (hL k), e,
      List.reverse_cons, â† List.length_reverse, List.get?_concat_length]
    rfl
  | pop f =>
    cases' e : S k with hd tl
    Â· simp only [Tape.mk'_head, ListBlank.head_cons, Tape.move_left_mk', List.length,
        Tape.write_mk', List.head?, iterate_zero_apply, List.tail_nil]
      rw [â† e, Function.update_eq_self]
      exact âŸ¨L, hL, by rw [addBottom_head_fst, cond]âŸ©
    Â· refine
        âŸ¨_, fun k' â†¦ ?_, by
          erw [List.length_cons, Tape.move_right_n_head, Tape.mk'_nth_nat, addBottom_nth_succ_fst,
            cond, iterate_succ', Function.comp, Tape.move_right_left, Tape.move_right_n_head,
            Tape.mk'_nth_nat, Tape.write_move_right_n fun a : Î“' â†¦ (a.1, update a.2 k none),
            addBottom_modifyNth fun a â†¦ update a k none, addBottom_nth_snd,
            stk_nth_val _ (hL k), e,
            show (List.cons hd tl).reverse.get? tl.length = some hd by
              rw [List.reverse_cons, â† List.length_reverse, List.get?_concat_length],
            List.head?, List.tail]âŸ©
      refine ListBlank.ext fun i â†¦ ?_
      rw [ListBlank.nth_map, ListBlank.nth_modifyNth, proj, PointedMap.mk_val]
      by_cases h' : k' = k
      Â· subst k'
        split_ifs with h <;> simp only [Function.update_same, ListBlank.nth_mk, List.tail]
        Â· rw [List.getI_eq_default]
          Â· rfl
          rw [h, List.length_reverse, List.length_map]
        rw [â† proj_map_nth, hL, ListBlank.nth_mk, e, List.map, List.reverse_cons]
        cases' lt_or_gt_of_ne h with h h
        Â· rw [List.getI_append]
          simpa only [List.length_map, List.length_reverse] using h
        Â· rw [gt_iff_lt] at h
          rw [List.getI_eq_default, List.getI_eq_default] <;>
            simp only [Nat.add_one_le_iff, h, List.length, le_of_lt, List.length_reverse,
              List.length_append, List.length_map]
      Â· split_ifs <;> rw [Function.update_noteq h', â† proj_map_nth, hL]
        rw [Function.update_noteq h']"
Mathlib/Topology/MetricSpace/CantorScheme.lean,CantorScheme.ClosureAntitone.map_of_vanishingDiam,ClosureAntitone.map_of_vanishingDiam,38dbcd8285bc4b1391619c12f158a7409f3dfc12,":= by
  rw [eq_univ_iff_forall]
  intro x
  choose u hu using fun n => hnonempty (res x n)
  have umem : âˆ€ n m : â„•, n â‰¤ m â†’ u m âˆˆ A (res x n) := by
    have : Antitone fun n : â„• => A (res x n) := by
      refine' antitone_nat_of_succ_le _
      intro n
      apply hanti.antitone
    intro n m hnm
    exact this hnm (hu _)
  have : CauchySeq u := by
    rw [Metric.cauchySeq_iff]
    intro Îµ Îµ_pos
    cases' hdiam.dist_lt _ Îµ_pos x with n hn
    use n
    intro mâ‚€ hmâ‚€ mâ‚ hmâ‚
    apply hn <;> apply umem <;> assumption
  cases' cauchySeq_tendsto_of_complete this with y hy
  use y
  rw [mem_interáµ¢]
  intro n
  apply hanti _ (x n)
  apply mem_closure_of_tendsto hy
  rw [eventually_atTop]
  exact âŸ¨n.succ, umem _âŸ©","error:  unknown identifier 'mem_interáµ¢'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.11936
case h
Î² : Type u_1
Î± : Type u_2
A : List Î² â†’ Set Î±
instâœÂ¹ : PseudoMetricSpace Î±
instâœ : CompleteSpace Î±
hdiam : VanishingDiam A
hanti : ClosureAntitone A
hnonempty : âˆ€ (l : List Î²), (A l).Nonempty
x : â„• â†’ Î²
u : â„• â†’ Î±
hu : âˆ€ (n : â„•), u n âˆˆ A (res x n)
umem : âˆ€ (n m : â„•), n â‰¤ m â†’ u m âˆˆ A (res x n)
this : CauchySeq u
y : Î±
hy : Tendsto u atTop (ğ“ y)
âŠ¢ y âˆˆ â‹‚ n, A (res x n)","theorem ClosureAntitone.map_of_vanishingDiam [CompleteSpace Î±] (hdiam : VanishingDiam A)
    (hanti : ClosureAntitone A) (hnonempty : âˆ€ l, (A l).Nonempty) : (inducedMap A).1 = univ ",":= by
  rw [eq_univ_iff_forall]
  intro x
  choose u hu using fun n => hnonempty (res x n)
  have umem : âˆ€ n m : â„•, n â‰¤ m â†’ u m âˆˆ A (res x n) := by
    have : Antitone fun n : â„• => A (res x n) := by
      refine antitone_nat_of_succ_le ?_
      intro n
      apply hanti.antitone
    intro n m hnm
    exact this hnm (hu _)
  have : CauchySeq u := by
    rw [Metric.cauchySeq_iff]
    intro Îµ Îµ_pos
    cases' hdiam.dist_lt _ Îµ_pos x with n hn
    use n
    intro mâ‚€ hmâ‚€ mâ‚ hmâ‚
    apply hn <;> apply umem <;> assumption
  cases' cauchySeq_tendsto_of_complete this with y hy
  use y
  rw [mem_iInter]
  intro n
  apply hanti _ (x n)
  apply mem_closure_of_tendsto hy
  rw [eventually_atTop]
  exact âŸ¨n.succ, umem _âŸ©"
Mathlib/RingTheory/PowerSeries/Basic.lean,PowerSeries.coeff_zero_X_mul,coeff_zero_X_mul,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":= by
  rw [â† (Ï†.commute_X s).eq, coeff_zero_mul_X]","error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.67259
R : Type u_1
instâœ : Semiring R
Ï† : RâŸ¦XâŸ§
âŠ¢ (coeff R 0) (X * Ï†) = 0
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated",theorem coeff_zero_X_mul (Ï† : RâŸ¦XâŸ§) : coeff R 0 (X * Ï†) = 0 ,:= by simp
Mathlib/Data/Finset/Lattice.lean,Finset.sup'_inf_distrib_left,sup'_inf_distrib_left,dee5d9343d596781e8ec7749927ce52e2d12df27,":= by
  induction hs using Finset.Nonempty.cons_induction with
  | singleton => simp
  | cons _ _ hs ih => simp_rw [sup'_cons hs, inf_sup_left, ih]","error:  application type mismatch
  sup'_cons hs
argument
  hs
has type
  aâœÂ¹ âˆ‰ sâœ : Prop
but is expected to have type
  ?m.319164.Nonempty : Prop
error:  simp made no progress","theorem sup'_inf_distrib_left (f : Î¹ â†’ Î±) (a : Î±) :
    a âŠ“ s.sup' hs f = s.sup' hs fun i â†¦ a âŠ“ f i ",":= by
  induction hs using Finset.Nonempty.cons_induction with
  | singleton => simp
  | cons _ _ _ hs ih => simp_rw [sup'_cons hs, inf_sup_left, ih]"
Mathlib/GroupTheory/OrderOfElement.lean,MonoidHom.isOfFinOrder,MonoidHom.isOfFinOrder,ab56fa28da38a962b7952fc9e52edb14bef2bc5a,":=
  (isOfFinOrder_iff_pow_eq_one _).mpr <| by
    rcases(isOfFinOrder_iff_pow_eq_one _).mp h with âŸ¨n, npos, hnâŸ©
    exact âŸ¨n, npos, by rw [â† f.map_pow, hn, f.map_one]âŸ©","error:  function expected at
  isOfFinOrder_iff_pow_eq_one
term has type
  IsOfFinOrder ?m.13111 â†” âˆƒ n, 0 < n âˆ§ ?m.13111 ^ n = 1","theorem MonoidHom.isOfFinOrder [Monoid H] (f : G â†’* H) {x : G} (h : IsOfFinOrder x) :
    IsOfFinOrder <| f x ",":=
  isOfFinOrder_iff_pow_eq_one.mpr <| by
    obtain âŸ¨n, npos, hnâŸ© := h.exists_pow_eq_one
    exact âŸ¨n, npos, by rw [â† f.map_pow, hn, f.map_one]âŸ©"
Mathlib/RingTheory/Etale/Basic.lean,Algebra.Etale.of_isLocalization_Away,of_isLocalization_Away,3a31aabe59645ce291dedbcbdd3f949a56d5178f,"  formallyEtale := Algebra.FormallyEtale.of_isLocalization 
  finitePresentation := IsLocalization.Away.finitePresentation r","error:  type mismatch
  FormallyEtale.of_isLocalization
has type
  âˆ€ (M : Submonoid ?m.48621) [inst : Algebra ?m.48621 ?m.48622] [inst_1 : IsLocalization M ?m.48622],
    FormallyEtale ?m.48621 ?m.48622 : Prop
but is expected to have type
  FormallyEtale R A : Prop","theorem of_isLocalization_Away (r : R) [IsLocalization.Away r A] : Etale R A where
","  formallyEtale := Algebra.FormallyEtale.of_isLocalization (Submonoid.powers r)
  finitePresentation := IsLocalization.Away.finitePresentation r"
Mathlib/LinearAlgebra/LinearIndependent.lean,linearIndependent_iUnion_finite,linearIndependent_iUnion_finite,ddffab96a653674eaf6ec54e6415f6fa7c2a49f7,":= by
  classical
  rw [iUnion_eq_iUnion_finset f]
  apply linearIndependent_iUnion_of_directed
  Â· apply directed_of_isDirected_le
    exact fun tâ‚ tâ‚‚ ht => iUnion_mono fun i => iUnion_subset_iUnion_const fun h => ht h
  intro t
  induction' t with i s his ih
  Â· refine' (linearIndependent_empty R M).mono _
    simp
  Â· rw [Finset.set_biUnion_insert]
    refine' (hl _).union ih _
    rw [span_iUnionâ‚‚]
    exact hd i s s.finite_toSet his","error:  unsolved goals
case h.mk
Î¹âœ : Type u'
Î¹' : Type u_1
R : Type u_2
K : Type u_3
M : Type u_4
M' : Type u_5
M'' : Type u_6
V : Type u
V' : Type u_7
v : Î¹âœ â†’ M
instâœâ¶ : Ring R
instâœâµ : AddCommGroup M
instâœâ´ : AddCommGroup M'
instâœÂ³ : AddCommGroup M''
instâœÂ² : Module R M
instâœÂ¹ : Module R M'
instâœ : Module R M''
a b : R
x y : M
Î¹ : Type u_8
f : Î¹ â†’ Set M
hl : âˆ€ (i : Î¹), LinearIndependent R fun (x : â†‘(f i)) â†¦ â†‘x
hd : âˆ€ (i : Î¹) (t : Set Î¹), t.Finite â†’ i âˆ‰ t â†’ Disjoint (span R (f i)) (â¨† i âˆˆ t, span R (f i))
i : Multiset Î¹
s : i.Nodup
âŠ¢ âˆ€ i_1 âˆˆ i, f i_1 âŠ† âˆ…
error:  no goals to be solved","theorem linearIndependent_iUnion_finite_subtype {Î¹ : Type*} {f : Î¹ â†’ Set M}
    (hl : âˆ€ i, LinearIndependent R (fun x => x : f i â†’ M))
    (hd : âˆ€ i, âˆ€ t : Set Î¹, t.Finite â†’ i âˆ‰ t â†’ Disjoint (span R (f i)) (â¨† i âˆˆ t, span R (f i))) :
    LinearIndependent R (fun x => x : (â‹ƒ i, f i) â†’ M) ",":= by
  classical
  rw [iUnion_eq_iUnion_finset f]
  apply linearIndependent_iUnion_of_directed
  Â· apply directed_of_isDirected_le
    exact fun tâ‚ tâ‚‚ ht => iUnion_mono fun i => iUnion_subset_iUnion_const fun h => ht h
  intro t
  induction' t using Finset.induction_on with i s his ih
  Â· refine (linearIndependent_empty R M).mono ?_
    simp
  Â· rw [Finset.set_biUnion_insert]
    refine (hl _).union ih ?_
    rw [span_iUnionâ‚‚]
    exact hd i s s.finite_toSet his"
Mathlib/Analysis/InnerProductSpace/Rayleigh.lean,LinearMap.IsSymmetric.hasEigenvalue_iInf_of_finiteDimensional,hasEigenvalue_iInf_of_finiteDimensional,7dc162787d2a79bf721a83a87f641ace70251b17,":= by
  haveI := FiniteDimensional.proper_rclike ğ•œ E
  let T' := hT.toSelfAdjoint
  obtain âŸ¨x, hxâŸ© : âˆƒ x : E, x â‰  0 := exists_ne 0
  have Hâ‚ : IsCompact (sphere (0 : E) â€–xâ€–) := isCompact_sphere _ _
  have Hâ‚‚ : (sphere (0 : E) â€–xâ€–).Nonempty := âŸ¨x, by simpâŸ©
  obtain âŸ¨xâ‚€, hxâ‚€', hTxâ‚€âŸ© :=
    Hâ‚.exists_forall_le Hâ‚‚ T'.val.reApplyInnerSelf_continuous.continuousOn
  have hxâ‚€ : â€–xâ‚€â€– = â€–xâ€– := by simpa using hxâ‚€'
  have : IsMinOn T'.val.reApplyInnerSelf (sphere 0 â€–xâ‚€â€–) xâ‚€ := by simpa only [â† hxâ‚€] using hTxâ‚€
  have hxâ‚€_ne : xâ‚€ â‰  0 := by
    have : â€–xâ‚€â€– â‰  0 := by simp only [hxâ‚€, norm_eq_zero, hx, Ne.def, not_false_iff]
    simpa [â† norm_eq_zero, Ne.def]
  exact hasEigenvalue_of_hasEigenvector (T'.prop.hasEigenvector_of_isMinOn hxâ‚€_ne this)","warning:  `IsCompact.exists_forall_le` has been deprecated, use `IsCompact.exists_isMinOn` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.178202 â†’ ?m.178202 â†’ Prop
error:  unsolved goals
ğ•œ : Type u_1
instâœÂ³ : RCLike ğ•œ
E : Type u_2
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : InnerProductSpace ğ•œ E
instâœ : FiniteDimensional ğ•œ E
_i : Nontrivial E
T : E â†’â‚—[ğ•œ] E
hT : T.IsSymmetric
thisâœ : ProperSpace E
T' : â†¥(selfAdjoint (E â†’L[ğ•œ] E)) := hT.toSelfAdjoint
x : E
hx : x â‰  0
Hâ‚ : IsCompact (sphere 0 â€–xâ€–)
Hâ‚‚ : (sphere 0 â€–xâ€–).Nonempty
xâ‚€ : E
hxâ‚€' : xâ‚€ âˆˆ sphere 0 â€–xâ€–
hTxâ‚€ : âˆ€ y âˆˆ sphere 0 â€–xâ€–, (â†‘T').reApplyInnerSelf xâ‚€ â‰¤ (â†‘T').reApplyInnerSelf y
hxâ‚€ : â€–xâ‚€â€– = â€–xâ€–
this : IsMinOn (â†‘T').reApplyInnerSelf (sphere 0 â€–xâ‚€â€–) xâ‚€
âŠ¢ â€–xâ€– â‰  0
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.178235 â†’ ?m.178235 â†’ Prop","theorem hasEigenvalue_iInf_of_finiteDimensional (hT : T.IsSymmetric) :
    HasEigenvalue T â†‘(â¨… x : { x : E // x â‰  0 }, RCLike.re âŸªT x, xâŸ« / â€–(x : E)â€– ^ 2 : â„) ",":= by
  haveI := FiniteDimensional.proper_rclike ğ•œ E
  let T' := hT.toSelfAdjoint
  obtain âŸ¨x, hxâŸ© : âˆƒ x : E, x â‰  0 := exists_ne 0
  have Hâ‚ : IsCompact (sphere (0 : E) â€–xâ€–) := isCompact_sphere _ _
  have Hâ‚‚ : (sphere (0 : E) â€–xâ€–).Nonempty := âŸ¨x, by simpâŸ©
  obtain âŸ¨xâ‚€, hxâ‚€', hTxâ‚€âŸ© :=
    Hâ‚.exists_isMinOn Hâ‚‚ T'.val.reApplyInnerSelf_continuous.continuousOn
  have hxâ‚€ : â€–xâ‚€â€– = â€–xâ€– := by simpa using hxâ‚€'
  have : IsMinOn T'.val.reApplyInnerSelf (sphere 0 â€–xâ‚€â€–) xâ‚€ := by simpa only [â† hxâ‚€] using hTxâ‚€
  have hxâ‚€_ne : xâ‚€ â‰  0 := by
    have : â€–xâ‚€â€– â‰  0 := by simp only [hxâ‚€, norm_eq_zero, hx, Ne, not_false_iff]
    simpa [â† norm_eq_zero, Ne]
  exact hasEigenvalue_of_hasEigenvector (T'.prop.hasEigenvector_of_isMinOn hxâ‚€_ne this)"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,HolderOnWith.hausdorffMeasure_image_le,hausdorffMeasure_image_le,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine' iSup_le fun R => iSup_le fun hR => _
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine' ENNReal.tsum_le_tsum fun n => _
      simp only [iSup_le_iff, nonempty_image_iff]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left s) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","warning:  `Set.nonempty_image_iff` has been deprecated, use `Set.image_nonempty` instead
error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set X : Type u_2
but is expected to have type
  ?m.169595 âˆˆ t n âˆ© ?m.169594 : Prop
error:  simp made no progress","theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s ",":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd"
Mathlib/GroupTheory/Perm/Support.lean,Equiv.Perm.support_swap_iff,support_swap_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine âŸ¨fun h => ?_, fun h => support_swap hâŸ©
  by_contra!
  rw [â† this] at h
  simp only [swap_self, support_refl, pair_eq_singleton] at h
  have : x âˆˆ âˆ… := by
    rw [h]
    exact mem_singleton.mpr rfl
  have := Finset.ne_empty_of_mem this
  exact this rfl","error:  typeclass instance problem is stuck, it is often due to metavariables
  Membership Î± ?m.43793","theorem support_swap_iff (x y : Î±) : support (swap x y) = {x, y} â†” x â‰  y ",":= by
  refine âŸ¨fun h => ?_, fun h => support_swap hâŸ©
  rintro rfl
  simp [Finset.ext_iff] at h"
Mathlib/MeasureTheory/Decomposition/Lebesgue.lean,MeasureTheory.Measure.absolutelyContinuous_withDensity_rnDeriv,absolutelyContinuous_withDensity_rnDeriv,4c45c3eb37944da725e7efcaf2bbc6cdd5b93feb,":= by
  rw [haveLebesgueDecomposition_add Î½ Î¼] at hÎ¼Î½
  refine AbsolutelyContinuous.mk (fun s _ hÎ½s â†¦ ?_)
  obtain âŸ¨t, _, ht1, ht2âŸ© := mutuallySingular_singularPart Î½ Î¼
  rw [â† inter_union_compl s t]
  refine le_antisymm ((measure_union_le (s âˆ© t) (s âˆ© tá¶œ)).trans ?_) (zero_le _)
  simp only [nonpos_iff_eq_zero, add_eq_zero]
  constructor
  Â· refine hÎ¼Î½ ?_
    simp only [coe_add, Pi.add_apply, add_eq_zero]
    constructor
    Â· exact measure_mono_null (Set.inter_subset_right _ _) ht1
    Â· exact measure_mono_null (Set.inter_subset_left _ _) hÎ½s
  Â· exact measure_mono_null (Set.inter_subset_right _ _) ht2","error:  function expected at
  inter_subset_right ?m.31899
term has type
  ?m.31898 âˆˆ ?m.31897
error:  function expected at
  inter_subset_left ?m.32208
term has type
  ?m.32207 âˆˆ ?m.32205
error:  function expected at
  inter_subset_right ?m.32488
term has type
  ?m.32487 âˆˆ ?m.32486","lemma absolutelyContinuous_withDensity_rnDeriv [HaveLebesgueDecomposition Î½ Î¼] (hÎ¼Î½ : Î¼ â‰ª Î½) :
    Î¼ â‰ª Î¼.withDensity (Î½.rnDeriv Î¼) ",":= by
  rw [haveLebesgueDecomposition_add Î½ Î¼] at hÎ¼Î½
  refine AbsolutelyContinuous.mk (fun s _ hÎ½s â†¦ ?_)
  obtain âŸ¨t, _, ht1, ht2âŸ© := mutuallySingular_singularPart Î½ Î¼
  rw [â† inter_union_compl s]
  refine le_antisymm ((measure_union_le (s âˆ© t) (s âˆ© tá¶œ)).trans ?_) (zero_le _)
  simp only [nonpos_iff_eq_zero, add_eq_zero]
  constructor
  Â· refine hÎ¼Î½ ?_
    simp only [coe_add, Pi.add_apply, add_eq_zero]
    constructor
    Â· exact measure_mono_null Set.inter_subset_right ht1
    Â· exact measure_mono_null Set.inter_subset_left hÎ½s
  Â· exact measure_mono_null Set.inter_subset_right ht2"
Mathlib/Data/Set/Finite.lean,Set.Infinite.exists_not_mem_finite,Infinite.exists_not_mem_finite,0e1fb8d54955c6fdc7263b0eb58946a3a50c37a4,":= by
  by_contra' h; exact hs $ ht.subset h","error:  unknown tactic
error:  unsolved goals
Î± : Type u
Î² : Type v
Î¹ : Sort w
Î³ : Type x
s t : Set Î±
hs : s.Infinite
ht : t.Finite
âŠ¢ âˆƒ a âˆˆ s, a âˆ‰ t","lemma Infinite.exists_not_mem_finite (hs : s.Infinite) (ht : t.Finite) : âˆƒ a, a âˆˆ s âˆ§ a âˆ‰ t ",":= by
  by_contra! h; exact hs <| ht.subset h"
Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean,jacobiSym.mod_right',mod_right',9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  rcases eq_or_ne a 0 with (rfl | haâ‚€)
  Â· rw [mul_zero, mod_zero]
  have hb' : Odd (b % (4 * a)) := hb.mod_even (Even.mul_right (by decide) _)
  rcases exists_eq_pow_mul_and_not_dvd haâ‚€ 2 (by norm_num) with âŸ¨e, a', haâ‚', haâ‚‚âŸ©
  have haâ‚ := odd_iff.mpr (two_dvd_ne_zero.mp haâ‚')
  nth_rw 2 [haâ‚‚]; nth_rw 1 [haâ‚‚]
  rw [Nat.cast_mul, mul_left, mul_left, quadratic_reciprocity' haâ‚ hb,
    quadratic_reciprocity' haâ‚ hb', Nat.cast_pow, pow_left, pow_left, Nat.cast_two, at_two hb,
    at_two hb']
  congr 1; swap; congr 1
  Â· simp_rw [qrSign]
    rw [Ï‡â‚„_nat_mod_four, Ï‡â‚„_nat_mod_four (b % (4 * a)), mod_mod_of_dvd b (dvd_mul_right 4 a)]
  Â· rw [mod_left â†‘(b % _), mod_left b, Int.coe_nat_mod, Int.emod_emod_of_dvd b]
    simp only [haâ‚‚, Nat.cast_mul, â† mul_assoc]
    apply dvd_mul_left
  cases' e with e; Â· rfl
  Â· rw [Ï‡â‚ˆ_nat_mod_eight, Ï‡â‚ˆ_nat_mod_eight (b % (4 * a)), mod_mod_of_dvd b]
    use 2 ^ e * a'; rw [haâ‚‚, Nat.pow_succ]; ring","warning:  jacobiSym does not have a doc string
error:  unknown constant 'Int.coe_nat_mod'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.71639
case inr.intro.intro.intro.e_a.e_a
a b : â„•
hb : Odd b
haâ‚€ : a â‰  0
hb' : Odd (b % (4 * a))
e a' : â„•
haâ‚' : Â¬2 âˆ£ a'
haâ‚‚ : a = 2 ^ e * a'
haâ‚ : Odd a'
âŠ¢ J(â†‘b % â†‘a' | a') = J(â†‘(b % (4 * a)) % â†‘a' | a')",theorem mod_right' (a : â„•) {b : â„•} (hb : Odd b) : J(a | b) = J(a | b % (4 * a)) ,":= by
  rcases eq_or_ne a 0 with (rfl | haâ‚€)
  Â· rw [mul_zero, mod_zero]
  have hb' : Odd (b % (4 * a)) := hb.mod_even (Even.mul_right (by decide) _)
  rcases exists_eq_pow_mul_and_not_dvd haâ‚€ 2 (by norm_num) with âŸ¨e, a', haâ‚', haâ‚‚âŸ©
  have haâ‚ := odd_iff.mpr (two_dvd_ne_zero.mp haâ‚')
  nth_rw 2 [haâ‚‚]; nth_rw 1 [haâ‚‚]
  rw [Nat.cast_mul, mul_left, mul_left, quadratic_reciprocity' haâ‚ hb,
    quadratic_reciprocity' haâ‚ hb', Nat.cast_pow, pow_left, pow_left, Nat.cast_two, at_two hb,
    at_two hb']
  congr 1; swap;
  Â· congr 1
    Â· simp_rw [qrSign]
      rw [Ï‡â‚„_nat_mod_four, Ï‡â‚„_nat_mod_four (b % (4 * a)), mod_mod_of_dvd b (dvd_mul_right 4 a)]
    Â· rw [mod_left â†‘(b % _), mod_left b, Int.natCast_mod, Int.emod_emod_of_dvd b]
      simp only [haâ‚‚, Nat.cast_mul, â† mul_assoc]
      apply dvd_mul_left
  cases' e with e; Â· rfl
  Â· rw [Ï‡â‚ˆ_nat_mod_eight, Ï‡â‚ˆ_nat_mod_eight (b % (4 * a)), mod_mod_of_dvd b]
    use 2 ^ e * a'; rw [haâ‚‚, Nat.pow_succ]; ring"
Mathlib/MeasureTheory/Function/ContinuousMapDense.lean,MeasureTheory.exists_continuous_snorm_sub_le_of_closed,exists_continuous_snorm_sub_le_of_closed,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  obtain âŸ¨Î·, Î·_pos, hÎ·âŸ© :
      âˆƒ Î· : â„â‰¥0, 0 < Î· âˆ§ âˆ€ s : Set Î±, Î¼ s â‰¤ Î· â†’ snorm (s.indicator fun _x => c) p Î¼ â‰¤ Îµ :=
    exists_snorm_indicator_le hp c hÎµ
  have Î·pos : (0 : â„â‰¥0âˆ) < Î· := ENNReal.coe_lt_coe.2 Î·_pos
  obtain âŸ¨V, sV, V_open, h'V, hVâŸ© : âˆƒ (V : Set Î±), V âŠ‡ s âˆ§ IsOpen V âˆ§ Î¼ V < âˆ âˆ§ Î¼ (V \ s) < Î· :=
    s_closed.measurableSet.exists_isOpen_diff_lt hs Î·pos.ne'
  let v := u âˆ© V
  have hsv : s âŠ† v := subset_inter hsu sV
  have hÎ¼v : Î¼ v < âˆ := (measure_mono (inter_subset_right _ _)).trans_lt h'V
  obtain âŸ¨g, hgv, hgs, hg_rangeâŸ© :=
    exists_continuous_zero_one_of_isClosed (u_open.inter V_open).isClosed_compl s_closed
      (disjoint_compl_left_iff.2 hsv)
  have g_norm : âˆ€ x, â€–g xâ€– = g x := fun x => by rw [Real.norm_eq_abs, abs_of_nonneg (hg_range x).1]
  have gc_bd0 : âˆ€ x, â€–g x â€¢ câ€– â‰¤ â€–câ€– := by
    intro x
    simp only [norm_smul, g_norm x]
    apply mul_le_of_le_one_left (norm_nonneg _)
    exact (hg_range x).2
  have gc_bd :
      âˆ€ x, â€–g x â€¢ c - s.indicator (fun _x => c) xâ€– â‰¤ â€–(v \ s).indicator (fun _x => c) xâ€– := by
    intro x
    by_cases hv : x âˆˆ v
    Â· rw [â† Set.diff_union_of_subset hsv] at hv
      cases' hv with hsv hs
      Â· simpa only [hsv.2, Set.indicator_of_not_mem, not_false_iff, sub_zero, hsv,
          Set.indicator_of_mem] using gc_bd0 x
      Â· simp [hgs hs, hs]
    Â· simp [hgv hv, show x âˆ‰ s from fun h => hv (hsv h)]
  have gc_support : (Function.support fun x : Î± => g x â€¢ c) âŠ† v := by
    refine' Function.support_subset_iff'.2 fun x hx => _
    simp only [hgv hx, Pi.zero_apply, zero_smul]
  have gc_mem : Memâ„’p (fun x => g x â€¢ c) p Î¼ := by
    refine' Memâ„’p.smul_of_top_left (memâ„’p_top_const _) _
    refine âŸ¨g.continuous.aestronglyMeasurable, ?_âŸ©
    have : snorm (v.indicator fun _x => (1 : â„)) p Î¼ < âŠ¤ := by
      refine' (snorm_indicator_const_le _ _).trans_lt _
      simp only [lt_top_iff_ne_top, hÎ¼v.ne, nnnorm_one, ENNReal.coe_one, one_div, one_mul, Ne,
        ENNReal.rpow_eq_top_iff, inv_lt_zero, false_and_iff, or_false_iff, not_and, not_lt,
        ENNReal.toReal_nonneg, imp_true_iff]
    refine' (snorm_mono fun x => _).trans_lt this
    by_cases hx : x âˆˆ v
    Â· simp only [hx, abs_of_nonneg (hg_range x).1, (hg_range x).2, Real.norm_eq_abs,
        indicator_of_mem, CstarRing.norm_one]
    Â· simp only [hgv hx, Pi.zero_apply, Real.norm_eq_abs, abs_zero, abs_nonneg]
  refine'
    âŸ¨fun x => g x â€¢ c, g.continuous.smul continuous_const, (snorm_mono gc_bd).trans _, gc_bd0,
      gc_support.trans (inter_subset_left _ _), gc_memâŸ©
  exact hÎ· _ ((measure_mono (diff_subset_diff (inter_subset_right _ _) Subset.rfl)).trans hV.le)","error:  function expected at
  inter_subset_right ?m.4277
term has type
  ?m.4276 âˆˆ ?m.4275
error:  function expected at
  inter_subset_left ?m.23707
term has type
  ?m.23706 âˆˆ ?m.23704
error:  function expected at
  inter_subset_right ?m.23790
term has type
  ?m.23789 âˆˆ ?m.23788","theorem exists_continuous_snorm_sub_le_of_closed [Î¼.OuterRegular] (hp : p â‰  âˆ) {s u : Set Î±}
    (s_closed : IsClosed s) (u_open : IsOpen u) (hsu : s âŠ† u) (hs : Î¼ s â‰  âˆ) (c : E) {Îµ : â„â‰¥0âˆ}
    (hÎµ : Îµ â‰  0) :
    âˆƒ f : Î± â†’ E,
      Continuous f âˆ§
        snorm (fun x => f x - s.indicator (fun _y => c) x) p Î¼ â‰¤ Îµ âˆ§
          (âˆ€ x, â€–f xâ€– â‰¤ â€–câ€–) âˆ§ Function.support f âŠ† u âˆ§ Memâ„’p f p Î¼ ",":= by
  obtain âŸ¨Î·, Î·_pos, hÎ·âŸ© :
      âˆƒ Î· : â„â‰¥0, 0 < Î· âˆ§ âˆ€ s : Set Î±, Î¼ s â‰¤ Î· â†’ snorm (s.indicator fun _x => c) p Î¼ â‰¤ Îµ :=
    exists_snorm_indicator_le hp c hÎµ
  have Î·pos : (0 : â„â‰¥0âˆ) < Î· := ENNReal.coe_lt_coe.2 Î·_pos
  obtain âŸ¨V, sV, V_open, h'V, hVâŸ© : âˆƒ (V : Set Î±), V âŠ‡ s âˆ§ IsOpen V âˆ§ Î¼ V < âˆ âˆ§ Î¼ (V \ s) < Î· :=
    s_closed.measurableSet.exists_isOpen_diff_lt hs Î·pos.ne'
  let v := u âˆ© V
  have hsv : s âŠ† v := subset_inter hsu sV
  have hÎ¼v : Î¼ v < âˆ := (measure_mono inter_subset_right).trans_lt h'V
  obtain âŸ¨g, hgv, hgs, hg_rangeâŸ© :=
    exists_continuous_zero_one_of_isClosed (u_open.inter V_open).isClosed_compl s_closed
      (disjoint_compl_left_iff.2 hsv)
  have g_norm : âˆ€ x, â€–g xâ€– = g x := fun x => by rw [Real.norm_eq_abs, abs_of_nonneg (hg_range x).1]
  have gc_bd0 : âˆ€ x, â€–g x â€¢ câ€– â‰¤ â€–câ€– := by
    intro x
    simp only [norm_smul, g_norm x]
    apply mul_le_of_le_one_left (norm_nonneg _)
    exact (hg_range x).2
  have gc_bd :
      âˆ€ x, â€–g x â€¢ c - s.indicator (fun _x => c) xâ€– â‰¤ â€–(v \ s).indicator (fun _x => c) xâ€– := by
    intro x
    by_cases hv : x âˆˆ v
    Â· rw [â† Set.diff_union_of_subset hsv] at hv
      cases' hv with hsv hs
      Â· simpa only [hsv.2, Set.indicator_of_not_mem, not_false_iff, sub_zero, hsv,
          Set.indicator_of_mem] using gc_bd0 x
      Â· simp [hgs hs, hs]
    Â· simp [hgv hv, show x âˆ‰ s from fun h => hv (hsv h)]
  have gc_support : (Function.support fun x : Î± => g x â€¢ c) âŠ† v := by
    refine Function.support_subset_iff'.2 fun x hx => ?_
    simp only [hgv hx, Pi.zero_apply, zero_smul]
  have gc_mem : Memâ„’p (fun x => g x â€¢ c) p Î¼ := by
    refine Memâ„’p.smul_of_top_left (memâ„’p_top_const _) ?_
    refine âŸ¨g.continuous.aestronglyMeasurable, ?_âŸ©
    have : snorm (v.indicator fun _x => (1 : â„)) p Î¼ < âŠ¤ := by
      refine (snorm_indicator_const_le _ _).trans_lt ?_
      simp only [lt_top_iff_ne_top, hÎ¼v.ne, nnnorm_one, ENNReal.coe_one, one_div, one_mul, Ne,
        ENNReal.rpow_eq_top_iff, inv_lt_zero, false_and_iff, or_false_iff, not_and, not_lt,
        ENNReal.toReal_nonneg, imp_true_iff]
    refine (snorm_mono fun x => ?_).trans_lt this
    by_cases hx : x âˆˆ v
    Â· simp only [hx, abs_of_nonneg (hg_range x).1, (hg_range x).2, Real.norm_eq_abs,
        indicator_of_mem, CstarRing.norm_one]
    Â· simp only [hgv hx, Pi.zero_apply, Real.norm_eq_abs, abs_zero, abs_nonneg]
  refine
    âŸ¨fun x => g x â€¢ c, g.continuous.smul continuous_const, (snorm_mono gc_bd).trans ?_, gc_bd0,
      gc_support.trans inter_subset_left, gc_memâŸ©
  exact hÎ· _ ((measure_mono (diff_subset_diff inter_subset_right Subset.rfl)).trans hV.le)"
Mathlib/Data/Multiset/Basic.lean,Multiset.map_erase_of_mem,map_erase_of_mem,25e538f3a737a71314ac143929711e67d0b14d73,":= by
  induction' s with y s ih
  Â· simp
  rcases eq_or_ne y x with rfl | hxy
  Â· simp
  replace h : x âˆˆ s := by simpa [hxy.symm] using h
  rw [s.erase_cons_tail hxy, map_cons, map_cons, ih h, erase_cons_tail_of_mem (mem_map_of_mem f h)]","warning:  @cons does not have a doc string
error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Î± : Type u_1
Î² : Type v
Î³ : Type u_2
instâœÂ¹ : DecidableEq Î±
instâœ : DecidableEq Î²
f : Î± â†’ Î²
s : Multiset Î±
x : Î±
h : x âˆˆ s
âŠ¢ map f (s.erase x) = (map f s).erase (f x)
warning:  `List.filter_congr'` has been deprecated, use `List.filter_congr` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead","theorem map_erase_of_mem [DecidableEq Î±] [DecidableEq Î²] (f : Î± â†’ Î²)
    (s : Multiset Î±) {x : Î±} (h : x âˆˆ s) : (s.erase x).map f = (s.map f).erase (f x) ",":= by
  induction' s using Multiset.induction_on with y s ih
  Â· simp
  rcases eq_or_ne y x with rfl | hxy
  Â· simp
  replace h : x âˆˆ s := by simpa [hxy.symm] using h
  rw [s.erase_cons_tail hxy, map_cons, map_cons, ih h, erase_cons_tail_of_mem (mem_map_of_mem f h)]"
Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean,AbsoluteValue.IsAdmissible.exists_approx_aux,exists_approx_aux,e2193fa2a3ac9de816d77eb776ed0fbe2dc6d19c,":= by
  haveI := Classical.decEq R
  induction' n with n ih
  Â· intro Îµ _hÎµ b _hb A
    refine' âŸ¨0, 1, _, _âŸ©
    Â· simp
    rintro âŸ¨i, âŸ¨âŸ©âŸ©
  intro Îµ hÎµ b hb A
  let M := h.card Îµ
  obtain âŸ¨s, s_inj, hsâŸ© :
    âˆƒ s : Fin (M ^ n).succ â†’ Fin (M ^ n.succ).succ,
      Function.Injective s âˆ§ âˆ€ iâ‚€ iâ‚, (abv (A (s iâ‚) 0 % b - A (s iâ‚€) 0 % b) : â„) < abv b â€¢ Îµ := by
    obtain âŸ¨t, htâŸ© :
      âˆƒ t : Fin (M ^ n.succ).succ â†’ Fin M,
        âˆ€ iâ‚€ iâ‚, t iâ‚€ = t iâ‚ â†’ (abv (A iâ‚ 0 % b - A iâ‚€ 0 % b) : â„) < abv b â€¢ Îµ :=
      h.exists_partition hÎµ hb fun x â†¦ A x 0
    obtain âŸ¨s, hsâŸ© :=
      Fintype.exists_lt_card_fiber_of_mul_lt_card (f := t)
        (by simpa only [Fintype.card_fin, pow_succ'] using Nat.lt_succ_self (M ^ n.succ))
    refine âŸ¨fun i â†¦ (Finset.univ.filter fun x â†¦ t x = s).toList.get <| i.castLE ?_, fun i j h â†¦ ?_,
      fun iâ‚€ iâ‚ â†¦ ht _ _ ?_âŸ©
    Â· rwa [Finset.length_toList]
    Â· simpa [(Finset.nodup_toList _).get_inj_iff] using h
    Â· have : âˆ€ i, t ((Finset.univ.filter fun x â†¦ t x = s).toList.get i) = s := fun i â†¦
        (Finset.mem_filter.mp (Finset.mem_toList.mp (List.get_mem _ i i.2))).2
      simp [this]
  obtain âŸ¨kâ‚€, kâ‚, hk, hâŸ© := ih hÎµ hb fun x â†¦ Fin.tail (A (s x))
  refine' âŸ¨s kâ‚€, s kâ‚, fun h â†¦ hk (s_inj h), fun i â†¦ Fin.cases _ (fun i â†¦ _) iâŸ©
  Â· exact hs kâ‚€ kâ‚
  Â· exact h i","error:  type mismatch
  hâœ
has type
  (Finset.filter (fun x â†¦ t x = s) Finset.univ).toList[â†‘i] =
    (Finset.filter (fun x â†¦ t x = s) Finset.univ).toList[â†‘j] : Prop
but is expected to have type
  i = j : Prop
error:  unsolved goals
case intro.intro.refine_3
R : Type u_1
instâœ : EuclideanDomain R
abv : AbsoluteValue R â„¤
h : abv.IsAdmissible
thisâœ : DecidableEq R
n : â„•
ih :
  âˆ€ {Îµ : â„},
    0 < Îµ â†’
      âˆ€ {b : R},
        b â‰  0 â†’
          âˆ€ (A : Fin (h.card Îµ ^ n).succ â†’ Fin n â†’ R),
            âˆƒ iâ‚€ iâ‚, iâ‚€ â‰  iâ‚ âˆ§ âˆ€ (k : Fin n), â†‘(abv (A iâ‚ k % b - A iâ‚€ k % b)) < abv b â€¢ Îµ
Îµ : â„
hÎµ : 0 < Îµ
b : R
hb : b â‰  0
A : Fin (h.card Îµ ^ (n + 1)).succ â†’ Fin (n + 1) â†’ R
M : â„• := h.card Îµ
t : Fin (M ^ n.succ).succ â†’ Fin M
ht : âˆ€ (iâ‚€ iâ‚ : Fin (M ^ n.succ).succ), t iâ‚€ = t iâ‚ â†’ â†‘(abv (A iâ‚ 0 % b - A iâ‚€ 0 % b)) < abv b â€¢ Îµ
s : Fin M
hs : M ^ n < (Finset.filter (fun x â†¦ t x = s) Finset.univ).card
iâ‚€ iâ‚ : Fin (M ^ n).succ
this :
  âˆ€ (i : Fin (Finset.filter (fun x â†¦ t x = s) Finset.univ).toList.length),
    t ((Finset.filter (fun x â†¦ t x = s) Finset.univ).toList.get i) = s
âŠ¢ t (Finset.filter (fun x â†¦ t x = s) Finset.univ).toList[â†‘iâ‚€] =
    t (Finset.filter (fun x â†¦ t x = s) Finset.univ).toList[â†‘iâ‚]","theorem exists_approx_aux (n : â„•) (h : abv.IsAdmissible) :
    âˆ€ {Îµ : â„} (_hÎµ : 0 < Îµ) {b : R} (_hb : b â‰  0) (A : Fin (h.card Îµ ^ n).succ â†’ Fin n â†’ R),
      âˆƒ iâ‚€ iâ‚, iâ‚€ â‰  iâ‚ âˆ§ âˆ€ k, (abv (A iâ‚ k % b - A iâ‚€ k % b) : â„) < abv b â€¢ Îµ ",":= by
  haveI := Classical.decEq R
  induction' n with n ih
  Â· intro Îµ _hÎµ b _hb A
    refine âŸ¨0, 1, ?_, ?_âŸ©
    Â· simp
    rintro âŸ¨i, âŸ¨âŸ©âŸ©
  intro Îµ hÎµ b hb A
  let M := h.card Îµ
  obtain âŸ¨s, s_inj, hsâŸ© :
    âˆƒ s : Fin (M ^ n).succ â†’ Fin (M ^ n.succ).succ,
      Function.Injective s âˆ§ âˆ€ iâ‚€ iâ‚, (abv (A (s iâ‚) 0 % b - A (s iâ‚€) 0 % b) : â„) < abv b â€¢ Îµ := by
    obtain âŸ¨t, htâŸ© :
      âˆƒ t : Fin (M ^ n.succ).succ â†’ Fin M,
        âˆ€ iâ‚€ iâ‚, t iâ‚€ = t iâ‚ â†’ (abv (A iâ‚ 0 % b - A iâ‚€ 0 % b) : â„) < abv b â€¢ Îµ :=
      h.exists_partition hÎµ hb fun x â†¦ A x 0
    obtain âŸ¨s, hsâŸ© :=
      Fintype.exists_lt_card_fiber_of_mul_lt_card (f := t)
        (by simpa only [Fintype.card_fin, pow_succ'] using Nat.lt_succ_self (M ^ n.succ))
    refine âŸ¨fun i â†¦ (Finset.univ.filter fun x â†¦ t x = s).toList.get <| i.castLE ?_, fun i j h â†¦ ?_,
      fun iâ‚€ iâ‚ â†¦ ht _ _ ?_âŸ©
    Â· rwa [Finset.length_toList]
    Â· ext
      simpa [(Finset.nodup_toList _).getElem_inj_iff] using h
    Â· have : âˆ€ i h, t ((Finset.univ.filter fun x â†¦ t x = s).toList.get âŸ¨i, hâŸ©) = s := fun i h â†¦
        (Finset.mem_filter.mp (Finset.mem_toList.mp (List.get_mem _ i h))).2
      simp only [Nat.succ_eq_add_one, Finset.length_toList, List.get_eq_getElem] at this
      simp only [Nat.succ_eq_add_one, List.get_eq_getElem, Fin.coe_castLE]
      rw [this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ iâ‚.2) hs),
        this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ iâ‚€.2) hs)]
  obtain âŸ¨kâ‚€, kâ‚, hk, hâŸ© := ih hÎµ hb fun x â†¦ Fin.tail (A (s x))
  refine âŸ¨s kâ‚€, s kâ‚, fun h â†¦ hk (s_inj h), fun i â†¦ Fin.cases ?_ (fun i â†¦ ?_) iâŸ©
  Â· exact hs kâ‚€ kâ‚
  Â· exact h i"
Mathlib/RingTheory/ChainOfDivisors.lean,pow_image_of_prime_by_factor_orderIso_dvd,pow_image_of_prime_by_factor_orderIso_dvd,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  by_cases hs : s = 0
  Â· simp [hs]
  suffices (d âŸ¨p, dvd_of_mem_normalizedFactors hpâŸ© : Associates N) ^ s =
      (d âŸ¨p ^ s, hs'âŸ©) by
    rw [this]
    apply Subtype.prop (d âŸ¨p ^ s, hs'âŸ©)
  obtain âŸ¨câ‚, rfl, hcâ‚', hcâ‚''âŸ© := exists_chain_of_prime_pow hs (prime_of_normalized_factor p hp)
  let câ‚‚ : Fin (s + 1) â†’ Associates N := fun t => d âŸ¨câ‚ t, le_trans (hcâ‚''.2 âŸ¨t, by simpâŸ©) hs'âŸ©
  have câ‚‚_def : âˆ€ t, câ‚‚ t = d âŸ¨câ‚ t, _âŸ© := fun t => rfl
  rw [â† câ‚‚_def]
  refine
    (eq_pow_second_of_chain_of_has_chain hs (fun t u h => ?_) (@fun r => âŸ¨@fun hr =>? _?, _âŸ©)? _).symm
  Â· rw [câ‚‚_def, câ‚‚_def, Subtype.coe_lt_coe, d.lt_iff_lt, Subtype.mk_lt_mk, hcâ‚'.lt_iff_lt]
    exact h
  Â· have : r â‰¤ n := hr.trans (d âŸ¨câ‚ 1 ^ s, _âŸ©).2
    suffices d.symm âŸ¨r, thisâŸ© â‰¤ âŸ¨câ‚ 1 ^ s, hs'âŸ© by
      obtain âŸ¨i, hiâŸ© := hcâ‚''.1 this
      use i
      simp only [câ‚‚_def, â† hi, d.apply_symm_apply, Subtype.coe_eta, Subtype.coe_mk]
    conv_rhs => rw [â† d.symm_apply_apply âŸ¨câ‚ 1 ^ s, hs'âŸ©]
    rw [d.symm.le_iff_le]
    simpa only [â† Subtype.coe_le_coe, Subtype.coe_mk] using hr
  Â· rintro âŸ¨i, hrâŸ©
    rw [hr, câ‚‚_def, Subtype.coe_le_coe, d.le_iff_le]
    simpa [Subtype.mk_le_mk] using hcâ‚''.2 âŸ¨i, rflâŸ©
  exact ne_zero_of_dvd_ne_zero hn (Subtype.prop (d âŸ¨câ‚ 1 ^ s, _âŸ©))","error:  unexpected token '?'; expected ')', ',' or ':'","theorem pow_image_of_prime_by_factor_orderIso_dvd
    {m p : Associates M} {n : Associates N} (hn : n â‰  0) (hp : p âˆˆ normalizedFactors m)
    (d : Set.Iic m â‰ƒo Set.Iic n) {s : â„•} (hs' : p ^ s â‰¤ m) :
    (d âŸ¨p, dvd_of_mem_normalizedFactors hpâŸ© : Associates N) ^ s â‰¤ n ",":= by
  by_cases hs : s = 0
  Â· simp [hs]
  suffices (d âŸ¨p, dvd_of_mem_normalizedFactors hpâŸ© : Associates N) ^ s =
      (d âŸ¨p ^ s, hs'âŸ©) by
    rw [this]
    apply Subtype.prop (d âŸ¨p ^ s, hs'âŸ©)
  obtain âŸ¨câ‚, rfl, hcâ‚', hcâ‚''âŸ© := exists_chain_of_prime_pow hs (prime_of_normalized_factor p hp)
  let câ‚‚ : Fin (s + 1) â†’ Associates N := fun t => d âŸ¨câ‚ t, le_trans (hcâ‚''.2 âŸ¨t, by simpâŸ©) hs'âŸ©
  have câ‚‚_def : âˆ€ t, câ‚‚ t = d âŸ¨câ‚ t, _âŸ© := fun t => rfl
  rw [â† câ‚‚_def]
  refine (eq_pow_second_of_chain_of_has_chain hs (fun t u h => ?_)
    (@fun r => âŸ¨@fun hr => ?_, ?_âŸ©) ?_).symm
  Â· rw [câ‚‚_def, câ‚‚_def, Subtype.coe_lt_coe, d.lt_iff_lt, Subtype.mk_lt_mk, hcâ‚'.lt_iff_lt]
    exact h
  Â· have : r â‰¤ n := hr.trans (d âŸ¨câ‚ 1 ^ s, _âŸ©).2
    suffices d.symm âŸ¨r, thisâŸ© â‰¤ âŸ¨câ‚ 1 ^ s, hs'âŸ© by
      obtain âŸ¨i, hiâŸ© := hcâ‚''.1 this
      use i
      simp only [câ‚‚_def, â† hi, d.apply_symm_apply, Subtype.coe_eta, Subtype.coe_mk]
    conv_rhs => rw [â† d.symm_apply_apply âŸ¨câ‚ 1 ^ s, hs'âŸ©]
    rw [d.symm.le_iff_le]
    simpa only [â† Subtype.coe_le_coe, Subtype.coe_mk] using hr
  Â· rintro âŸ¨i, hrâŸ©
    rw [hr, câ‚‚_def, Subtype.coe_le_coe, d.le_iff_le]
    simpa [Subtype.mk_le_mk] using hcâ‚''.2 âŸ¨i, rflâŸ©
  exact ne_zero_of_dvd_ne_zero hn (Subtype.prop (d âŸ¨câ‚ 1 ^ s, _âŸ©))"
Mathlib/Geometry/Manifold/LocalInvariantProperties.lean,PartialHomeomorph.isLocalStructomorphWithinAt_iff,_root_.PartialHomeomorph.isLocalStructomorphWithinAt_iff,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  constructor
  Â· intro hf h2x
    obtain âŸ¨e, he, hfe, hxeâŸ© := hf h2x
    refine âŸ¨e.restr f.source, closedUnderRestriction' he f.open_source, ?_, ?_, hxe,? _âŸ©
    Â· simp_rw [PartialHomeomorph.restr_source]
      exact (inter_subset_right _ _).trans interior_subset
    Â· intro x' hx'
      exact hfe âŸ¨hx'.1, hx'.2.1âŸ©
    Â· rw [f.open_source.interior_eq]
      exact Or.resolve_right hx (not_not.mpr h2x)
  Â· intro hf hx
    obtain âŸ¨e, he, _, hfe, hxeâŸ© := hf hx
    exact âŸ¨e, he, hfe, hxeâŸ©","error:  function expected at
  inter_subset_right ?m.80378
term has type
  ?m.80377 âˆˆ ?m.80376","theorem _root_.PartialHomeomorph.isLocalStructomorphWithinAt_iff {G : StructureGroupoid H}
    [ClosedUnderRestriction G] (f : PartialHomeomorph H H) {s : Set H} {x : H}
    (hx : x âˆˆ f.source âˆª sá¶œ) :
    G.IsLocalStructomorphWithinAt (â‡‘f) s x â†”
      x âˆˆ s â†’ âˆƒ e : PartialHomeomorph H H,
      e âˆˆ G âˆ§ e.source âŠ† f.source âˆ§ EqOn f (â‡‘e) (s âˆ© e.source) âˆ§ x âˆˆ e.source ",":= by
  constructor
  Â· intro hf h2x
    obtain âŸ¨e, he, hfe, hxeâŸ© := hf h2x
    refine âŸ¨e.restr f.source, closedUnderRestriction' he f.open_source, ?_, ?_, hxe, ?_âŸ©
    Â· simp_rw [PartialHomeomorph.restr_source]
      exact inter_subset_right.trans interior_subset
    Â· intro x' hx'
      exact hfe âŸ¨hx'.1, hx'.2.1âŸ©
    Â· rw [f.open_source.interior_eq]
      exact Or.resolve_right hx (not_not.mpr h2x)
  Â· intro hf hx
    obtain âŸ¨e, he, _, hfe, hxeâŸ© := hf hx
    exact âŸ¨e, he, hfe, hxeâŸ©"
Mathlib/LinearAlgebra/LinearIndependent.lean,linearIndependent_sum,linearIndependent_sum,0ef23fba776dbe5bb848bbfc3337bedef4a59c82,":= by
  classical
  rw [range_comp v, range_comp v]
  refine âŸ¨?_, ?_âŸ©
  Â· intro h
    refine âŸ¨h.comp _ Sum.inl_injective, h.comp _ Sum.inr_injective, ?_âŸ©
    refine h.disjoint_span_image ?_
    exact IsCompl.disjoint isCompl_range_inl_range_inr
  rintro âŸ¨hl, hr, hlrâŸ©
  rw [linearIndependent_iff'] at *
  intro s g hg i hi
  have :
    ((âˆ‘ i in s.preimage Sum.inl (Sum.inl_injective.injOn _), (fun x => g x â€¢ v x) (Sum.inl i)) +
        âˆ‘ i in s.preimage Sum.inr (Sum.inr_injective.injOn _), (fun x => g x â€¢ v x) (Sum.inr i)) =
      0 := by
    rw [Finset.sum_preimage' (g := fun x => g x â€¢ v x),
      Finset.sum_preimage' (g := fun x => g x â€¢ v x), â† Finset.sum_union, â† Finset.filter_or]
    Â· simpa only [â† mem_union, range_inl_union_range_inr, mem_univ, Finset.filter_True]
    Â· 
      refine Finset.disjoint_filter.2 fun x _ hx =>
        disjoint_left.1 ?_ hx
      exact IsCompl.disjoint isCompl_range_inl_range_inr
  rw [â† eq_neg_iff_add_eq_zero] at this
  rw [disjoint_def'] at hlr
  have A := by
    refine hlr _ (sum_mem fun i _ => ?_) _ (neg_mem <| sum_mem fun i _ => ?_) this
    Â· exact smul_mem _ _ (subset_span âŸ¨Sum.inl i, mem_range_self _, rflâŸ©)
    Â· exact smul_mem _ _ (subset_span âŸ¨Sum.inr i, mem_range_self _, rflâŸ©)
  cases' i with i i
  Â· exact hl _ _ A i (Finset.mem_preimage.2 hi)
  Â· rw [this, neg_eq_zero] at A
    exact hr _ _ A i (Finset.mem_preimage.2 hi)","error:  application type mismatch
  s.preimage Sum.inl â‹¯
argument
  Injective.injOn Sum.inl_injective ?m.376732
has type
  âˆ€ â¦ƒxâ‚‚ : ?m.376722â¦„, xâ‚‚ âˆˆ ?m.376730 â†’ Sum.inl ?m.376731 = Sum.inl xâ‚‚ â†’ ?m.376731 = xâ‚‚ : Prop
but is expected to have type
  InjOn Sum.inl (Sum.inl â»Â¹' â†‘s) : Prop
error:  application type mismatch
  s.preimage Sum.inr â‹¯
argument
  Injective.injOn Sum.inr_injective ?m.378237
has type
  âˆ€ â¦ƒxâ‚‚ : ?m.378227â¦„, xâ‚‚ âˆˆ ?m.378235 â†’ Sum.inr ?m.378236 = Sum.inr xâ‚‚ â†’ ?m.378236 = xâ‚‚ : Prop
but is expected to have type
  InjOn Sum.inr (Sum.inr â»Â¹' â†‘s) : Prop","theorem linearIndependent_sum {v : Sum Î¹ Î¹' â†’ M} :
    LinearIndependent R v â†”
      LinearIndependent R (v âˆ˜ Sum.inl) âˆ§
        LinearIndependent R (v âˆ˜ Sum.inr) âˆ§
          Disjoint (Submodule.span R (range (v âˆ˜ Sum.inl)))
            (Submodule.span R (range (v âˆ˜ Sum.inr))) ",":= by
  classical
  rw [range_comp v, range_comp v]
  refine âŸ¨?_, ?_âŸ©
  Â· intro h
    refine âŸ¨h.comp _ Sum.inl_injective, h.comp _ Sum.inr_injective, ?_âŸ©
    refine h.disjoint_span_image ?_
    exact IsCompl.disjoint isCompl_range_inl_range_inr
  rintro âŸ¨hl, hr, hlrâŸ©
  rw [linearIndependent_iff'] at *
  intro s g hg i hi
  have :
    ((âˆ‘ i âˆˆ s.preimage Sum.inl Sum.inl_injective.injOn, (fun x => g x â€¢ v x) (Sum.inl i)) +
        âˆ‘ i âˆˆ s.preimage Sum.inr Sum.inr_injective.injOn, (fun x => g x â€¢ v x) (Sum.inr i)) =
      0 := by
    rw [Finset.sum_preimage' (g := fun x => g x â€¢ v x),
      Finset.sum_preimage' (g := fun x => g x â€¢ v x), â† Finset.sum_union, â† Finset.filter_or]
    Â· simpa only [â† mem_union, range_inl_union_range_inr, mem_univ, Finset.filter_True]
    Â· 
      refine Finset.disjoint_filter.2 fun x _ hx =>
        disjoint_left.1 ?_ hx
      exact IsCompl.disjoint isCompl_range_inl_range_inr
  rw [â† eq_neg_iff_add_eq_zero] at this
  rw [disjoint_def'] at hlr
  have A := by
    refine hlr _ (sum_mem fun i _ => ?_) _ (neg_mem <| sum_mem fun i _ => ?_) this
    Â· exact smul_mem _ _ (subset_span âŸ¨Sum.inl i, mem_range_self _, rflâŸ©)
    Â· exact smul_mem _ _ (subset_span âŸ¨Sum.inr i, mem_range_self _, rflâŸ©)
  cases' i with i i
  Â· exact hl _ _ A i (Finset.mem_preimage.2 hi)
  Â· rw [this, neg_eq_zero] at A
    exact hr _ _ A i (Finset.mem_preimage.2 hi)"
Mathlib/MeasureTheory/Integral/TorusIntegral.lean,torusIntegral_succAbove,torusIntegral_succAbove,9e34a191034458a56331f976ff7400a26407c888,":= by
  set e : â„ Ã— â„â¿ â‰ƒáµ â„â¿âºÂ¹ := (MeasurableEquiv.piFinSuccAboveEquiv (fun _ => â„) i).symm
  have hem : MeasurePreserving e :=
    (volume_preserving_piFinSuccAboveEquiv (fun _ : Fin (n + 1) => â„) i).symm _
  have heÏ€ : (e â»Â¹' Icc 0 fun _ => 2 * Ï€) = Icc 0 (2 * Ï€) Ã—Ë¢ Icc (0 : â„â¿) fun _ => 2 * Ï€ :=
    ((OrderIso.piFinSuccAboveIso (fun _ => â„) i).symm.preimage_Icc _ _).trans (Icc_prod_eq _ _)
  rw [torusIntegral, â† hem.map_eq, set_integral_map_equiv, heÏ€, Measure.volume_eq_prod,
    set_integral_prod, circleIntegral_def_Icc]
  Â· refine' set_integral_congr measurableSet_Icc fun Î¸ _ => _
    simp only [torusIntegral, â† integral_smul, deriv_circleMap, i.prod_univ_succAbove _, smul_smul,
      torusMap, circleMap_zero]
    refine' set_integral_congr measurableSet_Icc fun Î˜ _ => _
    simp only [MeasurableEquiv.piFinSuccAboveEquiv_symm_apply, i.insertNth_apply_same,
      i.insertNth_apply_succAbove, (Â· âˆ˜ Â·)]
    congr 2
    simp only [funext_iff, i.forall_iff_succAbove, circleMap, Fin.insertNth_apply_same,
      eq_self_iff_true, Fin.insertNth_apply_succAbove, imp_true_iff, and_self_iff]
  Â· have := hf.function_integrable
    rwa [â† hem.integrableOn_comp_preimage e.measurableEmbedding, heÏ€] at this ","warning:  @torusIntegral does not have a doc string
error:  unknown constant 'MeasurableEquiv.piFinSuccAboveEquiv'
error:  unknown identifier 'volume_preserving_piFinSuccAboveEquiv'
error:  type mismatch
  Eq.trans (OrderIso.preimage_Icc (OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm ?m.124422 ?m.124423)
    (Icc_prod_eq ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124422)
      ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124423))
has type
  â‡‘(OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm â»Â¹' Icc ?m.124422 ?m.124423 =
    Icc ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124422).1
        ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124423).1 Ã—Ë¢
      Icc ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124422).2
        ((OrderIso.piFinSuccAboveIso (fun x â†¦ â„) i).symm.symm ?m.124423).2 : Prop
but is expected to have type
  (â‡‘e â»Â¹' Icc 0 fun x â†¦ 2 * Ï€) = Icc 0 (2 * Ï€) Ã—Ë¢ Icc 0 fun x â†¦ 2 * Ï€ : Prop
warning:  `MeasureTheory.set_integral_map_equiv` has been deprecated, use `MeasureTheory.setIntegral_map_equiv` instead
warning:  `MeasureTheory.set_integral_prod` has been deprecated, use `MeasureTheory.setIntegral_prod` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
warning:  `MeasureTheory.set_integral_congr` has been deprecated, use `MeasureTheory.setIntegral_congr` instead
error:  unknown constant 'MeasurableEquiv.piFinSuccAboveEquiv_symm_apply'
error:  simp made no progress","theorem torusIntegral_succAbove {f : â„‚â¿âºÂ¹ â†’ E} {c : â„‚â¿âºÂ¹} {R : â„â¿âºÂ¹} (hf : TorusIntegrable f c R)
    (i : Fin (n + 1)) :
    (âˆ¯ x in T(c, R), f x) =
      âˆ® x in C(c i, R i), âˆ¯ y in T(c âˆ˜ i.succAbove, R âˆ˜ i.succAbove), f (i.insertNth x y) ",":= by
  set e : â„ Ã— â„â¿ â‰ƒáµ â„â¿âºÂ¹ := (MeasurableEquiv.piFinSuccAbove (fun _ => â„) i).symm
  have hem : MeasurePreserving e :=
    (volume_preserving_piFinSuccAbove (fun _ : Fin (n + 1) => â„) i).symm _
  have heÏ€ : (e â»Â¹' Icc 0 fun _ => 2 * Ï€) = Icc 0 (2 * Ï€) Ã—Ë¢ Icc (0 : â„â¿) fun _ => 2 * Ï€ :=
    ((OrderIso.piFinSuccAboveIso (fun _ => â„) i).symm.preimage_Icc _ _).trans (Icc_prod_eq _ _)
  rw [torusIntegral, â† hem.map_eq, setIntegral_map_equiv, heÏ€, Measure.volume_eq_prod,
    setIntegral_prod, circleIntegral_def_Icc]
  Â· refine setIntegral_congr measurableSet_Icc fun Î¸ _ => ?_
    simp (config := { unfoldPartialApp := true }) only [e, torusIntegral, â† integral_smul,
      deriv_circleMap, i.prod_univ_succAbove _, smul_smul, torusMap, circleMap_zero]
    refine setIntegral_congr measurableSet_Icc fun Î˜ _ => ?_
    simp only [MeasurableEquiv.piFinSuccAbove_symm_apply, i.insertNth_apply_same,
      i.insertNth_apply_succAbove, (Â· âˆ˜ Â·)]
    congr 2
    simp only [funext_iff, i.forall_iff_succAbove, circleMap, Fin.insertNth_apply_same,
      eq_self_iff_true, Fin.insertNth_apply_succAbove, imp_true_iff, and_self_iff]
  Â· have := hf.function_integrable
    rwa [â† hem.integrableOn_comp_preimage e.measurableEmbedding, heÏ€] at this"
Mathlib/Algebra/Module/PID.lean,Submodule.isSemisimple_torsionBy_of_irreducible,Submodule.isSemisimple_torsionBy_of_irreducible,e54b06464b16cc1b649903b81d6957f117d1255b,":= by
  rw [IsSemisimpleModule, â† (submodule_torsionBy_orderIso a).complementedLattice_iff]
  set I : Ideal R := R âˆ™ a
  have _i2 : I.IsMaximal := PrincipalIdealRing.isMaximal_of_irreducible h
  let _i3 : Field (R â§¸ I) := Ideal.Quotient.field I
  exact Module.Submodule.complementedLattice",error:  unknown constant 'Module.Submodule.complementedLattice',"theorem Submodule.isSemisimple_torsionBy_of_irreducible {a : R} (h : Irreducible a) :
    IsSemisimpleModule R (torsionBy R M a) ",":=
  haveI := PrincipalIdealRing.isMaximal_of_irreducible h
  letI := Ideal.Quotient.field (R âˆ™ a)
  (submodule_torsionBy_orderIso a).complementedLattice"
Mathlib/Data/Num/Lemmas.lean,Num.ofNat'_bit,ofNat'_bit,c047c646d66e915f27c3e7f159bef508bfc8dd10,":=
  Nat.binaryRec_eq _ _ (.inl rfl)","warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
error:  invalid dotted identifier notation, unknown identifier `Nat.inl` from expected type
  â„•
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `castNum` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `Nat.cast_bit0` has been deprecated
warning:  `Nat.cast_bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated",theorem ofNat'_bit (b n) : ofNat' (Nat.bit b n) = cond b Num.bit1 Num.bit0 (ofNat' n) ,":=
  Nat.binaryRec_eq rfl _ _"
Mathlib/Combinatorics/SimpleGraph/StronglyRegular.lean,SimpleGraph.IsSRGWith.param_eq,IsSRGWith.param_eq,6a6473d9c0d8e59a580a4736af35de45e576d388,":= by
  letI := Classical.decEq V
  rw [â† h.card, Fintype.card_pos_iff] at hn
  obtain âŸ¨vâŸ© := hn
  convert card_mul_eq_card_mul G.Adj (s := G.neighborFinset v) (t := Gá¶œ.neighborFinset v) _ _
  Â· simp [h.regular v]
  Â· simp [h.compl.regular v]
  Â· intro w hw
    rw [mem_neighborFinset] at hw
    simp_rw [bipartiteAbove]
    change Finset.card (filter (fun a => Adj G w a) _) = _
    simp_rw [â† mem_neighborFinset, filter_mem_eq_inter]
    have s : {v} âŠ† G.neighborFinset w \ G.neighborFinset v := by
      rw [singleton_subset_iff, mem_sdiff, mem_neighborFinset]
      exact âŸ¨hw.symm, G.not_mem_neighborFinset_self vâŸ©
    rw [inter_comm, neighborFinset_compl, â† inter_sdiff_assoc, â† sdiff_eq_inter_compl, card_sdiff s,
      card_singleton, â† sdiff_inter_self_left, card_sdiff (by apply inter_subset_left)]
    congr
    Â· simp [h.regular w]
    Â· simp_rw [inter_comm, neighborFinset_def, â† Set.toFinset_inter, â† h.of_adj v w hw,
        â† Set.toFinset_card]
      congr!
  Â· intro w hw
    simp_rw [neighborFinset_compl, mem_sdiff, mem_compl, mem_singleton, mem_neighborFinset,
      â† Ne.def] at hw
    simp_rw [bipartiteBelow, adj_comm, â† mem_neighborFinset, filter_mem_eq_inter,
      neighborFinset_def, â† Set.toFinset_inter, â† h.of_not_adj hw.2.symm hw.1,
      â† Set.toFinset_card]
    congr!","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.59872 â†’ ?m.59872 â†’ Prop
error:  simp made no progress","theorem IsSRGWith.param_eq (h : G.IsSRGWith n k â„“ Î¼) (hn : 0 < n) :
    k * (k - â„“ - 1) = (n - k - 1) * Î¼ ",":= by
  letI := Classical.decEq V
  rw [â† h.card, Fintype.card_pos_iff] at hn
  obtain âŸ¨vâŸ© := hn
  convert card_mul_eq_card_mul G.Adj (s := G.neighborFinset v) (t := Gá¶œ.neighborFinset v) _ _
  Â· simp [h.regular v]
  Â· simp [h.compl.regular v]
  Â· intro w hw
    rw [mem_neighborFinset] at hw
    simp_rw [bipartiteAbove]
    change Finset.card (filter (fun a => Adj G w a) _) = _
    simp_rw [â† mem_neighborFinset, filter_mem_eq_inter]
    have s : {v} âŠ† G.neighborFinset w \ G.neighborFinset v := by
      rw [singleton_subset_iff, mem_sdiff, mem_neighborFinset]
      exact âŸ¨hw.symm, G.not_mem_neighborFinset_self vâŸ©
    rw [inter_comm, neighborFinset_compl, â† inter_sdiff_assoc, â† sdiff_eq_inter_compl, card_sdiff s,
      card_singleton, â† sdiff_inter_self_left, card_sdiff (by apply inter_subset_left)]
    congr
    Â· simp [h.regular w]
    Â· simp_rw [inter_comm, neighborFinset_def, â† Set.toFinset_inter, â† h.of_adj v w hw,
        â† Set.toFinset_card]
      congr!
  Â· intro w hw
    simp_rw [neighborFinset_compl, mem_sdiff, mem_compl, mem_singleton, mem_neighborFinset,
      â† Ne.eq_def] at hw
    simp_rw [bipartiteBelow, adj_comm, â† mem_neighborFinset, filter_mem_eq_inter,
      neighborFinset_def, â† Set.toFinset_inter, â† h.of_not_adj hw.2.symm hw.1,
      â† Set.toFinset_card]
    congr!"
Mathlib/Topology/Separation.lean,continuousOn_update_iff,continuousOn_update_iff,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rw [ContinuousOn, â† and_forall_ne x, and_comm]
  refine' and_congr âŸ¨fun H z hz => _, fun H z hzx hzs => _âŸ© (forall_congr' fun _ => _)
  Â· specialize H z hz.2 hz.1
    rw [continuousWithinAt_update_of_ne hz.2] at H
    exact H.mono (diff_subset _ _)
  Â· rw [continuousWithinAt_update_of_ne hzx]
    refine' (H z âŸ¨hzs, hzxâŸ©).mono_of_mem (inter_mem_nhdsWithin _ _)
    exact isOpen_ne.mem_nhds hzx
  Â· exact continuousWithinAt_update_same","error:  function expected at
  diff_subset ?m.63303
term has type
  ?m.63302 âˆˆ ?m.63300","theorem continuousOn_update_iff [T1Space X] [DecidableEq X] [TopologicalSpace Y] {f : X â†’ Y}
    {s : Set X} {x : X} {y : Y} :
    ContinuousOn (Function.update f x y) s â†”
      ContinuousOn f (s \ {x}) âˆ§ (x âˆˆ s â†’ Tendsto f (ğ“[s \ {x}] x) (ğ“ y)) ",":= by
  rw [ContinuousOn, â† and_forall_ne x, and_comm]
  refine and_congr âŸ¨fun H z hz => ?_, fun H z hzx hzs => ?_âŸ© (forall_congr' fun _ => ?_)
  Â· specialize H z hz.2 hz.1
    rw [continuousWithinAt_update_of_ne hz.2] at H
    exact H.mono diff_subset
  Â· rw [continuousWithinAt_update_of_ne hzx]
    refine (H z âŸ¨hzs, hzxâŸ©).mono_of_mem (inter_mem_nhdsWithin _ ?_)
    exact isOpen_ne.mem_nhds hzx
  Â· exact continuousWithinAt_update_same"
Mathlib/Data/Ordmap/Ordset.lean,Ordnode.Valid'.glue_aux,Valid'.glue_aux,ded82be28af61da8cf3266077ac67ad9bf41c841,":= by
  cases' l with ls ll lx lr; Â· exact âŸ¨hr, (zero_add _).symmâŸ©
  cases' r with rs rl rx rr; Â· exact âŸ¨hl, rflâŸ©
  dsimp [glue]; split_ifs
  Â· rw [splitMax_eq]
    Â· cases' Valid'.eraseMax_aux hl with v e
      suffices H : _ by
        refine âŸ¨Valid'.balanceR v (hr.of_gt ?_ ?_) H?, _âŸ©
        Â· refine findMax'_all (P := fun a : Î± => Bounded nil (a : WithTop Î±) oâ‚‚)
            lx lr hl.1.2.to_nil (sep.2.2.imp ?_)
          exact fun x h => hr.1.2.to_nil.mono_left (le_of_lt h.2.1)
        Â· exact @findMax'_all _ (fun a => All (Â· > a) (.node rs rl rx rr)) lx lr sep.2.1 sep.2.2
        Â· rw [size_balanceR v.3 hr.3 v.2 hr.2 H, add_right_comm, â† e, hl.2.1]; rfl
      refine Or.inl âŸ¨_, Or.inr e, ?_âŸ©
      rwa [hl.2.eq_node'] at bal
  Â· rw [splitMin_eq]
    Â· cases' Valid'.eraseMin_aux hr with v e
      suffices H : _ by
        refine âŸ¨Valid'.balanceL (hl.of_lt ?_ ?_) v H, ?_âŸ©
        Â· refine @findMin'_all (P := fun a : Î± => Bounded nil oâ‚ (a : WithBot Î±))
            rl rx (sep.2.1.1.imp ?_) hr.1.1.to_nil
          exact fun y h => hl.1.1.to_nil.mono_right (le_of_lt h)
        Â· exact
            @findMin'_all _ (fun a => All (Â· < a) (.node ls ll lx lr)) rl rx
              (all_iff_forall.2 fun x hx => sep.imp fun y hy => all_iff_forall.1 hy.1 _ hx)
              (sep.imp fun y hy => hy.2.1)
        Â· rw [size_balanceL hl.3 v.3 hl.2 v.2 H, add_assoc, â† e, hr.2.1]; rfl
      refine Or.inr âŸ¨_, Or.inr e, ?_âŸ©
      rwa [hr.2.eq_node'] at bal","error:  unknown identifier 'H?'
error:  unsolved goals
Î± : Type u_1
instâœ : Preorder Î±
oâ‚ : WithBot Î±
oâ‚‚ : WithTop Î±
ls : â„•
ll : Ordnode Î±
lx : Î±
lr : Ordnode Î±
hl : Valid' oâ‚ (Ordnode.node ls ll lx lr) oâ‚‚
rs : â„•
rl : Ordnode Î±
rx : Î±
rr : Ordnode Î±
hr : Valid' oâ‚ (Ordnode.node rs rl rx rr) oâ‚‚
sep : All (fun x â†¦ All (fun y â†¦ x < y) (Ordnode.node rs rl rx rr)) (Ordnode.node ls ll lx lr)
bal : BalancedSz (Ordnode.node ls ll lx lr).size (Ordnode.node rs rl rx rr).size
hâœ : ls > rs
v : Valid' oâ‚ (ll.node' lx lr).eraseMax â†‘(findMax' lx lr)
e : (ll.node' lx lr).size = (ll.node' lx lr).eraseMax.size + 1
H : ?m.298927
âŠ¢ Valid' oâ‚
      (((Ordnode.node (ll.size + lr.size + 1) ll lx lr).eraseMax, findMax' lx lr).1.balanceR
        ((Ordnode.node (ll.size + lr.size + 1) ll lx lr).eraseMax, findMax' lx lr).2 (Ordnode.node rs rl rx rr))
      oâ‚‚ âˆ§
    (((Ordnode.node (ll.size + lr.size + 1) ll lx lr).eraseMax, findMax' lx lr).1.balanceR
          ((Ordnode.node (ll.size + lr.size + 1) ll lx lr).eraseMax, findMax' lx lr).2
          (Ordnode.node rs rl rx rr)).size =
      ls + rs","theorem Valid'.glue_aux {l r oâ‚ oâ‚‚} (hl : Valid' oâ‚ l oâ‚‚) (hr : Valid' oâ‚ r oâ‚‚)
    (sep : l.All fun x => r.All fun y => x < y) (bal : BalancedSz (size l) (size r)) :
    Valid' oâ‚ (@glue Î± l r) oâ‚‚ âˆ§ size (glue l r) = size l + size r ",":= by
  cases' l with ls ll lx lr; Â· exact âŸ¨hr, (zero_add _).symmâŸ©
  cases' r with rs rl rx rr; Â· exact âŸ¨hl, rflâŸ©
  dsimp [glue]; split_ifs
  Â· rw [splitMax_eq]
    Â· cases' Valid'.eraseMax_aux hl with v e
      suffices H : _ by
        refine âŸ¨Valid'.balanceR v (hr.of_gt ?_ ?_) H, ?_âŸ©
        Â· refine findMax'_all (P := fun a : Î± => Bounded nil (a : WithTop Î±) oâ‚‚)
            lx lr hl.1.2.to_nil (sep.2.2.imp ?_)
          exact fun x h => hr.1.2.to_nil.mono_left (le_of_lt h.2.1)
        Â· exact @findMax'_all _ (fun a => All (Â· > a) (.node rs rl rx rr)) lx lr sep.2.1 sep.2.2
        Â· rw [size_balanceR v.3 hr.3 v.2 hr.2 H, add_right_comm, â† e, hl.2.1]; rfl
      refine Or.inl âŸ¨_, Or.inr e, ?_âŸ©
      rwa [hl.2.eq_node'] at bal
  Â· rw [splitMin_eq]
    Â· cases' Valid'.eraseMin_aux hr with v e
      suffices H : _ by
        refine âŸ¨Valid'.balanceL (hl.of_lt ?_ ?_) v H, ?_âŸ©
        Â· refine @findMin'_all (P := fun a : Î± => Bounded nil oâ‚ (a : WithBot Î±))
            rl rx (sep.2.1.1.imp ?_) hr.1.1.to_nil
          exact fun y h => hl.1.1.to_nil.mono_right (le_of_lt h)
        Â· exact
            @findMin'_all _ (fun a => All (Â· < a) (.node ls ll lx lr)) rl rx
              (all_iff_forall.2 fun x hx => sep.imp fun y hy => all_iff_forall.1 hy.1 _ hx)
              (sep.imp fun y hy => hy.2.1)
        Â· rw [size_balanceL hl.3 v.3 hl.2 v.2 H, add_assoc, â† e, hr.2.1]; rfl
      refine Or.inr âŸ¨_, Or.inr e, ?_âŸ©
      rwa [hr.2.eq_node'] at bal"
Mathlib/Data/Finsupp/Defs.lean,Finsupp.erase_add_single,erase_add_single,67e80fd089fe45abea632652c43b78eba72d60e3,":=
  DFinsupp.erase_add_single a f","warning:  Finsupp does not have a doc string
error:  unknown identifier 'DFinsupp.erase_add_single'",theorem erase_add_single (a : Î±) (f : Î± â†’â‚€ M) : f.erase a + single a (f a) = f ,":= by
  rw [â† update_eq_erase_add_single, update_self]"
Mathlib/Topology/Constructions.lean,Pi.induced_restrict,Pi.induced_restrict,5e9b46eda53a04cdc934ee46d5f72267d3a5bd0d,":= by
  simp [â† iInf_subtype'', â† induced_precomp' ((â†‘) : S â†’ Î¹), Set.restrict]","error:  unsolved goals
X : Type u
Y : Type v
Z : Type u_1
W : Type u_2
Îµ : Type u_3
Î¶ : Type u_4
Î¹ : Type u_5
Ï€ : Î¹ â†’ Type u_6
Îº : Type u_7
instâœ : TopologicalSpace X
T : (i : Î¹) â†’ TopologicalSpace (Ï€ i)
f : X â†’ (i : Î¹) â†’ Ï€ i
S : Set Î¹
âŠ¢ induced S.restrict topologicalSpace = induced (fun f j â†¦ f â†‘j) topologicalSpace","lemma Pi.induced_restrict (S : Set Î¹) :
    induced (S.restrict) Pi.topologicalSpace =
    â¨… i âˆˆ S, induced (eval i) (T i) ",":= by
  simp (config := { unfoldPartialApp := true }) [â† iInf_subtype'', â† induced_precomp' ((â†‘) : S â†’ Î¹),
    restrict]"
Mathlib/MeasureTheory/Measure/Regular.lean,MeasureTheory.Measure.InnerRegularWRT.of_restrict,of_restrict,fbfb504749d41358cab0fa037180ccfee9e3ccd4,":= by
  refine' âŸ¨fun A hA r hr => _âŸ©
  have HA : Î¼ A < âˆ := lt_of_lt_of_le hr le_top
  have hm : âˆ€ n, MeasurableSet (s n) := fun n => (h' n).measurableSet
  obtain âŸ¨A, hAm, hAs, hAd, rflâŸ© :
    âˆƒ A' : â„• â†’ Set Î±,
      (âˆ€ n, MeasurableSet (A' n)) âˆ§
        (âˆ€ n, A' n âŠ† s n) âˆ§ Pairwise (Disjoint on A') âˆ§ A = â‹ƒ n, A' n := by
    refine'
      âŸ¨fun n => A âˆ© disjointed s n, fun n => hA.inter (MeasurableSet.disjointed hm _), fun n =>
        (inter_subset_right _ _).trans (disjointed_subset _ _),
        (disjoint_disjointed s).mono fun k l hkl => hkl.mono inf_le_right inf_le_right, _âŸ©
    rw [â† inter_iUnion, iUnion_disjointed, univ_subset_iff.mp h'', inter_univ]
  rcases ENNReal.exists_pos_sum_of_countable' (tsub_pos_iff_lt.2 hr).ne' â„• with âŸ¨Î´, Î´0, hÎ´ÎµâŸ©
  rw [lt_tsub_iff_right, add_comm] at hÎ´Îµ
  have : âˆ€ n, âˆƒ U âŠ‡ A n, IsOpen U âˆ§ Î¼ U < Î¼ (A n) + Î´ n := by
    intro n
    have Hâ‚ : âˆ€ t, Î¼.restrict (s n) t = Î¼ (t âˆ© s n) := fun t => restrict_apply' (hm n)
    have Ht : Î¼.restrict (s n) (A n) â‰  âˆ := by
      rw [Hâ‚]
      exact ((measure_mono ((inter_subset_left _ _).trans (subset_iUnion A n))).trans_lt HA).ne
    rcases (A n).exists_isOpen_lt_add Ht (Î´0 n).ne' with âŸ¨U, hAU, hUo, hUâŸ©
    rw [Hâ‚, Hâ‚, inter_eq_self_of_subset_left (hAs _)] at hU
    exact âŸ¨U âˆ© s n, subset_inter hAU (hAs _), hUo.inter (h' n), hUâŸ©
  choose U hAU hUo hU using this
  refine' âŸ¨â‹ƒ n, U n, iUnion_mono hAU, isOpen_iUnion hUo, _âŸ©
  calc
    Î¼ (â‹ƒ n, U n) â‰¤ âˆ‘' n, Î¼ (U n) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Î¼ (A n) + Î´ n) := (ENNReal.tsum_le_tsum fun n => (hU n).le)
    _ = âˆ‘' n, Î¼ (A n) + âˆ‘' n, Î´ n := ENNReal.tsum_add
    _ = Î¼ (â‹ƒ n, A n) + âˆ‘' n, Î´ n := (congr_argâ‚‚ (Â· + Â·) (measure_iUnion hAd hAm).symm rfl)
    _ < r := hÎ´Îµ","error:  function expected at
  inter_subset_right ?m.25404
term has type
  ?m.25403 âˆˆ ?m.25402
error:  function expected at
  inter_subset_left ?m.28241
term has type
  ?m.28240 âˆˆ ?m.28238","lemma of_restrict [OpensMeasurableSpace Î±] {Î¼ : Measure Î±} {s : â„• â†’ Set Î±}
    (h : âˆ€ n, OuterRegular (Î¼.restrict (s n))) (h' : âˆ€ n, IsOpen (s n)) (h'' : univ âŠ† â‹ƒ n, s n) :
    OuterRegular Î¼ ",":= by
  refine âŸ¨fun A hA r hr => ?_âŸ©
  have HA : Î¼ A < âˆ := lt_of_lt_of_le hr le_top
  have hm : âˆ€ n, MeasurableSet (s n) := fun n => (h' n).measurableSet
  obtain âŸ¨A, hAm, hAs, hAd, rflâŸ© :
    âˆƒ A' : â„• â†’ Set Î±,
      (âˆ€ n, MeasurableSet (A' n)) âˆ§
        (âˆ€ n, A' n âŠ† s n) âˆ§ Pairwise (Disjoint on A') âˆ§ A = â‹ƒ n, A' n := by
    refine
      âŸ¨fun n => A âˆ© disjointed s n, fun n => hA.inter (MeasurableSet.disjointed hm _), fun n =>
        inter_subset_right.trans (disjointed_subset _ _),
        (disjoint_disjointed s).mono fun k l hkl => hkl.mono inf_le_right inf_le_right, ?_âŸ©
    rw [â† inter_iUnion, iUnion_disjointed, univ_subset_iff.mp h'', inter_univ]
  rcases ENNReal.exists_pos_sum_of_countable' (tsub_pos_iff_lt.2 hr).ne' â„• with âŸ¨Î´, Î´0, hÎ´ÎµâŸ©
  rw [lt_tsub_iff_right, add_comm] at hÎ´Îµ
  have : âˆ€ n, âˆƒ U âŠ‡ A n, IsOpen U âˆ§ Î¼ U < Î¼ (A n) + Î´ n := by
    intro n
    have Hâ‚ : âˆ€ t, Î¼.restrict (s n) t = Î¼ (t âˆ© s n) := fun t => restrict_apply' (hm n)
    have Ht : Î¼.restrict (s n) (A n) â‰  âˆ := by
      rw [Hâ‚]
      exact ((measure_mono (inter_subset_left.trans (subset_iUnion A n))).trans_lt HA).ne
    rcases (A n).exists_isOpen_lt_add Ht (Î´0 n).ne' with âŸ¨U, hAU, hUo, hUâŸ©
    rw [Hâ‚, Hâ‚, inter_eq_self_of_subset_left (hAs _)] at hU
    exact âŸ¨U âˆ© s n, subset_inter hAU (hAs _), hUo.inter (h' n), hUâŸ©
  choose U hAU hUo hU using this
  refine âŸ¨â‹ƒ n, U n, iUnion_mono hAU, isOpen_iUnion hUo, ?_âŸ©
  calc
    Î¼ (â‹ƒ n, U n) â‰¤ âˆ‘' n, Î¼ (U n) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Î¼ (A n) + Î´ n) := ENNReal.tsum_le_tsum fun n => (hU n).le
    _ = âˆ‘' n, Î¼ (A n) + âˆ‘' n, Î´ n := ENNReal.tsum_add
    _ = Î¼ (â‹ƒ n, A n) + âˆ‘' n, Î´ n := (congr_argâ‚‚ (Â· + Â·) (measure_iUnion hAd hAm).symm rfl)
    _ < r := hÎ´Îµ"
Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean,Real.volume_preserving_transvectionStruct,volume_preserving_transvectionStruct,ab8315c477f102732971f93929937880468e5ccc,":= by
  have ht : Measurable (toLin' t.toMatrix) :=
    (toLin' t.toMatrix).continuous_of_finiteDimensional.measurable
  refine âŸ¨ht, ?_âŸ©
  refine (pi_eq fun s hs â†¦ ?_).symm
  have h2s : MeasurableSet (univ.pi s) := .pi countable_univ fun i _ â†¦ hs i
  simp_rw [â† pi_pi, â† lintegral_indicator_one h2s]
  rw [lintegral_map (measurable_one.indicator h2s) ht, volume_pi]
  refine lintegral_eq_of_marginal_eq {t.i} ((measurable_one.indicator h2s).comp ht)
    (measurable_one.indicator h2s) ?_
  simp_rw [marginal_singleton]
  ext x
  cases t with | mk t_i t_j t_hij t_c =>
  simp [transvection, mulVec_stdBasisMatrix]
  simp_rw [Function.update_noteq t_hij.symm, â† Function.update_add, add_zero]
  rw [lintegral_add_right_eq_self fun xáµ¢ â†¦ indicator (univ.pi s) 1 (Function.update x t_i xáµ¢)]","error:  unknown identifier 'lintegral_eq_of_marginal_eq'
error:  no goals to be solved","theorem volume_preserving_transvectionStruct [DecidableEq Î¹] (t : TransvectionStruct Î¹ â„) :
    MeasurePreserving (toLin' t.toMatrix) ",":= by
  have ht : Measurable (toLin' t.toMatrix) :=
    (toLin' t.toMatrix).continuous_of_finiteDimensional.measurable
  refine âŸ¨ht, ?_âŸ©
  refine (pi_eq fun s hs â†¦ ?_).symm
  have h2s : MeasurableSet (univ.pi s) := .pi countable_univ fun i _ â†¦ hs i
  simp_rw [â† pi_pi, â† lintegral_indicator_one h2s]
  rw [lintegral_map (measurable_one.indicator h2s) ht, volume_pi]
  refine lintegral_eq_of_lmarginal_eq {t.i} ((measurable_one.indicator h2s).comp ht)
    (measurable_one.indicator h2s) ?_
  simp_rw [lmarginal_singleton]
  ext x
  cases t with | mk t_i t_j t_hij t_c =>
  simp [transvection, mulVec_stdBasisMatrix, t_hij.symm, â† Function.update_add,
    lintegral_add_right_eq_self fun xáµ¢ â†¦ indicator (univ.pi s) 1 (Function.update x t_i xáµ¢)]"
Mathlib/CategoryTheory/Limits/Indization/IndObject.lean,CategoryTheory.Limits.isIndObject_of_isFiltered_of_finallySmall,isIndObject_of_isFiltered_of_finallySmall,b00a3805fab44f4e1c5c20f20210228921360a80,":= by
  have hâ‚ : (factoring (fromFinalModel (CostructuredArrow yoneda A)) â‹™
      inclusion (fromFinalModel (CostructuredArrow yoneda A))).Final := Functor.final_of_natIso
    (factoringCompInclusion (fromFinalModel <| CostructuredArrow yoneda A)).symm
  have hâ‚‚ : Functor.Final (inclusion (fromFinalModel (CostructuredArrow yoneda A))) :=
    Functor.final_of_comp_full_faithful' (factoring _) (inclusion _)
  let c := (Presheaf.tautologicalCocone A).whisker (inclusion (fromFinalModel (CostructuredArrow yoneda A)))
  let hc : IsColimit c := (Functor.Final.isColimitWhiskerEquiv _ _).symm
    (Presheaf.isColimitTautologicalCocone A)
  have hq : Nonempty (FinalModel (CostructuredArrow yoneda A)) := Nonempty.map
    (Functor.Final.lift (fromFinalModel (CostructuredArrow yoneda A))) IsFiltered.nonempty
  exact âŸ¨_, inclusion (fromFinalModel _) â‹™ CostructuredArrow.proj yoneda A, c.Î¹, hcâŸ©","error:  unknown identifier 'Presheaf.tautologicalCocone'
error:  unsolved goals
C : Type u
instâœÂ² : Category.{v, u} C
A : Cáµ’áµ– â¥¤ Type v
instâœÂ¹ : IsFiltered (CostructuredArrow yoneda A)
instâœ : FinallySmall (CostructuredArrow yoneda A)
hâ‚ :
  (factoring (fromFinalModel (CostructuredArrow yoneda A)) â‹™
      inclusion (fromFinalModel (CostructuredArrow yoneda A))).Final
hâ‚‚ : (inclusion (fromFinalModel (CostructuredArrow yoneda A))).Final
âŠ¢ IsIndObject A","theorem isIndObject_of_isFiltered_of_finallySmall (A : Cáµ’áµ– â¥¤ Type v)
    [IsFiltered (CostructuredArrow yoneda A)] [FinallySmall.{v} (CostructuredArrow yoneda A)] :
    IsIndObject A ",":= by
  have hâ‚ : (factoring (fromFinalModel (CostructuredArrow yoneda A)) â‹™
      inclusion (fromFinalModel (CostructuredArrow yoneda A))).Final := Functor.final_of_natIso
    (factoringCompInclusion (fromFinalModel <| CostructuredArrow yoneda A)).symm
  have hâ‚‚ : Functor.Final (inclusion (fromFinalModel (CostructuredArrow yoneda A))) :=
    Functor.final_of_comp_full_faithful' (factoring _) (inclusion _)
  let c := (tautologicalCocone A).whisker (inclusion (fromFinalModel (CostructuredArrow yoneda A)))
  let hc : IsColimit c := (Functor.Final.isColimitWhiskerEquiv _ _).symm
    (isColimitTautologicalCocone A)
  have hq : Nonempty (FinalModel (CostructuredArrow yoneda A)) := Nonempty.map
    (Functor.Final.lift (fromFinalModel (CostructuredArrow yoneda A))) IsFiltered.nonempty
  exact âŸ¨_, inclusion (fromFinalModel _) â‹™ CostructuredArrow.proj yoneda A, c.Î¹, hcâŸ©"
Mathlib/NumberTheory/Padics/PadicNorm.lean,padicNorm.dvd_iff_norm_le,dvd_iff_norm_le,5facde50581cefe36eb491a50b05917b86b8b861,":= by
  unfold padicNorm; split_ifs with hz
  Â· norm_cast at hz
    simp [hz]
  Â· rw [zpow_le_iff_le, neg_le_neg_iff, padicValRat.of_int,
      padicValInt.of_ne_one_ne_zero hp.1.ne_one _]
    Â· norm_cast
      rw [â† PartENat.coe_le_coe, PartENat.natCast_get, â† multiplicity.pow_dvd_iff_le_multiplicity,
        Nat.cast_pow]
    Â· exact mod_cast hz
    Â· exact mod_cast hp.1.one_lt","error:  unsolved goals
p : â„•
hp : Fact (Nat.Prime p)
n : â„•
z : â„¤
hz : Â¬â†‘z = 0
âŠ¢ z â‰  0
error:  mod_cast has type
  Â¬z = 0 : Prop
but is expected to have type
  1 < p : Prop
error:  no goals to be solved",theorem dvd_iff_norm_le {n : â„•} {z : â„¤} : â†‘(p ^ n) âˆ£ z â†” padicNorm p z â‰¤ (p : â„š) ^ (-n : â„¤) ,":= by
  unfold padicNorm; split_ifs with hz
  Â· norm_cast at hz
    simp [hz]
  Â· rw [zpow_le_iff_le, neg_le_neg_iff, padicValRat.of_int,
      padicValInt.of_ne_one_ne_zero hp.1.ne_one _]
    Â· norm_cast
      rw [â† PartENat.coe_le_coe, PartENat.natCast_get, â† multiplicity.pow_dvd_iff_le_multiplicity,
        Nat.cast_pow]
      exact mod_cast hz
    Â· exact mod_cast hp.1.one_lt"
Mathlib/LinearAlgebra/LinearPMap.lean,LinearPMap.smul_graph,smul_graph,c438a06cb616a5e483fefc71bcf86a535642c566,":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  Â· rw [mem_graph_iff] at h
    rcases h with âŸ¨y, hy, hâŸ©
    rw [LinearPMap.smul_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id.def,
      LinearMap.smul_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y, hy
  rw [Submodule.mem_map] at h
  rcases h with âŸ¨x', hx', hâŸ©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id.def, LinearMap.smul_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' âŠ¢
  rcases hx' with âŸ¨y, hy, hx'âŸ©
  use y
  rw [â† h.1, â† h.2]
  simp [hy, hx']","warning:  LinearPMap does not have a doc string
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.532750 â†’ ?m.532750
error:  unsolved goals
case right
R : Type u_1
instâœâ¹ : Ring R
E : Type u_2
instâœâ¸ : AddCommGroup E
instâœâ· : Module R E
F : Type u_3
instâœâ¶ : AddCommGroup F
instâœâµ : Module R F
G : Type u_4
instâœâ´ : AddCommGroup G
instâœÂ³ : Module R G
M : Type u_5
instâœÂ² : Monoid M
instâœÂ¹ : DistribMulAction M F
instâœ : SMulCommClass R M F
yâœ : M
f : E â†’â‚—.[R] F
z : M
x_fst : E
x_snd : F
y : â†¥(z â€¢ f).domain
hy : â†‘y = (x_fst, x_snd).1
h : z â€¢ â†‘f y = (x_fst, x_snd).2
âŠ¢ id x_fst = x_fst âˆ§ z â€¢ id (â†‘f y) = x_snd
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.536551 â†’ ?m.536551","theorem smul_graph (f : E â†’â‚—.[R] F) (z : M) :
    (z â€¢ f).graph =
      f.graph.map ((LinearMap.id : E â†’â‚—[R] E).prodMap (z â€¢ (LinearMap.id : F â†’â‚—[R] F))) ",":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  Â· rw [mem_graph_iff] at h
    rcases h with âŸ¨y, hy, hâŸ©
    rw [LinearPMap.smul_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id,
      LinearMap.smul_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y, hy
  rw [Submodule.mem_map] at h
  rcases h with âŸ¨x', hx', hâŸ©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id, LinearMap.smul_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' âŠ¢
  rcases hx' with âŸ¨y, hy, hx'âŸ©
  use y
  rw [â† h.1, â† h.2]
  simp [hy, hx']"
Mathlib/MeasureTheory/Function/ConditionalExpectation/AEMeasurable.lean,MeasureTheory.AEStronglyMeasurable'.aeStronglyMeasurable'_of_measurableSpace_le_on,AEStronglyMeasurable'.aeStronglyMeasurable'_of_measurableSpace_le_on,2c3e6f259dc3044ad5e8065595330e4a8dffb768,":= by
  have h_ind_eq : s.indicator (hf.mk f) =áµ[Î¼] f := by
    refine'
      Filter.EventuallyEq.trans _ (indicator_ae_eq_of_restrict_compl_ae_eq_zero (hm _ hs_m) hf_zero)
    filter_upwards [hf.ae_eq_mk] with x hx
    by_cases hxs : x âˆˆ s
    Â· simp [hxs, hx]
    Â· simp [hxs]
  suffices : StronglyMeasurable[mâ‚‚] (s.indicator (hf.mk f))
  exact AEStronglyMeasurable'.congr this.aeStronglyMeasurable' h_ind_eq
  have hf_ind : StronglyMeasurable[m] (s.indicator (hf.mk f)) :=
    hf.stronglyMeasurable_mk.indicator hs_m
  exact
    hf_ind.stronglyMeasurable_of_measurableSpace_le_on hs_m hs fun x hxs =>
      Set.indicator_of_not_mem hxs _",error:  unexpected token ':'; expected term,"theorem AEStronglyMeasurable'.aeStronglyMeasurable'_of_measurableSpace_le_on {Î± E}
    {m mâ‚‚ m0 : MeasurableSpace Î±} {Î¼ : Measure Î±} [TopologicalSpace E] [Zero E] (hm : m â‰¤ m0)
    {s : Set Î±} {f : Î± â†’ E} (hs_m : MeasurableSet[m] s)
    (hs : âˆ€ t, MeasurableSet[m] (s âˆ© t) â†’ MeasurableSet[mâ‚‚] (s âˆ© t))
    (hf : AEStronglyMeasurable' m f Î¼) (hf_zero : f =áµ[Î¼.restrict sá¶œ] 0) :
    AEStronglyMeasurable' mâ‚‚ f Î¼ ",":= by
  have h_ind_eq : s.indicator (hf.mk f) =áµ[Î¼] f := by
    refine Filter.EventuallyEq.trans ?_ <|
      indicator_ae_eq_of_restrict_compl_ae_eq_zero (hm _ hs_m) hf_zero
    filter_upwards [hf.ae_eq_mk] with x hx
    by_cases hxs : x âˆˆ s
    Â· simp [hxs, hx]
    Â· simp [hxs]
  suffices StronglyMeasurable[mâ‚‚] (s.indicator (hf.mk f)) from
    AEStronglyMeasurable'.congr this.aeStronglyMeasurable' h_ind_eq
  have hf_ind : StronglyMeasurable[m] (s.indicator (hf.mk f)) :=
    hf.stronglyMeasurable_mk.indicator hs_m
  exact
    hf_ind.stronglyMeasurable_of_measurableSpace_le_on hs_m hs fun x hxs =>
      Set.indicator_of_not_mem hxs _"
Mathlib/RingTheory/Ideal/MinimalPrime.lean,Ideal.exists_comap_eq_of_mem_minimalPrimes_of_injective,Ideal.exists_comap_eq_of_mem_minimalPrimes_of_injective,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  have := H.1.1
  have : Nontrivial (Localization (Submonoid.map f p.primeCompl)) := by
    refine âŸ¨âŸ¨1, 0, ?_âŸ©âŸ©
    convert (IsLocalization.map_injective_of_injective p.primeCompl (Localization.AtPrime p)
        (Localization <| p.primeCompl.map f) hf).ne one_ne_zero
    Â· rw [map_one]
    Â· rw [map_zero]
  obtain âŸ¨M, hMâŸ© := Ideal.exists_maximal (Localization (Submonoid.map f p.primeCompl))
  refine âŸ¨M.comap (algebraMap S <| Localization (Submonoid.map f p.primeCompl)), inferInstance, ?_âŸ©
  rw [Ideal.comap_comap, â† @IsLocalization.map_comp _ _ _ _ _ _ _ _ _  Localization.isLocalization
      _ _ _ _ p.primeCompl.le_comap_map _ _ Localization.isLocalization,
    â† Ideal.comap_comap]
  suffices _ â‰¤ p by exact this.antisymm (H.2 âŸ¨inferInstance, bot_leâŸ© this)
  intro x hx
  by_contra h
  apply hM.ne_top
  apply M.eq_top_of_isUnit_mem hx
  apply IsUnit.map
  apply IsLocalization.map_units _ (show p.primeCompl from âŸ¨x, hâŸ©)","error:  application type mismatch
  @IsLocalization.map_comp ?m.21190 ?m.21191 ?m.21192 ?m.21193 ?m.21194 ?m.21195 ?m.21196 ?m.21197 ?m.21198
    Localization.isLocalization
argument
  Localization.isLocalization
has type
  IsLocalization ?m.21202 (Localization ?m.21202) : Prop
but is expected to have type
  ?m.21190 â†’+* ?m.21196 : Type (max ?u.21189 ?u.21187)
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.23400
case intro
R : Type u_1
S : Type u_2
instâœÂ¹ : CommSemiring R
instâœ : CommSemiring S
I J : Ideal R
f : R â†’+* S
hf : Function.Injective â‡‘f
p : Ideal R
H : p âˆˆ minimalPrimes R
thisâœ : p.IsPrime
this : Nontrivial (Localization (Submonoid.map f p.primeCompl))
M : Ideal (Localization (Submonoid.map f p.primeCompl))
hM : M.IsMaximal
âŠ¢ comap ((algebraMap S (Localization (Submonoid.map f p.primeCompl))).comp f) M = p","theorem Ideal.exists_comap_eq_of_mem_minimalPrimes_of_injective {f : R â†’+* S}
    (hf : Function.Injective f) (p) (H : p âˆˆ minimalPrimes R) :
    âˆƒ p' : Ideal S, p'.IsPrime âˆ§ p'.comap f = p ",":= by
  have := H.1.1
  have : Nontrivial (Localization (Submonoid.map f p.primeCompl)) := by
    refine âŸ¨âŸ¨1, 0, ?_âŸ©âŸ©
    convert (IsLocalization.map_injective_of_injective p.primeCompl (Localization.AtPrime p)
        (Localization <| p.primeCompl.map f) hf).ne one_ne_zero
    Â· rw [map_one]
    Â· rw [map_zero]
  obtain âŸ¨M, hMâŸ© := Ideal.exists_maximal (Localization (Submonoid.map f p.primeCompl))
  refine âŸ¨M.comap (algebraMap S <| Localization (Submonoid.map f p.primeCompl)), inferInstance, ?_âŸ©
  rw [Ideal.comap_comap, â† @IsLocalization.map_comp _ _ _ _ _ _ _ _ Localization.isLocalization
      _ _ _ _ p.primeCompl.le_comap_map _ Localization.isLocalization,
    â† Ideal.comap_comap]
  suffices _ â‰¤ p by exact this.antisymm (H.2 âŸ¨inferInstance, bot_leâŸ© this)
  intro x hx
  by_contra h
  apply hM.ne_top
  apply M.eq_top_of_isUnit_mem hx
  apply IsUnit.map
  apply IsLocalization.map_units _ (show p.primeCompl from âŸ¨x, hâŸ©)"
Mathlib/LinearAlgebra/PerfectPairing.lean,PerfectPairing.toDualRight_symm_toDualLeft,toDualRight_symm_toDualLeft,5c13d55efc8f9cf5bb7ee7c6ca36ce88ac3bb07f,":= by
  ext f
  simp only [LinearEquiv.dualMap_apply, Dual.eval_apply]
  exact toDualLeft_of_toDualRightInvFun p x f",error:  unknown identifier 'toDualLeft_of_toDualRightInvFun',"theorem toDualRight_symm_toDualLeft (x : M) :
    p.toDualRight.symm.dualMap (p.toDualLeft x) = Dual.eval R M x ",":= by
  ext f
  simp only [LinearEquiv.dualMap_apply, Dual.eval_apply]
  exact toDualLeft_of_toDualRight_symm p x f"
Mathlib/LinearAlgebra/Eigenspace/Minpoly.lean,Module.End.hasEigenvalue_of_isRoot,hasEigenvalue_of_isRoot,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  cases' dvd_iff_isRoot.2 h with p hp
  rw [HasEigenvalue, eigenspace]
  intro con
  cases' (LinearMap.isUnit_iff_ker_eq_bot _).2 con with u hu
  have p_ne_0 : p â‰  0 := by
    intro con
    apply minpoly.ne_zero f.isIntegral
    rw [hp, con, mul_zero]
  have : (aeval f) p = 0 := by
    have h_aeval := minpoly.aeval K f
    revert h_aeval
    simp [hp, â† hu]
  have h_deg := minpoly.degree_le_of_ne_zero K f p_ne_0 this
  rw [hp, degree_mul, degree_X_sub_C, Polynomial.degree_eq_natDegree p_ne_0] at h_deg
  norm_cast at h_deg
  omega","error:  invalid field notation, function 'Module.End.isIntegral' does not have argument with type (Module.End ...) that can be used, it must be explicit or implicit with a unique name",theorem hasEigenvalue_of_isRoot (h : (minpoly K f).IsRoot Î¼) : f.HasEigenvalue Î¼ ,":= by
  cases' dvd_iff_isRoot.2 h with p hp
  rw [HasEigenvalue, eigenspace]
  intro con
  cases' (LinearMap.isUnit_iff_ker_eq_bot _).2 con with u hu
  have p_ne_0 : p â‰  0 := by
    intro con
    apply minpoly.ne_zero (Algebra.IsIntegral.isIntegral (R := K) f)
    rw [hp, con, mul_zero]
  have : (aeval f) p = 0 := by
    have h_aeval := minpoly.aeval K f
    revert h_aeval
    simp [hp, â† hu]
  have h_deg := minpoly.degree_le_of_ne_zero K f p_ne_0 this
  rw [hp, degree_mul, degree_X_sub_C, Polynomial.degree_eq_natDegree p_ne_0] at h_deg
  norm_cast at h_deg
  omega"
Mathlib/Data/PNat/Xgcd.lean,PNat.gcdB'_coe,gcdB'_coe,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  dsimp [gcdB', gcdY, gcdZ, XgcdType.z]
  rw [Nat.succ_eq_add_one, Nat.succ_eq_add_one, add_assoc]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
a b : â„•+
âŠ¢ (a.xgcd b).y + (a.xgcd b).zp + 1 = (a.xgcd b).y + ((a.xgcd b).zp + 1)",theorem gcdB'_coe : (gcdB' a b : â„•) = gcdY a b + gcdZ a b ,":= by
  dsimp [gcdB', gcdY, gcdZ, XgcdType.z]
  rw [add_assoc]"
Mathlib/Combinatorics/HalesJewett.lean,Combinatorics.Line.exists_mono_in_high_dimension,exists_mono_in_high_dimension,f909ab9f9febceb93de8511363cdcc9b1a0d7525,":=
  Finite.induction_empty_option
  (
  fun {Î± Î±'} e =>
    forall_imp fun Îº =>
      forall_imp fun _ =>
        Exists.imp fun Î¹ =>
          Exists.imp fun _ h C =>
            let âŸ¨l, c, lcâŸ© := h fun v => C (e âˆ˜ v)
            âŸ¨l.map e, c, e.forall_congr_left.mp fun x => by rw [â† lc x, Line.map_apply]âŸ©)
  (by
    intro Îº _
    by_cases h : Nonempty Îº
    Â· refine âŸ¨Unit, inferInstance, fun C => âŸ¨default, Classical.arbitrary _, PEmpty.recâŸ©âŸ©
    Â· exact âŸ¨Empty, inferInstance, fun C => (h âŸ¨C (Empty.rec)âŸ©).elimâŸ©)
  (by
    intro Î± _ ihÎ± Îº _
    cases nonempty_fintype Îº
    by_cases h : Nonempty Î±
    case neg =>
      refine âŸ¨Unit, inferInstance, fun C => âŸ¨diagonal _ Unit, C fun _ => none, ?_âŸ©âŸ©
      rintro (_ | âŸ¨aâŸ©)
      Â· rfl
      Â· exact (h âŸ¨aâŸ©).elim
    suffices key :
      âˆ€ r : â„•,
        âˆƒ (Î¹ : Type) (_ : Fintype Î¹),
          âˆ€ C : (Î¹ â†’ Option Î±) â†’ Îº,
            (âˆƒ s : ColorFocused C, Multiset.card s.lines = r) âˆ¨ âˆƒ l, IsMono C l by
      obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := key (Fintype.card Îº + 1)
      refine âŸ¨Î¹, _inst, fun C => (hÎ¹ C).resolve_left ?_âŸ©
      rintro âŸ¨s, srâŸ©
      apply Nat.not_succ_le_self (Fintype.card Îº)
      rw [â† Nat.add_one, â† sr, â† Multiset.card_map, â† Finset.card_mk]
      exact Finset.card_le_univ âŸ¨_, s.distinct_colorsâŸ©
    intro r
    induction' r with r ihr
    Â· exact âŸ¨Empty, inferInstance, fun C => Or.inl âŸ¨default, Multiset.card_zeroâŸ©âŸ©
    obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := ihr
    specialize ihÎ± ((Î¹ â†’ Option Î±) â†’ Îº)
    obtain âŸ¨Î¹', _inst, hÎ¹'âŸ© := ihÎ±
    refine âŸ¨Sum Î¹ Î¹', inferInstance, ?_âŸ©
    intro C
    specialize hÎ¹' fun v' v => C (Sum.elim v (some âˆ˜ v'))
    obtain âŸ¨l', C', hl'âŸ© := hÎ¹'
    have mono_of_mono : (âˆƒ l, IsMono C' l) â†’ âˆƒ l, IsMono C l := by
      rintro âŸ¨l, c, hlâŸ©
      refine âŸ¨l.horizontal (some âˆ˜ l' (Classical.arbitrary Î±)), c, fun x => ?_âŸ©
      rw [Line.horizontal_apply, â† hl, â† hl']
    specialize hÎ¹ C'
    rcases hÎ¹ with (âŸ¨s, srâŸ© | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : âˆƒ p âˆˆ s.lines, (p : AlmostMono _).color = C' s.focus
    Â· obtain âŸ¨p, p_mem, hpâŸ© := h
      refine Or.inr (mono_of_mono âŸ¨p.line, p.color, ?_âŸ©)
      rintro (_ | _)
      Â· rw [hp, s.is_focused p p_mem]
      Â· apply p.has_color
    refine Or.inl âŸ¨âŸ¨(s.lines.map ?_).cons âŸ¨(l'.map some).vertical s.focus, C' s.focus, fun x => ?_âŸ©,
            Sum.elim s.focus (l'.map some none), ?_, ?_âŸ©, ?_âŸ©
    Â· refine fun p => âŸ¨p.line.prod (l'.map some), p.color, fun x => ?_âŸ©
      rw [Line.prod_apply, Line.map_apply, â† p.has_color, â† congr_fun (hl' x)]
    Â· rw [vertical_apply, â† congr_fun (hl' x), Line.map_apply]
    Â· simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | âŸ¨q, hq, rflâŸ©)
      Â· simp only [vertical_apply]
      Â· simp only [prod_apply, s.is_focused q hq]
    Â· rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact âŸ¨fun âŸ¨q, hq, heâŸ© => h âŸ¨q, hq, heâŸ©, s.distinct_colorsâŸ©
    Â· rw [Multiset.card_cons, Multiset.card_map, sr])","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  c
Î± Î±' : Type u
e : Î± â‰ƒ Î±'
Îº : Type (max v u)
xâœÂ¹ : Finite Îº
Î¹ : Type
xâœ : Fintype Î¹
h : âˆ€ (C : (Î¹ â†’ Î±) â†’ Îº), âˆƒ l, IsMono C l
C : (Î¹ â†’ Î±') â†’ Îº
l : Line Î± Î¹
c : Îº
lc : âˆ€ (x : Î±), (fun v â†¦ C (â‡‘e âˆ˜ v)) ((fun x i â†¦ (l.idxFun i).getD x) x) = c
x : Î±
âŠ¢ ?m.6437 x
error:  application type mismatch
  Exists.intro c ((Equiv.forall_congr_left e).mp fun x â†¦ ?m.6452 x)
argument
  (Equiv.forall_congr_left e).mp fun x â†¦ ?m.6452 x
has type
  âˆ€ (b : Î±'), ?m.6437 (e.symm b) : Prop
but is expected to have type
  âˆ€ (x : Î±'), C ((fun x i â†¦ ((map (â‡‘e) l).idxFun i).getD x) x) = c : Prop","theorem exists_mono_in_high_dimension' :
    âˆ€ (Î± : Type u) [Finite Î±] (Îº : Type max v u) [Finite Îº],
      âˆƒ (Î¹ : Type) (_ : Fintype Î¹), âˆ€ C : (Î¹ â†’ Î±) â†’ Îº, âˆƒ l : Line Î± Î¹, l.IsMono C ",":=
  Finite.induction_empty_option
  (
  fun {Î± Î±'} e =>
    forall_imp fun Îº =>
      forall_imp fun _ =>
        Exists.imp fun Î¹ =>
          Exists.imp fun _ h C =>
            let âŸ¨l, c, lcâŸ© := h fun v => C (e âˆ˜ v)
            âŸ¨l.map e, c, e.forall_congr_right.mp fun x => by rw [â† lc x, Line.map_apply]âŸ©)
  (by
    intro Îº _
    by_cases h : Nonempty Îº
    Â· refine âŸ¨Unit, inferInstance, fun C => âŸ¨default, Classical.arbitrary _, PEmpty.recâŸ©âŸ©
    Â· exact âŸ¨Empty, inferInstance, fun C => (h âŸ¨C (Empty.rec)âŸ©).elimâŸ©)
  (by
    intro Î± _ ihÎ± Îº _
    cases nonempty_fintype Îº
    by_cases h : Nonempty Î±
    case neg =>
      refine âŸ¨Unit, inferInstance, fun C => âŸ¨diagonal _ Unit, C fun _ => none, ?_âŸ©âŸ©
      rintro (_ | âŸ¨aâŸ©)
      Â· rfl
      Â· exact (h âŸ¨aâŸ©).elim
    suffices key :
      âˆ€ r : â„•,
        âˆƒ (Î¹ : Type) (_ : Fintype Î¹),
          âˆ€ C : (Î¹ â†’ Option Î±) â†’ Îº,
            (âˆƒ s : ColorFocused C, Multiset.card s.lines = r) âˆ¨ âˆƒ l, IsMono C l by
      obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := key (Fintype.card Îº + 1)
      refine âŸ¨Î¹, _inst, fun C => (hÎ¹ C).resolve_left ?_âŸ©
      rintro âŸ¨s, srâŸ©
      apply Nat.not_succ_le_self (Fintype.card Îº)
      rw [â† Nat.add_one, â† sr, â† Multiset.card_map, â† Finset.card_mk]
      exact Finset.card_le_univ âŸ¨_, s.distinct_colorsâŸ©
    intro r
    induction' r with r ihr
    Â· exact âŸ¨Empty, inferInstance, fun C => Or.inl âŸ¨default, Multiset.card_zeroâŸ©âŸ©
    obtain âŸ¨Î¹, _inst, hÎ¹âŸ© := ihr
    specialize ihÎ± ((Î¹ â†’ Option Î±) â†’ Îº)
    obtain âŸ¨Î¹', _inst, hÎ¹'âŸ© := ihÎ±
    refine âŸ¨Sum Î¹ Î¹', inferInstance, ?_âŸ©
    intro C
    specialize hÎ¹' fun v' v => C (Sum.elim v (some âˆ˜ v'))
    obtain âŸ¨l', C', hl'âŸ© := hÎ¹'
    have mono_of_mono : (âˆƒ l, IsMono C' l) â†’ âˆƒ l, IsMono C l := by
      rintro âŸ¨l, c, hlâŸ©
      refine âŸ¨l.horizontal (some âˆ˜ l' (Classical.arbitrary Î±)), c, fun x => ?_âŸ©
      rw [Line.horizontal_apply, â† hl, â† hl']
    specialize hÎ¹ C'
    rcases hÎ¹ with (âŸ¨s, srâŸ© | h)
    on_goal 2 => exact Or.inr (mono_of_mono h)
    by_cases h : âˆƒ p âˆˆ s.lines, (p : AlmostMono _).color = C' s.focus
    Â· obtain âŸ¨p, p_mem, hpâŸ© := h
      refine Or.inr (mono_of_mono âŸ¨p.line, p.color, ?_âŸ©)
      rintro (_ | _)
      Â· rw [hp, s.is_focused p p_mem]
      Â· apply p.has_color
    refine Or.inl âŸ¨âŸ¨(s.lines.map ?_).cons âŸ¨(l'.map some).vertical s.focus, C' s.focus, fun x => ?_âŸ©,
            Sum.elim s.focus (l'.map some none), ?_, ?_âŸ©, ?_âŸ©
    Â· refine fun p => âŸ¨p.line.prod (l'.map some), p.color, fun x => ?_âŸ©
      rw [Line.prod_apply, Line.map_apply, â† p.has_color, â† congr_fun (hl' x)]
    Â· rw [vertical_apply, â† congr_fun (hl' x), Line.map_apply]
    Â· simp_rw [Multiset.mem_cons, Multiset.mem_map]
      rintro _ (rfl | âŸ¨q, hq, rflâŸ©)
      Â· simp only [vertical_apply]
      Â· simp only [prod_apply, s.is_focused q hq]
    Â· rw [Multiset.map_cons, Multiset.map_map, Multiset.nodup_cons, Multiset.mem_map]
      exact âŸ¨fun âŸ¨q, hq, heâŸ© => h âŸ¨q, hq, heâŸ©, s.distinct_colorsâŸ©
    Â· rw [Multiset.card_cons, Multiset.card_map, sr])"
Mathlib/Data/List/OfFn.lean,List.get_ofFn_go,get_ofFn_go,66caaeed4dccada03ce195a3f9db1c0009ee8118,":= by
  let i+1 := i
  cases k <;> simp [ofFn.go, get_ofFn_go (i := i)]
  congr 2; omega","error:  omega could not prove the goal:
a possible counterexample may satisfy the constraints
  b â‰¥ 0
  d â‰¥ 0
  c â‰¥ 0
  c - d â‰¥ 2
  a â‰¥ 0
  a - b â‰¤ -1
where
 a := â†‘j
 b := â†‘n
 c := â†‘(ofFn.go f (i + 1) j h).length
 d := â†‘nâœ
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_ofFn` has been deprecated, use `List.get_ofFn` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem get_ofFn_go {n} (f : Fin n â†’ Î±) (i j h) (k) (hk) :
    get (ofFn.go f i j h) âŸ¨k, hkâŸ© = f âŸ¨j + k, by simp at hk; omegaâŸ© ",":= by
  simp [getElem_ofFn_go]"
Mathlib/Geometry/Manifold/ContMDiff/Defs.lean,contMDiffOn_iff_target,contMDiffOn_iff_target,b321eb91db8872c6a36050317461b235c1debedb,":= by
  simp only [contMDiffOn_iff, ModelWithCorners.source_eq, chartAt_self_eq,
    PartialHomeomorph.refl_localEquiv, PartialEquiv.refl_trans, extChartAt,
    PartialHomeomorph.extend, Set.preimage_univ, Set.inter_univ, and_congr_right_iff]
  intro h
  constructor
  Â· refine' fun h' y => âŸ¨_, fun x _ => h' x yâŸ©
    have h'' : ContinuousOn _ univ := (ModelWithCorners.continuous I').continuousOn
    convert (h''.comp' (chartAt H' y).continuousOn_toFun).comp' h
    simp
  Â· exact fun h' x y => (h' y).2 x 0","error:  unknown constant 'PartialHomeomorph.refl_localEquiv'
error:  type mismatch
  h' x y
has type
  ContDiffOn ğ•œ n
    (â†‘((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv) âˆ˜ f âˆ˜ â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm)
    (((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).target âˆ©
      â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm â»Â¹'
        (s âˆ© f â»Â¹' ((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv).source)) : Prop
but is expected to have type
  ContDiffOn ğ•œ n
    (â†‘((PartialHomeomorph.refl E').toPartialEquiv â‰« ğ“˜(ğ•œ, E').toPartialEquiv) âˆ˜
      (â†‘((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv) âˆ˜ f) âˆ˜
        â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm)
    (((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).target âˆ©
      â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm â»Â¹'
        (s âˆ© f â»Â¹' ((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv).source âˆ©
          â†‘((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv) âˆ˜ f â»Â¹'
            ((PartialHomeomorph.refl E').toPartialEquiv â‰« ğ“˜(ğ•œ, E').toPartialEquiv).source)) : Prop
error:  type mismatch
  (h' y).right x 0
has type
  ContDiffOn ğ•œ n
    (â†‘((PartialHomeomorph.refl E').toPartialEquiv â‰« ğ“˜(ğ•œ, E').toPartialEquiv) âˆ˜
      (â†‘((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv) âˆ˜ f) âˆ˜
        â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm)
    (((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).target âˆ©
      â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm â»Â¹'
        (s âˆ© f â»Â¹' ((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv).source âˆ©
          â†‘((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv) âˆ˜ f â»Â¹'
            ((PartialHomeomorph.refl E').toPartialEquiv â‰« ğ“˜(ğ•œ, E').toPartialEquiv).source)) : Prop
but is expected to have type
  ContDiffOn ğ•œ n
    (â†‘((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv) âˆ˜ f âˆ˜ â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm)
    (((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).target âˆ©
      â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm â»Â¹'
        (s âˆ© f â»Â¹' ((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv).source)) : Prop","theorem contMDiffOn_iff_target :
    ContMDiffOn I I' n f s â†”
      ContinuousOn f s âˆ§
        âˆ€ y : M',
          ContMDiffOn I ğ“˜(ğ•œ, E') n (extChartAt I' y âˆ˜ f) (s âˆ© f â»Â¹' (extChartAt I' y).source) ",":= by
  simp only [contMDiffOn_iff, ModelWithCorners.source_eq, chartAt_self_eq,
    PartialHomeomorph.refl_partialEquiv, PartialEquiv.refl_trans, extChartAt,
    PartialHomeomorph.extend, Set.preimage_univ, Set.inter_univ, and_congr_right_iff]
  intro h
  constructor
  Â· refine fun h' y => âŸ¨?_, fun x _ => h' x yâŸ©
    have h'' : ContinuousOn _ univ := (ModelWithCorners.continuous I').continuousOn
    convert (h''.comp' (chartAt H' y).continuousOn_toFun).comp' h
    simp
  Â· exact fun h' x y => (h' y).2 x 0"
Mathlib/Combinatorics/SetFamily/AhlswedeZhang.lean,Finset.map_truncatedInf,map_truncatedInf,01d739c14a27d96463129c57bbb1982309f33ea6,":= by
  have : e a âˆˆ upperClosure (s.map e.toEquiv.toEmbedding) â†” a âˆˆ upperClosure s := by simp
  simp_rw [truncatedInf, apply_dite e, map_finset_inf', map_bot, this]
  congr with h
  simp only [filter_map, Function.comp, Equiv.coe_toEmbedding, RelIso.coe_fn_toEquiv,
    OrderIso.le_iff_le, id.def]
  rw [inf'_map]
  simp only [Equiv.coe_toEmbedding, RelIso.coe_fn_toEquiv, Function.comp_apply]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.165026 â†’ ?m.165026
error:  unsolved goals
case e_t.h
Î± : Type u_1
Î² : Type u_2
instâœâµ : SemilatticeInf Î±
instâœâ´ : BoundedOrder Î±
instâœÂ³ : DecidableRel fun x x_1 â†¦ x â‰¤ x_1
instâœÂ² : SemilatticeInf Î²
instâœÂ¹ : BoundedOrder Î²
instâœ : DecidableRel fun x x_1 â†¦ x â‰¤ x_1
sâœ t : Finset Î±
aâœ : Î±
e : Î± â‰ƒo Î²
s : Finset Î±
a : Î±
this : e a âˆˆ upperClosure â†‘(map e.toEmbedding s) â†” a âˆˆ upperClosure â†‘s
h : a âˆˆ upperClosure â†‘s
âŠ¢ ((filter (fun x â†¦ x â‰¤ a) s).inf' â‹¯ fun x â†¦ e (id x)) = (filter (fun x â†¦ x â‰¤ a) s).inf' â‹¯ fun x â†¦ id (e x)","lemma map_truncatedInf (e : Î± â‰ƒo Î²) (s : Finset Î±) (a : Î±) :
    e (truncatedInf s a) = truncatedInf (s.map e.toEquiv.toEmbedding) (e a) ",":= by
  have : e a âˆˆ upperClosure (s.map e.toEquiv.toEmbedding) â†” a âˆˆ upperClosure s := by simp
  simp_rw [truncatedInf, apply_dite e, map_finset_inf', map_bot, this]
  congr with h
  simp only [filter_map, Function.comp, Equiv.coe_toEmbedding, RelIso.coe_fn_toEquiv,
    OrderIso.le_iff_le, id, inf'_map]"
Mathlib/Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean,ApproximatesLinearOn.surjOn_closedBall_of_nonlinearRightInverse,surjOn_closedBall_of_nonlinearRightInverse,e24d0042f0fd176848590f8a296e5c675237f634,":= by
  intro y hy
  rcases le_or_lt (f'symm.nnnorm : â„)â»Â¹ c with hc | hc
  Â· refine' âŸ¨b, by simp [Îµ0], _âŸ©
    have : dist y (f b) â‰¤ 0 :=
      (mem_closedBall.1 hy).trans (mul_nonpos_of_nonpos_of_nonneg (by linarith) Îµ0)
    simp only [dist_le_zero] at this
    rw [this]
  have If' : (0 : â„) < f'symm.nnnorm := by rw [â† inv_pos]; exact (NNReal.coe_nonneg _).trans_lt hc
  have Icf' : (c : â„) * f'symm.nnnorm < 1 := by rwa [inv_eq_one_div, lt_div_iff If'] at hc
  have Jf' : (f'symm.nnnorm : â„) â‰  0 := ne_of_gt If'
  have Jcf' : (1 : â„) - c * f'symm.nnnorm â‰  0 := by apply ne_of_gt; linarith
  set g := fun x => x + f'symm (y - f x) with hg
  set u := fun n : â„• => g^[n] b with hu
  have usucc : âˆ€ n, u (n + 1) = g (u n) := by simp [hu, â† iterate_succ_apply' g _ b]
  have A : âˆ€ z, dist (g z) z â‰¤ f'symm.nnnorm * dist (f z) y := by
    intro z
    rw [dist_eq_norm, hg, add_sub_cancel', dist_eq_norm']
    exact f'symm.bound _
  have B :
    âˆ€ z âˆˆ closedBall b Îµ,
      g z âˆˆ closedBall b Îµ â†’ dist (f (g z)) y â‰¤ c * f'symm.nnnorm * dist (f z) y := by
    intro z hz hgz
    set v := f'symm (y - f z)
    calc
      dist (f (g z)) y = â€–f (z + v) - yâ€– := by rw [dist_eq_norm]
      _ = â€–f (z + v) - f z - f' v + f' v - (y - f z)â€– := by congr 1; abel
      _ = â€–f (z + v) - f z - f' (z + v - z)â€– := by
        simp only [ContinuousLinearMap.NonlinearRightInverse.right_inv, add_sub_cancel',
          sub_add_cancel]
      _ â‰¤ c * â€–z + v - zâ€– := (hf _ (hÎµ hgz) _ (hÎµ hz))
      _ â‰¤ c * (f'symm.nnnorm * dist (f z) y) := by
        gcongr
        simpa [dist_eq_norm'] using f'symm.bound (y - f z)
      _ = c * f'symm.nnnorm * dist (f z) y := by ring
  have C : âˆ€ (n : â„•) (w : E), dist w b â‰¤ f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n) /
      (1 - c * f'symm.nnnorm) * dist (f b) y â†’ w âˆˆ closedBall b Îµ := fun n w hw â†¦ by
    apply hw.trans
    rw [div_mul_eq_mul_div, div_le_iff]; swap; Â· linarith
    calc
      (f'symm.nnnorm : â„) * (1 - ((c : â„) * f'symm.nnnorm) ^ n) * dist (f b) y =
          f'symm.nnnorm * dist (f b) y * (1 - ((c : â„) * f'symm.nnnorm) ^ n) :=
        by ring
      _ â‰¤ f'symm.nnnorm * dist (f b) y * 1 := by
        gcongr
        rw [sub_le_self_iff]
        positivity
      _ â‰¤ f'symm.nnnorm * (((f'symm.nnnorm : â„)â»Â¹ - c) * Îµ) := by
        rw [mul_one]
        gcongr
        exact mem_closedBall'.1 hy
      _ = Îµ * (1 - c * f'symm.nnnorm) := by field_simp; ring

  have D : âˆ€ n : â„•, dist (f (u n)) y â‰¤ ((c : â„) * f'symm.nnnorm) ^ n * dist (f b) y âˆ§
      dist (u n) b â‰¤ f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n) /
        (1 - (c : â„) * f'symm.nnnorm) * dist (f b) y := fun n â†¦ by
    induction' n with n IH; Â· simp [hu, le_refl]
    rw [usucc]
    have Ign : dist (g (u n)) b â‰¤ f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n.succ) /
        (1 - c * f'symm.nnnorm) * dist (f b) y :=
      calc
        dist (g (u n)) b â‰¤ dist (g (u n)) (u n) + dist (u n) b := dist_triangle _ _ _
        _ â‰¤ f'symm.nnnorm * dist (f (u n)) y + dist (u n) b := (add_le_add (A _) le_rfl)
        _ â‰¤ f'symm.nnnorm * (((c : â„) * f'symm.nnnorm) ^ n * dist (f b) y) +
              f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n) / (1 - c * f'symm.nnnorm) *
                dist (f b) y := by gcongr; exact IH.1; exact IH.2
        _ = f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n.succ) /
              (1 - (c : â„) * f'symm.nnnorm) * dist (f b) y := by
          field_simp [Jcf', pow_succ]; ring
    refine' âŸ¨_, IgnâŸ©
    calc
      dist (f (g (u n))) y â‰¤ c * f'symm.nnnorm * dist (f (u n)) y :=
        B _ (C n _ IH.2) (C n.succ _ Ign)
      _ â‰¤ (c : â„) * f'symm.nnnorm * (((c : â„) * f'symm.nnnorm) ^ n * dist (f b) y) := by
        gcongr
        apply IH.1
      _ = ((c : â„) * f'symm.nnnorm) ^ n.succ * dist (f b) y := by simp only [pow_succ']; ring
  have : CauchySeq u
  Â· refine cauchySeq_of_le_geometric _ (â†‘f'symm.nnnorm * dist (f b) y) Icf' fun n â†¦ ?_
    calc
      dist (u n) (u (n + 1)) = dist (g (u n)) (u n) := by rw [usucc, dist_comm]
      _ â‰¤ f'symm.nnnorm * dist (f (u n)) y := (A _)
      _ â‰¤ f'symm.nnnorm * (((c : â„) * f'symm.nnnorm) ^ n * dist (f b) y) := by
        gcongr
        exact (D n).1
      _ = f'symm.nnnorm * dist (f b) y * ((c : â„) * f'symm.nnnorm) ^ n := by ring
  obtain âŸ¨x, hxâŸ© : âˆƒ x, Tendsto u atTop (ğ“ x) := cauchySeq_tendsto_of_complete this
  have xmem : x âˆˆ closedBall b Îµ :=
    isClosed_ball.mem_of_tendsto hx (eventually_of_forall fun n => C n _ (D n).2)
  refine' âŸ¨x, xmem, _âŸ©
  have hx' : Tendsto u atTop (ğ“[closedBall b Îµ] x) := by
    simp only [nhdsWithin, tendsto_inf, hx, true_and_iff, ge_iff_le, tendsto_principal]
    exact eventually_of_forall fun n => C n _ (D n).2
  have T1 : Tendsto (f âˆ˜ u) atTop (ğ“ (f x)) :=
    (hf.continuousOn.mono hÎµ x xmem).tendsto.comp hx'
  have T2 : Tendsto (f âˆ˜ u) atTop (ğ“ y) := by
    rw [tendsto_iff_dist_tendsto_zero]
    refine' squeeze_zero (fun _ => dist_nonneg) (fun n => (D n).1) _
    simpa using (tendsto_pow_atTop_nhds_zero_of_lt_one (by positivity) Icf').mul tendsto_const_nhds
  exact tendsto_nhds_unique T1 T2","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
ğ•œ : Type u_1
instâœâ¹ : NontriviallyNormedField ğ•œ
E : Type u_2
instâœâ¸ : NormedAddCommGroup E
instâœâ· : NormedSpace ğ•œ E
F : Type u_3
instâœâ¶ : NormedAddCommGroup F
instâœâµ : NormedSpace ğ•œ F
G : Type u_4
instâœâ´ : NormedAddCommGroup G
instâœÂ³ : NormedSpace ğ•œ G
G' : Type u_5
instâœÂ² : NormedAddCommGroup G'
instâœÂ¹ : NormedSpace ğ•œ G'
Îµâœ : â„
instâœ : CompleteSpace E
f : E â†’ F
s : Set E
c : â„â‰¥0
f' : E â†’L[ğ•œ] F
hf : ApproximatesLinearOn f f' s c
f'symm : f'.NonlinearRightInverse
Îµ : â„
b : E
Îµ0 : 0 â‰¤ Îµ
hÎµ : closedBall b Îµ âŠ† s
y : F
hy : y âˆˆ closedBall (f b) (((â†‘f'symm.nnnorm)â»Â¹ - â†‘c) * Îµ)
hc : â†‘c < (â†‘f'symm.nnnorm)â»Â¹
If' : 0 < â†‘f'symm.nnnorm
Icf' : â†‘c * â†‘f'symm.nnnorm < 1
Jf' : â†‘f'symm.nnnorm â‰  0
Jcf' : 1 - â†‘c * â†‘f'symm.nnnorm â‰  0
g : E â†’ E := fun x â†¦ x + f'symm.toFun (y - f x)
hg : g = fun x â†¦ x + f'symm.toFun (y - f x)
u : â„• â†’ E := fun n â†¦ g^[n] b
hu : u = fun n â†¦ g^[n] b
usucc : âˆ€ (n : â„•), u (n + 1) = g (u n)
A : âˆ€ (z : E), dist (g z) z â‰¤ â†‘f'symm.nnnorm * dist (f z) y
z : E
hz : z âˆˆ closedBall b Îµ
hgz : g z âˆˆ closedBall b Îµ
v : E := f'symm.toFun (y - f z)
âŠ¢ â€–f (z + v) - f z - (y - f z)â€– = â€–f (z + v) - f z - f' vâ€–
error:  unsolved goals
case inr
ğ•œ : Type u_1
instâœâ¹ : NontriviallyNormedField ğ•œ
E : Type u_2
instâœâ¸ : NormedAddCommGroup E
instâœâ· : NormedSpace ğ•œ E
F : Type u_3
instâœâ¶ : NormedAddCommGroup F
instâœâµ : NormedSpace ğ•œ F
G : Type u_4
instâœâ´ : NormedAddCommGroup G
instâœÂ³ : NormedSpace ğ•œ G
G' : Type u_5
instâœÂ² : NormedAddCommGroup G'
instâœÂ¹ : NormedSpace ğ•œ G'
Îµâœ : â„
instâœ : CompleteSpace E
f : E â†’ F
s : Set E
c : â„â‰¥0
f' : E â†’L[ğ•œ] F
hf : ApproximatesLinearOn f f' s c
f'symm : f'.NonlinearRightInverse
Îµ : â„
b : E
Îµ0 : 0 â‰¤ Îµ
hÎµ : closedBall b Îµ âŠ† s
y : F
hy : y âˆˆ closedBall (f b) (((â†‘f'symm.nnnorm)â»Â¹ - â†‘c) * Îµ)
hc : â†‘c < (â†‘f'symm.nnnorm)â»Â¹
If' : 0 < â†‘f'symm.nnnorm
Icf' : â†‘c * â†‘f'symm.nnnorm < 1
Jf' : â†‘f'symm.nnnorm â‰  0
Jcf' : 1 - â†‘c * â†‘f'symm.nnnorm â‰  0
g : E â†’ E := fun x â†¦ x + f'symm.toFun (y - f x)
hg : g = fun x â†¦ x + f'symm.toFun (y - f x)
u : â„• â†’ E := fun n â†¦ g^[n] b
hu : u = fun n â†¦ g^[n] b
usucc : âˆ€ (n : â„•), u (n + 1) = g (u n)
A : âˆ€ (z : E), dist (g z) z â‰¤ â†‘f'symm.nnnorm * dist (f z) y
B : âˆ€ z âˆˆ closedBall b Îµ, g z âˆˆ closedBall b Îµ â†’ dist (f (g z)) y â‰¤ â†‘c * â†‘f'symm.nnnorm * dist (f z) y
C :
  âˆ€ (n : â„•) (w : E),
    dist w b â‰¤ â†‘f'symm.nnnorm * (1 - (â†‘c * â†‘f'symm.nnnorm) ^ n) / (1 - â†‘c * â†‘f'symm.nnnorm) * dist (f b) y â†’
      w âˆˆ closedBall b Îµ
D :
  âˆ€ (n : â„•),
    dist (f (u n)) y â‰¤ (â†‘c * â†‘f'symm.nnnorm) ^ n * dist (f b) y âˆ§
      dist (u n) b â‰¤ â†‘f'symm.nnnorm * (1 - (â†‘c * â†‘f'symm.nnnorm) ^ n) / (1 - â†‘c * â†‘f'symm.nnnorm) * dist (f b) y
this : CauchySeq u
âŠ¢ y âˆˆ f '' closedBall b Îµ","theorem surjOn_closedBall_of_nonlinearRightInverse (hf : ApproximatesLinearOn f f' s c)
    (f'symm : f'.NonlinearRightInverse) {Îµ : â„} {b : E} (Îµ0 : 0 â‰¤ Îµ) (hÎµ : closedBall b Îµ âŠ† s) :
    SurjOn f (closedBall b Îµ) (closedBall (f b) (((f'symm.nnnorm : â„)â»Â¹ - c) * Îµ)) ",":= by
  intro y hy
  rcases le_or_lt (f'symm.nnnorm : â„)â»Â¹ c with hc | hc
  Â· refine âŸ¨b, by simp [Îµ0], ?_âŸ©
    have : dist y (f b) â‰¤ 0 :=
      (mem_closedBall.1 hy).trans (mul_nonpos_of_nonpos_of_nonneg (by linarith) Îµ0)
    simp only [dist_le_zero] at this
    rw [this]
  have If' : (0 : â„) < f'symm.nnnorm := by rw [â† inv_pos]; exact (NNReal.coe_nonneg _).trans_lt hc
  have Icf' : (c : â„) * f'symm.nnnorm < 1 := by rwa [inv_eq_one_div, lt_div_iff If'] at hc
  have Jf' : (f'symm.nnnorm : â„) â‰  0 := ne_of_gt If'
  have Jcf' : (1 : â„) - c * f'symm.nnnorm â‰  0 := by apply ne_of_gt; linarith
  set g := fun x => x + f'symm (y - f x) with hg
  set u := fun n : â„• => g^[n] b with hu
  have usucc : âˆ€ n, u (n + 1) = g (u n) := by simp [hu, â† iterate_succ_apply' g _ b]
  have A : âˆ€ z, dist (g z) z â‰¤ f'symm.nnnorm * dist (f z) y := by
    intro z
    rw [dist_eq_norm, hg, add_sub_cancel_left, dist_eq_norm']
    exact f'symm.bound _
  have B :
    âˆ€ z âˆˆ closedBall b Îµ,
      g z âˆˆ closedBall b Îµ â†’ dist (f (g z)) y â‰¤ c * f'symm.nnnorm * dist (f z) y := by
    intro z hz hgz
    set v := f'symm (y - f z)
    calc
      dist (f (g z)) y = â€–f (z + v) - yâ€– := by rw [dist_eq_norm]
      _ = â€–f (z + v) - f z - f' v + f' v - (y - f z)â€– := by congr 1; abel
      _ = â€–f (z + v) - f z - f' (z + v - z)â€– := by
        simp only [v, ContinuousLinearMap.NonlinearRightInverse.right_inv, add_sub_cancel_left,
          sub_add_cancel]
      _ â‰¤ c * â€–z + v - zâ€– := hf _ (hÎµ hgz) _ (hÎµ hz)
      _ â‰¤ c * (f'symm.nnnorm * dist (f z) y) := by
        gcongr
        simpa [dist_eq_norm'] using f'symm.bound (y - f z)
      _ = c * f'symm.nnnorm * dist (f z) y := by ring
  have C : âˆ€ (n : â„•) (w : E), dist w b â‰¤ f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n) /
      (1 - c * f'symm.nnnorm) * dist (f b) y â†’ w âˆˆ closedBall b Îµ := fun n w hw â†¦ by
    apply hw.trans
    rw [div_mul_eq_mul_div, div_le_iff]; swap; Â· linarith
    calc
      (f'symm.nnnorm : â„) * (1 - ((c : â„) * f'symm.nnnorm) ^ n) * dist (f b) y =
          f'symm.nnnorm * dist (f b) y * (1 - ((c : â„) * f'symm.nnnorm) ^ n) := by
        ring
      _ â‰¤ f'symm.nnnorm * dist (f b) y * 1 := by
        gcongr
        rw [sub_le_self_iff]
        positivity
      _ â‰¤ f'symm.nnnorm * (((f'symm.nnnorm : â„)â»Â¹ - c) * Îµ) := by
        rw [mul_one]
        gcongr
        exact mem_closedBall'.1 hy
      _ = Îµ * (1 - c * f'symm.nnnorm) := by field_simp; ring

  have D : âˆ€ n : â„•, dist (f (u n)) y â‰¤ ((c : â„) * f'symm.nnnorm) ^ n * dist (f b) y âˆ§
      dist (u n) b â‰¤ f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n) /
        (1 - (c : â„) * f'symm.nnnorm) * dist (f b) y := fun n â†¦ by
    induction' n with n IH; Â· simp [hu, le_refl]
    rw [usucc]
    have Ign : dist (g (u n)) b â‰¤ f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n.succ) /
        (1 - c * f'symm.nnnorm) * dist (f b) y :=
      calc
        dist (g (u n)) b â‰¤ dist (g (u n)) (u n) + dist (u n) b := dist_triangle _ _ _
        _ â‰¤ f'symm.nnnorm * dist (f (u n)) y + dist (u n) b := add_le_add (A _) le_rfl
        _ â‰¤ f'symm.nnnorm * (((c : â„) * f'symm.nnnorm) ^ n * dist (f b) y) +
              f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n) / (1 - c * f'symm.nnnorm) *
                dist (f b) y := by
                  gcongr
                  Â· exact IH.1
                  Â· exact IH.2
        _ = f'symm.nnnorm * (1 - ((c : â„) * f'symm.nnnorm) ^ n.succ) /
              (1 - (c : â„) * f'symm.nnnorm) * dist (f b) y := by
          field_simp [Jcf', pow_succ]; ring
    refine âŸ¨?_, IgnâŸ©
    calc
      dist (f (g (u n))) y â‰¤ c * f'symm.nnnorm * dist (f (u n)) y :=
        B _ (C n _ IH.2) (C n.succ _ Ign)
      _ â‰¤ (c : â„) * f'symm.nnnorm * (((c : â„) * f'symm.nnnorm) ^ n * dist (f b) y) := by
        gcongr
        apply IH.1
      _ = ((c : â„) * f'symm.nnnorm) ^ n.succ * dist (f b) y := by simp only [pow_succ']; ring
  have : CauchySeq u := by
    refine cauchySeq_of_le_geometric _ (â†‘f'symm.nnnorm * dist (f b) y) Icf' fun n â†¦ ?_
    calc
      dist (u n) (u (n + 1)) = dist (g (u n)) (u n) := by rw [usucc, dist_comm]
      _ â‰¤ f'symm.nnnorm * dist (f (u n)) y := A _
      _ â‰¤ f'symm.nnnorm * (((c : â„) * f'symm.nnnorm) ^ n * dist (f b) y) := by
        gcongr
        exact (D n).1
      _ = f'symm.nnnorm * dist (f b) y * ((c : â„) * f'symm.nnnorm) ^ n := by ring
  obtain âŸ¨x, hxâŸ© : âˆƒ x, Tendsto u atTop (ğ“ x) := cauchySeq_tendsto_of_complete this
  have xmem : x âˆˆ closedBall b Îµ :=
    isClosed_ball.mem_of_tendsto hx (eventually_of_forall fun n => C n _ (D n).2)
  refine âŸ¨x, xmem, ?_âŸ©
  have hx' : Tendsto u atTop (ğ“[closedBall b Îµ] x) := by
    simp only [nhdsWithin, tendsto_inf, hx, true_and_iff, ge_iff_le, tendsto_principal]
    exact eventually_of_forall fun n => C n _ (D n).2
  have T1 : Tendsto (f âˆ˜ u) atTop (ğ“ (f x)) :=
    (hf.continuousOn.mono hÎµ x xmem).tendsto.comp hx'
  have T2 : Tendsto (f âˆ˜ u) atTop (ğ“ y) := by
    rw [tendsto_iff_dist_tendsto_zero]
    refine squeeze_zero (fun _ => dist_nonneg) (fun n => (D n).1) ?_
    simpa using (tendsto_pow_atTop_nhds_zero_of_lt_one (by positivity) Icf').mul tendsto_const_nhds
  exact tendsto_nhds_unique T1 T2"
Mathlib/Analysis/Calculus/MeanValue.lean,Convex.exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt_of_nnnorm_lt,exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt_of_nnnorm_lt,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  obtain âŸ¨Îµ, Îµ0, hÎµâŸ© : âˆƒ Îµ > 0,
      ball x Îµ âˆ© s âŠ† { y | HasFDerivWithinAt f (f' y) s y âˆ§ â€–f' yâ€–â‚Š < K } :=
    mem_nhdsWithin_iff.1 (hder.and <| hcont.nnnorm.eventually (gt_mem_nhds hK))
  rw [inter_comm] at hÎµ
  refine' âŸ¨s âˆ© ball x Îµ, inter_mem_nhdsWithin _ (ball_mem_nhds _ Îµ0), _âŸ©
  exact
    (hs.inter (convex_ball _ _)).lipschitzOnWith_of_nnnorm_hasFDerivWithin_le
      (fun y hy => (hÎµ hy).1.mono (inter_subset_left _ _)) fun y hy => (hÎµ hy).2.le","error:  function expected at
  inter_subset_left ?m.109881
term has type
  ?m.109880 âˆˆ ?m.109878","theorem exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt_of_nnnorm_lt (hs : Convex â„ s)
    {f : E â†’ G} (hder : âˆ€á¶  y in ğ“[s] x, HasFDerivWithinAt f (f' y) s y)
    (hcont : ContinuousWithinAt f' s x) (K : â„â‰¥0) (hK : â€–f' xâ€–â‚Š < K) :
    âˆƒ t âˆˆ ğ“[s] x, LipschitzOnWith K f t ",":= by
  obtain âŸ¨Îµ, Îµ0, hÎµâŸ© : âˆƒ Îµ > 0,
      ball x Îµ âˆ© s âŠ† { y | HasFDerivWithinAt f (f' y) s y âˆ§ â€–f' yâ€–â‚Š < K } :=
    mem_nhdsWithin_iff.1 (hder.and <| hcont.nnnorm.eventually (gt_mem_nhds hK))
  rw [inter_comm] at hÎµ
  refine âŸ¨s âˆ© ball x Îµ, inter_mem_nhdsWithin _ (ball_mem_nhds _ Îµ0), ?_âŸ©
  exact
    (hs.inter (convex_ball _ _)).lipschitzOnWith_of_nnnorm_hasFDerivWithin_le
      (fun y hy => (hÎµ hy).1.mono inter_subset_left) fun y hy => (hÎµ hy).2.le"
Mathlib/NumberTheory/NumberField/CanonicalEmbedding/ConvexBody.lean,NumberField.mixedEmbedding.norm_le_convexBodySumFun,norm_le_convexBodySumFun,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine max_le ?_ ?_
  Â· refine (pi_norm_le_iff_of_nonneg (convexBodySumFun_nonneg x)).mpr (fun w => ?_)
    refine le_add_of_le_of_nonneg ?_ ?_
    Â· exact Finset.single_le_sum (fun z _ => norm_nonneg (x.1 z)) (Finset.mem_univ w)
    Â· exact mul_nonneg zero_le_two <| Finset.sum_nonneg (fun w _ => norm_nonneg (x.2 w))
  Â· refine (pi_norm_le_iff_of_nonneg (convexBodySumFun_nonneg x)).mpr (fun w => ?_)
    refine le_add_of_nonneg_of_le ?_ ?_
    Â· exact Finset.sum_nonneg (fun w _ => norm_nonneg (x.1 w))
    Â· rw [Finset.mul_sum]
      refine le_trans (by linarith [norm_nonneg (x.2 w)] : â€–x.2 wâ€– â‰¤ 2 * â€–x.2 wâ€–) ?_
      exact Finset.single_le_sum (fun z _ => mul_nonneg zero_le_two (norm_nonneg (x.2 z)))
        (Finset.mem_univ w)","error:  typeclass instance problem is stuck, it is often due to metavariables
  CovariantClass ?m.200099 ?m.200099 (fun x x_1 â†¦ x + x_1) fun x x_1 â†¦ x â‰¤ x_1
error:  type mismatch
  le_add_of_nonneg_of_le ?m.201301 ?m.201302
has type
  â€–x.2 wâ€– â‰¤ ?m.201298 + ?m.201300 : Prop
but is expected to have type
  â€–x.2 wâ€– â‰¤ convexBodySumFun x : Prop",theorem norm_le_convexBodySumFun (x : E K) : â€–xâ€– â‰¤ convexBodySumFun x ,":= by
  rw [norm_eq_sup'_normAtPlace]
  refine (Finset.sup'_le_iff _ _).mpr fun w _ â†¦ ?_
  rw [convexBodySumFun_apply, â† Finset.univ.add_sum_erase _ (Finset.mem_univ w)]
  refine le_add_of_le_of_nonneg  ?_ ?_
  Â· exact le_mul_of_one_le_left (normAtPlace_nonneg w x) one_le_mult
  Â· exact Finset.sum_nonneg (fun _ _ => mul_nonneg (Nat.cast_pos.mpr mult_pos).le
      (normAtPlace_nonneg _ _))"
Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean,mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt,mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt,0f24aee7da46f85fee5cacc716172444ce31e582,":= by
  induction' n with n hn
  Â· simpa using hz
  Â· rw [_root_.pow_succ, mul_smul] at hz
    exact
      hn
        (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint
          (isIntegral_smul _ hzint) hz hei)",error:  unknown identifier 'isIntegral_smul',"theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}
    (hp : Prime p) (hBint : IsIntegral R B.gen) {n : â„•} {z : L} (hzint : IsIntegral R z)
    (hz : p ^ n â€¢ z âˆˆ adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt ğ“Ÿ) :
    z âˆˆ adjoin R ({B.gen} : Set L) ",":= by
  induction' n with n hn
  Â· simpa using hz
  Â· rw [_root_.pow_succ', mul_smul] at hz
    exact
      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)"
Mathlib/Data/Nat/MaxPowDiv.lean,Nat.maxPowDiv.go_succ,go_succ,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  rw [go_eq]
  conv_rhs => rw [go_eq]
  by_cases h : (1 < p âˆ§ 0 < n âˆ§ n % p = 0); swap
  Â· simp only [if_neg h]
  Â· have : n / p < n := by apply Nat.div_lt_self <;> aesop
    simp only [if_pos h]
    apply go_succ","warning:  maxPowDiv does not have a doc string
error:  unknown identifier 'go_eq'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.1498
k p n : â„•
âŠ¢ go (k + 1) p n = go k p n + 1",theorem go_succ {k p n : â„•} : go (k+1) p n = go k p n + 1 ,":= by
  induction k, p, n using go.induct
  case case1 h ih =>
    unfold go
    simp only [if_pos h]
    exact ih
  case case2 h =>
    unfold go
    simp only [if_neg h]"
Mathlib/LinearAlgebra/LinearPMap.lean,LinearPMap.neg_graph,neg_graph,59c36da5834220170716566e80c451914feb876f,":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  Â· rw [mem_graph_iff] at h
    rcases h with âŸ¨y, hy, hâŸ©
    rw [LinearPMap.neg_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id.def,
      LinearMap.neg_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y
    simp [hy, h]
  rw [Submodule.mem_map] at h
  rcases h with âŸ¨x', hx', hâŸ©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id.def, LinearMap.neg_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx'âŠ¢
  rcases hx' with âŸ¨y, hy, hx'âŸ©
  use y
  rw [â† h.1, â† h.2]
  simp [hy, hx']","warning:  LinearPMap does not have a doc string
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.548521 â†’ ?m.548521
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.550936 â†’ ?m.550936","theorem neg_graph (f : E â†’â‚—.[R] F) :
    (-f).graph =
    f.graph.map ((LinearMap.id : E â†’â‚—[R] E).prodMap (-(LinearMap.id : F â†’â‚—[R] F))) ",":= by
  ext x; cases' x with x_fst x_snd
  constructor <;> intro h
  Â· rw [mem_graph_iff] at h
    rcases h with âŸ¨y, hy, hâŸ©
    rw [LinearPMap.neg_apply] at h
    rw [Submodule.mem_map]
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id,
      LinearMap.neg_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y, hy
  rw [Submodule.mem_map] at h
  rcases h with âŸ¨x', hx', hâŸ©
  cases x'
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id, LinearMap.neg_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' âŠ¢
  rcases hx' with âŸ¨y, hy, hx'âŸ©
  use y
  rw [â† h.1, â† h.2]
  simp [hy, hx']"
Mathlib/Topology/TietzeExtension.lean,BoundedContinuousFunction.exists_extension_forall_exists_le_ge_of_closedEmbedding,exists_extension_forall_exists_le_ge_of_closedEmbedding,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  inhabit X
  obtain âŸ¨a, haâŸ© : âˆƒ a, IsGLB (range f) a
  exact âŸ¨_, isGLB_ciInf (Real.bounded_iff_bddBelow_bddAbove.1 f.bounded_range).1âŸ©
  obtain âŸ¨b, hbâŸ© : âˆƒ b, IsLUB (range f) b
  exact âŸ¨_, isLUB_ciSup (Real.bounded_iff_bddBelow_bddAbove.1 f.bounded_range).2âŸ©
  have hmem : âˆ€ x, f x âˆˆ Icc a b := fun x => âŸ¨ha.1 âŸ¨x, rflâŸ©, hb.1 âŸ¨x, rflâŸ©âŸ©
  have hle : a â‰¤ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  Â· have : âˆ€ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp
    ring
  obtain âŸ¨g, hg_mem, hgfâŸ© : âˆƒ g : Y â†’áµ‡ â„, (âˆ€ y, âˆƒ x, g y âˆˆ Icc (f x) b) âˆ§ g âˆ˜ e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with âŸ¨g, hg_mem, hgfâŸ©
    rcases em (âˆƒ x, f x = a) with (âŸ¨x, rflâŸ© | ha')
    Â· exact âŸ¨g, fun y => âŸ¨x, hg_mem _âŸ©, hgfâŸ©
    have hd : Disjoint (range e âˆª g â»Â¹' Ici c) (g â»Â¹' {a}) := by
      refine' disjoint_union_left.2 âŸ¨_, Disjoint.preimage _ _âŸ©
      Â· rw [Set.disjoint_left]
        rintro _ âŸ¨x, rflâŸ© (rfl : g (e x) = a)
        exact ha' âŸ¨x, (congr_fun hgf x).symmâŸ©
      Â· exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.closed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      âŸ¨dg, dg0, dga, dgmemâŸ©
    replace hgf : âˆ€ x, (g + dg) (e x) = f x
    Â· intro x
      simp [dg0 (Or.inl <| mem_range_self _), â† hgf]
    refine' âŸ¨g + dg, fun y => _, funext hgfâŸ©
    Â· have hay : a < (g + dg) y := by
        rcases(hg_mem y).1.eq_or_lt with (rfl | hlt)
        Â· refine' (lt_add_iff_pos_right _).2 _
          calc
            0 < c - g y := sub_pos.2 hac
            _ = dg y := (dga rfl).symm
        Â· exact hlt.trans_le ((le_add_iff_nonneg_right _).2 <| (dgmem y).1)
      rcases ha.exists_between hay with âŸ¨_, âŸ¨x, rflâŸ©, _, hxyâŸ©
      refine' âŸ¨x, hxy.le, _âŸ©
      cases' le_total c (g y) with hc hc
      Â· simp [dg0 (Or.inr hc), (hg_mem y).2]
      Â· calc
          g y + dg y â‰¤ c + (c - a) := add_le_add hc (dgmem _).2
          _ = b := by rw [hsub, add_sub_cancel'_right]
  choose xl hxl hgb using hg_mem
  rcases em (âˆƒ x, f x = b) with (âŸ¨x, rflâŸ© | hb')
  Â· exact âŸ¨g, fun y => âŸ¨xl y, x, hxl y, hgb yâŸ©, hgfâŸ©
  have hd : Disjoint (range e âˆª g â»Â¹' Iic c) (g â»Â¹' {b}) := by
    refine' disjoint_union_left.2 âŸ¨_, Disjoint.preimage _ _âŸ©
    Â· rw [Set.disjoint_left]
      rintro _ âŸ¨x, rflâŸ© (rfl : g (e x) = b)
      exact hb' âŸ¨x, (congr_fun hgf x).symmâŸ©
    Â· exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.closed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    âŸ¨dg, dg0, dgb, dgmemâŸ©
  replace hgf : âˆ€ x, (g - dg) (e x) = f x
  Â· intro x
    simp [dg0 (Or.inl <| mem_range_self _), â† hgf]
  refine' âŸ¨g - dg, fun y => _, funext hgfâŸ©
  Â· have hyb : (g - dg) y < b := by
      rcases(hgb y).eq_or_lt with (rfl | hlt)
      Â· refine' (sub_lt_self_iff _).2 _
        calc
          0 < g y - c := sub_pos.2 hcb
          _ = dg y := (dgb rfl).symm
      Â· exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
    rcases hb.exists_between hyb with âŸ¨_, âŸ¨xu, rflâŸ©, hyxu, _âŸ©
    cases' lt_or_le c (g y) with hc hc
    Â· rcases em (a âˆˆ range f) with (âŸ¨x, rflâŸ© | _)
      Â· refine' âŸ¨x, xu, _, hyxu.leâŸ©
        calc
          f x = c - (b - c) := by rw [â† hsub, sub_sub_cancel]
          _ â‰¤ g y - dg y := sub_le_sub hc.le (dgmem _).2
      Â· have hay : a < (g - dg) y := by
          calc
            a = c - (b - c) := by rw [â† hsub, sub_sub_cancel]
            _ < g y - (b - c) := (sub_lt_sub_right hc _)
            _ â‰¤ g y - dg y := sub_le_sub_left (dgmem _).2 _
        rcases ha.exists_between hay with âŸ¨_, âŸ¨x, rflâŸ©, _, hxyâŸ©
        exact âŸ¨x, xu, hxy.le, hyxu.leâŸ©
    Â· refine' âŸ¨xl y, xu, _, hyxu.leâŸ©
      simp [dg0 (Or.inr hc), hxl]","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case intro.intro.inr.intro.intro.intro
X : Type u_1
Y : Type u_2
instâœÂ³ : TopologicalSpace X
instâœÂ² : TopologicalSpace Y
instâœÂ¹ : NormalSpace Y
instâœ : Nonempty X
f : X â†’áµ‡ â„
e : X â†’ Y
he : ClosedEmbedding e
inhabited_h : Inhabited X
a : â„
ha : IsGLB (range â‡‘f) a
b : â„
hb : IsLUB (range â‡‘f) b
hmem : âˆ€ (x : X), f x âˆˆ Icc a b
hle : a â‰¤ b
hlt : a < b
c : â„ := (a + b) / 2
hac : a < c
hcb : c < b
hsub : c - a = b - c
g : Y â†’áµ‡ â„
hg_mem : âˆ€ (y : Y), g y âˆˆ Icc a b
ha' : Â¬âˆƒ x, f x = a
hd : Disjoint (range e âˆª â‡‘g â»Â¹' Ici c) (â‡‘g â»Â¹' {a})
dg : Y â†’áµ‡ â„
dg0 : EqOn (â‡‘dg) (Function.const Y 0) (range e âˆª â‡‘g â»Â¹' Ici c)
dga : EqOn (â‡‘dg) (Function.const Y (c - a)) (â‡‘g â»Â¹' {a})
dgmem : âˆ€ (x : Y), dg x âˆˆ Icc 0 (c - a)
hgf : âˆ€ (x : X), (g + dg) (e x) = f x
âŠ¢ âˆƒ g, (âˆ€ (y : Y), âˆƒ x, g y âˆˆ Icc (f x) b) âˆ§ â‡‘g âˆ˜ e = â‡‘f
error:  unsolved goals
case intro.intro.inr.intro.intro
X : Type u_1
Y : Type u_2
instâœÂ³ : TopologicalSpace X
instâœÂ² : TopologicalSpace Y
instâœÂ¹ : NormalSpace Y
instâœ : Nonempty X
f : X â†’áµ‡ â„
e : X â†’ Y
he : ClosedEmbedding e
inhabited_h : Inhabited X
a : â„
ha : IsGLB (range â‡‘f) a
b : â„
hb : IsLUB (range â‡‘f) b
hmem : âˆ€ (x : X), f x âˆˆ Icc a b
hle : a â‰¤ b
hlt : a < b
c : â„ := (a + b) / 2
hac : a < c
hcb : c < b
hsub : c - a = b - c
g : Y â†’áµ‡ â„
hg_mem : âˆ€ (y : Y), âˆƒ x, g y âˆˆ Icc (f x) b
hgf : â‡‘g âˆ˜ e = â‡‘f
âŠ¢ âˆƒ g, (âˆ€ (y : Y), âˆƒ xâ‚ xâ‚‚, g y âˆˆ Icc (f xâ‚) (f xâ‚‚)) âˆ§ â‡‘g âˆ˜ e = â‡‘f","theorem exists_extension_forall_exists_le_ge_of_closedEmbedding [Nonempty X] (f : X â†’áµ‡ â„)
    {e : X â†’ Y} (he : ClosedEmbedding e) :
    âˆƒ g : Y â†’áµ‡ â„, (âˆ€ y, âˆƒ xâ‚ xâ‚‚, g y âˆˆ Icc (f xâ‚) (f xâ‚‚)) âˆ§ g âˆ˜ e = f ",":= by
  inhabit X
  obtain âŸ¨a, haâŸ© : âˆƒ a, IsGLB (range f) a := âŸ¨_, isGLB_ciInf f.isBounded_range.bddBelowâŸ©
  obtain âŸ¨b, hbâŸ© : âˆƒ b, IsLUB (range f) b := âŸ¨_, isLUB_ciSup f.isBounded_range.bddAboveâŸ©
  have hmem : âˆ€ x, f x âˆˆ Icc a b := fun x => âŸ¨ha.1 âŸ¨x, rflâŸ©, hb.1 âŸ¨x, rflâŸ©âŸ©
  have hle : a â‰¤ b := (hmem default).1.trans (hmem default).2
  rcases hle.eq_or_lt with (rfl | hlt)
  Â· have : âˆ€ x, f x = a := by simpa using hmem
    use const Y a
    simp [this, Function.funext_iff]
  set c := (a + b) / 2
  have hac : a < c := left_lt_add_div_two.2 hlt
  have hcb : c < b := add_div_two_lt_right.2 hlt
  have hsub : c - a = b - c := by
    field_simp [c]
    ring
  obtain âŸ¨g, hg_mem, hgfâŸ© : âˆƒ g : Y â†’áµ‡ â„, (âˆ€ y, âˆƒ x, g y âˆˆ Icc (f x) b) âˆ§ g âˆ˜ e = f := by
    rcases exists_extension_forall_mem_Icc_of_closedEmbedding f hmem hle he with âŸ¨g, hg_mem, hgfâŸ©
    rcases em (âˆƒ x, f x = a) with (âŸ¨x, rflâŸ© | ha')
    Â· exact âŸ¨g, fun y => âŸ¨x, hg_mem _âŸ©, hgfâŸ©
    have hd : Disjoint (range e âˆª g â»Â¹' Ici c) (g â»Â¹' {a}) := by
      refine disjoint_union_left.2 âŸ¨?_, Disjoint.preimage _ ?_âŸ©
      Â· rw [Set.disjoint_left]
        rintro _ âŸ¨x, rflâŸ© (rfl : g (e x) = a)
        exact ha' âŸ¨x, (congr_fun hgf x).symmâŸ©
      Â· exact Set.disjoint_singleton_right.2 hac.not_le
    rcases exists_bounded_mem_Icc_of_closed_of_le
        (he.isClosed_range.union <| isClosed_Ici.preimage g.continuous)
        (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hac.le) with
      âŸ¨dg, dg0, dga, dgmemâŸ©
    replace hgf : âˆ€ x, (g + dg) (e x) = f x := by
      intro x
      simp [dg0 (Or.inl <| mem_range_self _), â† hgf]
    refine âŸ¨g + dg, fun y => ?_, funext hgfâŸ©
    have hay : a < (g + dg) y := by
      rcases (hg_mem y).1.eq_or_lt with (rfl | hlt)
      Â· refine (lt_add_iff_pos_right _).2 ?_
        calc
          0 < c - g y := sub_pos.2 hac
          _ = dg y := (dga rfl).symm
      Â· exact hlt.trans_le (le_add_of_nonneg_right (dgmem y).1)
    rcases ha.exists_between hay with âŸ¨_, âŸ¨x, rflâŸ©, _, hxyâŸ©
    refine âŸ¨x, hxy.le, ?_âŸ©
    rcases le_total c (g y) with hc | hc
    Â· simp [dg0 (Or.inr hc), (hg_mem y).2]
    Â· calc
        g y + dg y â‰¤ c + (c - a) := add_le_add hc (dgmem _).2
        _ = b := by rw [hsub, add_sub_cancel]
  choose xl hxl hgb using hg_mem
  rcases em (âˆƒ x, f x = b) with (âŸ¨x, rflâŸ© | hb')
  Â· exact âŸ¨g, fun y => âŸ¨xl y, x, hxl y, hgb yâŸ©, hgfâŸ©
  have hd : Disjoint (range e âˆª g â»Â¹' Iic c) (g â»Â¹' {b}) := by
    refine disjoint_union_left.2 âŸ¨?_, Disjoint.preimage _ ?_âŸ©
    Â· rw [Set.disjoint_left]
      rintro _ âŸ¨x, rflâŸ© (rfl : g (e x) = b)
      exact hb' âŸ¨x, (congr_fun hgf x).symmâŸ©
    Â· exact Set.disjoint_singleton_right.2 hcb.not_le
  rcases exists_bounded_mem_Icc_of_closed_of_le
      (he.isClosed_range.union <| isClosed_Iic.preimage g.continuous)
      (isClosed_singleton.preimage g.continuous) hd (sub_nonneg.2 hcb.le) with
    âŸ¨dg, dg0, dgb, dgmemâŸ©
  replace hgf : âˆ€ x, (g - dg) (e x) = f x := by
    intro x
    simp [dg0 (Or.inl <| mem_range_self _), â† hgf]
  refine âŸ¨g - dg, fun y => ?_, funext hgfâŸ©
  have hyb : (g - dg) y < b := by
    rcases (hgb y).eq_or_lt with (rfl | hlt)
    Â· refine (sub_lt_self_iff _).2 ?_
      calc
        0 < g y - c := sub_pos.2 hcb
        _ = dg y := (dgb rfl).symm
    Â· exact ((sub_le_self_iff _).2 (dgmem _).1).trans_lt hlt
  rcases hb.exists_between hyb with âŸ¨_, âŸ¨xu, rflâŸ©, hyxu, _âŸ©
  cases' lt_or_le c (g y) with hc hc
  Â· rcases em (a âˆˆ range f) with (âŸ¨x, rflâŸ© | _)
    Â· refine âŸ¨x, xu, ?_, hyxu.leâŸ©
      calc
        f x = c - (b - c) := by rw [â† hsub, sub_sub_cancel]
        _ â‰¤ g y - dg y := sub_le_sub hc.le (dgmem _).2
    Â· have hay : a < (g - dg) y := by
        calc
          a = c - (b - c) := by rw [â† hsub, sub_sub_cancel]
          _ < g y - (b - c) := sub_lt_sub_right hc _
          _ â‰¤ g y - dg y := sub_le_sub_left (dgmem _).2 _
      rcases ha.exists_between hay with âŸ¨_, âŸ¨x, rflâŸ©, _, hxyâŸ©
      exact âŸ¨x, xu, hxy.le, hyxu.leâŸ©
  Â· refine âŸ¨xl y, xu, ?_, hyxu.leâŸ©
    simp [dg0 (Or.inr hc), hxl]"
Mathlib/Algebra/GroupWithZero/Units/Basic.lean,isUnit_iff_ne_zero,isUnit_iff_ne_zero,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  Units.exists_iff_ne_zero","error:  type mismatch
  Units.exists_iff_ne_zero
has type
  (âˆƒ u, ?m.18082 â†‘u) â†” âˆƒ x, x â‰  0 âˆ§ ?m.18082 x : Prop
but is expected to have type
  IsUnit a â†” a â‰  0 : Prop
warning:  declaration uses 'sorry'
warning:  `IsUnit.div_mul_left` has been deprecated, use `div_mul_cancel_right` instead
warning:  `IsUnit.div_mul_right` has been deprecated, use `div_mul_cancel_left` instead",theorem isUnit_iff_ne_zero : IsUnit a â†” a â‰  0 ,":=
  (Units.exists_iff_ne_zero (p := (Â· = a))).trans (by simp)"
Mathlib/Analysis/Convex/Mul.lean,ConvexOn.smul',ConvexOn.smul',54f7158db90360ed2142693f55c501ce19411627,":= by
  refine âŸ¨hf.1, fun x hx y hy a b ha hb hab â†¦ ?_âŸ©
  dsimp
  refine (smul_le_smul (hf.2 hx hy ha hb hab) (hg.2 hx hy ha hb hab) (hgâ‚€ $ hf.1 hx hy ha hb hab) $
    add_nonneg (smul_nonneg ha $ hfâ‚€ hx) $ smul_nonneg hb $ hfâ‚€ hy).trans ?_
  calc
      _ = (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g y + f y â€¢ g x) := ?_
    _ â‰¤ (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g x + f y â€¢ g y) := by
        gcongr _ + (a * b) â€¢ ?_; exact hfg.smul_add_smul_le_smul_add_smul hx hy
    _ = (a * (a + b)) â€¢ (f x â€¢ g x) + (b * (a + b)) â€¢ (f y â€¢ g y) := by
        simp only [mul_add, add_smul, smul_add, mul_comm _ a]; abel
    _ = _ := by simp_rw [hab, mul_one]
  simp only [mul_add, add_smul, smul_add]
  rw [â†smul_smul_smul_comm a, â†smul_smul_smul_comm b, â†smul_smul_smul_comm a b,
    â†smul_smul_smul_comm b b, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_comm b,
    add_comm _ ((b * b) â€¢ f y â€¢ g y), add_add_add_comm, add_comm ((a * b) â€¢ f y â€¢ g x)]","error:  application type mismatch
  smul_le_smul (hf.right hx hy ha hb hab) (hg.right hx hy ha hb hab) (hgâ‚€ (hf.left hx hy ha hb hab))
argument
  hgâ‚€ (hf.left hx hy ha hb hab)
has type
  0 â‰¤ g (a â€¢ x + b â€¢ y) : Prop
but is expected to have type
  0 â‰¤ f (a â€¢ x + b â€¢ y) : Prop
error:  application type mismatch
  smul_nonneg ha (hfâ‚€ hx)
argument
  hfâ‚€ hx
has type
  0 â‰¤ f x : Prop
but is expected to have type
  0 â‰¤ g x : Prop
error:  application type mismatch
  smul_nonneg hb (hfâ‚€ hy)
argument
  hfâ‚€ hy
has type
  0 â‰¤ f y : Prop
but is expected to have type
  0 â‰¤ g y : Prop","lemma ConvexOn.smul' (hf : ConvexOn ğ•œ s f) (hg : ConvexOn ğ•œ s g) (hfâ‚€ : âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ 0 â‰¤ f x)
    (hgâ‚€ : âˆ€ â¦ƒxâ¦„, x âˆˆ s â†’ 0 â‰¤ g x) (hfg : MonovaryOn f g s) : ConvexOn ğ•œ s (f â€¢ g) ",":= by
  refine âŸ¨hf.1, fun x hx y hy a b ha hb hab â†¦ ?_âŸ©
  dsimp
  refine
    (smul_le_smul (hf.2 hx hy ha hb hab) (hg.2 hx hy ha hb hab) (hfâ‚€ <| hf.1 hx hy ha hb hab) <|
      add_nonneg (smul_nonneg ha <| hgâ‚€ hx) <| smul_nonneg hb <| hgâ‚€ hy).trans ?_
  calc
      _ = (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g y + f y â€¢ g x) := ?_
    _ â‰¤ (a * a) â€¢ (f x â€¢ g x) + (b * b) â€¢ (f y â€¢ g y) + (a * b) â€¢ (f x â€¢ g x + f y â€¢ g y) := by
        gcongr _ + (a * b) â€¢ ?_; exact hfg.smul_add_smul_le_smul_add_smul hx hy
    _ = (a * (a + b)) â€¢ (f x â€¢ g x) + (b * (a + b)) â€¢ (f y â€¢ g y) := by
        simp only [mul_add, add_smul, smul_add, mul_comm _ a]; abel
    _ = _ := by simp_rw [hab, mul_one]
  simp only [mul_add, add_smul, smul_add]
  rw [â† smul_smul_smul_comm a, â† smul_smul_smul_comm b, â† smul_smul_smul_comm a b,
    â† smul_smul_smul_comm b b, smul_eq_mul, smul_eq_mul, smul_eq_mul, smul_eq_mul, mul_comm b,
    add_comm _ ((b * b) â€¢ f y â€¢ g y), add_add_add_comm, add_comm ((a * b) â€¢ f y â€¢ g x)]"
Mathlib/Algebra/Homology/HomologicalComplex.lean,HomologicalComplex.isZero_zero,isZero_zero,fb98761d788707d6cdd69ffa788a8c96aafbbe4b,":= by
  refine' âŸ¨fun X => âŸ¨âŸ¨âŸ¨0âŸ©, fun f => _âŸ©âŸ©, fun X => âŸ¨âŸ¨âŸ¨0âŸ©, fun f => _âŸ©âŸ©âŸ©
  all_goals
    ext
    dsimp only [zero]
    subsingleton","error:  unknown tactic
error:  unsolved goals
case refine'_1.h
Î¹ : Type u_1
V : Type u
instâœÂ² : Category.{v, u} V
instâœÂ¹ : HasZeroMorphisms V
c : ComplexShape Î¹
C : HomologicalComplex V c
instâœ : HasZeroObject V
X : HomologicalComplex V c
f : zero âŸ¶ X
iâœ : Î¹
âŠ¢ f.f iâœ = Hom.f 0 iâœ

case refine'_2.h
Î¹ : Type u_1
V : Type u
instâœÂ² : Category.{v, u} V
instâœÂ¹ : HasZeroMorphisms V
c : ComplexShape Î¹
C : HomologicalComplex V c
instâœ : HasZeroObject V
X : HomologicalComplex V c
f : X âŸ¶ zero
iâœ : Î¹
âŠ¢ f.f iâœ = Hom.f 0 iâœ",theorem isZero_zero [HasZeroObject V] : IsZero (zero : HomologicalComplex V c) ,":= by
  refine âŸ¨fun X => âŸ¨âŸ¨âŸ¨0âŸ©, fun f => ?_âŸ©âŸ©, fun X => âŸ¨âŸ¨âŸ¨0âŸ©, fun f => ?_âŸ©âŸ©âŸ©
  all_goals
    ext
    dsimp [zero]
    apply Subsingleton.elim"
Mathlib/AlgebraicGeometry/EllipticCurve/Jacobian.lean,WeierstrassCurve.Jacobian.X_eq_of_equiv,X_eq_of_equiv,5f623dbbfb1d9c0f7f7df0c222909ea19906d81f,":= by
  rcases h with âŸ¨u, rflâŸ©
  simp only [smul_fin3_ext]
  ring1","error:  ring failed, ring expressions not equal
R : Type u
instâœÂ¹ : CommRing R
W' : Jacobian R
F : Type v
instâœ : Field F
W : Jacobian F
Q : Fin 3 â†’ R
u : RË£
âŠ¢ (u â€¢ Q) x * Q z ^ 2 = Q x * (u â€¢ Q) z ^ 2",lemma X_eq_of_equiv {P Q : Fin 3 â†’ R} (h : P â‰ˆ Q) : P x * Q z ^ 2 = Q x * P z ^ 2 ,":= by
  rcases h with âŸ¨u, rflâŸ©
  simp only [Units.smul_def, smul_fin3_ext]
  ring1"
Mathlib/AlgebraicTopology/SimplexCategory.lean,SimplexCategory.Î´_comp_Ïƒ_self,Î´_comp_Ïƒ_self,7472132820a806816d92180a5476e45b47a8d68b,":= by
  exact Hom.ext _ _ (OrderHom.ext _ _ (Fin.predAbove_comp_succAbove_castSucc))",error:  unknown constant 'Fin.predAbove_comp_succAbove_castSucc',"theorem Î´_comp_Ïƒ_self {n} {i : Fin (n + 1)} :
    Î´ (Fin.castSucc i) â‰« Ïƒ i = ğŸ™ ([n] : SimplexCategory) ",":= by
  rcases i with âŸ¨i, hiâŸ©
  ext âŸ¨j, hjâŸ©
  simp? at hj says simp only [len_mk] at hj
  dsimp [Ïƒ, Î´, Fin.predAbove, Fin.succAbove]
  simp only [Fin.lt_iff_val_lt_val, Fin.dite_val, Fin.ite_val, Fin.coe_pred, ge_iff_le,
    Fin.coe_castLT, dite_eq_ite]
  split_ifs
  any_goals simp
  all_goals omega"
Mathlib/Analysis/Seminorm.lean,Seminorm.bddBelow_range_add,bddBelow_range_add,25809c65be2c5ba2d25f9844e146d865bb6309d4,":=
  âŸ¨0, by
    rintro _ âŸ¨x, rflâŸ©
    exact add_nonneg (map_nonneg _ _) (map_nonneg _ _)âŸ©","error:  failed to synthesize
  Preorder E
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  Preorder E
use `set_option diagnostics true` to get diagnostic information",theorem bddBelow_range_add : BddBelow (range fun u => p u + q (x - u)) ,":=
  âŸ¨0, by
    rintro _ âŸ¨x, rflâŸ©
    dsimp; positivityâŸ©"
Mathlib/Combinatorics/SetFamily/HarrisKleitman.lean,IsLowerSet.le_card_inter_finset,IsLowerSet.le_card_inter_finset,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  induction' s using Finset.induction with a s hs ih generalizing ğ’œ â„¬
  Â· simp_rw [subset_empty, â† subset_singleton_iff', subset_singleton_iff] at hğ’œs hâ„¬s
    obtain rfl | rfl := hğ’œs
    Â· simp only [card_empty, zero_mul, empty_inter, mul_zero, le_refl]
    obtain rfl | rfl := hâ„¬s
    Â· simp only [card_empty, inter_empty, mul_zero, zero_mul, le_refl]
    Â· simp only [card_empty, pow_zero, inter_singleton_of_mem, mem_singleton, card_singleton,
        le_refl]
  rw [card_insert_of_not_mem hs, â† card_memberSubfamily_add_card_nonMemberSubfamily a ğ’œ, â†
    card_memberSubfamily_add_card_nonMemberSubfamily a â„¬, add_mul, mul_add, mul_add,
    add_comm (_ * _), add_add_add_comm]
  refine'
    (add_le_add_right
          (mul_add_mul_le_mul_add_mul
              (card_le_card hğ’œ.memberSubfamily_subset_nonMemberSubfamily) <|
            card_le_card hâ„¬.memberSubfamily_subset_nonMemberSubfamily)
          _).trans
      _
  rw [â† two_mul, pow_succ, mul_assoc]
  have hâ‚€ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’
      âˆ€ t âˆˆ ğ’.nonMemberSubfamily a, t âŠ† s := by
    rintro ğ’ hğ’ t ht
    rw [mem_nonMemberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 (hğ’ _ ht.1)
  have hâ‚ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’
      âˆ€ t âˆˆ ğ’.memberSubfamily a, t âŠ† s := by
    rintro ğ’ hğ’ t ht
    rw [mem_memberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 ((subset_insert _ _).trans <| hğ’ _ ht.1)
  refine' mul_le_mul_left' _ _
  refine' (add_le_add (ih hğ’œ.memberSubfamily hâ„¬.memberSubfamily (hâ‚ _ hğ’œs) <| hâ‚ _ hâ„¬s) <|
    ih hğ’œ.nonMemberSubfamily hâ„¬.nonMemberSubfamily (hâ‚€ _ hğ’œs) <| hâ‚€ _ hâ„¬s).trans_eq _
  rw [â† mul_add, â† memberSubfamily_inter, â† nonMemberSubfamily_inter,
    card_memberSubfamily_add_card_nonMemberSubfamily]","error:  typeclass instance problem is stuck, it is often due to metavariables
  CovariantClass ?m.7655 ?m.7655 (fun x x_1 â†¦ x * x_1) fun x x_1 â†¦ x â‰¤ x_1","theorem IsLowerSet.le_card_inter_finset' (hğ’œ : IsLowerSet (ğ’œ : Set (Finset Î±)))
    (hâ„¬ : IsLowerSet (â„¬ : Set (Finset Î±))) (hğ’œs : âˆ€ t âˆˆ ğ’œ, t âŠ† s) (hâ„¬s : âˆ€ t âˆˆ â„¬, t âŠ† s) :
    ğ’œ.card * â„¬.card â‰¤ 2 ^ s.card * (ğ’œ âˆ© â„¬).card ",":= by
  induction' s using Finset.induction with a s hs ih generalizing ğ’œ â„¬
  Â· simp_rw [subset_empty, â† subset_singleton_iff', subset_singleton_iff] at hğ’œs hâ„¬s
    obtain rfl | rfl := hğ’œs
    Â· simp only [card_empty, zero_mul, empty_inter, mul_zero, le_refl]
    obtain rfl | rfl := hâ„¬s
    Â· simp only [card_empty, inter_empty, mul_zero, zero_mul, le_refl]
    Â· simp only [card_empty, pow_zero, inter_singleton_of_mem, mem_singleton, card_singleton,
        le_refl]
  rw [card_insert_of_not_mem hs, â† card_memberSubfamily_add_card_nonMemberSubfamily a ğ’œ, â†
    card_memberSubfamily_add_card_nonMemberSubfamily a â„¬, add_mul, mul_add, mul_add,
    add_comm (_ * _), add_add_add_comm]
  refine
    (add_le_add_right
          (mul_add_mul_le_mul_add_mul
              (card_le_card hğ’œ.memberSubfamily_subset_nonMemberSubfamily) <|
            card_le_card hâ„¬.memberSubfamily_subset_nonMemberSubfamily)
          _).trans
      ?_
  rw [â† two_mul, pow_succ', mul_assoc]
  have hâ‚€ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’
      âˆ€ t âˆˆ ğ’.nonMemberSubfamily a, t âŠ† s := by
    rintro ğ’ hğ’ t ht
    rw [mem_nonMemberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 (hğ’ _ ht.1)
  have hâ‚ : âˆ€ ğ’ : Finset (Finset Î±), (âˆ€ t âˆˆ ğ’, t âŠ† insert a s) â†’
      âˆ€ t âˆˆ ğ’.memberSubfamily a, t âŠ† s := by
    rintro ğ’ hğ’ t ht
    rw [mem_memberSubfamily] at ht
    exact (subset_insert_iff_of_not_mem ht.2).1 ((subset_insert _ _).trans <| hğ’ _ ht.1)
  refine mul_le_mul_left' ?_ _
  refine (add_le_add (ih hğ’œ.memberSubfamily hâ„¬.memberSubfamily (hâ‚ _ hğ’œs) <| hâ‚ _ hâ„¬s) <|
    ih hğ’œ.nonMemberSubfamily hâ„¬.nonMemberSubfamily (hâ‚€ _ hğ’œs) <| hâ‚€ _ hâ„¬s).trans_eq ?_
  rw [â† mul_add, â† memberSubfamily_inter, â† nonMemberSubfamily_inter,
    card_memberSubfamily_add_card_nonMemberSubfamily]"
Mathlib/Order/OrderIsoNat.lean,exists_increasing_or_nonincreasing_subseq',exists_increasing_or_nonincreasing_subseq',ef3c9bcd07782b044027916a64e925f3e4951707,":= by
  classical
    let bad : Set â„• := { m | âˆ€ n, m < n â†’ Â¬r (f m) (f n) }
    by_cases hbad : Infinite bad
    Â· haveI := hbad
      refine âŸ¨Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => ?_âŸ©
      have h := @Set.mem_range_self _ _ â†‘(Nat.orderEmbeddingOfSet bad) m
      rw [Nat.orderEmbeddingOfSet_range bad] at h
      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)
    Â· rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad
      obtain âŸ¨m, hmâŸ© : âˆƒ m, âˆ€ n, m â‰¤ n â†’ Â¬n âˆˆ bad := by
        by_cases he : hbad.toFinset.Nonempty
        Â· refine
            âŸ¨(hbad.toFinset.max' he).succ, fun n hn nbad =>
              Nat.not_succ_le_self _
                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))âŸ©
        Â· exact âŸ¨0, fun n _ nbad => he âŸ¨n, hbad.mem_toFinset.2 nbadâŸ©âŸ©
      have h : âˆ€ n : â„•, âˆƒ n' : â„•, n < n' âˆ§ r (f (n + m)) (f (n' + m)) := by
        intro n
        have h := hm _ (le_add_of_nonneg_left n.zero_le)
        simp only [bad, exists_prop, not_not, Set.mem_setOf_eq, not_forall] at h
        obtain âŸ¨n', hn1, hn2âŸ© := h
        obtain âŸ¨x, hpos, rflâŸ© := exists_pos_add_of_lt hn1
        refine âŸ¨n + x, add_lt_add_left hpos n, ?_âŸ©
        rw [add_assoc, add_comm x m, â† add_assoc]
        exact hn2
      let g' : â„• â†’ â„• := @Nat.rec (fun _ => â„•) m fun n gn => Nat.find (h gn)
      exact
        âŸ¨(RelEmbedding.natLT (fun n => g' n + m) fun n =>
              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,
          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2âŸ©","error:  failed to synthesize
  CovariantClass â„• â„• (Function.swap fun x x_1 â†¦ x + x_1) fun x x_1 â†¦ x â‰¤ x_1
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  exists_pos_add_of_lt hn1
argument
  hn1
has type
  @LT.lt â„• instLTNat (n + m) n' : Prop
but is expected to have type
  @LT.lt â„• Preorder.toLT (n + m) n' : Prop","theorem exists_increasing_or_nonincreasing_subseq' (r : Î± â†’ Î± â†’ Prop) (f : â„• â†’ Î±) :
    âˆƒ g : â„• â†ªo â„•,
      (âˆ€ n : â„•, r (f (g n)) (f (g (n + 1)))) âˆ¨ âˆ€ m n : â„•, m < n â†’ Â¬r (f (g m)) (f (g n)) ",":= by
  classical
    let bad : Set â„• := { m | âˆ€ n, m < n â†’ Â¬r (f m) (f n) }
    by_cases hbad : Infinite bad
    Â· haveI := hbad
      refine âŸ¨Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => ?_âŸ©
      have h := @Set.mem_range_self _ _ â†‘(Nat.orderEmbeddingOfSet bad) m
      rw [Nat.orderEmbeddingOfSet_range bad] at h
      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)
    Â· rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad
      obtain âŸ¨m, hmâŸ© : âˆƒ m, âˆ€ n, m â‰¤ n â†’ Â¬n âˆˆ bad := by
        by_cases he : hbad.toFinset.Nonempty
        Â· refine
            âŸ¨(hbad.toFinset.max' he).succ, fun n hn nbad =>
              Nat.not_succ_le_self _
                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))âŸ©
        Â· exact âŸ¨0, fun n _ nbad => he âŸ¨n, hbad.mem_toFinset.2 nbadâŸ©âŸ©
      have h : âˆ€ n : â„•, âˆƒ n' : â„•, n < n' âˆ§ r (f (n + m)) (f (n' + m)) := by
        intro n
        have h := hm _ (Nat.le_add_left m n)
        simp only [bad, exists_prop, not_not, Set.mem_setOf_eq, not_forall] at h
        obtain âŸ¨n', hn1, hn2âŸ© := h
        refine âŸ¨n + n' - n - m, by omega, ?_âŸ©
        convert hn2
        omega
      let g' : â„• â†’ â„• := @Nat.rec (fun _ => â„•) m fun n gn => Nat.find (h gn)
      exact
        âŸ¨(RelEmbedding.natLT (fun n => g' n + m) fun n =>
              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,
          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2âŸ©"
Mathlib/MeasureTheory/Measure/Regular.lean,MeasureTheory.Measure.OuterRegular.of_restrict,of_restrict,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  refine âŸ¨fun A hA r hr => ?_âŸ©
  have HA : Î¼ A < âˆ := lt_of_lt_of_le hr le_top
  have hm : âˆ€ n, MeasurableSet (s n) := fun n => (h' n).measurableSet
  obtain âŸ¨A, hAm, hAs, hAd, rflâŸ© :
    âˆƒ A' : â„• â†’ Set Î±,
      (âˆ€ n, MeasurableSet (A' n)) âˆ§
        (âˆ€ n, A' n âŠ† s n) âˆ§ Pairwise (Disjoint on A') âˆ§ A = â‹ƒ n, A' n := by
    refine'
      âŸ¨fun n => A âˆ© disjointed s n, fun n => hA.inter (MeasurableSet.disjointed hm _), fun n =>
        (inter_subset_right _ _).trans (disjointed_subset _ _),
        (disjoint_disjointed s).mono fun k l hkl => hkl.mono inf_le_right inf_le_right, _âŸ©
    rw [â† inter_iUnion, iUnion_disjointed, univ_subset_iff.mp h'', inter_univ]
  rcases ENNReal.exists_pos_sum_of_countable' (tsub_pos_iff_lt.2 hr).ne' â„• with âŸ¨Î´, Î´0, hÎ´ÎµâŸ©
  rw [lt_tsub_iff_right, add_comm] at hÎ´Îµ
  have : âˆ€ n, âˆƒ U âŠ‡ A n, IsOpen U âˆ§ Î¼ U < Î¼ (A n) + Î´ n := by
    intro n
    have Hâ‚ : âˆ€ t, Î¼.restrict (s n) t = Î¼ (t âˆ© s n) := fun t => restrict_apply' (hm n)
    have Ht : Î¼.restrict (s n) (A n) â‰  âˆ := by
      rw [Hâ‚]
      exact ((measure_mono ((inter_subset_left _ _).trans (subset_iUnion A n))).trans_lt HA).ne
    rcases (A n).exists_isOpen_lt_add Ht (Î´0 n).ne' with âŸ¨U, hAU, hUo, hUâŸ©
    rw [Hâ‚, Hâ‚, inter_eq_self_of_subset_left (hAs _)] at hU
    exact âŸ¨U âˆ© s n, subset_inter hAU (hAs _), hUo.inter (h' n), hUâŸ©
  choose U hAU hUo hU using this
  refine' âŸ¨â‹ƒ n, U n, iUnion_mono hAU, isOpen_iUnion hUo, _âŸ©
  calc
    Î¼ (â‹ƒ n, U n) â‰¤ âˆ‘' n, Î¼ (U n) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Î¼ (A n) + Î´ n) := ENNReal.tsum_le_tsum fun n => (hU n).le
    _ = âˆ‘' n, Î¼ (A n) + âˆ‘' n, Î´ n := ENNReal.tsum_add
    _ = Î¼ (â‹ƒ n, A n) + âˆ‘' n, Î´ n := (congr_argâ‚‚ (Â· + Â·) (measure_iUnion hAd hAm).symm rfl)
    _ < r := hÎ´Îµ","error:  function expected at
  inter_subset_right ?m.25404
term has type
  ?m.25403 âˆˆ ?m.25402
error:  function expected at
  inter_subset_left ?m.28241
term has type
  ?m.28240 âˆˆ ?m.28238","lemma of_restrict [OpensMeasurableSpace Î±] {Î¼ : Measure Î±} {s : â„• â†’ Set Î±}
    (h : âˆ€ n, OuterRegular (Î¼.restrict (s n))) (h' : âˆ€ n, IsOpen (s n)) (h'' : univ âŠ† â‹ƒ n, s n) :
    OuterRegular Î¼ ",":= by
  refine âŸ¨fun A hA r hr => ?_âŸ©
  have HA : Î¼ A < âˆ := lt_of_lt_of_le hr le_top
  have hm : âˆ€ n, MeasurableSet (s n) := fun n => (h' n).measurableSet
  obtain âŸ¨A, hAm, hAs, hAd, rflâŸ© :
    âˆƒ A' : â„• â†’ Set Î±,
      (âˆ€ n, MeasurableSet (A' n)) âˆ§
        (âˆ€ n, A' n âŠ† s n) âˆ§ Pairwise (Disjoint on A') âˆ§ A = â‹ƒ n, A' n := by
    refine
      âŸ¨fun n => A âˆ© disjointed s n, fun n => hA.inter (MeasurableSet.disjointed hm _), fun n =>
        inter_subset_right.trans (disjointed_subset _ _),
        (disjoint_disjointed s).mono fun k l hkl => hkl.mono inf_le_right inf_le_right, ?_âŸ©
    rw [â† inter_iUnion, iUnion_disjointed, univ_subset_iff.mp h'', inter_univ]
  rcases ENNReal.exists_pos_sum_of_countable' (tsub_pos_iff_lt.2 hr).ne' â„• with âŸ¨Î´, Î´0, hÎ´ÎµâŸ©
  rw [lt_tsub_iff_right, add_comm] at hÎ´Îµ
  have : âˆ€ n, âˆƒ U âŠ‡ A n, IsOpen U âˆ§ Î¼ U < Î¼ (A n) + Î´ n := by
    intro n
    have Hâ‚ : âˆ€ t, Î¼.restrict (s n) t = Î¼ (t âˆ© s n) := fun t => restrict_apply' (hm n)
    have Ht : Î¼.restrict (s n) (A n) â‰  âˆ := by
      rw [Hâ‚]
      exact ((measure_mono (inter_subset_left.trans (subset_iUnion A n))).trans_lt HA).ne
    rcases (A n).exists_isOpen_lt_add Ht (Î´0 n).ne' with âŸ¨U, hAU, hUo, hUâŸ©
    rw [Hâ‚, Hâ‚, inter_eq_self_of_subset_left (hAs _)] at hU
    exact âŸ¨U âˆ© s n, subset_inter hAU (hAs _), hUo.inter (h' n), hUâŸ©
  choose U hAU hUo hU using this
  refine âŸ¨â‹ƒ n, U n, iUnion_mono hAU, isOpen_iUnion hUo, ?_âŸ©
  calc
    Î¼ (â‹ƒ n, U n) â‰¤ âˆ‘' n, Î¼ (U n) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (Î¼ (A n) + Î´ n) := ENNReal.tsum_le_tsum fun n => (hU n).le
    _ = âˆ‘' n, Î¼ (A n) + âˆ‘' n, Î´ n := ENNReal.tsum_add
    _ = Î¼ (â‹ƒ n, A n) + âˆ‘' n, Î´ n := (congr_argâ‚‚ (Â· + Â·) (measure_iUnion hAd hAm).symm rfl)
    _ < r := hÎ´Îµ"
Mathlib/FieldTheory/NormalClosure.lean,Algebra.IsAlgebraic.isNormalClosure_iff,isNormalClosure_iff,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  refine âŸ¨fun âŸ¨splits, hâŸ© â†¦ âŸ¨splits, ?_âŸ©, fun âŸ¨splits, hâŸ© â†¦ âŸ¨splits, ?_âŸ©âŸ© <;>
    simpa only [alg.normalClosure_eq_iSup_adjoin_of_splits splits] using h","error:  type mismatch
  hâœ
has type
  â¨† x, IntermediateField.adjoin F ((minpoly F x).rootSet L) = âŠ¤ : Prop
but is expected to have type
  normalClosure F K L = âŠ¤ : Prop
error:  type mismatch
  hâœ
has type
  normalClosure F K L = âŠ¤ : Prop
but is expected to have type
  â¨† x, IntermediateField.adjoin F ((minpoly F x).rootSet L) = âŠ¤ : Prop
error:  unsolved goals
case refine_1
F : Type u_1
K : Type u_2
L : Type u_3
instâœâµ : Field F
instâœâ´ : Field K
instâœÂ³ : Field L
instâœÂ² : Algebra F K
instâœÂ¹ : Algebra F L
instâœ : Algebra.IsAlgebraic F K
splitsâœ : âˆ€ (x : K), Splits (algebraMap F L) (minpoly F x)
xâœ : IsNormalClosure F K L
splits : âˆ€ (x : K), Splits (algebraMap F L) (minpoly F x)
h : â¨† x, IntermediateField.adjoin F ((minpoly F x).rootSet L) = âŠ¤
âŠ¢ normalClosure F K L = âŠ¤

case refine_2
F : Type u_1
K : Type u_2
L : Type u_3
instâœâµ : Field F
instâœâ´ : Field K
instâœÂ³ : Field L
instâœÂ² : Algebra F K
instâœÂ¹ : Algebra F L
instâœ : Algebra.IsAlgebraic F K
splitsâœ : âˆ€ (x : K), Splits (algebraMap F L) (minpoly F x)
xâœ : (âˆ€ (x : K), Splits (algebraMap F L) (minpoly F x)) âˆ§ normalClosure F K L = âŠ¤
splits : âˆ€ (x : K), Splits (algebraMap F L) (minpoly F x)
h : normalClosure F K L = âŠ¤
âŠ¢ â¨† x, IntermediateField.adjoin F ((minpoly F x).rootSet L) = âŠ¤","lemma isNormalClosure_iff : IsNormalClosure F K L â†”
    (âˆ€ x : K, (minpoly F x).Splits (algebraMap F L)) âˆ§ normalClosure F K L = âŠ¤ ",":= by
  refine âŸ¨fun âŸ¨splits, hâŸ© â†¦ âŸ¨splits, ?_âŸ©, fun âŸ¨splits, hâŸ© â†¦ âŸ¨splits, ?_âŸ©âŸ© <;>
    simpa only [normalClosure_eq_iSup_adjoin_of_splits splits] using h"
Mathlib/Data/Set/Basic.lean,Set.subset_union_of_subset_left,subset_union_of_subset_left,70dcc1355b9ce0a6754f8d809c95a171072d3aac,":=
  Subset.trans h (subset_union_left t u)","error:  application type mismatch
  subset_union_left t
argument
  t
has type
  Set Î± : Type u
but is expected to have type
  ?m.30852 âˆˆ ?m.30850 : Prop",theorem subset_union_of_subset_left {s t : Set Î±} (h : s âŠ† t) (u : Set Î±) : s âŠ† t âˆª u ,":=
  h.trans subset_union_left"
Mathlib/Data/Real/Archimedean.lean,Real.iInf_Ioi_eq_iInf_rat_gt,iInf_Ioi_eq_iInf_rat_gt,8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85,":= by
  refine le_antisymm ?_ ?_
  Â· have : Nonempty { r' : â„š // x < â†‘r' } := by
      obtain âŸ¨r, hrxâŸ© := exists_rat_gt x
      exact âŸ¨âŸ¨r, hrxâŸ©âŸ©
    refine le_ciInf fun r => ?_
    obtain âŸ¨y, hxy, hyrâŸ© := exists_rat_btwn r.prop
    refine ciInf_set_le hf (hxy.trans ?_)
    exact_mod_cast hyr
  Â· refine le_ciInf fun q => ?_
    have hq := q.prop
    rw [mem_Ioi] at hq
    obtain âŸ¨y, hxy, hyqâŸ© := exists_rat_btwn hq
    refine (ciInf_le ?_ ?_).tran?s _
    Â· refine âŸ¨hf.some, fun z => ?_âŸ©
      rintro âŸ¨u, rflâŸ©
      suffices hfu : f u âˆˆ f '' Ioi x from hf.choose_spec hfu
      exact âŸ¨u, u.prop, rflâŸ©
    Â· exact âŸ¨y, hxyâŸ©
    Â· refine hf_mono (le_trans ?_ hyq.le)
      norm_cast","error:  invalid field 'tran?s', the environment does not contain 'LE.le.tran?s'
  ciInf_le ?m.42701 ?m.42702
has type
  iInf ?m.42700 â‰¤ ?m.42700 ?m.42702
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  ciInf_le ?m.42701 ?m.42702
has type
  Preorder.toLE.1 (iInf ?m.42700) (?m.42700 ?m.42702)
error:  no goals to be solved","theorem iInf_Ioi_eq_iInf_rat_gt {f : â„ â†’ â„} (x : â„) (hf : BddBelow (f '' Ioi x))
    (hf_mono : Monotone f) : â¨… r : Ioi x, f r = â¨… q : { q' : â„š // x < q' }, f q ",":= by
  refine le_antisymm ?_ ?_
  Â· have : Nonempty { r' : â„š // x < â†‘r' } := by
      obtain âŸ¨r, hrxâŸ© := exists_rat_gt x
      exact âŸ¨âŸ¨r, hrxâŸ©âŸ©
    refine le_ciInf fun r => ?_
    obtain âŸ¨y, hxy, hyrâŸ© := exists_rat_btwn r.prop
    refine ciInf_set_le hf (hxy.trans ?_)
    exact_mod_cast hyr
  Â· refine le_ciInf fun q => ?_
    have hq := q.prop
    rw [mem_Ioi] at hq
    obtain âŸ¨y, hxy, hyqâŸ© := exists_rat_btwn hq
    refine (ciInf_le ?_ ?_).trans ?_
    Â· refine âŸ¨hf.some, fun z => ?_âŸ©
      rintro âŸ¨u, rflâŸ©
      suffices hfu : f u âˆˆ f '' Ioi x from hf.choose_spec hfu
      exact âŸ¨u, u.prop, rflâŸ©
    Â· exact âŸ¨y, hxyâŸ©
    Â· refine hf_mono (le_trans ?_ hyq.le)
      norm_cast"
Mathlib/MeasureTheory/SetSemiring.lean,MeasureTheory.IsSetSemiring.sUnion_diffFinset,sUnion_diffFinset,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  classical
  rw [(hC.diff_eq_Union' s hs t ht).choose_spec.2.2]
  simp only [diffFinset, coe_sdiff, coe_singleton, diff_singleton_subset_iff]
  rw [sUnion_diff_singleton_empty]","error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.3705
Î± : Type u_1
C : Set (Set Î±)
s t : Set Î±
hC : IsSetSemiring C
hs : s âˆˆ C
ht : t âˆˆ C
âŠ¢ â‹ƒâ‚€ â†‘(hC.diffFinset hs ht) = s \ t","lemma sUnion_diffFinset (hC : IsSetSemiring C) (hs : s âˆˆ C) (ht : t âˆˆ C) :
    â‹ƒâ‚€ hC.diffFinset hs ht = s \ t ",":= by
  classical
  rw [(hC.diff_eq_sUnion' s hs t ht).choose_spec.2.2]
  simp only [diffFinset, coe_sdiff, coe_singleton, diff_singleton_subset_iff]
  rw [sUnion_diff_singleton_empty]"
Mathlib/MeasureTheory/OuterMeasure/Caratheodory.lean,MeasureTheory.OuterMeasure.isCaratheodory_union,isCaratheodory_union,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= fun t => by
  rw [hâ‚ t, hâ‚‚ (t âˆ© sâ‚), hâ‚‚ (t \ sâ‚), hâ‚ (t âˆ© (sâ‚ âˆª sâ‚‚)), inter_diff_assoc _ _ sâ‚,
    Set.inter_assoc _ _ sâ‚, inter_eq_self_of_subset_right (Set.subset_union_left _ _),
    union_diff_left, hâ‚‚ (t âˆ© sâ‚)]
  simp [diff_eq, add_assoc]","error:  function expected at
  subset_union_left ?m.11956
term has type
  ?m.11955 âˆˆ ?m.11953 âˆª ?m.11954
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  m (t âˆ© sâ‚)
Î± : Type u
m : OuterMeasure Î±
s sâ‚ sâ‚‚ : Set Î±
hâ‚ : m.IsCaratheodory sâ‚
hâ‚‚ : m.IsCaratheodory sâ‚‚
t : Set Î±
âŠ¢ m sâ‚‚ + m ((t âˆ© sâ‚) \ sâ‚‚) + (m (t \ sâ‚ âˆ© sâ‚‚) + m ((t \ sâ‚) \ sâ‚‚)) =
    m (t âˆ© ((sâ‚ âˆª sâ‚‚) âˆ© sâ‚)) + m (t âˆ© (sâ‚‚ \ sâ‚)) + m (t \ (sâ‚ âˆª sâ‚‚))
warning:  `MeasureTheory.OuterMeasure.iUnion` has been deprecated, use `MeasureTheory.measure_iUnion_le` instead","theorem isCaratheodory_union (hâ‚ : IsCaratheodory m sâ‚) (hâ‚‚ : IsCaratheodory m sâ‚‚) :
    IsCaratheodory m (sâ‚ âˆª sâ‚‚) ",":= fun t => by
  rw [hâ‚ t, hâ‚‚ (t âˆ© sâ‚), hâ‚‚ (t \ sâ‚), hâ‚ (t âˆ© (sâ‚ âˆª sâ‚‚)), inter_diff_assoc _ _ sâ‚,
    Set.inter_assoc _ _ sâ‚, inter_eq_self_of_subset_right Set.subset_union_left,
    union_diff_left, hâ‚‚ (t âˆ© sâ‚)]
  simp [diff_eq, add_assoc]"
Mathlib/CategoryTheory/Limits/Final.lean,CategoryTheory.Functor.final_of_equivalence_comp,final_of_equivalence_comp,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,"  out d :=
    have := StructuredArrow.isEquivalencePre d F G
    isConnected_of_equivalent (StructuredArrow.pre d F G).asEquivalence","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  StructuredArrow
has type
  ?m.269169 â†’ ?m.269060 â¥¤ ?m.269169 â†’ Type (max ?u.269057 ?u.269058)
error:  invalid occurrence of universe level 'u_1' at 'CategoryTheory.Functor.final_iff_equivalence_comp', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  final_of_equivalence_comp.{vâ‚, vâ‚‚, vâ‚ƒ, uâ‚, uâ‚‚, uâ‚ƒ, u_1} F G
at declaration body
  fun {C : Type uâ‚} [Category.{vâ‚, uâ‚} C] {D : Type uâ‚‚} [Category.{vâ‚‚, uâ‚‚} D] {E : Type uâ‚ƒ} [Category.{vâ‚ƒ, uâ‚ƒ} E]
      (F : C â¥¤ D) (G : D â¥¤ E) [F.IsEquivalence] â†¦
    { mp := fun (x : G.Final) â†¦ final_equivalence_comp F G,
      mpr := fun (x : (F â‹™ G).Final) â†¦ final_of_equivalence_comp F G }
error:  unknown identifier 'final_iff_equivalence_comp'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.285128
C : Type uâ‚
instâœÂ² : Category.{vâ‚, uâ‚} C
D : Type uâ‚‚
instâœÂ¹ : Category.{vâ‚‚, uâ‚‚} D
E : Type uâ‚ƒ
instâœ : Category.{vâ‚ƒ, uâ‚ƒ} E
F : C â¥¤ D
G : D â¥¤ E
hF : F.Final
hG : G.Final
sâ‚ : C â‰Œ AsSmall C := AsSmall.equiv
sâ‚‚ : D â‰Œ AsSmall D := AsSmall.equiv
sâ‚ƒ : E â‰Œ AsSmall E := AsSmall.equiv
i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
  isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor))
âŠ¢ ((F â‹™ G) â‹™ sâ‚ƒ.functor).Final
error:  unknown identifier 'final_iff_equivalence_comp'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.293182
C : Type uâ‚
instâœÂ² : Category.{vâ‚, uâ‚} C
D : Type uâ‚‚
instâœÂ¹ : Category.{vâ‚‚, uâ‚‚} D
E : Type uâ‚ƒ
instâœ : Category.{vâ‚ƒ, uâ‚ƒ} E
F : C â¥¤ D
G : D â¥¤ E
hF : F.Final
hFG : (F â‹™ G).Final
sâ‚ : C â‰Œ AsSmall C := AsSmall.equiv
sâ‚‚ : D â‰Œ AsSmall D := AsSmall.equiv
sâ‚ƒ : E â‰Œ AsSmall E := AsSmall.equiv
_i : sâ‚.inverse â‹™ (F â‹™ G) â‹™ sâ‚ƒ.functor â‰… (sâ‚.inverse â‹™ F â‹™ sâ‚‚.functor) â‹™ sâ‚‚.inverse â‹™ G â‹™ sâ‚ƒ.functor :=
  isoWhiskerLeft (sâ‚.inverse â‹™ F) (isoWhiskerRight sâ‚‚.unitIso (G â‹™ sâ‚ƒ.functor))
âŠ¢ (G â‹™ sâ‚ƒ.functor).Final","theorem final_of_equivalence_comp [IsEquivalence F] [Final (F â‹™ G)] : Final G where
",  out d := isConnected_of_equivalent (StructuredArrow.pre d F G).asEquivalence
Mathlib/SetTheory/Cardinal/Cofinality.lean,Ordinal.exists_fundamental_sequence,exists_fundamental_sequence,5068808d2b4c25cf905cf7fee10ded8e447c2346,":= by
  suffices h : âˆƒ o f, IsFundamentalSequence a o f
  Â· rcases h with âŸ¨o, f, hfâŸ©
    exact âŸ¨_, hf.ord_cofâŸ©
  rcases exists_lsub_cof a with âŸ¨Î¹, f, hf, hÎ¹âŸ©
  rcases ord_eq Î¹ with âŸ¨r, wo, hrâŸ©
  haveI := wo
  let r' := Subrel r { i | âˆ€ j, r j i â†’ f j < f i }
  let hrr' : r' â†ªr r := Subrel.relEmbedding _ _
  haveI := hrr'.isWellOrder
  refine'
    âŸ¨_, _, hrr'.ordinal_type_le.trans _, @fun i j _ h _ => (enum r' j h).prop _ _,
      le_antisymm (blsub_le fun i hi => lsub_le_iff.1 hf.le _) _âŸ©
  Â· rw [â† hÎ¹, hr]
  Â· change r (hrr'.1 _) (hrr'.1 _)
    rwa [hrr'.2, @enum_lt_enum _ r']
  Â· rw [â† hf, lsub_le_iff]
    intro i
    suffices h : âˆƒ i' hi', f i â‰¤ bfamilyOfFamily' r' (fun i => f i) i' hi'
    Â· rcases h with âŸ¨i', hi', hfgâŸ©
      exact hfg.trans_lt (lt_blsub _ _ _)
    by_cases h : âˆ€ j, r j i â†’ f j < f i
    Â· refine' âŸ¨typein r' âŸ¨i, hâŸ©, typein_lt_type _ _, _âŸ©
      rw [bfamilyOfFamily'_typein]
    Â· push_neg  at h
      cases' wo.wf.min_mem _ h with hji hij
      refine' âŸ¨typein r' âŸ¨_, fun k hkj => lt_of_lt_of_le _ hijâŸ©, typein_lt_type _ _, _âŸ©
      Â· by_contra' H
        exact (wo.wf.not_lt_min _ h âŸ¨IsTrans.trans _ _ _ hkj hji, HâŸ©) hkj
      Â· rwa [bfamilyOfFamily'_typein]",error:  unexpected token 'Â·'; expected 'by' or 'from',"theorem exists_fundamental_sequence (a : Ordinal.{u}) :
    âˆƒ f, IsFundamentalSequence a a.cof.ord f ",":= by
  suffices h : âˆƒ o f, IsFundamentalSequence a o f by
    rcases h with âŸ¨o, f, hfâŸ©
    exact âŸ¨_, hf.ord_cofâŸ©
  rcases exists_lsub_cof a with âŸ¨Î¹, f, hf, hÎ¹âŸ©
  rcases ord_eq Î¹ with âŸ¨r, wo, hrâŸ©
  haveI := wo
  let r' := Subrel r { i | âˆ€ j, r j i â†’ f j < f i }
  let hrr' : r' â†ªr r := Subrel.relEmbedding _ _
  haveI := hrr'.isWellOrder
  refine
    âŸ¨_, _, hrr'.ordinal_type_le.trans ?_, @fun i j _ h _ => (enum r' j h).prop _ ?_,
      le_antisymm (blsub_le fun i hi => lsub_le_iff.1 hf.le _) ?_âŸ©
  Â· rw [â† hÎ¹, hr]
  Â· change r (hrr'.1 _) (hrr'.1 _)
    rwa [hrr'.2, @enum_lt_enum _ r']
  Â· rw [â† hf, lsub_le_iff]
    intro i
    suffices h : âˆƒ i' hi', f i â‰¤ bfamilyOfFamily' r' (fun i => f i) i' hi' by
      rcases h with âŸ¨i', hi', hfgâŸ©
      exact hfg.trans_lt (lt_blsub _ _ _)
    by_cases h : âˆ€ j, r j i â†’ f j < f i
    Â· refine âŸ¨typein r' âŸ¨i, hâŸ©, typein_lt_type _ _, ?_âŸ©
      rw [bfamilyOfFamily'_typein]
    Â· push_neg at h
      cases' wo.wf.min_mem _ h with hji hij
      refine âŸ¨typein r' âŸ¨_, fun k hkj => lt_of_lt_of_le ?_ hijâŸ©, typein_lt_type _ _, ?_âŸ©
      Â· by_contra! H
        exact (wo.wf.not_lt_min _ h âŸ¨IsTrans.trans _ _ _ hkj hji, HâŸ©) hkj
      Â· rwa [bfamilyOfFamily'_typein]"
Mathlib/MeasureTheory/Decomposition/Lebesgue.lean,MeasureTheory.Measure.eq_singularPart,eq_singularPart,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have : HaveLebesgueDecomposition Î¼ Î½ := âŸ¨âŸ¨âŸ¨s, fâŸ©, hf, hs, haddâŸ©âŸ©
  obtain âŸ¨hmeas, hsing, hadd'âŸ© := haveLebesgueDecomposition_spec Î¼ Î½
  obtain âŸ¨âŸ¨S, hSâ‚, hSâ‚‚, hSâ‚ƒâŸ©, âŸ¨T, hTâ‚, hTâ‚‚, hTâ‚ƒâŸ©âŸ© := hs, hsing
  rw [hadd'] at hadd
  have hÎ½inter : Î½ (S âˆ© T)á¶œ = 0 := by
    rw [compl_inter]
    refine nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) ?_)
    rw [hTâ‚ƒ, hSâ‚ƒ, add_zero]
  have heq : s.restrict (S âˆ© T)á¶œ = (Î¼.singularPart Î½).restrict (S âˆ© T)á¶œ := by
    ext1 A hA
    have hf : Î½.withDensity f (A âˆ© (S âˆ© T)á¶œ) = 0 := by
      refine withDensity_absolutelyContinuous Î½ _ ?_
      rw [â† nonpos_iff_eq_zero]
      exact hÎ½inter â–¸ measure_mono (inter_subset_right _ _)
    have hrn : Î½.withDensity (Î¼.rnDeriv Î½) (A âˆ© (S âˆ© T)á¶œ) = 0 := by
      refine withDensity_absolutelyContinuous Î½ _ ?_
      rw [â† nonpos_iff_eq_zero]
      exact hÎ½inter â–¸ measure_mono (inter_subset_right _ _)
    rw [restrict_apply hA, restrict_apply hA, â† add_zero (s (A âˆ© (S âˆ© T)á¶œ)), â† hf, â† add_apply, â†
      hadd, add_apply, hrn, add_zero]
  have heq' : âˆ€ A : Set Î±, MeasurableSet A â†’ s A = s.restrict (S âˆ© T)á¶œ A := by
    intro A hA
    have hsinter : s (A âˆ© (S âˆ© T)) = 0 := by
      rw [â† nonpos_iff_eq_zero]
      exact hSâ‚‚ â–¸ measure_mono ((inter_subset_right _ _).trans (inter_subset_left _ _))
    rw [restrict_apply hA, â† diff_eq, AEDisjoint.measure_diff_left hsinter]
  ext1 A hA
  have hÎ¼inter : Î¼.singularPart Î½ (A âˆ© (S âˆ© T)) = 0 := by
    rw [â† nonpos_iff_eq_zero]
    exact hTâ‚‚ â–¸ measure_mono ((inter_subset_right _ _).trans (inter_subset_right _ _))
  rw [heq' A hA, heq, restrict_apply hA, â† diff_eq, AEDisjoint.measure_diff_left hÎ¼inter]","error:  function expected at
  inter_subset_right ?m.52103
term has type
  ?m.52102 âˆˆ ?m.52101
error:  function expected at
  inter_subset_right ?m.52720
term has type
  ?m.52719 âˆˆ ?m.52718
error:  function expected at
  inter_subset_right ?m.53949
term has type
  ?m.53948 âˆˆ ?m.53947
error:  function expected at
  inter_subset_right ?m.54737
term has type
  ?m.54736 âˆˆ ?m.54735","theorem eq_singularPart {s : Measure Î±} {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) (hs : s âŸ‚â‚˜ Î½)
    (hadd : Î¼ = s + Î½.withDensity f) : s = Î¼.singularPart Î½ ",":= by
  have : HaveLebesgueDecomposition Î¼ Î½ := âŸ¨âŸ¨âŸ¨s, fâŸ©, hf, hs, haddâŸ©âŸ©
  obtain âŸ¨hmeas, hsing, hadd'âŸ© := haveLebesgueDecomposition_spec Î¼ Î½
  obtain âŸ¨âŸ¨S, hSâ‚, hSâ‚‚, hSâ‚ƒâŸ©, âŸ¨T, hTâ‚, hTâ‚‚, hTâ‚ƒâŸ©âŸ© := hs, hsing
  rw [hadd'] at hadd
  have hÎ½inter : Î½ (S âˆ© T)á¶œ = 0 := by
    rw [compl_inter]
    refine nonpos_iff_eq_zero.1 (le_trans (measure_union_le _ _) ?_)
    rw [hTâ‚ƒ, hSâ‚ƒ, add_zero]
  have heq : s.restrict (S âˆ© T)á¶œ = (Î¼.singularPart Î½).restrict (S âˆ© T)á¶œ := by
    ext1 A hA
    have hf : Î½.withDensity f (A âˆ© (S âˆ© T)á¶œ) = 0 := by
      refine withDensity_absolutelyContinuous Î½ _ ?_
      rw [â† nonpos_iff_eq_zero]
      exact hÎ½inter â–¸ measure_mono inter_subset_right
    have hrn : Î½.withDensity (Î¼.rnDeriv Î½) (A âˆ© (S âˆ© T)á¶œ) = 0 := by
      refine withDensity_absolutelyContinuous Î½ _ ?_
      rw [â† nonpos_iff_eq_zero]
      exact hÎ½inter â–¸ measure_mono inter_subset_right
    rw [restrict_apply hA, restrict_apply hA, â† add_zero (s (A âˆ© (S âˆ© T)á¶œ)), â† hf, â† add_apply, â†
      hadd, add_apply, hrn, add_zero]
  have heq' : âˆ€ A : Set Î±, MeasurableSet A â†’ s A = s.restrict (S âˆ© T)á¶œ A := by
    intro A hA
    have hsinter : s (A âˆ© (S âˆ© T)) = 0 := by
      rw [â† nonpos_iff_eq_zero]
      exact hSâ‚‚ â–¸ measure_mono (inter_subset_right.trans inter_subset_left)
    rw [restrict_apply hA, â† diff_eq, AEDisjoint.measure_diff_left hsinter]
  ext1 A hA
  have hÎ¼inter : Î¼.singularPart Î½ (A âˆ© (S âˆ© T)) = 0 := by
    rw [â† nonpos_iff_eq_zero]
    exact hTâ‚‚ â–¸ measure_mono (inter_subset_right.trans inter_subset_right)
  rw [heq' A hA, heq, restrict_apply hA, â† diff_eq, AEDisjoint.measure_diff_left hÎ¼inter]"
Mathlib/Algebra/Lie/Engel.lean,LieAlgebra.isEngelian_of_subsingleton,LieAlgebra.isEngelian_of_subsingleton,ffad8a75cc872177a4f2b6e5db3a8798fd58afae,":= by
  intro M _i1 _i2 _i3 _i4 _h
  use 1
  suffices (âŠ¤ : LieIdeal R L) = âŠ¥ by simp [this]
  subsingleton [(LieSubmodule.subsingleton_iff R L L).mpr inferInstance]","error:  unknown tactic
error:  unsolved goals
case h
R : Type uâ‚
L : Type uâ‚‚
Lâ‚‚ : Type uâ‚ƒ
Mâœ : Type uâ‚„
instâœâ¹ : CommRing R
instâœâ¸ : LieRing L
instâœâ· : LieAlgebra R L
instâœâ¶ : LieRing Lâ‚‚
instâœâµ : LieAlgebra R Lâ‚‚
instâœâ´ : AddCommGroup Mâœ
instâœÂ³ : Module R Mâœ
instâœÂ² : LieRingModule L Mâœ
instâœÂ¹ : LieModule R L Mâœ
instâœ : Subsingleton L
M : Type u_1
_i1 : AddCommGroup M
_i2 : Module R M
_i3 : LieRingModule L M
_i4 : LieModule R L M
_h : âˆ€ (x : L), _root_.IsNilpotent ((toEnd R L M) x)
âŠ¢ âŠ¤ = âŠ¥",theorem LieAlgebra.isEngelian_of_subsingleton [Subsingleton L] : LieAlgebra.IsEngelian R L ,":= by
  intro M _i1 _i2 _i3 _i4 _h
  use 1
  suffices (âŠ¤ : LieIdeal R L) = âŠ¥ by simp [this]
  haveI := (LieSubmodule.subsingleton_iff R L L).mpr inferInstance
  apply Subsingleton.elim"
Mathlib/CategoryTheory/Filtered/Basic.lean,CategoryTheory.IsCofiltered.inf_exists,inf_exists,c0e01e2659027402daf13d3c9c6f81d96a0d9b85,":= by
  classical
  induction' H with h' H' nmf h''
  Â· obtain âŸ¨S, fâŸ© := inf_objs_exists O
    exact âŸ¨S, fun mX => (f mX).some, by rintro - - - - - âŸ¨âŸ©âŸ©
  Â· obtain âŸ¨X, Y, mX, mY, fâŸ© := h'
    obtain âŸ¨S', T', w'âŸ© := h''
    refine' âŸ¨eq (T' mX â‰« f) (T' mY), fun mZ => eqHom (T' mX â‰« f) (T' mY) â‰« T' mZ, _âŸ©
    intro X' Y' mX' mY' f' mf'
    rw [Category.assoc]
    by_cases h : X = X' âˆ§ Y = Y'
    Â· rcases h with âŸ¨rfl, rflâŸ©
      by_cases hf : f = f'
      Â· subst hf
        apply eq_condition
      Â· rw [@w' _ _ mX mY f']
        simp only [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, true_and] at mf'
        rcases mf' with mf' | mf'
        Â· exfalso
          exact hf mf'.symm
        Â· exact mf'
    Â· rw [@w' _ _ mX' mY' f' _]
      apply Finset.mem_of_mem_insert_of_ne mf'
      contrapose! h
      obtain âŸ¨rfl, hâŸ© := h
      trivial","error:  rcases tactic failed: aâœ : Quot.lift (fun l â†¦ âŸ¨Xâœ, âŸ¨Yâœ, âŸ¨mXâœ, âŸ¨mYâœ, fâœâŸ©âŸ©âŸ©âŸ© âˆˆ l) â‹¯
  { val := h', nodup := H' }.val is not an inductive datatype
error:  no goals to be solved","theorem inf_exists :
    âˆƒ (S : C) (T : âˆ€ {X : C}, X âˆˆ O â†’ (S âŸ¶ X)),
      âˆ€ {X Y : C} (mX : X âˆˆ O) (mY : Y âˆˆ O) {f : X âŸ¶ Y},
        (âŸ¨X, Y, mX, mY, fâŸ© : Î£' (X Y : C) (_ : X âˆˆ O) (_ : Y âˆˆ O), X âŸ¶ Y) âˆˆ H â†’
          T mX â‰« f = T mY ",":= by
  classical
  induction' H using Finset.induction with h' H' nmf h''
  Â· obtain âŸ¨S, fâŸ© := inf_objs_exists O
    exact âŸ¨S, fun mX => (f mX).some, by rintro - - - - - âŸ¨âŸ©âŸ©
  Â· obtain âŸ¨X, Y, mX, mY, fâŸ© := h'
    obtain âŸ¨S', T', w'âŸ© := h''
    refine âŸ¨eq (T' mX â‰« f) (T' mY), fun mZ => eqHom (T' mX â‰« f) (T' mY) â‰« T' mZ, ?_âŸ©
    intro X' Y' mX' mY' f' mf'
    rw [Category.assoc]
    by_cases h : X = X' âˆ§ Y = Y'
    Â· rcases h with âŸ¨rfl, rflâŸ©
      by_cases hf : f = f'
      Â· subst hf
        apply eq_condition
      Â· rw [@w' _ _ mX mY f']
        simp only [Finset.mem_insert, PSigma.mk.injEq, heq_eq_eq, true_and] at mf'
        rcases mf' with mf' | mf'
        Â· exfalso
          exact hf mf'.symm
        Â· exact mf'
    Â· rw [@w' _ _ mX' mY' f' _]
      apply Finset.mem_of_mem_insert_of_ne mf'
      contrapose! h
      obtain âŸ¨rfl, hâŸ© := h
      trivial"
Mathlib/Logic/Relator.lean,Relator.LeftUnique.flip,LeftUnique.flip,b72bb8581e966b6491cee1c5638e18fae2fc11b2,:=,error:  unexpected token 'lemma'; expected term,lemma LeftUnique.flip (h : LeftUnique r) : RightUnique (flip r) ,":=
  fun _ _ _ hâ‚ hâ‚‚ => h hâ‚ hâ‚‚"
Mathlib/Algebra/Lie/Weights/Basic.lean,LieModule.comap_weightSpace_eq_of_injective,comap_weightSpace_eq_of_injective,5fb9beab28702fb284701d494bc9b7c5f52fef53,":= by
  refine le_antisymm (fun m hm â†¦ ?_) ?_
  Â· simp only [LieSubmodule.mem_comap, mem_weightSpace] at hm
    simp only [mem_weightSpace]
    intro x
    have h : (toEndomorphism R L Mâ‚‚ x - Ï‡ x â€¢ â†‘1) âˆ˜â‚— f =
             f âˆ˜â‚— (toEndomorphism R L M x - Ï‡ x â€¢ â†‘1) := by ext; simp
    obtain âŸ¨k, hkâŸ© := hm x
    use k
    suffices : f (((toEndomorphism R L M x - Ï‡ x â€¢ â†‘1) ^ k) m) = 0
    Â· rw [â† f.map_zero] at this; exact hf this
    simpa [hk] using (LinearMap.congr_fun (LinearMap.commute_pow_left_of_commute h k) m).symm
  Â· rw [â† LieSubmodule.map_le_iff_le_comap]
    exact map_weightSpace_le f","error:  unexpected token ':'; expected term
error:  unsolved goals
case refine_2
K : Type u_1
R : Type u_2
L : Type u_3
M : Type u_4
instâœÂ¹Â¹ : CommRing R
instâœÂ¹â° : LieRing L
instâœâ¹ : LieAlgebra R L
instâœâ¸ : LieAlgebra.IsNilpotent R L
instâœâ· : AddCommGroup M
instâœâ¶ : Module R M
instâœâµ : LieRingModule L M
instâœâ´ : LieModule R L M
Mâ‚‚ : Type u_5
instâœÂ³ : AddCommGroup Mâ‚‚
instâœÂ² : Module R Mâ‚‚
instâœÂ¹ : LieRingModule L Mâ‚‚
instâœ : LieModule R L Mâ‚‚
Ï‡ : L â†’ R
f : M â†’â‚—â…R,Lâ† Mâ‚‚
hf : Injective â‡‘f
âŠ¢ weightSpace M Ï‡ â‰¤ LieSubmodule.comap f (weightSpace Mâ‚‚ Ï‡)","lemma comap_weightSpace_eq_of_injective (hf : Injective f) :
    (weightSpace Mâ‚‚ Ï‡).comap f = weightSpace M Ï‡ ",":= by
  refine le_antisymm (fun m hm â†¦ ?_) ?_
  Â· simp only [LieSubmodule.mem_comap, mem_weightSpace] at hm
    simp only [mem_weightSpace]
    intro x
    have h : (toEnd R L Mâ‚‚ x - Ï‡ x â€¢ â†‘1) âˆ˜â‚— f =
             f âˆ˜â‚— (toEnd R L M x - Ï‡ x â€¢ â†‘1) := by ext; simp
    obtain âŸ¨k, hkâŸ© := hm x
    use k
    suffices f (((toEnd R L M x - Ï‡ x â€¢ â†‘1) ^ k) m) = 0 by
      rw [â† f.map_zero] at this; exact hf this
    simpa [hk] using (LinearMap.congr_fun (LinearMap.commute_pow_left_of_commute h k) m).symm
  Â· rw [â† LieSubmodule.map_le_iff_le_comap]
    exact map_weightSpace_le f"
Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Instances.lean,cfcHom_nnreal_eq_restrict,cfcHom_nnreal_eq_restrict,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have := UniqueContinuousFunctionalCalculus.compactSpace_spectrum a (R := â„)
  apply (SpectrumRestricts.nnreal_of_nonneg ha).cfcHom_eq_restrict isometry_subtype_coe","error:  application type mismatch
  @SpectrumRestricts.cfcHom_eq_restrict ?m.1017896 ?m.1017897 ?m.1017898 ?m.1017899 ?m.1017900 ?m.1017901 ?m.1017902
    ?m.1017903 ?m.1017904 ?m.1017905 ?m.1017906 ?m.1017907 ?m.1017908 ?m.1017909 ?m.1017910 ?m.1017911 ?m.1017912
    ?m.1017913 ?m.1017914 ?m.1017915 ?m.1017916 ?m.1017917 ?m.1017918 ?m.1017919 ?m.1017920 ?m.1017921 ?m.1017922
    ?m.1017923 ?m.1017931 isometry_subtype_coe
argument
  isometry_subtype_coe
has type
  Isometry Subtype.val : Prop
but is expected to have type
  UniformEmbedding â‡‘(algebraMap ?m.1017896 ?m.1017897) : Prop","lemma cfcHom_nnreal_eq_restrict {a : A} (ha : 0 â‰¤ a) :
    cfcHom ha = (SpectrumRestricts.nnreal_of_nonneg ha).starAlgHom
      (cfcHom (IsSelfAdjoint.of_nonneg ha)) ",":= by
  have := UniqueContinuousFunctionalCalculus.compactSpace_spectrum a (R := â„)
  apply (SpectrumRestricts.nnreal_of_nonneg ha).cfcHom_eq_restrict uniformEmbedding_subtype_val"
Mathlib/Topology/Order/Bounded.lean,Filter.isBounded_ge_map_of_bounded_range,Filter.isBounded_ge_map_of_bounded_range,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [Real.isBounded_iff_bddBelow_bddAbove] at h
  obtain âŸ¨c, hcâŸ© := h.1
  apply isBoundedUnder_of âŸ¨c, by simpa [mem_lowerBounds] using hcâŸ©","error:  unknown constant 'Real.isBounded_iff_bddBelow_bddAbove'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.4054
Î¹ : Type u_1
F : Filter Î¹
f : Î¹ â†’ â„
h : Bornology.IsBounded (range f)
âŠ¢ IsBounded (fun x x_1 â†¦ x â‰¥ x_1) (map f F)","lemma Filter.isBounded_ge_map_of_bounded_range {Î¹ : Type*} (F : Filter Î¹) {f : Î¹ â†’ â„}
    (h : Bornology.IsBounded (Set.range f)) :
    (F.map f).IsBounded (Â· â‰¥ Â·) ",":= by
  obtain âŸ¨c, hcâŸ© := h.bddBelow
  apply isBoundedUnder_of âŸ¨c, by simpa [mem_lowerBounds] using hcâŸ©"
Mathlib/CategoryTheory/Limits/Final.lean,CategoryTheory.Functor.initial_of_adjunction,initial_of_adjunction,c27ed32d370b030de9da7574fb6ad900747de344,":=
  {
    out := fun d =>
      let u : CostructuredArrow L d := CostructuredArrow.mk (adj.counit.app d)
      @zigzag_isConnected _ _ âŸ¨uâŸ© fun f g =>
        Relation.ReflTransGen.trans
          (Relation.ReflTransGen.single
            (show Zag f u from
              Or.inl âŸ¨CostructuredArrow.homMk (adj.homEquiv f.left d f.hom) (by simp)âŸ©))
          (Relation.ReflTransGen.single
            (show Zag u g from
              Or.inr âŸ¨CostructuredArrow.homMk (adj.homEquiv g.left d g.hom) (by simp)âŸ©)) }","error:  unsolved goals
C : Type uâ‚
instâœÂ¹ : Category.{vâ‚, uâ‚} C
D : Type uâ‚‚
instâœ : Category.{vâ‚‚, uâ‚‚} D
L : C â¥¤ D
R : D â¥¤ C
adj : L âŠ£ R
d : D
u : CostructuredArrow L d := CostructuredArrow.mk (adj.counit.app d)
f g : CostructuredArrow L d
âŠ¢ L.map (adj.unit.app f.left) â‰« L.map (R.map f.hom) â‰« u.hom = f.hom
error:  unsolved goals
C : Type uâ‚
instâœÂ¹ : Category.{vâ‚, uâ‚} C
D : Type uâ‚‚
instâœ : Category.{vâ‚‚, uâ‚‚} D
L : C â¥¤ D
R : D â¥¤ C
adj : L âŠ£ R
d : D
u : CostructuredArrow L d := CostructuredArrow.mk (adj.counit.app d)
f g : CostructuredArrow L d
âŠ¢ L.map (adj.unit.app g.left) â‰« L.map (R.map g.hom) â‰« u.hom = g.hom",theorem initial_of_adjunction {L : C â¥¤ D} {R : D â¥¤ C} (adj : L âŠ£ R) : Initial L ,":=
  { out := fun d =>
      let u : CostructuredArrow L d := CostructuredArrow.mk (adj.counit.app d)
      @zigzag_isConnected _ _ âŸ¨uâŸ© fun f g =>
        Relation.ReflTransGen.trans
          (Relation.ReflTransGen.single
            (show Zag f u from
              Or.inl âŸ¨CostructuredArrow.homMk (adj.homEquiv f.left d f.hom) (by simp [u])âŸ©))
          (Relation.ReflTransGen.single
            (show Zag u g from
              Or.inr âŸ¨CostructuredArrow.homMk (adj.homEquiv g.left d g.hom) (by simp [u])âŸ©)) }"
Mathlib/Data/List/OfFn.lean,List.get?_ofFn,get?_ofFn,a380f5a603bf5030bc30e58b1aed19567f67b98d,":=
  if h : i < (ofFn f).length
  then by
    rw [get?_eq_get h, get_ofFn]
    Â· simp at h; simp [ofFnNthVal, h]
  else by
    rw [ofFnNthVal, dif_neg] <;>
    simpa using h","error:  type mismatch
  hâœ
has type
  n â‰¤ i : Prop
but is expected to have type
  ofFnNthVal f i = none : Prop
error:  unsolved goals
Î± : Type u
n : â„•
f : Fin n â†’ Î±
i : â„•
h : Â¬i < (ofFn f).length
âŠ¢ (ofFn f).get? i = none
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_ofFn` has been deprecated, use `List.get_ofFn` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead",theorem get?_ofFn {n} (f : Fin n â†’ Î±) (i) : get? (ofFn f) i = ofFnNthVal f i ,":= by
  simp"
Mathlib/CategoryTheory/MorphismProperty/IsInvertedBy.lean,CategoryTheory.MorphismProperty.IsInvertedBy.map_iff,IsInvertedBy.map_iff,9e489ab7d68355941805e728e4919d91867ce21a,":= by
  simp only [IsInvertedBy.iff_map_subset_isomorphisms, map_map]","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  IsInvertedBy
has type
  MorphismProperty ?m.9941 â†’ ?m.9941 â¥¤ ?m.9995 â†’ Prop
error:  simp made no progress","lemma IsInvertedBy.map_iff {Câ‚ Câ‚‚ Câ‚ƒ : Type*} [Category Câ‚] [Category Câ‚‚] [Category Câ‚ƒ]
    (W : MorphismProperty Câ‚) (F : Câ‚ â¥¤ Câ‚‚) (G : Câ‚‚ â¥¤ Câ‚ƒ) :
    (W.map F).IsInvertedBy G â†” W.IsInvertedBy (F â‹™ G) ",":= by
  simp only [IsInvertedBy.iff_map_le_isomorphisms, map_map]"
Mathlib/Data/Fin/Basic.lean,Fin.modNat_rev,modNat_rev,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  ext
  have Hâ‚ : i % n + 1 â‰¤ n := i.modNat.is_lt
  have Hâ‚‚ : i / n < m := i.divNat.is_lt
  simp only [coe_modNat, val_rev]
  calc
    (m * n - (i + 1)) % n = (m * n - ((i / n) * n + i % n + 1)) % n := by rw [Nat.div_add_mod']
    _ = ((m - i / n - 1) * n + (n - (i % n + 1))) % n := by
      rw [tsub_mul, one_mul, tsub_add_tsub_cancel _ Hâ‚, tsub_mul, tsub_tsub, add_assoc]
      exact le_mul_of_one_le_left' <| le_tsub_of_add_le_left Hâ‚‚
    _ = n - (i % n + 1) := by
      rw [mul_comm, Nat.mul_add_mod, Nat.mod_eq_of_lt]; exact i.modNat.rev.is_lt","warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Fin.val_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  unknown identifier 'tsub_mul'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.76022
n m : â„•
i : Fin (m * n)
Hâ‚ : â†‘i % n + 1 â‰¤ n
Hâ‚‚ : â†‘i / n < m
âŠ¢ (m * n - (â†‘i / n * n + â†‘i % n + 1)) % n = ((m - â†‘i / n - 1) * n + (n - (â†‘i % n + 1))) % n
error:  unknown identifier 'mul_comm'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.76024
n m : â„•
i : Fin (m * n)
Hâ‚ : â†‘i % n + 1 â‰¤ n
Hâ‚‚ : â†‘i / n < m
âŠ¢ ((m - â†‘i / n - 1) * n + (n - (â†‘i % n + 1))) % n = n - (â†‘i % n + 1)",theorem modNat_rev (i : Fin (m * n)) : i.rev.modNat = i.modNat.rev ,":= by
  ext
  have Hâ‚ : i % n + 1 â‰¤ n := i.modNat.is_lt
  have Hâ‚‚ : i / n < m := i.divNat.is_lt
  simp only [coe_modNat, val_rev]
  calc
    (m * n - (i + 1)) % n = (m * n - ((i / n) * n + i % n + 1)) % n := by rw [Nat.div_add_mod']
    _ = ((m - i / n - 1) * n + (n - (i % n + 1))) % n := by
      rw [Nat.mul_sub_right_distrib, Nat.one_mul, Nat.sub_add_sub_cancel _ Hâ‚,
        Nat.mul_sub_right_distrib, Nat.sub_sub, Nat.add_assoc]
      exact Nat.le_mul_of_pos_left _ <| Nat.le_sub_of_add_le' Hâ‚‚
    _ = n - (i % n + 1) := by
      rw [Nat.mul_comm, Nat.mul_add_mod, Nat.mod_eq_of_lt]; exact i.modNat.rev.is_lt"
Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean,tprod_setProd_singleton_right,tprod_setProd_singleton_right,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [tprod_congr_set_coe _ Set.prod_singleton, tprod_image _ ((Prod.mk.inj_right c).injOn _)]","error:  application type mismatch
  tprod_image ?m.8074 (Injective.injOn (Prod.mk.inj_right c) ?m.8103)
argument
  Injective.injOn (Prod.mk.inj_right c) ?m.8103
has type
  âˆ€ â¦ƒxâ‚‚ : ?m.8092â¦„, xâ‚‚ âˆˆ ?m.8101 â†’ (?m.8102, c) = (xâ‚‚, c) â†’ ?m.8102 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn ?m.8073 ?m.8075 : Prop","lemma tprod_setProd_singleton_right (s : Set Î²) (c : Î³) (f : Î² Ã— Î³ â†’ Î±) :
    (âˆ' x : s Ã—Ë¢ {c}, f x) = âˆ' b : s, f (b, c) ",":= by
  rw [tprod_congr_set_coe _ Set.prod_singleton, tprod_image _ (Prod.mk.inj_right c).injOn]"
Mathlib/MeasureTheory/Integral/Gamma.lean,Complex.integral_rpow_mul_exp_neg_rpow,Complex.integral_rpow_mul_exp_neg_rpow,a645d903a5e02e8cbb9215f6195147610bf99954,":= by
  calc
    _ = âˆ« x in Ioi (0 : â„) Ã—Ë¢ Ioo (-Ï€) Ï€, x.1 * (|x.1| ^ q * rexp (-|x.1| ^ p)) : = by
      rw [â† Complex.integral_comp_polarCoord_symm, polarCoord_target]
      simp_rw [Complex.norm_eq_abs, Complex.polardCoord_symm_abs, smul_eq_mul]
    _ = (âˆ« x in Ioi (0 : â„), x * |x| ^ q * rexp (-|x| ^ p)) * âˆ« _ in Ioo (-Ï€) Ï€, 1 : = by
      rw [â† setIntegral_prod_mul, volume_eq_prod]
      simp_rw [mul_one]
      congr! 2; ring
    _ = 2 * Ï€ * âˆ« x in Ioi (0 : â„), x * |x| ^ q * rexp (-|x| ^ p) : = by
      simp_rw [integral_const, Measure.restrict_apply MeasurableSet.univ, Set.univ_inter,
        volume_Ioo, sub_neg_eq_add, â† two_mul, ENNReal.toReal_ofReal (by positivity : 0 â‰¤ 2 * Ï€),
        smul_eq_mul, mul_one, mul_comm]
    _ = 2 * Ï€ * âˆ« x in Ioi (0 : â„), x ^ (q + 1) * rexp (-x ^ p) : = by
      congr 1
      refine setIntegral_congr measurableSet_Ioi (fun x hx => ?_)
      rw [abs_eq_self.mpr (le_of_lt (by exact hx)), rpow_add hx, rpow_one]
      ring
    _ = (2 * Real.pi / p) * Real.Gamma ((q + 2) / p) := by
      rw [_root_.integral_rpow_mul_exp_neg_rpow (by linarith) (by linarith), add_assoc,
        one_add_one_eq_two]
      ring","error:  invalid 'calc' step, failed to synthesize `Trans` instance
  Trans Eq Eq ?m.38557
use `set_option diagnostics true` to get diagnostic information
error:  unexpected token ':'; expected command","theorem Complex.integral_rpow_mul_exp_neg_rpow {p q : â„} (hp : 1 â‰¤ p) (hq : - 2 < q) :
    âˆ« x : â„‚, â€–xâ€– ^ q * rexp (- â€–xâ€– ^ p) = (2 * Ï€ / p) * Real.Gamma ((q + 2) / p) ",":= by
  calc
    _ = âˆ« x in Ioi (0:â„) Ã—Ë¢ Ioo (-Ï€) Ï€, x.1 * (|x.1| ^ q * rexp (-|x.1| ^ p)) := by
      rw [â† Complex.integral_comp_polarCoord_symm, polarCoord_target]
      simp_rw [Complex.norm_eq_abs, Complex.polardCoord_symm_abs, smul_eq_mul]
    _ = (âˆ« x in Ioi (0:â„), x * |x| ^ q * rexp (-|x| ^ p)) * âˆ« _ in Ioo (-Ï€) Ï€, 1 := by
      rw [â† setIntegral_prod_mul, volume_eq_prod]
      simp_rw [mul_one]
      congr! 2; ring
    _ = 2 * Ï€ * âˆ« x in Ioi (0:â„), x * |x| ^ q * rexp (-|x| ^ p) := by
      simp_rw [integral_const, Measure.restrict_apply MeasurableSet.univ, Set.univ_inter,
        volume_Ioo, sub_neg_eq_add, â† two_mul, ENNReal.toReal_ofReal (by positivity : 0 â‰¤ 2 * Ï€),
        smul_eq_mul, mul_one, mul_comm]
    _ = 2 * Ï€ * âˆ« x in Ioi (0:â„), x ^ (q + 1) * rexp (-x ^ p) := by
      congr 1
      refine setIntegral_congr measurableSet_Ioi (fun x hx => ?_)
      rw [abs_eq_self.mpr (le_of_lt (by exact hx)), rpow_add hx, rpow_one]
      ring
    _ = (2 * Real.pi / p) * Real.Gamma ((q + 2) / p) := by
      rw [_root_.integral_rpow_mul_exp_neg_rpow (by linarith) (by linarith), add_assoc,
        one_add_one_eq_two]
      ring"
Mathlib/Analysis/Calculus/InverseFunctionTheorem/FDeriv.lean,HasStrictFDerivAt.approximates_deriv_on_nhds,approximates_deriv_on_nhds,725777c9521e486121164fad32a2a0ada4823522,":= by
  cases' hc with hE hc
  Â· refine' âŸ¨univ, IsOpen.mem_nhds isOpen_univ trivial, fun x _ y _ => _âŸ©
    simp [@Subsingleton.elim E hE x y]
  have := hf.definition hc
  rw [nhds_prod_eq, Filter.Eventually, mem_prod_same_iff] at this
  rcases this with âŸ¨s, has, hsâŸ©
  exact âŸ¨s, has, fun x hx y hy => hs (mk_mem_prod hx hy)âŸ©","error:  invalid field 'definition', the environment does not contain 'HasStrictFDerivAt.definition'
  hf
has type
  HasStrictFDerivAt f f' a
error:  invalid field 'definition', the environment does not contain 'Asymptotics.IsLittleO.definition'
  hf
has type
  (fun p â†¦ f p.1 - f p.2 - f' (p.1 - p.2)) =o[ğ“ (a, a)] fun p â†¦ p.1 - p.2
error:  unsolved goals
case inr
ğ•œ : Type u_1
instâœâ¸ : NontriviallyNormedField ğ•œ
E : Type u_2
instâœâ· : NormedAddCommGroup E
instâœâ¶ : NormedSpace ğ•œ E
F : Type u_3
instâœâµ : NormedAddCommGroup F
instâœâ´ : NormedSpace ğ•œ F
G : Type u_4
instâœÂ³ : NormedAddCommGroup G
instâœÂ² : NormedSpace ğ•œ G
G' : Type u_5
instâœÂ¹ : NormedAddCommGroup G'
instâœ : NormedSpace ğ•œ G'
Îµ : â„
f : E â†’ F
f' : E â†’L[ğ•œ] F
a : E
hf : HasStrictFDerivAt f f' a
c : â„â‰¥0
hc : 0 < c
âŠ¢ âˆƒ s âˆˆ ğ“ a, ApproximatesLinearOn f f' s c","theorem approximates_deriv_on_nhds {f : E â†’ F} {f' : E â†’L[ğ•œ] F} {a : E}
    (hf : HasStrictFDerivAt f f' a) {c : â„â‰¥0} (hc : Subsingleton E âˆ¨ 0 < c) :
    âˆƒ s âˆˆ ğ“ a, ApproximatesLinearOn f f' s c ",":= by
  cases' hc with hE hc
  Â· refine âŸ¨univ, IsOpen.mem_nhds isOpen_univ trivial, fun x _ y _ => ?_âŸ©
    simp [@Subsingleton.elim E hE x y]
  have := hf.def hc
  rw [nhds_prod_eq, Filter.Eventually, mem_prod_same_iff] at this
  rcases this with âŸ¨s, has, hsâŸ©
  exact âŸ¨s, has, fun x hx y hy => hs (mk_mem_prod hx hy)âŸ©"
Mathlib/MeasureTheory/SetSemiring.lean,MeasureTheory.IsSetSemiring.exists_disjoint_finset_diff_eq,exists_disjoint_finset_diff_eq,961db629df93e5dbd02440deee4c37efcf2faa85,":= by
  classical
  induction I using Finset.induction with
  | empty =>
    simp only [coe_empty, sUnion_empty, diff_empty, exists_prop]
    refine âŸ¨{s}, singleton_subset_set_iff.mpr hs, ?_âŸ©
    simp only [coe_singleton, pairwiseDisjoint_singleton, sUnion_singleton, eq_self_iff_true,
      and_self_iff]
  | @insert t I' _ h => ?_

  rw [coe_insert] at hI
  have ht : t âˆˆ C := hI (Set.mem_insert _ _)
  obtain âŸ¨J, h_ss, h_dis, h_eqâŸ© := h ((Set.subset_insert _ _).trans hI)
  let Ju : âˆ€ u âˆˆ C, Finset (Set Î±) := fun u hu â†¦ hC.diffFinset hu ht
  have hJu_subset : âˆ€ (u) (hu : u âˆˆ C), â†‘(Ju u hu) âŠ† C := by
    intro u hu x hx
    exact hC.diffFinset_subset hu ht hx
  have hJu_disj : âˆ€ (u) (hu : u âˆˆ C), (Ju u hu : Set (Set Î±)).PairwiseDisjoint id := fun u hu â†¦
    hC.pairwiseDisjoint_diffFinset hu ht
  have hJu_sUnion : âˆ€ (u) (hu : u âˆˆ C), â‹ƒâ‚€ (Ju u hu : Set (Set Î±)) = u \ t :=
    fun u hu â†¦ hC.sUnion_diffFinset hu ht
  have hJu_disj' : âˆ€ (u) (hu : u âˆˆ C) (v) (hv : v âˆˆ C) (_h_dis : Disjoint u v),
      Disjoint (â‹ƒâ‚€ (Ju u hu : Set (Set Î±))) (â‹ƒâ‚€ â†‘(Ju v hv)) :=by
    intro u hu v hv huv_disj
    rw [hJu_sUnion, hJu_sUnion]
    exact disjoint_of_subset (Set.diff_subset u t) (Set.diff_subset v t) huv_disj
  let J' : Finset (Set Î±) := Finset.biUnion (Finset.univ : Finset J) fun u â†¦ Ju u (h_ss u.prop)
  have hJ'_subset : â†‘J' âŠ† C := by
    intro u
    simp only [J' ,Subtype.coe_mk, univ_eq_attach, coe_biUnion, mem_coe, mem_attach, iUnion_true,
      mem_iUnion, Finset.exists_coe, bex_imp]
    intro v hv huvt
    exact hJu_subset v (h_ss hv) huvt
  refine âŸ¨J', hJ'_subset, ?_, ?_âŸ©
  Â· rw [Finset.coe_biUnion]
    refine PairwiseDisjoint.biUnion ?_ ?_
    Â· simp only [univ_eq_attach, mem_coe, id, iSup_eq_iUnion]
      simp_rw [PairwiseDisjoint, Set.Pairwise]
      intro x _ y _ hxy
      have hxy_disj : Disjoint (x : Set Î±) y := by
        by_contra h_contra
        refine hxy ?_
        refine Subtype.ext ?_
        exact h_dis.elim x.prop y.prop h_contra
      convert hJu_disj' (x : Set Î±) (h_ss x.prop) y (h_ss y.prop) hxy_disj
      Â· rw [sUnion_eq_biUnion]
        congr
      Â· rw [sUnion_eq_biUnion]
        congr
    Â· exact fun u _ â†¦ hJu_disj _ _
  Â· rw [coe_insert, sUnion_insert, Set.union_comm, â† Set.diff_diff, h_eq]
    simp_rw [J', sUnion_eq_biUnion, Set.iUnion_diff]
    simp only [Subtype.coe_mk, mem_coe, Finset.mem_biUnion, Finset.mem_univ, exists_true_left,
      Finset.exists_coe, iUnion_exists, true_and]
    rw [iUnion_comm]
    refine iUnion_congr fun i â†¦ ?_
    by_cases hi : i âˆˆ J
    Â· simp only [hi, iUnion_true, exists_prop]
      rw [â† hJu_sUnion i (h_ss hi), sUnion_eq_biUnion]
      simp only [mem_coe]
    Â· simp only [hi, iUnion_of_empty, iUnion_empty]","error:  application type mismatch
  diff_subset u
argument
  u
has type
  Set Î± : Type u_1
but is expected to have type
  ?m.9837 âˆˆ ?m.9835 \ ?m.9836 : Prop
error:  application type mismatch
  diff_subset v
argument
  v
has type
  Set Î± : Type u_1
but is expected to have type
  ?m.10150 âˆˆ ?m.10148 \ ?m.10149 : Prop
warning:  `bex_imp` has been deprecated, use `existsâ‚‚_imp` instead","lemma exists_disjoint_finset_diff_eq (hC : IsSetSemiring C) (hs : s âˆˆ C) (hI : â†‘I âŠ† C) :
    âˆƒ J : Finset (Set Î±), â†‘J âŠ† C âˆ§ PairwiseDisjoint (J : Set (Set Î±)) id âˆ§
      s \ â‹ƒâ‚€ I = â‹ƒâ‚€ J ",":= by
  classical
  induction I using Finset.induction with
  | empty =>
    simp only [coe_empty, sUnion_empty, diff_empty, exists_prop]
    refine âŸ¨{s}, singleton_subset_set_iff.mpr hs, ?_âŸ©
    simp only [coe_singleton, pairwiseDisjoint_singleton, sUnion_singleton, eq_self_iff_true,
      and_self_iff]
  | @insert t I' _ h => ?_

  rw [coe_insert] at hI
  have ht : t âˆˆ C := hI (Set.mem_insert _ _)
  obtain âŸ¨J, h_ss, h_dis, h_eqâŸ© := h ((Set.subset_insert _ _).trans hI)
  let Ju : âˆ€ u âˆˆ C, Finset (Set Î±) := fun u hu â†¦ hC.diffFinset hu ht
  have hJu_subset : âˆ€ (u) (hu : u âˆˆ C), â†‘(Ju u hu) âŠ† C := by
    intro u hu x hx
    exact hC.diffFinset_subset hu ht hx
  have hJu_disj : âˆ€ (u) (hu : u âˆˆ C), (Ju u hu : Set (Set Î±)).PairwiseDisjoint id := fun u hu â†¦
    hC.pairwiseDisjoint_diffFinset hu ht
  have hJu_sUnion : âˆ€ (u) (hu : u âˆˆ C), â‹ƒâ‚€ (Ju u hu : Set (Set Î±)) = u \ t :=
    fun u hu â†¦ hC.sUnion_diffFinset hu ht
  have hJu_disj' : âˆ€ (u) (hu : u âˆˆ C) (v) (hv : v âˆˆ C) (_h_dis : Disjoint u v),
      Disjoint (â‹ƒâ‚€ (Ju u hu : Set (Set Î±))) (â‹ƒâ‚€ â†‘(Ju v hv)) :=by
    intro u hu v hv huv_disj
    rw [hJu_sUnion, hJu_sUnion]
    exact disjoint_of_subset Set.diff_subset Set.diff_subset huv_disj
  let J' : Finset (Set Î±) := Finset.biUnion (Finset.univ : Finset J) fun u â†¦ Ju u (h_ss u.prop)
  have hJ'_subset : â†‘J' âŠ† C := by
    intro u
    simp only [J' ,Subtype.coe_mk, univ_eq_attach, coe_biUnion, mem_coe, mem_attach, iUnion_true,
      mem_iUnion, Finset.exists_coe, existsâ‚‚_imp]
    intro v hv huvt
    exact hJu_subset v (h_ss hv) huvt
  refine âŸ¨J', hJ'_subset, ?_, ?_âŸ©
  Â· rw [Finset.coe_biUnion]
    refine PairwiseDisjoint.biUnion ?_ ?_
    Â· simp only [univ_eq_attach, mem_coe, id, iSup_eq_iUnion]
      simp_rw [PairwiseDisjoint, Set.Pairwise]
      intro x _ y _ hxy
      have hxy_disj : Disjoint (x : Set Î±) y := by
        by_contra h_contra
        refine hxy ?_
        refine Subtype.ext ?_
        exact h_dis.elim x.prop y.prop h_contra
      convert hJu_disj' (x : Set Î±) (h_ss x.prop) y (h_ss y.prop) hxy_disj
      Â· rw [sUnion_eq_biUnion]
        congr
      Â· rw [sUnion_eq_biUnion]
        congr
    Â· exact fun u _ â†¦ hJu_disj _ _
  Â· rw [coe_insert, sUnion_insert, Set.union_comm, â† Set.diff_diff, h_eq]
    simp_rw [J', sUnion_eq_biUnion, Set.iUnion_diff]
    simp only [Subtype.coe_mk, mem_coe, Finset.mem_biUnion, Finset.mem_univ, exists_true_left,
      Finset.exists_coe, iUnion_exists, true_and]
    rw [iUnion_comm]
    refine iUnion_congr fun i â†¦ ?_
    by_cases hi : i âˆˆ J
    Â· simp only [hi, iUnion_true, exists_prop]
      rw [â† hJu_sUnion i (h_ss hi), sUnion_eq_biUnion]
      simp only [mem_coe]
    Â· simp only [hi, iUnion_of_empty, iUnion_empty]"
Mathlib/Geometry/Manifold/PartitionOfUnity.lean,SmoothBumpCovering.exists_isSubordinate,exists_isSubordinate,19e0ba92d515807cd80a1789fabbf5c4355561be,":= by
  haveI : LocallyCompactSpace H := I.locally_compact
  haveI : LocallyCompactSpace M := ChartedSpace.locallyCompact H M
  haveI : NormalSpace M := normal_of_paracompact_t2
  have hB := fun x hx => SmoothBumpFunction.nhds_basis_support I (hU x hx)
  rcases refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set hs hB with
    âŸ¨Î¹, c, f, hf, hsub', hfinâŸ©
  choose hcs hfU using hf
  rcases exists_subset_iUnion_closed_subset hs (fun i => (f i).isOpen_support)
    (fun x _ => hfin.point_finite x) hsub' with âŸ¨V, hsV, hVc, hVfâŸ©
  choose r hrR hr using fun i => (f i).exists_r_pos_lt_subset_ball (hVc i) (hVf i)
  refine' âŸ¨Î¹, âŸ¨c, fun i => (f i).updateRIn (r i) (hrR i), hcs, _, fun x hx => _âŸ©, fun i => _âŸ©
  Â· simpa only [SmoothBumpFunction.support_updateRIn]
  Â· refine' (mem_iUnion.1 <| hsV hx).imp fun i hi => _
    exact ((f i).updateRIn _ _).eventuallyEq_one_of_dist_lt
      ((f i).support_subset_source <| hVf _ hi) (hr i hi).2
  Â· simpa only [SmoothBumpFunction.support_updateRIn, tsupport] using hfU i","error:  invalid field 'locally_compact', the environment does not contain 'ModelWithCorners.locally_compact'
  I
has type
  ModelWithCorners â„ E H
error:  unknown constant 'ChartedSpace.locallyCompact'
error:  unknown identifier 'normal_of_paracompact_t2'","theorem exists_isSubordinate [T2Space M] [SigmaCompactSpace M] (hs : IsClosed s)
    (hU : âˆ€ x âˆˆ s, U x âˆˆ ğ“ x) :
    âˆƒ (Î¹ : Type uM) (f : SmoothBumpCovering Î¹ I M s), f.IsSubordinate U ",":= by
  haveI : LocallyCompactSpace H := I.locallyCompactSpace
  haveI : LocallyCompactSpace M := ChartedSpace.locallyCompactSpace H M
  have hB := fun x hx => SmoothBumpFunction.nhds_basis_support I (hU x hx)
  rcases refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set hs hB with
    âŸ¨Î¹, c, f, hf, hsub', hfinâŸ©
  choose hcs hfU using hf
  rcases exists_subset_iUnion_closed_subset hs (fun i => (f i).isOpen_support)
    (fun x _ => hfin.point_finite x) hsub' with âŸ¨V, hsV, hVc, hVfâŸ©
  choose r hrR hr using fun i => (f i).exists_r_pos_lt_subset_ball (hVc i) (hVf i)
  refine âŸ¨Î¹, âŸ¨c, fun i => (f i).updateRIn (r i) (hrR i), hcs, ?_, fun x hx => ?_âŸ©, fun i => ?_âŸ©
  Â· simpa only [SmoothBumpFunction.support_updateRIn]
  Â· refine (mem_iUnion.1 <| hsV hx).imp fun i hi => ?_
    exact ((f i).updateRIn _ _).eventuallyEq_one_of_dist_lt
      ((f i).support_subset_source <| hVf _ hi) (hr i hi).2
  Â· simpa only [SmoothBumpFunction.support_updateRIn, tsupport] using hfU i"
Mathlib/Topology/Separation.lean,t2_separation,t2_separation,3fca282c58b247f313d18951a2f93d8341cd48a7,":=
  T2Space.t2 x y h","error:  application type mismatch
  T2Space.t2 x
argument
  x
has type
  X : Type u_1
but is expected to have type
  ?m.120553 â‰  ?m.120554 : Prop","theorem t2_separation [T2Space X] {x y : X} (h : x â‰  y) :
    âˆƒ u v : Set X, IsOpen u âˆ§ IsOpen v âˆ§ x âˆˆ u âˆ§ y âˆˆ v âˆ§ Disjoint u v ",":=
  T2Space.t2 h"
Mathlib/Topology/Connected/PathConnected.lean,Path.range_reparam,range_reparam,f655aad92f39fa1eff3436b3b0c4a1004e666b53,":= by
  change range (Î³ âˆ˜ f) = range Î³
  have : range f = univ := by
    rw [range_iff_surjective]
    intro t
    have hâ‚ : Continuous (Set.IccExtend (zero_le_one' â„) f) := by fun_prop
    have := intermediate_value_Icc (zero_le_one' â„) hâ‚.continuousOn
    Â· rw [IccExtend_left, IccExtend_right, Icc.mk_zero, Icc.mk_one, hfâ‚€, hfâ‚] at this
      rcases this t.2 with âŸ¨w, hwâ‚, hwâ‚‚âŸ©
      rw [IccExtend_of_mem _ _ hwâ‚] at hwâ‚‚
      exact âŸ¨_, hwâ‚‚âŸ©
  rw [range_comp, this, image_univ]","error:  `fun_prop` was unable to prove `Continuous (IccExtend â‹¯ f)`

Try running with discharger `fun_prop (disch:=aesop)` or with a different discharger tactic like `assumption`, `linarith`, `omega`.
Sometimes it is useful to run `fun_prop (disch:=trace_state; sorry)` which will print all the necessary subgoals for `fun_prop` to succeed.

Potential issues to fix:
  No theorems found for `Set.IccExtend` in order to prove Continuous fun a â†¦ IccExtend â‹¯ f a
  Failed to synthesize instance DiscreteTopology â„ when applying theorem continuous_of_discreteTopology.

For more detailed information use `set_option trace.Meta.Tactic.fun_prop true`","theorem range_reparam (Î³ : Path x y) {f : I â†’ I} (hfcont : Continuous f) (hfâ‚€ : f 0 = 0)
    (hfâ‚ : f 1 = 1) : range (Î³.reparam f hfcont hfâ‚€ hfâ‚) = range Î³ ",":= by
  change range (Î³ âˆ˜ f) = range Î³
  have : range f = univ := by
    rw [range_iff_surjective]
    intro t
    have hâ‚ : Continuous (Set.IccExtend (zero_le_one' â„) f) := by continuity
    have := intermediate_value_Icc (zero_le_one' â„) hâ‚.continuousOn
    Â· rw [IccExtend_left, IccExtend_right, Icc.mk_zero, Icc.mk_one, hfâ‚€, hfâ‚] at this
      rcases this t.2 with âŸ¨w, hwâ‚, hwâ‚‚âŸ©
      rw [IccExtend_of_mem _ _ hwâ‚] at hwâ‚‚
      exact âŸ¨_, hwâ‚‚âŸ©
  rw [range_comp, this, image_univ]"
Mathlib/AlgebraicGeometry/Spec.lean,AlgebraicGeometry.Spec.topMap_id,Spec.topMap_id,796b4033eac2ff07562cc3dd2ea6c81031f7e12e,":=
  PrimeSpectrum.comap_id","error:  unsolved goals
case w.w
R : CommRingCat
Uâœ : TopologicalSpace.Opens â†‘â†‘(sheafedSpaceObj R).toPresheafedSpace
xâœ : (forget CommRingCat).obj ((sheafedSpaceObj R).presheaf.obj { unop := Uâœ })
âŠ¢ (ğŸ™ ((structureSheaf â†‘R).val.obj { unop := (TopologicalSpace.Opens.map (topMap (ğŸ™ R))).obj Uâœ }))
      ((ğŸ™ ((structureSheaf â†‘R).val.obj { unop := Uâœ })) xâœ) =
    (ğŸ™ ((structureSheaf â†‘R).val.obj { unop := Uâœ })) xâœ",theorem Spec.topMap_id (R : CommRingCat.{u}) : Spec.topMap (ğŸ™ R) = ğŸ™ (Spec.topObj R) ,":=
  rfl"
Mathlib/Data/Finset/Interval.lean,Finset.monotone_iff_forall_le_cons,monotone_iff_forall_le_cons,818337c6bd6587795f69dffefeeae7988f4bdba8,":= by
  classical simp [monotone_iff_forall_covby, covby_iff_exists_cons]","error:  unknown identifier 'monotone_iff_forall_covby'
error:  unknown identifier 'covby_iff_exists_cons'
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
instâœ : Preorder Î²
s t : Finset Î±
f : Finset Î± â†’ Î²
âŠ¢ Monotone f â†” âˆ€ (s : Finset Î±) â¦ƒa : Î±â¦„, a âˆ‰ s â†’ f s â‰¤ f (insert a s)","lemma monotone_iff_forall_le_cons : Monotone f â†” âˆ€ s, âˆ€ â¦ƒaâ¦„ (ha), f s â‰¤ f (cons a s ha) ",":= by
  classical simp [monotone_iff_forall_covBy, covBy_iff_exists_cons]"
Mathlib/Algebra/BigOperators/Finsupp.lean,Finsupp.univ_sum_single_apply',univ_sum_single_apply',67e80fd089fe45abea632652c43b78eba72d60e3,":= by
  simp_rw [Finsupp.single, DFinsupp.single, coe_mk']
  classical rw [Finset.sum_pi_single]
  simp","error:  unknown identifier 'DFinsupp.single'
error:  simp made no progress","theorem univ_sum_single_apply' [AddCommMonoid M] [Fintype Î±] (i : Î±) (m : M) :
    âˆ‘ j : Î±, single j m i = m ",":= by
  simp_rw [single, coe_mk]
  classical rw [Finset.sum_pi_single]
  simp"
Mathlib/Topology/MetricSpace/Polish.lean,ClosedEmbedding.polishSpace,_root_.ClosedEmbedding.polishSpace,c857de248bf3499170a7907f818ac2f6465b7e05,":= by
  letI := upgradePolishSpace Î²
  letI : MetricSpace Î± := hf.toEmbedding.comapMetricSpace f
  haveI : SecondCountableTopology Î± := hf.toEmbedding.secondCountableTopology
  have : CompleteSpace Î± := by
    rw [completeSpace_iff_isComplete_range hf.toEmbedding.to_isometry.uniformInducing]
    exact hf.closed_range.isComplete
  infer_instance","error:  invalid field 'closed_range', the environment does not contain 'ClosedEmbedding.closed_range'
  hf
has type
  ClosedEmbedding f","theorem _root_.ClosedEmbedding.polishSpace [TopologicalSpace Î±] [TopologicalSpace Î²] [PolishSpace Î²]
    {f : Î± â†’ Î²} (hf : ClosedEmbedding f) : PolishSpace Î± ",":= by
  letI := upgradePolishSpace Î²
  letI : MetricSpace Î± := hf.toEmbedding.comapMetricSpace f
  haveI : SecondCountableTopology Î± := hf.toEmbedding.secondCountableTopology
  have : CompleteSpace Î± := by
    rw [completeSpace_iff_isComplete_range hf.toEmbedding.to_isometry.uniformInducing]
    exact hf.isClosed_range.isComplete
  infer_instance"
Mathlib/Data/Matrix/Basic.lean,Matrix.zero_le_one_elem,zero_le_one_elem,45be2b6ff944cfa5ed20e4a70f766526e146f323,":= by
  by_cases hi : i = j <;> simp [hi]","warning:  @transpose does not have a doc string
warning:  @conjTranspose does not have a doc string
error:  simp made no progress
error:  unsolved goals
case pos
l : Type u_1
m : Type u_2
n : Type u_3
o : Type u_4
m' : o â†’ Type u_5
n' : o â†’ Type u_6
R : Type u_7
S : Type u_8
Î± : Type v
Î² : Type w
Î³ : Type u_9
instâœâ´ : DecidableEq n
instâœÂ³ : Zero Î±
instâœÂ² : One Î±
instâœÂ¹ : Preorder Î±
instâœ : ZeroLEOneClass Î±
i j : n
hi : i = j
âŠ¢ 0 â‰¤ 1 i j
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Matrix.bit1_apply` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `Matrix.bit1_apply` has been deprecated
warning:  @dotProduct does not have a doc string
warning:  @mulVec does not have a doc string
warning:  @vecMul does not have a doc string","lemma zero_le_one_elem [Preorder Î±] [ZeroLEOneClass Î±] (i j : n) :
    0 â‰¤ (1 : Matrix n n Î±) i j ",":= by
  by_cases hi : i = j
  Â· subst hi
    simp
  Â· simp [hi]"
Mathlib/NumberTheory/Modular.lean,ModularGroup.smul_eq_lcRow0_add,smul_eq_lcRow0_add,1871d0d927ef9246e863af6b14b88ae5dff513d0,":= by
  have nonZ1 : (p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2 â‰  0 := mod_cast hp.sq_add_sq_ne_zero
  have : ((â†‘) : â„¤ â†’ â„) âˆ˜ p â‰  0 := fun h => hp.ne_zero (by ext i; simpa using congr_fun h i)
  have nonZ2 : (p 0 : â„‚) * z + p 1 â‰  0 := by simpa using linear_ne_zero _ z this
  field_simp [nonZ1, nonZ2, denom_ne_zero, num]
  rw [(by simp :
    (p 1 : â„‚) * z - p 0 = (p 1 * z - p 0) * â†‘(Matrix.det (â†‘g : Mat[2, 2][â„¤])))]
  rw [â† hg, det_fin_two]
  simp only [Int.coe_castRingHom, coe_matrix_coe, Int.cast_mul, ofReal_int_cast, map_apply, denom,
    Int.cast_sub, coe_GLPos_coe_GL_coe_matrix, coe'_apply_complex]
  ring","error:  unexpected token ','; expected ':', ']' or ']''
error:  unsolved goals
g : SL(2, â„¤)
z : â„
p : Fin 2 â†’ â„¤
hp : IsCoprime (p 0) (p 1)
hg : â†‘g 1 = p
nonZ1 : â†‘(p 0) ^ 2 + â†‘(p 1) ^ 2 â‰  0
this : Int.cast âˆ˜ p â‰  0
nonZ2 : â†‘(p 0) * â†‘z + â†‘(p 1) â‰  0
âŠ¢ â†‘(p 1) * â†‘z - â†‘(p 0) = (â†‘(p 1) * â†‘z - â†‘(p 0)) * ?m.101538.det
error:  invalid occurrence of universe level 'u_1' at 'ModularGroup.tendsto_abs_re_smul', it does not occur at the declaration type, nor it is explicit universe level provided by the user, occurring at expression
  smul_eq_lcRow0_add.{u_1} z hp (Subtype.property.{1} g)
at declaration body
  fun (z : â„) {p : Fin 2 â†’ â„¤} (hp : IsCoprime (p 0) (p 1)) â†¦
    let_fun this : Tendsto (fun (g : â†‘((fun (g : SL(2, â„¤)) â†¦ â†‘g 1) â»Â¹' {p})) â†¦ (â†‘g â€¢ z).re) cofinite (cocompact â„) :=
      let_fun this : (â†‘(p 0) ^ 2 + â†‘(p 1) ^ 2)â»Â¹ â‰  0 :=
        inv_ne_zero
          (cast
            (Eq.trans
              (Eq.trans
                (congr
                  (congrArg Ne
                    (congr (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (p x ^ 2)) (Eq.symm Nat.cast_zero))
                      (congrArg (fun (x : Fin 2) â†¦ p x ^ 2) (Eq.symm Nat.cast_one))))
                  (Eq.symm Nat.cast_zero))
                (congrArg Not
                  (congr
                    (congrArg Eq
                      (congr (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (p x ^ 2)) Nat.cast_zero)
                        (congrArg (fun (x : Fin 2) â†¦ p x ^ 2) Nat.cast_one)))
                    Nat.cast_zero)))
              (Eq.symm
                (Eq.trans
                  (Eq.trans
                    (congr
                      (congrArg Ne
                        (congr (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (â†‘(p x) ^ 2)) (Eq.symm Nat.cast_zero))
                          (congrArg (fun (x : Fin 2) â†¦ â†‘(p x) ^ 2) (Eq.symm Nat.cast_one))))
                      (Eq.symm Nat.cast_zero))
                    (Eq.trans
                      (congrArg (fun (x : â„) â†¦ x â‰  â†‘0)
                        (Eq.trans
                          (congr (congrArg HAdd.hAdd (Mathlib.Algebra.Ring.Int._auxLemma.2 (p â†‘0) 2))
                            (Mathlib.Algebra.Ring.Int._auxLemma.2 (p â†‘1) 2))
                          (Mathlib.Data.Int.Cast.Basic._auxLemma.7 (p â†‘0 ^ 2) (p â†‘1 ^ 2))))
                      (congrArg Not
                        (Eq.trans
                          (congrArg (Eq â†‘(p â†‘0 ^ 2 + p â†‘1 ^ 2))
                            (Eq.trans Nat.cast_zero
                              (Eq.symm (Eq.trans (congrArg Int.cast Nat.cast_zero) Int.cast_zero))))
                          Mathlib.Data.Int.Cast.Lemmas._auxLemma.3))))
                  (congrArg Not
                    (congr
                      (congrArg Eq
                        (congr (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (p x ^ 2)) Nat.cast_zero)
                          (congrArg (fun (x : Fin 2) â†¦ p x ^ 2) Nat.cast_one)))
                      Nat.cast_zero)))))
            (IsCoprime.sq_add_sq_ne_zero hp));
      let f : â„ â‰ƒâ‚œ â„ := Homeomorph.mulRightâ‚€ (â†‘(p 0) ^ 2 + â†‘(p 1) ^ 2)â»Â¹ this;
      let ff : â„ â‰ƒâ‚œ â„ :=
        Homeomorph.addRight ((â†‘(p 1) * â†‘z - â†‘(p 0)) / ((â†‘(p 0) ^ 2 + â†‘(p 1) ^ 2) * (â†‘(p 0) * â†‘z + â†‘(p 1)))).re;
      Eq.mpr
        (eq_of_heq
          ((fun (Î± Î±' : Type) (e'_1 : Î± = Î±') (Î² : Type) (f : Î± â†’ Î²) (f' : Î±' â†’ Î²) (e'_3 : Î± = Î±' â†’ HEq f f')
                (lâ‚ : Filter Î±) (lâ‚' : Filter Î±') (e'_4 : Î± = Î±' â†’ HEq lâ‚ lâ‚') (lâ‚‚ : Filter Î²) â†¦
              Eq.casesOn (motive := fun (a : Type) (x : Î± = a) â†¦
                Î±' = a â†’ HEq e'_1 x â†’ HEq (Tendsto f lâ‚ lâ‚‚) (Tendsto f' lâ‚' lâ‚‚)) e'_1
                (fun (h : Î±' = Î±) â†¦
                  Eq.ndrec (motive := fun (Î±' : Type) â†¦
                    âˆ€ (e_1 : Î± = Î±') (f' : Î±' â†’ Î²),
                      HEq f f' â†’
                        âˆ€ (lâ‚' : Filter Î±'),
                          HEq lâ‚ lâ‚' â†’ HEq e_1 (Eq.refl Î±) â†’ HEq (Tendsto f lâ‚ lâ‚‚) (Tendsto f' lâ‚' lâ‚‚))
                    (fun (e_1 : Î± = Î±) (f' : Î± â†’ Î²) (e_3 : HEq f f') (lâ‚' : Filter Î±) (e_4 : HEq lâ‚ lâ‚')
                        (h : HEq e_1 (Eq.refl Î±)) â†¦
                      HEq.casesOn (motive := fun {Î²_1 : Type} (a : Î²_1) (x : HEq f a) â†¦
                        (Î± â†’ Î²) = Î²_1 â†’ HEq f' a â†’ HEq e_3 x â†’ HEq (Tendsto f lâ‚ lâ‚‚) (Tendsto f' lâ‚' lâ‚‚)) e_3
                        (fun (h : (Î± â†’ Î²) = (Î± â†’ Î²)) (h : HEq f' f) â†¦
                          Eq.ndrec (motive := fun (f' : Î± â†’ Î²) â†¦
                            âˆ€ (e_3 : HEq f f'), HEq e_3 (HEq.refl f) â†’ HEq (Tendsto f lâ‚ lâ‚‚) (Tendsto f' lâ‚' lâ‚‚))
                            (fun (e_3 : HEq f f) (h : HEq e_3 (HEq.refl f)) â†¦
                              HEq.casesOn (motive := fun {Î²_1 : Type} (a : Î²_1) (x : HEq lâ‚ a) â†¦
                                Filter Î± = Î²_1 â†’ HEq lâ‚' a â†’ HEq e_4 x â†’ HEq (Tendsto f lâ‚ lâ‚‚) (Tendsto f lâ‚' lâ‚‚)) e_4
                                (fun (h : Filter Î± = Filter Î±) (h : HEq lâ‚' lâ‚) â†¦
                                  Eq.ndrec (motive := fun (lâ‚' : Filter Î±) â†¦
                                    âˆ€ (e_4 : HEq lâ‚ lâ‚'),
                                      HEq e_4 (HEq.refl lâ‚) â†’ HEq (Tendsto f lâ‚ lâ‚‚) (Tendsto f lâ‚' lâ‚‚))
                                    (fun (e_4 : HEq lâ‚ lâ‚) (h : HEq e_4 (HEq.refl lâ‚)) â†¦ HEq.refl (Tendsto f lâ‚ lâ‚‚))
                                    (Eq.symm (eq_of_heq h)) e_4)
                                (Eq.refl (Filter Î±)) (HEq.refl lâ‚') (HEq.refl e_4))
                            (Eq.symm (eq_of_heq h)) e_3)
                        (Eq.refl (Î± â†’ Î²)) (HEq.refl f') (HEq.refl e_3))
                    (Eq.symm h) e'_1 f' (e'_3 e'_1) lâ‚' (e'_4 e'_1))
                (Eq.refl Î±') (HEq.refl e'_1))
            â†‘((fun (g : SL(2, â„¤)) â†¦ â†‘g 1) â»Â¹' {p}) { g : SL(2, â„¤) // â†‘g 1 = p }
            (eq_of_heq
              ((fun (e : @Set.Elem = @Subtype) (Î± : Type) (s s' : Set Î±) (e'_2 : s = s') â†¦
                  Eq.casesOn (motive := fun (a : {Î± : Type} â†’ Set Î± â†’ Type) (x : @Set.Elem = a) â†¦
                    @Subtype = a â†’ HEq e x â†’ HEq (â†‘s) (Subtype s')) e
                    (fun (h : @Subtype = @Set.Elem) â†¦
                      Eq.ndrec (motive := fun (f' : {Î± : Type} â†’ Set Î± â†’ Type) â†¦
                        âˆ€ (e : @Set.Elem = f'), HEq e (Eq.refl @Set.Elem) â†’ HEq (â†‘s) (f' s'))
                        (fun (e : @Set.Elem = @Set.Elem) (h : HEq e (Eq.refl @Set.Elem)) â†¦
                          Eq.casesOn (motive := fun (a : Set Î±) (x : s = a) â†¦ s' = a â†’ HEq e'_2 x â†’ HEq â†‘s â†‘s') e'_2
                            (fun (h : s' = s) â†¦
                              Eq.ndrec (motive := fun (s' : Set Î±) â†¦ âˆ€ (e_2 : s = s'), HEq e_2 (Eq.refl s) â†’ HEq â†‘s â†‘s')
                                (fun (e_2 : s = s) (h : HEq e_2 (Eq.refl s)) â†¦ HEq.refl â†‘s) (Eq.symm h) e'_2)
                            (Eq.refl s') (HEq.refl e'_2))
                        (Eq.symm h) e)
                    (Eq.refl @Subtype) (HEq.refl e))
                (Eq.refl @Set.Elem) SL(2, â„¤) ((fun (g : SL(2, â„¤)) â†¦ â†‘g 1) â»Â¹' {p}) (fun (g : SL(2, â„¤)) â†¦ â†‘g 1 = p)
                (funext fun (x : SL(2, â„¤)) â†¦ Eq.refl (((fun (g : SL(2, â„¤)) â†¦ â†‘g 1) â»Â¹' {p}) x))))
            â„ (fun (g : â†‘((fun (g : SL(2, â„¤)) â†¦ â†‘g 1) â»Â¹' {p})) â†¦ (â†‘g â€¢ z).re)
            (â‡‘(f.trans ff) âˆ˜ fun (g : { g : SL(2, â„¤) // â†‘g 1 = p }) â†¦
              (lcRow0 p) â†‘((SpecialLinearGroup.map (Int.castRingHom â„)) â†‘g))
            (fun (e_1 : â†‘((fun (g : SL(2, â„¤)) â†¦ â†‘g 1) â»Â¹' {p}) = { g : SL(2, â„¤) // â†‘g 1 = p }) â†¦
              heq_of_eq
                (funext fun (g : â†‘((fun (g : SL(2, â„¤)) â†¦ â†‘g 1) â»Â¹' {p})) â†¦
                  let_fun this :
                    (â†‘g â€¢ z).re =
                      (lcRow0 p) â†‘((SpecialLinearGroup.map (Int.castRingHom â„)) â†‘g) / (â†‘(p 0) ^ 2 + â†‘(p 1) ^ 2) +
                        ((â†‘(p 1) * â†‘z - â†‘(p 0)) / ((â†‘(p 0) ^ 2 + â†‘(p 1) ^ 2) * (â†‘(p 0) * â†‘z + â†‘(p 1)))).re :=
                    cast
                      (Eq.trans
                        (Eq.trans
                          (Eq.trans
                            (congrArg (fun (x : â„‚) â†¦ (â†‘(â†‘g â€¢ z)).re = x.re)
                              (congr
                                (congrArg
                                  (fun (x : â„‚) â†¦
                                    HAdd.hAdd (â†‘((lcRow0 p) â†‘((SpecialLinearGroup.map (Int.castRingHom â„)) â†‘g)) / x))
                                  (congr (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (â†‘(p x) ^ 2)) (Eq.symm Nat.cast_zero))
                                    (congrArg (fun (x : Fin 2) â†¦ â†‘(p x) ^ 2) (Eq.symm Nat.cast_one))))
                                (congr
                                  (congrArg HDiv.hDiv
                                    (congr (congrArg (fun (x : Fin 2) â†¦ HSub.hSub (â†‘(p x) * â†‘z)) (Eq.symm Nat.cast_one))
                                      (congrArg (fun (x : Fin 2) â†¦ â†‘(p x)) (Eq.symm Nat.cast_zero))))
                                  (congr
                                    (congrArg HMul.hMul
                                      (congr
                                        (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (â†‘(p x) ^ 2)) (Eq.symm Nat.cast_zero))
                                        (congrArg (fun (x : Fin 2) â†¦ â†‘(p x) ^ 2) (Eq.symm Nat.cast_one))))
                                    (congr
                                      (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (â†‘(p x) * â†‘z)) (Eq.symm Nat.cast_zero))
                                      (congrArg (fun (x : Fin 2) â†¦ â†‘(p x)) (Eq.symm Nat.cast_one)))))))
                            (congrArg (fun (x : â„‚) â†¦ (â†‘(â†‘g â€¢ z)).re = x.re)
                              (congr
                                (congrArg HAdd.hAdd
                                  (Eq.trans
                                    (Eq.trans
                                      (congrArg
                                        (HDiv.hDiv â†‘((lcRow0 p) â†‘((SpecialLinearGroup.map (Int.castRingHom â„)) â†‘g)))
                                        (Eq.trans
                                          (congr (congrArg HAdd.hAdd (Mathlib.Algebra.Ring.Int._auxLemma.2 (p â†‘0) 2))
                                            (Mathlib.Algebra.Ring.Int._auxLemma.2 (p â†‘1) 2))
                                          (Mathlib.Data.Int.Cast.Basic._auxLemma.7 (p â†‘0 ^ 2) (p â†‘1 ^ 2))))
                                      (congrArg
                                        (HDiv.hDiv â†‘((lcRow0 p) â†‘((SpecialLinearGroup.map (Int.castRingHom â„)) â†‘g)))
                                        (Eq.trans
                                          (Eq.trans
                                            (Eq.trans
                                              (congrArg Int.cast
                                                (congr (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (p x ^ 2)) Nat.cast_zero)
                                                  (congrArg (fun (x : Fin 2) â†¦ p x ^ 2) Nat.cast_one)))
                                              (Int.cast_add (p 0 ^ 2) (p 1 ^ 2)))
                                            (congr (congrArg HAdd.hAdd (Int.cast_pow (p 0) 2)) (Int.cast_pow (p 1) 2)))
                                          (Eq.symm
                                            (Eq.trans
                                              (Eq.trans
                                                (congrArg ofReal'
                                                  (Eq.trans
                                                    (Eq.trans
                                                      (congrArg Int.cast
                                                        (congr
                                                          (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (p x ^ 2))
                                                            Nat.cast_zero)
                                                          (congrArg (fun (x : Fin 2) â†¦ p x ^ 2) Nat.cast_one)))
                                                      (Int.cast_add (p 0 ^ 2) (p 1 ^ 2)))
                                                    (congr (congrArg HAdd.hAdd (Int.cast_pow (p 0) 2))
                                                      (Int.cast_pow (p 1) 2))))
                                                (ofReal_add (â†‘(p 0) ^ 2) (â†‘(p 1) ^ 2)))
                                              (congr (congrArg HAdd.hAdd (ofReal_pow (â†‘(p 0)) 2))
                                                (ofReal_pow (â†‘(p 1)) 2)))))))
                                    (Mathlib.Data.Complex.Basic._auxLemma.16
                                      ((lcRow0 p) â†‘((SpecialLinearGroup.map (Int.castRingHom â„)) â†‘g))
                                      â†‘(p â†‘0 ^ 2 + p â†‘1 ^ 2))))
                                (congrArg (fun (x : â„‚) â†¦ (â†‘(p â†‘1) * â†‘z - â†‘(p â†‘0)) / (x * (â†‘(p â†‘0) * â†‘z + â†‘(p â†‘1))))
                                  (Eq.trans
                                    (congr (congrArg HAdd.hAdd (Mathlib.Algebra.Ring.Int._auxLemma.2 (p â†‘0) 2))
                                      (Mathlib.Algebra.Ring.Int._auxLemma.2 (p â†‘1) 2))
                                    (Mathlib.Data.Int.Cast.Basic._auxLemma.7 (p â†‘0 ^ 2) (p â†‘1 ^ 2)))))))
                          (congrArg (fun (x : â„‚) â†¦ (â†‘(â†‘g â€¢ z)).re = x.re)
                            (congr
                              (congrArg
                                (fun (x : â„¤) â†¦
                                  HAdd.hAdd â†‘((lcRow0 p) â†‘((SpecialLinearGroup.map (Int.castRingHom â„)) â†‘g) / â†‘x))
                                (congr (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (p x ^ 2)) Nat.cast_zero)
                                  (congrArg (fun (x : Fin 2) â†¦ p x ^ 2) Nat.cast_one)))
                              (congr
                                (congrArg HDiv.hDiv
                                  (congr (congrArg (fun (x : Fin 2) â†¦ HSub.hSub (â†‘(p x) * â†‘z)) Nat.cast_one)
                                    (congrArg (fun (x : Fin 2) â†¦ â†‘(p x)) Nat.cast_zero)))
                                (congr
                                  (congrArg (fun (x : â„¤) â†¦ HMul.hMul â†‘x)
                                    (congr (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (p x ^ 2)) Nat.cast_zero)
                                      (congrArg (fun (x : Fin 2) â†¦ p x ^ 2) Nat.cast_one)))
                                  (congr (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (â†‘(p x) * â†‘z)) Nat.cast_zero)
                                    (congrArg (fun (x : Fin 2) â†¦ â†‘(p x)) Nat.cast_one)))))))
                        (Eq.symm
                          (Eq.trans
                            (Eq.trans
                              (congrArg (Eq (â†‘g â€¢ z).re)
                                (congr
                                  (congrArg
                                    (fun (x : â„) â†¦
                                      HAdd.hAdd ((lcRow0 p) â†‘((SpecialLinearGroup.map (Int.castRingHom â„)) â†‘g) / x))
                                    (congr (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (â†‘(p x) ^ 2)) (Eq.symm Nat.cast_zero))
                                      (congrArg (fun (x : Fin 2) â†¦ â†‘(p x) ^ 2) (Eq.symm Nat.cast_one))))
                                  (congrArg Complex.re
                                    (congr
                                      (congrArg HDiv.hDiv
                                        (congr
                                          (congrArg (fun (x : Fin 2) â†¦ HSub.hSub (â†‘(p x) * â†‘z)) (Eq.symm Nat.cast_one))
                                          (congrArg (fun (x : Fin 2) â†¦ â†‘(p x)) (Eq.symm Nat.cast_zero))))
                                      (congr
                                        (congrArg HMul.hMul
                                          (congr
                                            (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (â†‘(p x) ^ 2))
                                              (Eq.symm Nat.cast_zero))
                                            (congrArg (fun (x : Fin 2) â†¦ â†‘(p x) ^ 2) (Eq.symm Nat.cast_one))))
                                        (congr
                                          (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (â†‘(p x) * â†‘z)) (Eq.symm Nat.cast_zero))
                                          (congrArg (fun (x : Fin 2) â†¦ â†‘(p x)) (Eq.symm Nat.cast_one))))))))
                              (congrArg (Eq (â†‘g â€¢ z).re)
                                (congr
                                  (congrArg
                                    (fun (x : â„) â†¦
                                      HAdd.hAdd ((lcRow0 p) â†‘((SpecialLinearGroup.map (Int.castRingHom â„)) â†‘g) / x))
                                    (Eq.trans
                                      (congr (congrArg HAdd.hAdd (Mathlib.Algebra.Ring.Int._auxLemma.2 (p â†‘0) 2))
                                        (Mathlib.Algebra.Ring.Int._auxLemma.2 (p â†‘1) 2))
                                      (Mathlib.Data.Int.Cast.Basic._auxLemma.7 (p â†‘0 ^ 2) (p â†‘1 ^ 2))))
                                  (congrArg
                                    (fun (x : â„‚) â†¦ ((â†‘(p â†‘1) * â†‘z - â†‘(p â†‘0)) / (x * (â†‘(p â†‘0) * â†‘z + â†‘(p â†‘1)))).re)
                                    (Eq.trans
                                      (congr (congrArg HAdd.hAdd (Mathlib.Algebra.Ring.Int._auxLemma.2 (p â†‘0) 2))
                                        (Mathlib.Algebra.Ring.Int._auxLemma.2 (p â†‘1) 2))
                                      (Mathlib.Data.Int.Cast.Basic._auxLemma.7 (p â†‘0 ^ 2) (p â†‘1 ^ 2)))))))
                            (congrArg (Eq (â†‘g â€¢ z).re)
                              (congr
                                (congrArg
                                  (fun (x : â„¤) â†¦
                                    HAdd.hAdd ((lcRow0 p) â†‘((SpecialLinearGroup.map (Int.castRingHom â„)) â†‘g) / â†‘x))
                                  (congr (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (p x ^ 2)) Nat.cast_zero)
                                    (congrArg (fun (x : Fin 2) â†¦ p x ^ 2) Nat.cast_one)))
                                (congrArg Complex.re
                                  (congr
                                    (congrArg HDiv.hDiv
                                      (congr (congrArg (fun (x : Fin 2) â†¦ HSub.hSub (â†‘(p x) * â†‘z)) Nat.cast_one)
                                        (congrArg (fun (x : Fin 2) â†¦ â†‘(p x)) Nat.cast_zero)))
                                    (congr
                                      (congrArg (fun (x : â„¤) â†¦ HMul.hMul â†‘x)
                                        (congr (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (p x ^ 2)) Nat.cast_zero)
                                          (congrArg (fun (x : Fin 2) â†¦ p x ^ 2) Nat.cast_one)))
                                      (congr (congrArg (fun (x : Fin 2) â†¦ HAdd.hAdd (â†‘(p x) * â†‘z)) Nat.cast_zero)
                                        (congrArg (fun (x : Fin 2) â†¦ â†‘(p x)) Nat.cast_one))))))))))
                      (congr_arg Complex.re (smul_eq_lcRow0_add z hp g.property));
                  this))
            cofinite cofinite
            (fun (e_1 : â†‘((fun (g : SL(2, â„¤)) â†¦ â†‘g 1) â»Â¹' {p}) = { g : SL(2, â„¤) // â†‘g 1 = p }) â†¦
              heq_of_eq (Eq.refl cofinite))
            (cocompact â„)))
        (_root_.id
          (Tendsto.comp (ClosedEmbedding.tendsto_cocompact (Homeomorph.closedEmbedding (f.trans ff)))
            (tendsto_lcRow0 hp)));
    Tendsto.comp tendsto_norm_cocompact_atTop this
error:  unknown identifier 'tendsto_abs_re_smul'
error:  application type mismatch
  And.intro g.property
argument
  g.property
has type
  (â†‘g).det = 1 : Prop
but is expected to have type
  â†‘g 1 = cd : Prop
error:  application type mismatch
  Set.mem_preimage.mp g.property
argument
  g.property
has type
  (â†‘g).det = 1 : Prop
but is expected to have type
  1 âˆˆ â†‘g â»Â¹' {cd} : Prop
error:  application type mismatch
  âŸ¨â†‘g1, thisâŸ©
argument
  this
has type
  g1 âˆˆ (fun g â†¦ â†‘g 1) â»Â¹' {cd} : Prop
but is expected to have type
  (â†‘g1).det = 1 : Prop
warning:  fd does not have a doc string
warning:  fdo does not have a doc string","theorem smul_eq_lcRow0_add {p : Fin 2 â†’ â„¤} (hp : IsCoprime (p 0) (p 1)) (hg : (â†‘â‚˜g) 1 = p) :
    â†‘(g â€¢ z) =
      (lcRow0 p â†‘(g : SL(2, â„)) : â„‚) / ((p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2) +
        ((p 1 : â„‚) * z - p 0) / (((p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2) * (p 0 * z + p 1)) ",":= by
  have nonZ1 : (p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2 â‰  0 := mod_cast hp.sq_add_sq_ne_zero
  have : ((â†‘) : â„¤ â†’ â„) âˆ˜ p â‰  0 := fun h => hp.ne_zero (by ext i; simpa using congr_fun h i)
  have nonZ2 : (p 0 : â„‚) * z + p 1 â‰  0 := by simpa using linear_ne_zero _ z this
  field_simp [nonZ1, nonZ2, denom_ne_zero, num]
  rw [(by simp :
    (p 1 : â„‚) * z - p 0 = (p 1 * z - p 0) * â†‘(Matrix.det (â†‘g : Matrix (Fin 2) (Fin 2) â„¤)))]
  rw [â† hg, det_fin_two]
  simp only [Int.coe_castRingHom, coe_matrix_coe, Int.cast_mul, ofReal_intCast, map_apply, denom,
    Int.cast_sub, coe_GLPos_coe_GL_coe_matrix, coe'_apply_complex]
  ring"
Mathlib/GroupTheory/Finiteness.lean,Subgroup.rank_closure_finset_le_card,rank_closure_finset_le_card,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  classical
  let t : Finset (closure (s : Set G)) := s.preimage Subtype.val (Subtype.coe_injective.injOn _)
  have ht : closure (t : Set (closure (s : Set G))) = âŠ¤ := by
    rw [Finset.coe_preimage]
    exact closure_preimage_eq_top (s : Set G)
  apply (Group.rank_le (closure (s : Set G)) ht).trans
  suffices H : Set.InjOn Subtype.val (t : Set (closure (s : Set G))) by
    rw [â† Finset.card_image_of_injOn H, Finset.image_preimage]
    apply Finset.card_filter_le
  apply Subtype.coe_injective.injOn","error:  application type mismatch
  s.preimage Subtype.val â‹¯
argument
  Function.Injective.injOn Subtype.coe_injective ?m.50022
has type
  âˆ€ â¦ƒxâ‚‚ : Subtype ?m.49998â¦„, xâ‚‚ âˆˆ ?m.50020 â†’ â†‘?m.50021 = â†‘xâ‚‚ â†’ ?m.50021 = xâ‚‚ : Prop
but is expected to have type
  Set.InjOn Subtype.val (Subtype.val â»Â¹' â†‘s) : Prop",theorem rank_closure_finset_le_card (s : Finset G) : Group.rank (closure (s : Set G)) â‰¤ s.card ,":= by
  classical
  let t : Finset (closure (s : Set G)) := s.preimage Subtype.val Subtype.coe_injective.injOn
  have ht : closure (t : Set (closure (s : Set G))) = âŠ¤ := by
    rw [Finset.coe_preimage]
    exact closure_preimage_eq_top (s : Set G)
  apply (Group.rank_le (closure (s : Set G)) ht).trans
  suffices H : Set.InjOn Subtype.val (t : Set (closure (s : Set G))) by
    rw [â† Finset.card_image_of_injOn H, Finset.image_preimage]
    apply Finset.card_filter_le
  apply Subtype.coe_injective.injOn"
Mathlib/CategoryTheory/Sites/DenseSubsite.lean,CategoryTheory.Functor.IsCoverDense.Types.pushforwardFamily_compatible,pushforwardFamily_compatible,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  intro Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ e
  apply H.ext
  intro Y f
  simp only [pushforwardFamily, â† FunctorToTypes.map_comp_apply, â† op_comp]
  change (â„±.map _ â‰« Î±.app (op _) â‰« â„±'.val.map _) _ = (â„±.map _ â‰« Î±.app (op _) â‰« â„±'.val.map _) _
  rw [â† G.image_preimage (f â‰« gâ‚ â‰« _)]
  rw [â† G.image_preimage (f â‰« gâ‚‚ â‰« _)]
  erw [â† Î±.naturality (G.preimage _).op]
  erw [â† Î±.naturality (G.preimage _).op]
  refine' congr_fun _ x
  simp only [Functor.comp_map, â† Category.assoc, Functor.op_map, Quiver.Hom.unop_op]
  rw [â† â„±.map_comp, â† â„±.map_comp] 
  simp only [â† op_comp, G.image_preimage]
  congr 3
  simp [e]",error:  unknown identifier 'H.ext',"theorem pushforwardFamily_compatible {X} (x : â„±.obj (op X)) :
    (pushforwardFamily Î± x).Compatible ",":= by
  intro Yâ‚ Yâ‚‚ Z gâ‚ gâ‚‚ fâ‚ fâ‚‚ hâ‚ hâ‚‚ e
  apply IsCoverDense.ext G
  intro Y f
  simp only [pushforwardFamily, â† FunctorToTypes.map_comp_apply, â† op_comp]
  change (â„±.map _ â‰« Î±.app (op _) â‰« â„±'.val.map _) _ = (â„±.map _ â‰« Î±.app (op _) â‰« â„±'.val.map _) _
  rw [â† G.map_preimage (f â‰« gâ‚ â‰« _)]
  rw [â† G.map_preimage (f â‰« gâ‚‚ â‰« _)]
  erw [â† Î±.naturality (G.preimage _).op]
  erw [â† Î±.naturality (G.preimage _).op]
  refine congr_fun ?_ x
  simp only [Functor.comp_map, â† Category.assoc, Functor.op_map, Quiver.Hom.unop_op,
    â† â„±.map_comp, â† op_comp, G.map_preimage]
  congr 3
  simp [e]"
Mathlib/Analysis/Normed/Field/Basic.lean,nnnorm_pow,nnnorm_pow,61ddcfa78d90f5773ac5739822ee3721851aa662,"  | 1, _ => by simp only [pow_one, le_rfl]
  | n + 2, _ => by
    simpa only [pow_succ _ (n + 1)] using
      le_trans (nnnorm_mul_le _ _) (mul_le_mul_left' (nnnorm_pow_le' a n.succ_pos) _)","error:  type mismatch
  hâœ
has type
  â€–a ^ (n + 1) * a ^ n.succâ€–â‚Š â‰¤ â€–a ^ (n + 1)â€–â‚Š * â€–aâ€–â‚Š ^ n.succ : Prop
but is expected to have type
  â€–a ^ (n + 1) * aâ€–â‚Š â‰¤ â€–aâ€–â‚Š ^ (n + 1) * â€–aâ€–â‚Š : Prop","theorem nnnorm_pow_le' (a : Î±) : âˆ€ {n : â„•}, 0 < n â†’ â€–a ^ nâ€–â‚Š â‰¤ â€–aâ€–â‚Š ^ n
","  | 1, _ => by simp only [pow_one, le_rfl]
  | n + 2, _ => by
    simpa only [pow_succ' _ (n + 1)] using
      le_trans (nnnorm_mul_le _ _) (mul_le_mul_left' (nnnorm_pow_le' a n.succ_pos) _)"
Mathlib/Geometry/Euclidean/Circumcenter.lean,AffineIndependent.existsUnique_dist_eq,_root_.AffineIndependent.existsUnique_dist_eq,9e34a191034458a56331f976ff7400a26407c888,":= by
  cases nonempty_fintype Î¹
  induction' hn : Fintype.card Î¹ with m hm generalizing Î¹
  Â· exfalso
    have h := Fintype.card_pos_iff.2 hne
    rw [hn] at h
    exact lt_irrefl 0 h
  Â· cases' m with m
    Â· rw [Fintype.card_eq_one_iff] at hn
      cases' hn with i hi
      haveI : Unique Î¹ := âŸ¨âŸ¨iâŸ©, hiâŸ©
      use âŸ¨p i, 0âŸ©
      simp only [Set.range_unique, AffineSubspace.mem_affineSpan_singleton]
      constructor
      Â· simp_rw [hi default, Set.singleton_subset_iff, Sphere.mem_coe, mem_sphere, dist_self]
        exact âŸ¨âŸ¨âŸ©, by simp only [Metric.sphere_zero, Set.mem_singleton_iff]âŸ©
      Â· rintro âŸ¨cc, crâŸ©
        simp only
        rintro âŸ¨rfl, hdistâŸ©
        simp [Set.singleton_subset_iff, Sphere.mem_coe, mem_sphere, dist_self] at hdist
        rw [hi default, hdist]
    Â· have i := hne.some
      let Î¹2 := { x // x â‰  i }
      have hc : Fintype.card Î¹2 = m + 1 := by
        rw [Fintype.card_of_subtype (Finset.univ.filter fun x => x â‰  i)]
        Â· rw [Finset.filter_not]
          rw [Finset.filter_eq' _ i, if_pos (Finset.mem_univ _),
            Finset.card_sdiff (Finset.subset_univ _), Finset.card_singleton, Finset.card_univ, hn]
          simp
        Â· simp
      haveI : Nonempty Î¹2 := Fintype.card_pos_iff.1 (hc.symm â–¸ Nat.zero_lt_succ _)
      have ha2 : AffineIndependent â„ fun i2 : Î¹2 => p i2 := ha.subtype _
      replace hm := hm ha2 _ hc
      have hr : Set.range p = insert (p i) (Set.range fun i2 : Î¹2 => p i2) := by
        change _ = insert _ (Set.range fun i2 : { x | x â‰  i } => p i2)
        rw [â† Set.image_eq_range, â† Set.image_univ, â† Set.image_insert_eq]
        congr with j
        simp [Classical.em]
      rw [hr, â† affineSpan_insert_affineSpan]
      refine' existsUnique_dist_eq_of_insert (Set.range_nonempty _) (subset_spanPoints â„ _) _ hm
      convert ha.not_mem_affineSpan_diff i Set.univ
      change (Set.range fun i2 : { x | x â‰  i } => p i2) = _
      rw [â† Set.image_eq_range]
      congr with j
      simp",error:  simp made no progress,"theorem _root_.AffineIndependent.existsUnique_dist_eq {Î¹ : Type*} [hne : Nonempty Î¹] [Finite Î¹]
    {p : Î¹ â†’ P} (ha : AffineIndependent â„ p) :
    âˆƒ! cs : Sphere P, cs.center âˆˆ affineSpan â„ (Set.range p) âˆ§ Set.range p âŠ† (cs : Set P) ",":= by
  cases nonempty_fintype Î¹
  induction' hn : Fintype.card Î¹ with m hm generalizing Î¹
  Â· exfalso
    have h := Fintype.card_pos_iff.2 hne
    rw [hn] at h
    exact lt_irrefl 0 h
  Â· cases' m with m
    Â· rw [Fintype.card_eq_one_iff] at hn
      cases' hn with i hi
      haveI : Unique Î¹ := âŸ¨âŸ¨iâŸ©, hiâŸ©
      use âŸ¨p i, 0âŸ©
      simp only [Set.range_unique, AffineSubspace.mem_affineSpan_singleton]
      constructor
      Â· simp_rw [hi default, Set.singleton_subset_iff]
        exact âŸ¨âŸ¨âŸ©, by simp only [Metric.sphere_zero, Set.mem_singleton_iff]âŸ©
      Â· rintro âŸ¨cc, crâŸ©
        simp only
        rintro âŸ¨rfl, hdistâŸ©
        simp? [Set.singleton_subset_iff] at hdist says
          simp only [Set.singleton_subset_iff, Metric.mem_sphere, dist_self] at hdist
        rw [hi default, hdist]
    Â· have i := hne.some
      let Î¹2 := { x // x â‰  i }
      have hc : Fintype.card Î¹2 = m + 1 := by
        rw [Fintype.card_of_subtype (Finset.univ.filter fun x => x â‰  i)]
        Â· rw [Finset.filter_not]
          rw [Finset.filter_eq' _ i, if_pos (Finset.mem_univ _),
            Finset.card_sdiff (Finset.subset_univ _), Finset.card_singleton, Finset.card_univ, hn]
          simp
        Â· simp
      haveI : Nonempty Î¹2 := Fintype.card_pos_iff.1 (hc.symm â–¸ Nat.zero_lt_succ _)
      have ha2 : AffineIndependent â„ fun i2 : Î¹2 => p i2 := ha.subtype _
      replace hm := hm ha2 _ hc
      have hr : Set.range p = insert (p i) (Set.range fun i2 : Î¹2 => p i2) := by
        change _ = insert _ (Set.range fun i2 : { x | x â‰  i } => p i2)
        rw [â† Set.image_eq_range, â† Set.image_univ, â† Set.image_insert_eq]
        congr with j
        simp [Classical.em]
      rw [hr, â† affineSpan_insert_affineSpan]
      refine existsUnique_dist_eq_of_insert (Set.range_nonempty _) (subset_spanPoints â„ _) ?_ hm
      convert ha.not_mem_affineSpan_diff i Set.univ
      change (Set.range fun i2 : { x | x â‰  i } => p i2) = _
      rw [â† Set.image_eq_range]
      congr with j
      simp"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.cyclotomicRing_isIntegralClosure_of_prime,cyclotomicRing_isIntegralClosure_of_prime,5a786280b45234ae60496d1ed8320b46fcf59034,":= by
  haveI : CharZero â„š := OrderedAddCommMonoidWithOne.to_charZero
  have hÎ¶ := zeta_spec (p ^ k) â„š (CyclotomicField (p ^ k) â„š)
  refine' âŸ¨IsFractionRing.injective _ _, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, _âŸ©, rflâŸ©, _âŸ©âŸ©
  Â· have := (isIntegralClosure_adjoin_singleton_of_prime_pow hÎ¶)
    obtain âŸ¨y, rflâŸ© := this.isIntegral_iff.1 h
    refine' adjoin_mono _ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hÎ¶.pow_eq_one
  Â· rintro âŸ¨y, rflâŸ©
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} â„¤ _) _)","error:  unknown identifier 'OrderedAddCommMonoidWithOne.to_charZero'
error:  function expected at
  integral {p ^ k} â„¤ ?m.69711
term has type
  Algebra.IsIntegral â„¤ ?m.69711","theorem cyclotomicRing_isIntegralClosure_of_prime_pow :
    IsIntegralClosure (CyclotomicRing (p ^ k) â„¤ â„š) â„¤ (CyclotomicField (p ^ k) â„š) ",":= by
  have hÎ¶ := zeta_spec (p ^ k) â„š (CyclotomicField (p ^ k) â„š)
  refine âŸ¨IsFractionRing.injective _ _, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©, ?_âŸ©âŸ©
  Â· have := isIntegralClosure_adjoin_singleton_of_prime_pow hÎ¶
    obtain âŸ¨y, rflâŸ© := this.isIntegral_iff.1 h
    refine adjoin_mono ?_ y.2
    simp only [PNat.pow_coe, Set.singleton_subset_iff, Set.mem_setOf_eq]
    exact hÎ¶.pow_eq_one
  Â· rintro âŸ¨y, rflâŸ©
    exact IsIntegral.algebraMap ((IsCyclotomicExtension.integral {p ^ k} â„¤ _).isIntegral _)"
Mathlib/RingTheory/Adjoin/FG.lean,Algebra.fg_trans,fg_trans,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  rcases fg_def.1 h1 with âŸ¨p, hp, hp'âŸ©
  rcases fg_def.1 h2 with âŸ¨q, hq, hq'âŸ©
  refine' fg_def.2 âŸ¨p * q, hp.mul hq, le_antisymm _ _âŸ©
  Â· rw [span_le, Set.mul_subset_iff]
    intro x hx y hy
    change x * y âˆˆ adjoin R (s âˆª t)
    refine' Subalgebra.mul_mem _ _ _
    Â· have : x âˆˆ Subalgebra.toSubmodule (adjoin R s) := by
        rw [â† hp']
        exact subset_span hx
      exact adjoin_mono (Set.subset_union_left _ _) this
    have : y âˆˆ Subalgebra.toSubmodule (adjoin (adjoin R s) t) := by
      rw [â† hq']
      exact subset_span hy
    change y âˆˆ adjoin R (s âˆª t)
    rwa [adjoin_union_eq_adjoin_adjoin]
  Â· intro r hr
    change r âˆˆ adjoin R (s âˆª t) at hr
    rw [adjoin_union_eq_adjoin_adjoin] at hr
    change r âˆˆ Subalgebra.toSubmodule (adjoin (adjoin R s) t) at hr
    rw [â† hq', â† Set.image_id q, Finsupp.mem_span_image_iff_total (adjoin R s)] at hr
    rcases hr with âŸ¨l, hlq, rflâŸ©
    have := @Finsupp.total_apply A A (adjoin R s)
    rw [this, Finsupp.sum]
    refine' sum_mem _
    intro z hz
    change (l z).1 * _ âˆˆ _
    have : (l z).1 âˆˆ Subalgebra.toSubmodule (adjoin R s) := (l z).2
    rw [â† hp', â† Set.image_id p, Finsupp.mem_span_image_iff_total R] at this
    rcases this with âŸ¨l2, hlp, hlâŸ©
    have := @Finsupp.total_apply A A R
    rw [this] at hl
    rw [â† hl, Finsupp.sum_mul]
    refine' sum_mem _
    intro t ht
    change _ * _ âˆˆ _
    rw [smul_mul_assoc]
    refine' smul_mem _ _ _
    exact subset_span âŸ¨t, hlp ht, z, hlq hz, rflâŸ©","error:  function expected at
  Set.subset_union_left ?m.6827
term has type
  ?m.6826 âˆˆ ?m.6824 âˆª ?m.6825","theorem fg_trans (h1 : (adjoin R s).toSubmodule.FG) (h2 : (adjoin (adjoin R s) t).toSubmodule.FG) :
    (adjoin R (s âˆª t)).toSubmodule.FG ",":= by
  rcases fg_def.1 h1 with âŸ¨p, hp, hp'âŸ©
  rcases fg_def.1 h2 with âŸ¨q, hq, hq'âŸ©
  refine fg_def.2 âŸ¨p * q, hp.mul hq, le_antisymm ?_ ?_âŸ©
  Â· rw [span_le, Set.mul_subset_iff]
    intro x hx y hy
    change x * y âˆˆ adjoin R (s âˆª t)
    refine Subalgebra.mul_mem _ ?_ ?_
    Â· have : x âˆˆ Subalgebra.toSubmodule (adjoin R s) := by
        rw [â† hp']
        exact subset_span hx
      exact adjoin_mono Set.subset_union_left this
    have : y âˆˆ Subalgebra.toSubmodule (adjoin (adjoin R s) t) := by
      rw [â† hq']
      exact subset_span hy
    change y âˆˆ adjoin R (s âˆª t)
    rwa [adjoin_union_eq_adjoin_adjoin]
  Â· intro r hr
    change r âˆˆ adjoin R (s âˆª t) at hr
    rw [adjoin_union_eq_adjoin_adjoin] at hr
    change r âˆˆ Subalgebra.toSubmodule (adjoin (adjoin R s) t) at hr
    rw [â† hq', â† Set.image_id q, Finsupp.mem_span_image_iff_total (adjoin R s)] at hr
    rcases hr with âŸ¨l, hlq, rflâŸ©
    have := @Finsupp.total_apply A A (adjoin R s)
    rw [this, Finsupp.sum]
    refine sum_mem ?_
    intro z hz
    change (l z).1 * _ âˆˆ _
    have : (l z).1 âˆˆ Subalgebra.toSubmodule (adjoin R s) := (l z).2
    rw [â† hp', â† Set.image_id p, Finsupp.mem_span_image_iff_total R] at this
    rcases this with âŸ¨l2, hlp, hlâŸ©
    have := @Finsupp.total_apply A A R
    rw [this] at hl
    rw [â† hl, Finsupp.sum_mul]
    refine sum_mem ?_
    intro t ht
    change _ * _ âˆˆ _
    rw [smul_mul_assoc]
    refine smul_mem _ _ ?_
    exact subset_span âŸ¨t, hlp ht, z, hlq hz, rflâŸ©"
Mathlib/NumberTheory/LegendreSymbol/GaussEisensteinLemmas.lean,ZMod.Ico_map_valMinAbs_natAbs_eq_Ico_map_id,Ico_map_valMinAbs_natAbs_eq_Ico_map_id,b492f764dc62b80a0be745055df26ce5b018a24a,":= by
  have he : âˆ€ {x}, x âˆˆ Ico 1 (p / 2).succ â†’ x â‰  0 âˆ§ x â‰¤ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : âˆ€ {x}, x âˆˆ Ico 1 (p / 2).succ â†’ x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : âˆ€ {x}, x âˆˆ Ico 1 (p / 2).succ â†’ Â¬p âˆ£ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : âˆ€ (x : â„•) (hx : x âˆˆ Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs âˆˆ Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, lt_succ_iff, succ_le_iff, pos_iff_ne_zero,
      natAbs_valMinAbs_le _]
  have hsurj : âˆ€ (b : â„•) (hb : b âˆˆ Ico 1 (p / 2).succ),
      âˆƒ x, âˆƒ _ : x âˆˆ Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by
    intro b hb
    refine' âŸ¨(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr âŸ¨_, _âŸ©, _âŸ©
    Â· apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne.def, _root_.mul_eq_zero, or_self_iff]
    Â· apply lt_succ_of_le; apply natAbs_valMinAbs_le
    Â· rw [nat_cast_natAbs_valMinAbs]
      split_ifs
      Â· erw [mul_div_cancel' _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
      Â· erw [mul_neg, mul_div_cancel' _ hap, natAbs_valMinAbs_neg, valMinAbs_def_pos,
          val_cast_of_lt (hep hb), if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)","error:  unknown identifier 'lt_succ_iff'
error:  unsolved goals
p : â„•
hp : Fact (Nat.Prime p)
a : ZMod p
hap : a â‰  0
he : âˆ€ {x : â„•}, x âˆˆ Ico 1 (p / 2).succ â†’ x â‰  0 âˆ§ x â‰¤ p / 2
hep : âˆ€ {x : â„•}, x âˆˆ Ico 1 (p / 2).succ â†’ x < p
hpe : âˆ€ {x : â„•}, x âˆˆ Ico 1 (p / 2).succ â†’ Â¬p âˆ£ x
x : â„•
hx : x âˆˆ Ico 1 (p / 2).succ
âŠ¢ (a * â†‘x).valMinAbs.natAbs < p / 2 + 1
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.14841 â†’ ?m.14841 â†’ Prop
error:  unsolved goals
case refine'_1.a
p : â„•
hp : Fact (Nat.Prime p)
a : ZMod p
hap : a â‰  0
he : âˆ€ {x : â„•}, x âˆˆ Ico 1 (p / 2).succ â†’ x â‰  0 âˆ§ x â‰¤ p / 2
hep : âˆ€ {x : â„•}, x âˆˆ Ico 1 (p / 2).succ â†’ x < p
hpe : âˆ€ {x : â„•}, x âˆˆ Ico 1 (p / 2).succ â†’ Â¬p âˆ£ x
hmem : âˆ€ x âˆˆ Ico 1 (p / 2).succ, (a * â†‘x).valMinAbs.natAbs âˆˆ Ico 1 (p / 2).succ
b : â„•
hb : b âˆˆ Ico 1 (p / 2).succ
âŠ¢ (â†‘b * aâ»Â¹).valMinAbs.natAbs â‰  0
warning:  `ZMod.nat_cast_natAbs_valMinAbs` has been deprecated, use `ZMod.natCast_natAbs_valMinAbs` instead
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancelâ‚€` instead
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancelâ‚€` instead","theorem Ico_map_valMinAbs_natAbs_eq_Ico_map_id (p : â„•) [hp : Fact p.Prime] (a : ZMod p)
    (hap : a â‰  0) : ((Ico 1 (p / 2).succ).1.map fun (x : â„•) => (a * x).valMinAbs.natAbs) =
    (Ico 1 (p / 2).succ).1.map fun a => a ",":= by
  have he : âˆ€ {x}, x âˆˆ Ico 1 (p / 2).succ â†’ x â‰  0 âˆ§ x â‰¤ p / 2 := by
    simp (config := { contextual := true }) [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]
  have hep : âˆ€ {x}, x âˆˆ Ico 1 (p / 2).succ â†’ x < p := fun hx =>
    lt_of_le_of_lt (he hx).2 (Nat.div_lt_self hp.1.pos (by decide))
  have hpe : âˆ€ {x}, x âˆˆ Ico 1 (p / 2).succ â†’ Â¬p âˆ£ x := fun hx hpx =>
    not_lt_of_ge (le_of_dvd (Nat.pos_of_ne_zero (he hx).1) hpx) (hep hx)
  have hmem : âˆ€ (x : â„•) (hx : x âˆˆ Ico 1 (p / 2).succ),
      (a * x : ZMod p).valMinAbs.natAbs âˆˆ Ico 1 (p / 2).succ := by
    intro x hx
    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, Nat.lt_succ_iff, succ_le_iff,
      pos_iff_ne_zero, natAbs_valMinAbs_le _]
  have hsurj : âˆ€ (b : â„•) (hb : b âˆˆ Ico 1 (p / 2).succ),
      âˆƒ x, âˆƒ _ : x âˆˆ Ico 1 (p / 2).succ, (a * x : ZMod p).valMinAbs.natAbs = b := by
    intro b hb
    refine âŸ¨(b / a : ZMod p).valMinAbs.natAbs, mem_Ico.mpr âŸ¨?_, ?_âŸ©, ?_âŸ©
    Â· apply Nat.pos_of_ne_zero
      simp only [div_eq_mul_inv, hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hb, not_false_iff,
        valMinAbs_eq_zero, inv_eq_zero, Int.natAbs_eq_zero, Ne, _root_.mul_eq_zero, or_self_iff]
    Â· apply lt_succ_of_le; apply natAbs_valMinAbs_le
    Â· rw [natCast_natAbs_valMinAbs]
      split_ifs
      Â· erw [mul_div_cancelâ‚€ _ hap, valMinAbs_def_pos, val_cast_of_lt (hep hb),
          if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
      Â· erw [mul_neg, mul_div_cancelâ‚€ _ hap, natAbs_valMinAbs_neg, valMinAbs_def_pos,
          val_cast_of_lt (hep hb), if_pos (le_of_lt_succ (mem_Ico.1 hb).2), Int.natAbs_ofNat]
  exact Multiset.map_eq_map_of_bij_of_nodup _ _ (Finset.nodup _) (Finset.nodup _)
    (fun x _ => (a * x : ZMod p).valMinAbs.natAbs) hmem
    (inj_on_of_surj_on_of_card_le _ hmem hsurj le_rfl) hsurj (fun _ _ => rfl)"
Mathlib/Algebra/Group/Fin.lean,Fin.sub_one_lt_iff,sub_one_lt_iff,d809edf84d23c189fffa872efa68df4ec3d7e9fe,":=
  not_iff_not.1 <| by simp only [not_lt, le_sub_one_iff, le_zero_iff]",error:  simp made no progress,lemma sub_one_lt_iff {k : Fin (n + 1)} : k - 1 < k â†” 0 < k ,":=
  not_iff_not.1 <| by simp only [lt_def, not_lt, val_fin_le, le_sub_one_iff, le_zero_iff]"
Mathlib/Analysis/Calculus/LocalExtr/Basic.lean,IsLocalMin.hasDerivAt_eq_zero,IsLocalMin.hasDerivAt_eq_zero,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  simpa using FunLike.congr_fun (h.hasFDerivAt_eq_zero (hasDerivAt_iff_hasFDerivAt.1 hf)) 1",error:  unknown constant 'FunLike.congr_fun',theorem IsLocalMin.hasDerivAt_eq_zero (h : IsLocalMin f a) (hf : HasDerivAt f f' a) : f' = 0 ,":= by
  simpa using DFunLike.congr_fun (h.hasFDerivAt_eq_zero (hasDerivAt_iff_hasFDerivAt.1 hf)) 1"
Mathlib/AlgebraicGeometry/Morphisms/ClosedImmersion.lean,AlgebraicGeometry.IsClosedImmersion.spec_of_surjective,spec_of_surjective,522709fb663293411481bc3e307de4801942d55a,"  base_closed := PrimeSpectrum.closedEmbedding_comap_of_surjective _ _ h
  surj_on_stalks x := by
    dsimp
    erw [â† localRingHom_comp_stalkIso, CommRingCat.coe_comp, CommRingCat.coe_comp]
    apply Function.Surjective.comp (Function.Surjective.comp _ _) _
    Â· exact (ConcreteCategory.bijective_of_isIso (StructureSheaf.stalkIso S x).inv).2
    Â· exact surjective_localRingHom_of_surjective f h x.asIdeal
    Â· let g := (StructureSheaf.stalkIso ((CommRingCat.of R))
        ((PrimeSpectrum.comap (CommRingCat.ofHom f)) x)).hom
      exact (ConcreteCategory.bijective_of_isIso g).2",error:  dsimp made no progress,"theorem spec_of_surjective {R S : CommRingCat} (f : R âŸ¶ S) (h : Function.Surjective f) :
    IsClosedImmersion (Spec.map f) where
","  base_closed := PrimeSpectrum.closedEmbedding_comap_of_surjective _ _ h
  surj_on_stalks x := by
    erw [â† localRingHom_comp_stalkIso, CommRingCat.coe_comp, CommRingCat.coe_comp]
    apply Function.Surjective.comp (Function.Surjective.comp _ _) _
    Â· exact (ConcreteCategory.bijective_of_isIso (StructureSheaf.stalkIso S x).inv).2
    Â· exact surjective_localRingHom_of_surjective f h x.asIdeal
    Â· let g := (StructureSheaf.stalkIso ((CommRingCat.of R))
        ((PrimeSpectrum.comap (CommRingCat.ofHom f)) x)).hom
      exact (ConcreteCategory.bijective_of_isIso g).2"
Mathlib/MeasureTheory/Covering/BesicovitchVectorSpace.lean,Besicovitch.exists_goodÎ´,exists_goodÎ´,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  classical
  by_contra' h
  set N := multiplicity E + 1 with hN
  have :
    âˆ€ Î´ : â„, 0 < Î´ â†’ âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§
      âˆ€ i j, i â‰  j â†’ 1 - Î´ â‰¤ â€–f i - f jâ€– := by
    intro Î´ hÎ´
    rcases lt_or_le Î´ 1 with (hÎ´' | hÎ´')
    Â· rcases h Î´ hÎ´ hÎ´' with âŸ¨s, hs, h's, s_cardâŸ©
      obtain âŸ¨f, f_inj, hfsâŸ© : âˆƒ f : Fin N â†’ E, Function.Injective f âˆ§ range f âŠ† â†‘s := by
        have : Fintype.card (Fin N) â‰¤ s.card := by simp only [Fintype.card_fin]; exact s_card
        rcases Function.Embedding.exists_of_card_le_finset this with âŸ¨f, hfâŸ©
        exact âŸ¨f, f.injective, hfâŸ©
      simp only [range_subset_iff, Finset.mem_coe] at hfs
      refine' âŸ¨f, fun i => hs _ (hfs i), fun i j hij => h's _ (hfs i) _ (hfs j) (f_inj.ne hij)âŸ©
    Â· exact
        âŸ¨fun _ => 0, fun i => by simp; norm_num, fun i j _ => by
          simpa only [norm_zero, sub_nonpos, sub_self]âŸ©
  choose! F hF using this
  have : âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§ âˆ€ i j, i â‰  j â†’ 1 â‰¤ â€–f i - f jâ€– := by
    obtain âŸ¨u, _, zero_lt_u, huâŸ© :
      âˆƒ u : â„• â†’ â„,
        (âˆ€ m n : â„•, m < n â†’ u n < u m) âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Filter.Tendsto u Filter.atTop (ğ“ 0) :=
      exists_seq_strictAnti_tendsto (0 : â„)
    have A : âˆ€ n, F (u n) âˆˆ closedBall (0 : Fin N â†’ E) 2 := by
      intro n
      simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right,
        (hF (u n) (zero_lt_u n)).left, forall_const]
    obtain âŸ¨f, fmem, Ï†, Ï†_mono, hfâŸ© :
      âˆƒ f âˆˆ closedBall (0 : Fin N â†’ E) 2,
        âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (ğ“ f) :=
      IsCompact.tendsto_subseq (isCompact_closedBall _ _) A
    refine' âŸ¨f, fun i => _, fun i j hij => _âŸ©
    Â· simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right] at fmem
      exact fmem i
    Â· have A : Tendsto (fun n => â€–F (u (Ï† n)) i - F (u (Ï† n)) jâ€–) atTop (ğ“ â€–f i - f jâ€–) :=
        ((hf.apply i).sub (hf.apply j)).norm
      have B : Tendsto (fun n => 1 - u (Ï† n)) atTop (ğ“ (1 - 0)) :=
        tendsto_const_nhds.sub (hu.comp Ï†_mono.tendsto_atTop)
      rw [sub_zero] at B
      exact le_of_tendsto_of_tendsto' B A fun n => (hF (u (Ï† n)) (zero_lt_u _)).2 i j hij
  rcases this with âŸ¨f, hf, h'fâŸ©
  have finj : Function.Injective f := by
    intro i j hij
    by_contra h
    have : 1 â‰¤ â€–f i - f jâ€– := h'f i j h
    simp only [hij, norm_zero, sub_self] at this
    exact lt_irrefl _ (this.trans_lt zero_lt_one)
  let s := Finset.image f Finset.univ
  have s_card : s.card = N := by rw [Finset.card_image_of_injective _ finj]; exact Finset.card_fin N
  have hs : âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2 := by
    simp only [hf, forall_apply_eq_imp_iff', forall_const, forall_exists_index, Finset.mem_univ,
      Finset.mem_image, true_and]
  have h's : âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 â‰¤ â€–c - dâ€– := by
    simp only [forall_apply_eq_imp_iff', forall_exists_index, Finset.mem_univ, Finset.mem_image,
      Ne.def, exists_true_left, forall_apply_eq_imp_iff', forall_true_left, true_and]
    intro i j hij
    have : i â‰  j := fun h => by rw [h] at hij; exact hij rfl
    exact h'f i j this
  have : s.card â‰¤ multiplicity E := card_le_multiplicity hs h's
  rw [s_card, hN] at this
  exact lt_irrefl _ ((Nat.lt_succ_self (multiplicity E)).trans_le this)","error:  unknown tactic
error:  unsolved goals
E : Type u_1
instâœÂ² : NormedAddCommGroup E
instâœÂ¹ : NormedSpace â„ E
instâœ : FiniteDimensional â„ E
âŠ¢ âˆƒ Î´,
    0 < Î´ âˆ§
      Î´ < 1 âˆ§
        âˆ€ (s : Finset E), (âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2) â†’ (âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 - Î´ â‰¤ â€–c - dâ€–) â†’ s.card â‰¤ multiplicity E","theorem exists_goodÎ´ :
    âˆƒ Î´ : â„, 0 < Î´ âˆ§ Î´ < 1 âˆ§ âˆ€ s : Finset E, (âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2) â†’
      (âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 - Î´ â‰¤ â€–c - dâ€–) â†’ s.card â‰¤ multiplicity E ",":= by
  classical
  by_contra! h
  set N := multiplicity E + 1 with hN
  have :
    âˆ€ Î´ : â„, 0 < Î´ â†’ âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§
      Pairwise fun i j => 1 - Î´ â‰¤ â€–f i - f jâ€– := by
    intro Î´ hÎ´
    rcases lt_or_le Î´ 1 with (hÎ´' | hÎ´')
    Â· rcases h Î´ hÎ´ hÎ´' with âŸ¨s, hs, h's, s_cardâŸ©
      obtain âŸ¨f, f_inj, hfsâŸ© : âˆƒ f : Fin N â†’ E, Function.Injective f âˆ§ range f âŠ† â†‘s := by
        have : Fintype.card (Fin N) â‰¤ s.card := by simp only [Fintype.card_fin]; exact s_card
        rcases Function.Embedding.exists_of_card_le_finset this with âŸ¨f, hfâŸ©
        exact âŸ¨f, f.injective, hfâŸ©
      simp only [range_subset_iff, Finset.mem_coe] at hfs
      exact âŸ¨f, fun i => hs _ (hfs i), fun i j hij => h's _ (hfs i) _ (hfs j) (f_inj.ne hij)âŸ©
    Â· exact
        âŸ¨fun _ => 0, by simp, fun i j _ => by
          simpa only [norm_zero, sub_nonpos, sub_self]âŸ©
  choose! F hF using this
  have : âˆƒ f : Fin N â†’ E, (âˆ€ i : Fin N, â€–f iâ€– â‰¤ 2) âˆ§ Pairwise fun i j => 1 â‰¤ â€–f i - f jâ€– := by
    obtain âŸ¨u, _, zero_lt_u, huâŸ© :
      âˆƒ u : â„• â†’ â„,
        (âˆ€ m n : â„•, m < n â†’ u n < u m) âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Filter.Tendsto u Filter.atTop (ğ“ 0) :=
      exists_seq_strictAnti_tendsto (0 : â„)
    have A : âˆ€ n, F (u n) âˆˆ closedBall (0 : Fin N â†’ E) 2 := by
      intro n
      simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right,
        (hF (u n) (zero_lt_u n)).left, forall_const]
    obtain âŸ¨f, fmem, Ï†, Ï†_mono, hfâŸ© :
      âˆƒ f âˆˆ closedBall (0 : Fin N â†’ E) 2,
        âˆƒ Ï† : â„• â†’ â„•, StrictMono Ï† âˆ§ Tendsto ((F âˆ˜ u) âˆ˜ Ï†) atTop (ğ“ f) :=
      IsCompact.tendsto_subseq (isCompact_closedBall _ _) A
    refine âŸ¨f, fun i => ?_, fun i j hij => ?_âŸ©
    Â· simp only [pi_norm_le_iff_of_nonneg zero_le_two, mem_closedBall, dist_zero_right] at fmem
      exact fmem i
    Â· have A : Tendsto (fun n => â€–F (u (Ï† n)) i - F (u (Ï† n)) jâ€–) atTop (ğ“ â€–f i - f jâ€–) :=
        ((hf.apply_nhds i).sub (hf.apply_nhds j)).norm
      have B : Tendsto (fun n => 1 - u (Ï† n)) atTop (ğ“ (1 - 0)) :=
        tendsto_const_nhds.sub (hu.comp Ï†_mono.tendsto_atTop)
      rw [sub_zero] at B
      exact le_of_tendsto_of_tendsto' B A fun n => (hF (u (Ï† n)) (zero_lt_u _)).2 hij
  rcases this with âŸ¨f, hf, h'fâŸ©
  have finj : Function.Injective f := by
    intro i j hij
    by_contra h
    have : 1 â‰¤ â€–f i - f jâ€– := h'f h
    simp only [hij, norm_zero, sub_self] at this
    exact lt_irrefl _ (this.trans_lt zero_lt_one)
  let s := Finset.image f Finset.univ
  have s_card : s.card = N := by rw [Finset.card_image_of_injective _ finj]; exact Finset.card_fin N
  have hs : âˆ€ c âˆˆ s, â€–câ€– â‰¤ 2 := by
    simp only [s, hf, forall_apply_eq_imp_iff, forall_const, forall_exists_index, Finset.mem_univ,
      Finset.mem_image, true_and]
  have h's : âˆ€ c âˆˆ s, âˆ€ d âˆˆ s, c â‰  d â†’ 1 â‰¤ â€–c - dâ€– := by
    simp only [s, forall_apply_eq_imp_iff, forall_exists_index, Finset.mem_univ, Finset.mem_image,
      Ne, exists_true_left, forall_apply_eq_imp_iff, forall_true_left, true_and]
    intro i j hij
    have : i â‰  j := fun h => by rw [h] at hij; exact hij rfl
    exact h'f this
  have : s.card â‰¤ multiplicity E := card_le_multiplicity hs h's
  rw [s_card, hN] at this
  exact lt_irrefl _ ((Nat.lt_succ_self (multiplicity E)).trans_le this)"
Mathlib/RingTheory/Polynomial/Dickson.lean,Polynomial.dickson_one_one_mul,dickson_one_one_mul,65ff221423bef7d05add8bacc18ce5375a6c78b2,":= by
  have h : (1 : R) = Int.castRingHom R 1
  simp only [eq_intCast, Int.cast_one]
  rw [h]
  simp only [â† map_dickson (Int.castRingHom R), â† map_comp]
  congr 1
  apply map_injective (Int.castRingHom â„š) Int.cast_injective
  simp only [map_dickson, map_comp, eq_intCast, Int.cast_one, dickson_one_one_eq_chebyshev_T,
    Chebyshev.T_mul, two_mul, â† add_comp]
  simp only [â† two_mul, â† comp_assoc]
  apply evalâ‚‚_congr rfl rfl
  rw [comp_assoc]
  apply evalâ‚‚_congr rfl _ rfl
  rw [mul_comp, C_comp, X_comp, â† mul_assoc, C_half_mul_two_eq_one, one_mul]","error:  unexpected identifier; expected '|'
error:  unsolved goals
R : Type u_1
S : Type u_2
instâœÂ¹ : CommRing R
instâœ : CommRing S
k : â„•
a : R
m n : â„•
h : 1 = (Int.castRingHom R) 1
âŠ¢ dickson 1 1 (m * n) = (dickson 1 1 m).comp (dickson 1 1 n)","theorem dickson_one_one_mul (m n : â„•) :
    dickson 1 (1 : R) (m * n) = (dickson 1 1 m).comp (dickson 1 1 n) ",":= by
  have h : (1 : R) = Int.castRingHom R 1 := by simp only [eq_intCast, Int.cast_one]
  rw [h]
  simp only [â† map_dickson (Int.castRingHom R), â† map_comp]
  congr 1
  apply map_injective (Int.castRingHom â„š) Int.cast_injective
  simp only [map_dickson, map_comp, eq_intCast, Int.cast_one, dickson_one_one_eq_chebyshev_T,
    Nat.cast_mul, Chebyshev.T_mul, two_mul, â† add_comp]
  simp only [â† two_mul, â† comp_assoc]
  apply evalâ‚‚_congr rfl rfl
  rw [comp_assoc]
  apply evalâ‚‚_congr rfl _ rfl
  rw [mul_comp, C_comp, X_comp, â† mul_assoc, C_half_mul_two_eq_one, one_mul]"
Mathlib/RingTheory/Jacobson.lean,Ideal.Polynomial.quotient_mk_comp_C_isIntegral_of_jacobson,quotient_mk_comp_C_isIntegral_of_jacobson,a76dc22f3a90e5ab96e9284d30276a87a4324a5d,":= by
  refine' (isIntegral_quotientMap_iff _).mp _
  let P' : Ideal R := P.comap C
  obtain âŸ¨pX, hpX, hp0âŸ© :=
    exists_nonzero_mem_of_ne_bot (ne_of_lt (bot_lt_of_maximal P polynomial_not_isField)).symm hP'
  let a : R â§¸ P' := (pX.map (Quotient.mk P')).leadingCoeff
  let M : Submonoid (R â§¸ P') := Submonoid.powers a
  let Ï† : R â§¸ P' â†’+* R[X] â§¸ P := quotientMap P C le_rfl
  haveI hP'_prime : P'.IsPrime := comap_isPrime C P
  have hM : (0 : R â§¸ P') âˆ‰ M := fun âŸ¨n, hnâŸ© => hp0 <| leadingCoeff_eq_zero.mp (pow_eq_zero hn)
  let M' : Submonoid (R[X] â§¸ P) := M.map Ï†
  refine' Ï†.isIntegral_tower_bot_of_isIntegral (algebraMap _ (Localization M')) _ _
  Â· refine' IsLocalization.injective (Localization M')
      (show M' â‰¤ _ from le_nonZeroDivisors_of_noZeroDivisors fun hM' => hM _)
    exact
      let âŸ¨z, zM, z0âŸ© := hM'
      quotientMap_injective (_root_.trans z0 Ï†.map_zero.symm) â–¸ zM
  Â· suffices : RingHom.comp (algebraMap (R[X] â§¸ P) (Localization M')) Ï† =
      (IsLocalization.map (Localization M') Ï† M.le_comap_map).comp
        (algebraMap (R â§¸ P') (Localization M))
    rw [this]
    refine' RingHom.isIntegral_trans (algebraMap (R â§¸ P') (Localization M))
      (IsLocalization.map (Localization M') Ï† M.le_comap_map) _ _
    Â· exact (algebraMap (R â§¸ P') (Localization M)).isIntegral_of_surjective
        (IsField.localization_map_bijective hM ((Quotient.maximal_ideal_iff_isField_quotient _).mp
          (isMaximal_comap_C_of_isMaximal P hP'))).2
    Â· 
      have isloc : IsLocalization M' (Localization M') := by infer_instance
      exact @isIntegral_isLocalization_polynomial_quotient R _
        (Localization M) (Localization M') _ _ P pX hpX _ _ _ isloc
    rw [IsLocalization.map_comp M.le_comap_map]",error:  unexpected token ':'; expected term,"theorem quotient_mk_comp_C_isIntegral_of_jacobson' [Nontrivial R] (hR : IsJacobson R)
    (hP' : âˆ€ x : R, C x âˆˆ P â†’ x = 0) : ((Quotient.mk P).comp C : R â†’+* R[X] â§¸ P).IsIntegral ",":= by
  refine (isIntegral_quotientMap_iff _).mp ?_
  let P' : Ideal R := P.comap C
  obtain âŸ¨pX, hpX, hp0âŸ© :=
    exists_nonzero_mem_of_ne_bot (ne_of_lt (bot_lt_of_maximal P polynomial_not_isField)).symm hP'
  let a : R â§¸ P' := (pX.map (Quotient.mk P')).leadingCoeff
  let M : Submonoid (R â§¸ P') := Submonoid.powers a
  let Ï† : R â§¸ P' â†’+* R[X] â§¸ P := quotientMap P C le_rfl
  haveI hP'_prime : P'.IsPrime := comap_isPrime C P
  have hM : (0 : R â§¸ P') âˆ‰ M := fun âŸ¨n, hnâŸ© => hp0 <| leadingCoeff_eq_zero.mp (pow_eq_zero hn)
  let M' : Submonoid (R[X] â§¸ P) := M.map Ï†
  refine RingHom.IsIntegral.tower_bot Ï† (algebraMap _ (Localization M')) ?_ ?_
  Â· refine IsLocalization.injective (Localization M')
      (show M' â‰¤ _ from le_nonZeroDivisors_of_noZeroDivisors fun hM' => hM ?_)
    exact
      let âŸ¨z, zM, z0âŸ© := hM'
      quotientMap_injective (_root_.trans z0 Ï†.map_zero.symm) â–¸ zM
  Â· suffices RingHom.comp (algebraMap (R[X] â§¸ P) (Localization M')) Ï† =
      (IsLocalization.map (Localization M') Ï† M.le_comap_map).comp
        (algebraMap (R â§¸ P') (Localization M)) by
      rw [this]
      refine RingHom.IsIntegral.trans (algebraMap (R â§¸ P') (Localization M))
        (IsLocalization.map (Localization M') Ï† M.le_comap_map) ?_ ?_
      Â· exact (algebraMap (R â§¸ P') (Localization M)).isIntegral_of_surjective
          (IsField.localization_map_bijective hM ((Quotient.maximal_ideal_iff_isField_quotient _).mp
            (isMaximal_comap_C_of_isMaximal P hP'))).2
      Â· 
        have isloc : IsLocalization M' (Localization M') := by infer_instance
        exact @isIntegral_isLocalization_polynomial_quotient R _
          (Localization M) (Localization M') _ _ P pX hpX _ _ _ isloc
    rw [IsLocalization.map_comp M.le_comap_map]"
Mathlib/CategoryTheory/Sites/Coherent/Equivalence.lean,CategoryTheory.Equivalence.precoherent,precoherent,98740267311a24ae6a2fe792964006babfd6788e,"  pullback f Î± _ Xâ‚ Ï€â‚ _ := by
    obtain âŸ¨Î², x, Xâ‚‚', Ï€â‚‚', _, i, Î¹', h'âŸ© :=
      Precoherent.pullback (e.inverse.map f) Î± (fun i â†¦ e.inverse.obj (Xâ‚ i))
      (fun i â†¦ (e.inverse.map (Ï€â‚ i))) inferInstance
    refine âŸ¨Î², x, _, fun b â†¦ e.functor.map (Ï€â‚‚' b) â‰« e.counit.app _, ?_, i,
      fun b â†¦ (e.toAdjunction.homEquiv _ _).symm (Î¹' b), fun b â†¦ ?_âŸ©
    Â· have : EffectiveEpiFamily _ fun i â†¦ (e.functor.map (Ï€â‚‚' i)) :=
        âŸ¨âŸ¨effectiveEpiFamilyStructOfEquivalence e Xâ‚‚' Ï€â‚‚'âŸ©âŸ©
      infer_instance
    Â· simpa using congrArg ((fun f â†¦ f â‰« e.counit.app _) âˆ˜ e.functor.map) (h' b)","error:  function expected at
  Precoherent D
term has type
  Prop
error:  unknown identifier 'f'
error:  unknown identifier 'Î±'
error:  unknown identifier 'Xâ‚'
error:  unknown identifier 'Ï€â‚'
error:  rcases tactic failed: xâœ : Sort u_3 is not an inductive datatype
error:  invalid field 'precoherent', the environment does not contain 'CategoryTheory.Equivalence.precoherent'
  equivSmallModel C
has type
  C â‰Œ SmallModel.{u_3, u_4, u_1} C
error:  unknown identifier 'precoherent'
error:  failed to synthesize
  Precoherent D
use `set_option diagnostics true` to get diagnostic information
error:  invalid field 'precoherent', the environment does not contain 'CategoryTheory.Equivalence.precoherent'
  e
has type
  C â‰Œ D
error:  failed to synthesize
  Precoherent D
use `set_option diagnostics true` to get diagnostic information
error:  invalid field 'precoherent', the environment does not contain 'CategoryTheory.Equivalence.precoherent'
  e
has type
  C â‰Œ D
error:  failed to synthesize
  Precoherent D
use `set_option diagnostics true` to get diagnostic information
error:  typeclass instance problem is stuck, it is often due to metavariables
  Category.{u_4, u_4} ?m.12885",theorem precoherent : Precoherent D ,:= e.inverse.reflects_precoherent
Mathlib/LinearAlgebra/AffineSpace/AffineSubspace.lean,AffineSubspace.parallel_iff_direction_eq_and_eq_bot_iff_eq_bot,parallel_iff_direction_eq_and_eq_bot_iff_eq_bot,8ebdc4fc31c6976c61d6dcb2373dcd1a5bafbc85,":= by
  refine âŸ¨fun h => âŸ¨h.direction_eq, ?_, ?_âŸ©, fun h =?> _âŸ©
  Â· rintro rfl
    exact bot_parallel_iff_eq_bot.1 h
  Â· rintro rfl
    exact parallel_bot_iff_eq_bot.1 h
  Â· rcases h with âŸ¨hd, hbâŸ©
    by_cases hsâ‚ : sâ‚ = âŠ¥
    Â· rw [hsâ‚, bot_parallel_iff_eq_bot]
      exact hb.1 hsâ‚
    Â· have hsâ‚‚ : sâ‚‚ â‰  âŠ¥ := hb.not.1 hsâ‚
      rcases (nonempty_iff_ne_bot sâ‚).2 hsâ‚ with âŸ¨pâ‚, hpâ‚âŸ©
      rcases (nonempty_iff_ne_bot sâ‚‚).2 hsâ‚‚ with âŸ¨pâ‚‚, hpâ‚‚âŸ©
      refine âŸ¨pâ‚‚ -áµ¥ pâ‚, (eq_iff_direction_eq_of_mem hpâ‚‚ ?_).2 ?_âŸ©
      Â· rw [mem_map]
        refine âŸ¨pâ‚, hpâ‚, ?_âŸ©
        simp
      Â· simpa using hd.symm","warning:  @AffineSubspace.Parallel does not have a doc string
error:  unexpected token '='; expected 'â†¦', '=>'
error:  unsolved goals
case refine_1
k : Type u_1
V : Type u_2
P : Type u_3
instâœÂ³ : Ring k
instâœÂ² : AddCommGroup V
instâœÂ¹ : Module k V
instâœ : AffineSpace V P
sâ‚ sâ‚‚ : AffineSubspace k P
h : sâ‚ âˆ¥ sâ‚‚
âŠ¢ sâ‚ = âŠ¥ â†’ sâ‚‚ = âŠ¥

case refine_2
k : Type u_1
V : Type u_2
P : Type u_3
instâœÂ³ : Ring k
instâœÂ² : AddCommGroup V
instâœÂ¹ : Module k V
instâœ : AffineSpace V P
sâ‚ sâ‚‚ : AffineSubspace k P
h : sâ‚ âˆ¥ sâ‚‚
âŠ¢ sâ‚‚ = âŠ¥ â†’ sâ‚ = âŠ¥","theorem parallel_iff_direction_eq_and_eq_bot_iff_eq_bot {sâ‚ sâ‚‚ : AffineSubspace k P} :
    sâ‚ âˆ¥ sâ‚‚ â†” sâ‚.direction = sâ‚‚.direction âˆ§ (sâ‚ = âŠ¥ â†” sâ‚‚ = âŠ¥) ",":= by
  refine âŸ¨fun h => âŸ¨h.direction_eq, ?_, ?_âŸ©, fun h => ?_âŸ©
  Â· rintro rfl
    exact bot_parallel_iff_eq_bot.1 h
  Â· rintro rfl
    exact parallel_bot_iff_eq_bot.1 h
  Â· rcases h with âŸ¨hd, hbâŸ©
    by_cases hsâ‚ : sâ‚ = âŠ¥
    Â· rw [hsâ‚, bot_parallel_iff_eq_bot]
      exact hb.1 hsâ‚
    Â· have hsâ‚‚ : sâ‚‚ â‰  âŠ¥ := hb.not.1 hsâ‚
      rcases (nonempty_iff_ne_bot sâ‚).2 hsâ‚ with âŸ¨pâ‚, hpâ‚âŸ©
      rcases (nonempty_iff_ne_bot sâ‚‚).2 hsâ‚‚ with âŸ¨pâ‚‚, hpâ‚‚âŸ©
      refine âŸ¨pâ‚‚ -áµ¥ pâ‚, (eq_iff_direction_eq_of_mem hpâ‚‚ ?_).2 ?_âŸ©
      Â· rw [mem_map]
        refine âŸ¨pâ‚, hpâ‚, ?_âŸ©
        simp
      Â· simpa using hd.symm"
Mathlib/Combinatorics/Hall/Basic.lean,Fintype.all_card_le_filter_rel_iff_exists_injective,Fintype.all_card_le_filter_rel_iff_exists_injective,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  haveI := Classical.decEq Î²
  let r' a := univ.filter fun b => r a b
  have h : âˆ€ A : Finset Î±, (univ.filter fun b : Î² => âˆƒ a âˆˆ A, r a b) = A.biUnion r' := by
    intro A
    ext b
    simp
  have h' : âˆ€ (f : Î± â†’ Î²) (x), r x (f x) â†” f x âˆˆ r' x := by simp
  simp_rw [h, h']
  apply Finset.all_card_le_biUnion_card_iff_exists_injective","error:  unsolved goals
case a
Î± : Type u
Î² : Type v
instâœÂ¹ : Fintype Î²
r : Î± â†’ Î² â†’ Prop
instâœ : (a : Î±) â†’ DecidablePred (r a)
this : DecidableEq Î²
r' : Î± â†’ Finset Î² := fun a â†¦ filter (fun b â†¦ r a b) univ
A : Finset Î±
b : Î²
âŠ¢ (âˆƒ a âˆˆ A, r a b) â†” âˆƒ a âˆˆ A, b âˆˆ r' a
error:  simp made no progress","theorem Fintype.all_card_le_filter_rel_iff_exists_injective {Î± : Type u} {Î² : Type v} [Fintype Î²]
    (r : Î± â†’ Î² â†’ Prop) [âˆ€ a, DecidablePred (r a)] :
    (âˆ€ A : Finset Î±, A.card â‰¤ (univ.filter fun b : Î² => âˆƒ a âˆˆ A, r a b).card) â†”
      âˆƒ f : Î± â†’ Î², Function.Injective f âˆ§ âˆ€ x, r x (f x) ",":= by
  haveI := Classical.decEq Î²
  let r' a := univ.filter fun b => r a b
  have h : âˆ€ A : Finset Î±, (univ.filter fun b : Î² => âˆƒ a âˆˆ A, r a b) = A.biUnion r' := by
    intro A
    ext b
    simp [r']
  have h' : âˆ€ (f : Î± â†’ Î²) (x), r x (f x) â†” f x âˆˆ r' x := by simp [r']
  simp_rw [h, h']
  apply Finset.all_card_le_biUnion_card_iff_exists_injective"
Mathlib/Topology/Category/CompHaus/EffectiveEpi.lean,CompHaus.effectiveEpi_tfae,effectiveEpi_tfae,62c2d6a1d2ffdbe5bcaa653b84d3602a209e4c8c,":= by
  tfae_have : 1 â†’ 2
  Â· intro; infer_instance
  tfae_have : 2 â†” 3 := epi_iff_surjective Ï€
  tfae_have : 3 â†’ 1 := fun hÏ€ â†¦ âŸ¨âŸ¨struct Ï€ hÏ€âŸ©âŸ©
  tfae_finish",error:  unexpected token ':'; expected numeral,"theorem effectiveEpi_tfae
    {B X : CompHaus.{u}} (Ï€ : X âŸ¶ B) :
    TFAE
    [ EffectiveEpi Ï€
    , Epi Ï€
    , Function.Surjective Ï€
    ] ",":= by
  tfae_have 1 â†’ 2
  Â· intro; infer_instance
  tfae_have 2 â†” 3
  Â· exact epi_iff_surjective Ï€
  tfae_have 3 â†’ 1
  Â· exact fun hÏ€ â†¦ âŸ¨âŸ¨struct Ï€ hÏ€âŸ©âŸ©
  tfae_finish"
Mathlib/RingTheory/Ideal/Over.lean,Ideal.exists_ideal_over_prime_of_isIntegral,exists_ideal_over_prime_of_isIntegral,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  have hP0 : (0 : S) âˆ‰ Algebra.algebraMapSubmonoid S P.primeCompl := by
    rintro âŸ¨x, âŸ¨hx, x0âŸ©âŸ©
    exact absurd (hP x0) hx
  let Râ‚š := Localization P.primeCompl
  let Sâ‚š := Localization (Algebra.algebraMapSubmonoid S P.primeCompl)
  letI : IsDomain (Localization (Algebra.algebraMapSubmonoid S P.primeCompl)) :=
    IsLocalization.isDomain_localization (le_nonZeroDivisors_of_noZeroDivisors hP0)
  obtain âŸ¨Qâ‚š : Ideal Sâ‚š, Qâ‚š_maximalâŸ© := exists_maximal Sâ‚š
  letI : SMul Râ‚š Sâ‚š := localizationSMul P.primeCompl S
  let _ : Algebra Râ‚š Sâ‚š := localizationAlgebra P.primeCompl S
  have : Algebra.IsIntegral Râ‚š Sâ‚š := âŸ¨isIntegral_localizationâŸ©
  have Qâ‚š_max : IsMaximal (comap _ Qâ‚š) :=
    isMaximal_comap_of_isIntegral_of_isMaximal (R := Râ‚š) (S := Sâ‚š) Qâ‚š
  refine' âŸ¨comap (algebraMap S Sâ‚š) Qâ‚š, âŸ¨comap_isPrime _ Qâ‚š, _âŸ©âŸ©
  convert Localization.AtPrime.comap_maximalIdeal (I := P)
  rw [comap_comap, â† LocalRing.eq_maximalIdeal Qâ‚š_max,
    â† @IsLocalization.map_comp (P := S) (Q := Sâ‚š) (g := algebraMap R S)
    (M := P.primeCompl) (T := Algebra.algebraMapSubmonoid S P.primeCompl) (S := Râ‚š) _
    _ _ _ _ _ _ (fun p hp => Algebra.mem_algebraMapSubmonoid_of_mem âŸ¨p, hpâŸ©) _ _]
  rfl","error:  unknown identifier 'localizationSMul'
error:  application type mismatch
  @IsLocalization.map_comp R CommRing.toCommSemiring P.primeCompl Râ‚š ?m.186514 ?m.186515 S CommRing.toCommSemiring
    ?m.186517 (algebraMap R S) (Algebra.algebraMapSubmonoid S P.primeCompl) Sâ‚š ?m.186612 ?m.186613 fun p hp â†¦
    Algebra.mem_algebraMapSubmonoid_of_mem âŸ¨p, hpâŸ©
argument
  fun p hp â†¦ Algebra.mem_algebraMapSubmonoid_of_mem âŸ¨p, hpâŸ©
has type
  âˆ€ (p : ?m.186615) (hp : p âˆˆ ?m.186829 p),
    (algebraMap ?m.186615 (?m.186830 p hp)) â†‘âŸ¨p, hpâŸ© âˆˆ Algebra.algebraMapSubmonoid (?m.186830 p hp) (?m.186829 p) : Prop
but is expected to have type
  Algebra S Sâ‚š : Type u_2
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.187670
case h.e'_2
R : Type u_1
instâœâµ : CommRing R
S : Type u_2
instâœâ´ : CommRing S
f : R â†’+* S
I J : Ideal S
instâœÂ³ : Algebra R S
instâœÂ² : IsDomain S
instâœÂ¹ : Algebra.IsIntegral R S
P : Ideal R
instâœ : P.IsPrime
hP : RingHom.ker (algebraMap R S) â‰¤ P
hP0 : 0 âˆ‰ Algebra.algebraMapSubmonoid S P.primeCompl
Râ‚š : Type u_1 := Localization P.primeCompl
Sâ‚š : Type u_2 := Localization (Algebra.algebraMapSubmonoid S P.primeCompl)
thisâœÂ¹ : IsDomain (Localization (Algebra.algebraMapSubmonoid S P.primeCompl)) :=
  IsLocalization.isDomain_localization (le_nonZeroDivisors_of_noZeroDivisors hP0)
Qâ‚š : Ideal Sâ‚š
Qâ‚š_maximal : Qâ‚š.IsMaximal
thisâœ : SMul Râ‚š Sâ‚š := sorryAx (SMul Râ‚š Sâ‚š) true
xâœ : Algebra Râ‚š Sâ‚š := localizationAlgebra P.primeCompl S
this : Algebra.IsIntegral Râ‚š Sâ‚š
Qâ‚š_max : (comap (algebraMap Râ‚š Sâ‚š) Qâ‚š).IsMaximal
âŠ¢ comap ((algebraMap S Sâ‚š).comp (algebraMap R S)) Qâ‚š =
    comap (algebraMap R (Localization.AtPrime P)) (comap (algebraMap Râ‚š Sâ‚š) Qâ‚š)","theorem exists_ideal_over_prime_of_isIntegral_of_isDomain [Algebra.IsIntegral R S] (P : Ideal R)
    [IsPrime P] (hP : RingHom.ker (algebraMap R S) â‰¤ P) :
    âˆƒ Q : Ideal S, IsPrime Q âˆ§ Q.comap (algebraMap R S) = P ",":= by
  have hP0 : (0 : S) âˆ‰ Algebra.algebraMapSubmonoid S P.primeCompl := by
    rintro âŸ¨x, âŸ¨hx, x0âŸ©âŸ©
    exact absurd (hP x0) hx
  let Râ‚š := Localization P.primeCompl
  let Sâ‚š := Localization (Algebra.algebraMapSubmonoid S P.primeCompl)
  letI : IsDomain (Localization (Algebra.algebraMapSubmonoid S P.primeCompl)) :=
    IsLocalization.isDomain_localization (le_nonZeroDivisors_of_noZeroDivisors hP0)
  obtain âŸ¨Qâ‚š : Ideal Sâ‚š, Qâ‚š_maximalâŸ© := exists_maximal Sâ‚š
  let _ : Algebra Râ‚š Sâ‚š := localizationAlgebra P.primeCompl S
  have : Algebra.IsIntegral Râ‚š Sâ‚š := âŸ¨isIntegral_localizationâŸ©
  have Qâ‚š_max : IsMaximal (comap _ Qâ‚š) :=
    isMaximal_comap_of_isIntegral_of_isMaximal (R := Râ‚š) (S := Sâ‚š) Qâ‚š
  refine âŸ¨comap (algebraMap S Sâ‚š) Qâ‚š, âŸ¨comap_isPrime _ Qâ‚š, ?_âŸ©âŸ©
  convert Localization.AtPrime.comap_maximalIdeal (I := P)
  rw [comap_comap, â† LocalRing.eq_maximalIdeal Qâ‚š_max,
    â† @IsLocalization.map_comp (P := S) (Q := Sâ‚š) (g := algebraMap R S)
    (M := P.primeCompl) (T := Algebra.algebraMapSubmonoid S P.primeCompl) (S := Râ‚š) _
    _ _ _ _ _ (fun p hp => Algebra.mem_algebraMapSubmonoid_of_mem âŸ¨p, hpâŸ©) _ _]
  rfl"
Mathlib/NumberTheory/Modular.lean,ModularGroup.smul_eq_lcRow0_add,smul_eq_lcRow0_add,9e34a191034458a56331f976ff7400a26407c888,":= by
  have nonZ1 : (p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2 â‰  0 := by exact_mod_cast hp.sq_add_sq_ne_zero
  have : ((â†‘) : â„¤ â†’ â„) âˆ˜ p â‰  0 := fun h => hp.ne_zero (by ext i; simpa using congr_fun h i)
  have nonZ2 : (p 0 : â„‚) * z + p 1 â‰  0 := by simpa using linear_ne_zero _ z this
  field_simp [nonZ1, nonZ2, denom_ne_zero, SMul.smul, smulAux, smulAux', num]
  rw [(by simp :
    (p 1 : â„‚) * z - p 0 = (p 1 * z - p 0) * â†‘(Matrix.det (â†‘g : Matrix (Fin 2) (Fin 2) â„¤)))]
  rw [â† hg, det_fin_two]
  simp only [Int.coe_castRingHom, coe_matrix_coe, Int.cast_mul, ofReal_int_cast, map_apply, denom,
    Int.cast_sub, coe_GLPos_coe_GL_coe_matrix]
  ring","error:  unknown identifier 'ofReal_int_cast'
info:  Try this: ring_nf
error:  unsolved goals
g : SL(2, â„¤)
z : â„
p : Fin 2 â†’ â„¤
hp : IsCoprime (p 0) (p 1)
hg : â†‘g 1 = p
nonZ1 : â†‘(p 0) ^ 2 + â†‘(p 1) ^ 2 â‰  0
this : Int.cast âˆ˜ p â‰  0
nonZ2 : â†‘(p 0) * â†‘z + â†‘(p 1) â‰  0
âŠ¢ â†‘(â†‘g 0 0) * â†‘z * â†‘(â†‘g 1 0) ^ 2 * â†‘(â†‘g 1 1) ^ 3 * 2 + â†‘(â†‘g 0 0) * â†‘z * â†‘(â†‘g 1 0) ^ 4 * â†‘(â†‘g 1 1) +
                        â†‘(â†‘g 0 0) * â†‘z * â†‘(â†‘g 1 1) ^ 5 +
                      â†‘(â†‘g 0 0) * â†‘z ^ 2 * â†‘(â†‘g 1 0) * â†‘(â†‘g 1 1) ^ 4 +
                    â†‘(â†‘g 0 0) * â†‘z ^ 2 * â†‘(â†‘g 1 0) ^ 3 * â†‘(â†‘g 1 1) ^ 2 * 2 +
                  â†‘(â†‘g 0 0) * â†‘z ^ 2 * â†‘(â†‘g 1 0) ^ 5 +
                â†‘z * â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) * â†‘(â†‘g 1 1) ^ 4 +
              â†‘z * â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 3 * â†‘(â†‘g 1 1) ^ 2 * 2 +
            â†‘z * â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 5 +
          â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 2 * â†‘(â†‘g 1 1) ^ 3 * 2 +
        â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 4 * â†‘(â†‘g 1 1) +
      â†‘(â†‘g 0 1) * â†‘(â†‘g 1 1) ^ 5 =
    â†‘(â†‘g 0 0) * â†‘z * â†‘(â†‘g 1 0) ^ 2 * â†‘(â†‘g 1 1) ^ 2 * â†‘(â†‘â†‘â†‘g 1 1) * 2 + â†‘(â†‘g 0 0) * â†‘z * â†‘(â†‘g 1 0) ^ 4 * â†‘(â†‘â†‘â†‘g 1 1) +
                        â†‘(â†‘g 0 0) * â†‘z * â†‘(â†‘g 1 1) ^ 4 * â†‘(â†‘â†‘â†‘g 1 1) +
                      â†‘(â†‘g 0 0) * â†‘z ^ 2 * â†‘(â†‘g 1 0) ^ 2 * â†‘(â†‘g 1 1) ^ 2 * â†‘(â†‘â†‘â†‘g 1 0) * 2 +
                    â†‘(â†‘g 0 0) * â†‘z ^ 2 * â†‘(â†‘g 1 0) ^ 4 * â†‘(â†‘â†‘â†‘g 1 0) +
                  â†‘(â†‘g 0 0) * â†‘z ^ 2 * â†‘(â†‘g 1 1) ^ 4 * â†‘(â†‘â†‘â†‘g 1 0) +
                â†‘z * â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 2 * â†‘(â†‘g 1 1) ^ 2 * â†‘(â†‘â†‘â†‘g 1 0) * 2 +
              â†‘z * â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 4 * â†‘(â†‘â†‘â†‘g 1 0) +
            â†‘z * â†‘(â†‘g 0 1) * â†‘(â†‘g 1 1) ^ 4 * â†‘(â†‘â†‘â†‘g 1 0) +
          â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 2 * â†‘(â†‘g 1 1) ^ 2 * â†‘(â†‘â†‘â†‘g 1 1) * 2 +
        â†‘(â†‘g 0 1) * â†‘(â†‘g 1 0) ^ 4 * â†‘(â†‘â†‘â†‘g 1 1) +
      â†‘(â†‘g 0 1) * â†‘(â†‘g 1 1) ^ 4 * â†‘(â†‘â†‘â†‘g 1 1)
warning:  fd does not have a doc string
warning:  fdo does not have a doc string","theorem smul_eq_lcRow0_add {p : Fin 2 â†’ â„¤} (hp : IsCoprime (p 0) (p 1)) (hg : (â†‘â‚˜g) 1 = p) :
    â†‘(g â€¢ z) =
      (lcRow0 p â†‘(g : SL(2, â„)) : â„‚) / ((p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2) +
        ((p 1 : â„‚) * z - p 0) / (((p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2) * (p 0 * z + p 1)) ",":= by
  have nonZ1 : (p 0 : â„‚) ^ 2 + (p 1 : â„‚) ^ 2 â‰  0 := mod_cast hp.sq_add_sq_ne_zero
  have : ((â†‘) : â„¤ â†’ â„) âˆ˜ p â‰  0 := fun h => hp.ne_zero (by ext i; simpa using congr_fun h i)
  have nonZ2 : (p 0 : â„‚) * z + p 1 â‰  0 := by simpa using linear_ne_zero _ z this
  field_simp [nonZ1, nonZ2, denom_ne_zero, num]
  rw [(by simp :
    (p 1 : â„‚) * z - p 0 = (p 1 * z - p 0) * â†‘(Matrix.det (â†‘g : Matrix (Fin 2) (Fin 2) â„¤)))]
  rw [â† hg, det_fin_two]
  simp only [Int.coe_castRingHom, coe_matrix_coe, Int.cast_mul, ofReal_intCast, map_apply, denom,
    Int.cast_sub, coe_GLPos_coe_GL_coe_matrix, coe'_apply_complex]
  ring"
Mathlib/RingTheory/Polynomial/Basic.lean,Ideal.mem_map_C_iff,mem_map_C_iff,00fcb9a9293b6e643df66a59b22d20787b471779,":= by
  constructor
  Â· intro hf
    apply @Submodule.span_induction _ _ _ _ _ f _ _ hf
    Â· intro f hf n
      cases' (Set.mem_image _ _ _).mp hf with x hx
      rw [â† hx.right, coeff_C]
      by_cases n = 0
      Â· simpa [h] using hx.left
      Â· simp [h]
    Â· simp
    Â· exact fun f g hf hg n => by simp [I.add_mem (hf n) (hg n)]
    Â· refine' fun f g hg n => _
      rw [smul_eq_mul, coeff_mul]
      exact I.sum_mem fun c _ => I.mul_mem_left (f.coeff c.fst) (hg c.snd)
  Â· intro hf
    rw [â† sum_monomial_eq f]
    refine' (I.map C : Ideal R[X]).sum_mem fun n _ => _
    simp [â† C_mul_X_pow_eq_monomial]
    rw [mul_comm]
    exact (I.map C : Ideal R[X]).mul_mem_left _ (mem_map_of_mem _ (hf n))","error:  unknown identifier 'h'
error:  type mismatch
  hâœ
has type
  x âˆˆ I : Prop
but is expected to have type
  (if n = 0 then x else 0) âˆˆ I : Prop
error:  unknown identifier 'h'
error:  simp made no progress","theorem mem_map_C_iff {I : Ideal R} {f : R[X]} :
    f âˆˆ (Ideal.map (C : R â†’+* R[X]) I : Ideal R[X]) â†” âˆ€ n : â„•, f.coeff n âˆˆ I ",":= by
  constructor
  Â· intro hf
    apply @Submodule.span_induction _ _ _ _ _ f _ _ hf
    Â· intro f hf n
      cases' (Set.mem_image _ _ _).mp hf with x hx
      rw [â† hx.right, coeff_C]
      by_cases h : n = 0
      Â· simpa [h] using hx.left
      Â· simp [h]
    Â· simp
    Â· exact fun f g hf hg n => by simp [I.add_mem (hf n) (hg n)]
    Â· refine fun f g hg n => ?_
      rw [smul_eq_mul, coeff_mul]
      exact I.sum_mem fun c _ => I.mul_mem_left (f.coeff c.fst) (hg c.snd)
  Â· intro hf
    rw [â† sum_monomial_eq f]
    refine (I.map C : Ideal R[X]).sum_mem fun n _ => ?_
    simp only [â† C_mul_X_pow_eq_monomial, ne_eq]
    rw [mul_comm]
    exact (I.map C : Ideal R[X]).mul_mem_left _ (mem_map_of_mem _ (hf n))"
Mathlib/Data/Set/Card.lean,Set.ncard_diff_singleton_le,ncard_diff_singleton_le,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  obtain hs | hs := s.finite_or_infinite
  Â· apply ncard_le_ncard (diff_subset _ _) hs
  convert @zero_le â„• _ _
  exact (hs.diff (by simp : Set.Finite {a})).ncard","error:  function expected at
  diff_subset ?m.149651
term has type
  ?m.149650 âˆˆ ?m.149648",theorem ncard_diff_singleton_le (s : Set Î±) (a : Î±) : (s \ {a}).ncard â‰¤ s.ncard ,":= by
  obtain hs | hs := s.finite_or_infinite
  Â· apply ncard_le_ncard diff_subset hs
  convert @zero_le â„• _ _
  exact (hs.diff (by simp : Set.Finite {a})).ncard"
Mathlib/ModelTheory/Skolem.lean,FirstOrder.Language.exists_elementarySubstructure_card_eq,exists_elementarySubstructure_card_eq,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  obtain âŸ¨s', hs'âŸ© := Cardinal.le_mk_iff_exists_set.1 h4
  rw [â† aleph0_le_lift.{_, w}] at h1
  rw [â† hs'] at h1 h2 âŠ¢
  refine
    âŸ¨elementarySkolemâ‚Reduct (closure (L.sum L.skolemâ‚) (s âˆª Equiv.ulift '' s')),
      (s.subset_union_left _).trans subset_closure, ?_âŸ©
  have h := mk_image_eq_lift _ s' Equiv.ulift.injective
  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h
  rw [coeSort_elementarySkolemâ‚Reduct, â† h, lift_inj]
  refine
    le_antisymm (lift_le.1 (lift_card_closure_le.trans ?_))
      (mk_le_mk_of_subset ((Set.subset_union_right _ _).trans subset_closure))
  rw [max_le_iff, aleph0_le_lift, â† aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]
  Â· refine âŸ¨h1, (mk_union_le _ _).trans ?_, (lift_le.2 card_functions_sum_skolemâ‚_le).trans ?_âŸ©
    Â· rw [â† lift_le, lift_add, h, add_comm, add_eq_max h1]
      exact max_le le_rfl h2
    Â· rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, â† lift_le.{w'},
        lift_lift, lift_lift, â† aleph0_le_lift, h]
      refine âŸ¨?_, h1âŸ©
      rw [â† lift_lift.{w', w}]
      refine _root_.trans (lift_le.{w}.2 h3) ?_
      rw [lift_lift, â† lift_lift.{w, max u v}, â† hs', â† h, lift_lift]
  Â· refine _root_.trans ?_ (lift_le.2 (mk_le_mk_of_subset (Set.subset_union_right _ _)))
    rw [aleph0_le_lift, â† aleph0_le_lift, h]
    exact h1","error:  invalid field 'trans', the environment does not contain 'Membership.mem.trans'
  Set.subset_union_left ?m.26890
has type
  ?m.26889 âˆˆ s âˆª ?m.26888
error:  invalid field 'trans', the environment does not contain 'Set.Mem.trans'
  Set.subset_union_left ?m.26890
has type
  Set.Mem ?m.26889 (s âˆª ?m.26888)
error:  invalid field 'trans', the environment does not contain 'Union.union.trans'
  Set.subset_union_left ?m.26890
has type
  (s âˆª ?m.26888) ?m.26889
error:  invalid field 'trans', the environment does not contain 'Set.union.trans'
  Set.subset_union_left ?m.26890
has type
  s.union ?m.26888 ?m.26889
error:  invalid field 'trans', the environment does not contain 'setOf.trans'
  Set.subset_union_left ?m.26890
has type
  {a | a âˆˆ s âˆ¨ a âˆˆ ?m.26888} ?m.26889
error:  invalid field 'trans', the environment does not contain 'Or.trans'
  Set.subset_union_left ?m.26890
has type
  ?m.26889 âˆˆ s âˆ¨ ?m.26889 âˆˆ ?m.26888
error:  function expected at
  Set.subset_union_right ?m.27688
term has type
  ?m.27687 âˆˆ ?m.27685 âˆª ?m.27686
error:  function expected at
  Set.subset_union_right ?m.29978
term has type
  ?m.29977 âˆˆ ?m.29975 âˆª ?m.29976","theorem exists_elementarySubstructure_card_eq (s : Set M) (Îº : Cardinal.{w'}) (h1 : â„µâ‚€ â‰¤ Îº)
    (h2 : Cardinal.lift.{w'} #s â‰¤ Cardinal.lift.{w} Îº)
    (h3 : Cardinal.lift.{w'} L.card â‰¤ Cardinal.lift.{max u v} Îº)
    (h4 : Cardinal.lift.{w} Îº â‰¤ Cardinal.lift.{w'} #M) :
    âˆƒ S : L.ElementarySubstructure M, s âŠ† S âˆ§ Cardinal.lift.{w'} #S = Cardinal.lift.{w} Îº ",":= by
  obtain âŸ¨s', hs'âŸ© := Cardinal.le_mk_iff_exists_set.1 h4
  rw [â† aleph0_le_lift.{_, w}] at h1
  rw [â† hs'] at h1 h2 âŠ¢
  refine
    âŸ¨elementarySkolemâ‚Reduct (closure (L.sum L.skolemâ‚) (s âˆª Equiv.ulift '' s')),
      (s.subset_union_left).trans subset_closure, ?_âŸ©
  have h := mk_image_eq_lift _ s' Equiv.ulift.injective
  rw [lift_umax.{w, w'}, lift_id'.{w, w'}] at h
  rw [coeSort_elementarySkolemâ‚Reduct, â† h, lift_inj]
  refine
    le_antisymm (lift_le.1 (lift_card_closure_le.trans ?_))
      (mk_le_mk_of_subset ((s.subset_union_right).trans subset_closure))
  rw [max_le_iff, aleph0_le_lift, â† aleph0_le_lift.{_, w'}, h, add_eq_max, max_le_iff, lift_le]
  Â· refine âŸ¨h1, (mk_union_le _ _).trans ?_, (lift_le.2 card_functions_sum_skolemâ‚_le).trans ?_âŸ©
    Â· rw [â† lift_le, lift_add, h, add_comm, add_eq_max h1]
      exact max_le le_rfl h2
    Â· rw [lift_max, lift_aleph0, max_le_iff, aleph0_le_lift, and_comm, â† lift_le.{w'},
        lift_lift, lift_lift, â† aleph0_le_lift, h]
      refine âŸ¨?_, h1âŸ©
      rw [â† lift_lift.{w', w}]
      refine _root_.trans (lift_le.{w}.2 h3) ?_
      rw [lift_lift, â† lift_lift.{w, max u v}, â† hs', â† h, lift_lift]
  Â· refine _root_.trans ?_ (lift_le.2 (mk_le_mk_of_subset Set.subset_union_right))
    rw [aleph0_le_lift, â† aleph0_le_lift, h]
    exact h1"
Mathlib/Algebra/Algebra/Spectrum.lean,spectrum.units_smul_resolvent_self,units_smul_resolvent_self,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  simpa only [Units.smul_def, Algebra.id.smul_eq_mul, Units.inv_mul] using
    @units_smul_resolvent _ _ _ _ _ _ r r a","error:  function expected at
  units_smul_resolvent
term has type
  ?m.56256 â€¢ resolvent r r = resolvent (?m.56256â»Â¹ â€¢ r) (?m.56256â»Â¹ â€¢ r)","theorem units_smul_resolvent_self {r : RË£} {a : A} :
    r â€¢ resolvent a (r : R) = resolvent (râ»Â¹ â€¢ a) (1 : R) ",":= by
  simpa only [Units.smul_def, Algebra.id.smul_eq_mul, Units.inv_mul] using
    @units_smul_resolvent _ _ _ _ _ r r a"
Mathlib/Topology/Algebra/Module/FiniteDimension.lean,LinearMap.closedEmbedding_of_injective,LinearMap.closedEmbedding_of_injective,a72355ef55a57571b6ce4d9bdddaa9ee3213673c,":=
  let g := LinearEquiv.ofInjective f (LinearMap.ker_eq_bot.mp hf)
  { embedding_subtype_val.comp g.toContinuousLinearEquiv.toHomeomorph.embedding with
    closed_range := by
      haveI := f.finiteDimensional_range
      simpa [LinearMap.range_coe f] using f.range.closed_of_finiteDimensional }",error:  'closed_range' is not a field of structure 'ClosedEmbedding',"theorem LinearMap.closedEmbedding_of_injective [FiniteDimensional ğ•œ E] {f : E â†’â‚—[ğ•œ] F}
    (hf : LinearMap.ker f = âŠ¥) : ClosedEmbedding f ",":=
  let g := LinearEquiv.ofInjective f (LinearMap.ker_eq_bot.mp hf)
  { embedding_subtype_val.comp g.toContinuousLinearEquiv.toHomeomorph.embedding with
    isClosed_range := by
      haveI := f.finiteDimensional_range
      simpa [LinearMap.range_coe f] using f.range.closed_of_finiteDimensional }"
Mathlib/Dynamics/OmegaLimit.lean,eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset,eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset,08ffc014ce7472c743cc849e2820181b3a1c4cae,":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  let k := closure (image2 Ï• v s)
  have hk : IsCompact (k \ n) :=
    IsCompact.diff (isCompact_of_isClosed_subset hcâ‚ isClosed_closure hvâ‚‚) hnâ‚
  let j u := closure (image2 Ï• (u âˆ© v) s)á¶œ
  have hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u) := fun _ _ â†¦ isOpen_compl_iff.mpr isClosed_closure
  have hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u := by
    have : (â‹ƒ u âˆˆ f, j u) = â‹ƒ u : (â†¥f.sets), j u := bunionáµ¢_eq_unionáµ¢ _ _
    rw [this, diff_subset_comm, diff_unionáµ¢]
    rw [omegaLimit_eq_interáµ¢_inter _ _ _ hvâ‚] at hnâ‚‚
    simp_rw [diff_compl]
    rw [â† inter_interáµ¢]
    exact Subset.trans (inter_subset_right _ _) hnâ‚‚
  rcases hk.elim_finite_subcover_image hjâ‚ hjâ‚‚ with âŸ¨g, hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f, hgâ‚‚, hgâ‚ƒâŸ©
  let w := (â‹‚ u âˆˆ g, u) âˆ© v
  have hwâ‚‚ : w âˆˆ f := by simpa [*]
  have hwâ‚ƒ : k \ n âŠ† closure (image2 Ï• w s)á¶œ := by
    apply Subset.trans hgâ‚ƒ
    simp only [unionáµ¢_subset_iff, compl_subset_compl]
    intros u hu
    mono*
    refine' interáµ¢_subset_of_subset u (interáµ¢_subset_of_subset hu _)
    all_goals exact Subset.rfl
  have hwâ‚„ : ká¶œ âŠ† closure (image2 Ï• w s)á¶œ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset (inter_subset_right _ _) Subset.rfl)
  have hnc : ná¶œ âŠ† k \ n âˆª ká¶œ := by rw [union_comm, â† inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 Ï• w s) âŠ† n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hwâ‚ƒ hwâ‚„))
  exact âŸ¨_, hwâ‚‚, hwâŸ©","warning:  @omegaLimit does not have a doc string
error:  unknown identifier 'isCompact_of_isClosed_subset'
error:  type mismatch
  isOpen_compl_iff.mpr isClosed_closure
has type
  IsOpen (closure ?m.18571)á¶œ : Prop
but is expected to have type
  IsOpen (j xâœÂ¹) : Prop
error:  unknown identifier 'bunionáµ¢_eq_unionáµ¢'
error:  unknown identifier 'diff_unionáµ¢'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.19401
Ï„ : Type u_1
Î± : Type u_2
Î² : Type u_3
Î¹ : Type u_4
instâœ : TopologicalSpace Î²
f : Filter Ï„
Ï• : Ï„ â†’ Î± â†’ Î²
s sâ‚ sâ‚‚ : Set Î±
c : Set Î²
hcâ‚ : IsCompact c
n : Set Î²
hnâ‚ : IsOpen n
hnâ‚‚ : Ï‰ f Ï• s âŠ† n
v : Set Ï„
hvâ‚ : v âˆˆ f
hvâ‚‚ : closure (image2 Ï• v s) âŠ† c
k : Set Î² := closure (image2 Ï• v s)
hk : IsCompact (k \ n)
j : Set Ï„ â†’ Set Î² := fun u â†¦ closure (image2 Ï• (u âˆ© v) s)á¶œ
hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u)
this : â‹ƒ u âˆˆ f, j u = â‹ƒ u, j â†‘u
âŠ¢ k \ â‹ƒ u, j â†‘u âŠ† n
error:  tactic 'assumption' failed
Ï„ : Type u_1
Î± : Type u_2
Î² : Type u_3
Î¹ : Type u_4
instâœ : TopologicalSpace Î²
f : Filter Ï„
Ï• : Ï„ â†’ Î± â†’ Î²
s sâ‚ sâ‚‚ : Set Î±
c : Set Î²
hcâ‚ : IsCompact c
n : Set Î²
hnâ‚ : IsOpen n
hnâ‚‚ : Ï‰ f Ï• s âŠ† n
v : Set Ï„
hvâ‚ : v âˆˆ f
hvâ‚‚ : closure (image2 Ï• v s) âŠ† c
k : Set Î² := closure (image2 Ï• v s)
hk : IsCompact (k \ n)
j : Set Ï„ â†’ Set Î² := fun u â†¦ closure (image2 Ï• (u âˆ© v) s)á¶œ
hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u)
hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u
g : Set (Set Ï„)
hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f
hgâ‚‚ : g.Finite
hgâ‚ƒ : k \ n âŠ† â‹ƒ i âˆˆ g, j i
w : Set Ï„ := (â‹‚ u âˆˆ g, u) âˆ© v
âŠ¢ w âˆˆ f
error:  unknown identifier 'unionáµ¢_subset_iff'
error:  simp made no progress
error:  simp made no progress
error:  application type mismatch
  union_subset hwâ‚ƒ
argument
  hwâ‚ƒ
has type
  k \ n âŠ† closure (image2 Ï• w s)á¶œ : Prop
but is expected to have type
  k \ n âŠ† (closure (image2 Ï• w s))á¶œ : Prop","theorem eventually_closure_subset_of_isCompact_absorbing_of_isOpen_of_omegaLimit_subset' {c : Set Î²}
    (hcâ‚ : IsCompact c) (hcâ‚‚ : âˆƒ v âˆˆ f, closure (image2 Ï• v s) âŠ† c) {n : Set Î²} (hnâ‚ : IsOpen n)
    (hnâ‚‚ : Ï‰ f Ï• s âŠ† n) : âˆƒ u âˆˆ f, closure (image2 Ï• u s) âŠ† n ",":= by
  rcases hcâ‚‚ with âŸ¨v, hvâ‚, hvâ‚‚âŸ©
  let k := closure (image2 Ï• v s)
  have hk : IsCompact (k \ n) :=
    (hcâ‚.of_isClosed_subset isClosed_closure hvâ‚‚).diff hnâ‚
  let j u := (closure (image2 Ï• (u âˆ© v) s))á¶œ
  have hjâ‚ : âˆ€ u âˆˆ f, IsOpen (j u) := fun _ _ â†¦ isOpen_compl_iff.mpr isClosed_closure
  have hjâ‚‚ : k \ n âŠ† â‹ƒ u âˆˆ f, j u := by
    have : â‹ƒ u âˆˆ f, j u = â‹ƒ u : (â†¥f.sets), j u := biUnion_eq_iUnion _ _
    rw [this, diff_subset_comm, diff_iUnion]
    rw [omegaLimit_eq_iInter_inter _ _ _ hvâ‚] at hnâ‚‚
    simp_rw [j, diff_compl]
    rw [â† inter_iInter]
    exact Subset.trans inter_subset_right hnâ‚‚
  rcases hk.elim_finite_subcover_image hjâ‚ hjâ‚‚ with âŸ¨g, hgâ‚ : âˆ€ u âˆˆ g, u âˆˆ f, hgâ‚‚, hgâ‚ƒâŸ©
  let w := (â‹‚ u âˆˆ g, u) âˆ© v
  have hwâ‚‚ : w âˆˆ f := by simpa [w, *]
  have hwâ‚ƒ : k \ n âŠ† (closure (image2 Ï• w s))á¶œ := by
    apply Subset.trans hgâ‚ƒ
    simp only [j, iUnion_subset_iff, compl_subset_compl]
    intros u hu
    mono
    refine iInter_subset_of_subset u (iInter_subset_of_subset hu ?_)
    all_goals exact Subset.rfl
  have hwâ‚„ : ká¶œ âŠ† (closure (image2 Ï• w s))á¶œ := by
    simp only [compl_subset_compl]
    exact closure_mono (image2_subset inter_subset_right Subset.rfl)
  have hnc : ná¶œ âŠ† k \ n âˆª ká¶œ := by rw [union_comm, â† inter_subset, diff_eq, inter_comm]
  have hw : closure (image2 Ï• w s) âŠ† n :=
    compl_subset_compl.mp (Subset.trans hnc (union_subset hwâ‚ƒ hwâ‚„))
  exact âŸ¨_, hwâ‚‚, hwâŸ©"
Mathlib/Data/Nat/Bitwise.lean,Nat.testBit_eq_inth,testBit_eq_inth,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  induction' i with i ih generalizing n
  Â· simp only [testBit, zero_eq, shiftRight_zero, and_one_is_mod, mod_two_of_bodd,
      bodd_eq_bits_head, List.getI_zero_eq_headI]
    cases List.headI (bits n) <;> rfl
  conv_lhs => rw [â† bit_decomp n]
  rw [testBit_bit_succ, ih n.div2, div2_bits_eq_tail]
  cases n.bits <;> simp","warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case zero.false
n : â„•
âŠ¢ (1 &&& n != 0) = false
error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case zero.true
n : â„•
âŠ¢ (1 &&& n != 0) = true
error:  unsolved goals
case zero.false
n : â„•
âŠ¢ (1 &&& n != 0) = false

case zero.true
n : â„•
âŠ¢ (1 &&& n != 0) = true
warning:  `Nat.mul_lt_mul'` has been deprecated, use `Nat.mul_lt_mul_of_le_of_lt` instead
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated",theorem testBit_eq_inth (n i : â„•) : n.testBit i = n.bits.getI i ,":= by
  induction' i with i ih generalizing n
  Â· simp only [testBit, zero_eq, shiftRight_zero, one_and_eq_mod_two, mod_two_of_bodd,
      bodd_eq_bits_head, List.getI_zero_eq_headI]
    cases List.headI (bits n) <;> rfl
  conv_lhs => rw [â† bit_decomp n]
  rw [testBit_bit_succ, ih n.div2, div2_bits_eq_tail]
  cases n.bits <;> simp"
Mathlib/Data/List/Nodup.lean,List.inj_on_of_nodup_map,inj_on_of_nodup_map,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' l with hd tl ih
  Â· simp
  Â· simp only [map, nodup_cons, mem_map, not_exists, not_and, â† Ne.def] at d
    simp only [mem_cons]
    rintro _ (rfl | hâ‚) _ (rfl | hâ‚‚) hâ‚ƒ
    Â· rfl
    Â· apply (d.1 _ hâ‚‚ hâ‚ƒ.symm).elim
    Â· apply (d.1 _ hâ‚ hâ‚ƒ).elim
    Â· apply ih d.2 hâ‚ hâ‚‚ hâ‚ƒ","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `Fin.eq_of_veq` has been deprecated, use `Fin.eq_of_val_eq` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.27761 â†’ ?m.27761 â†’ Prop","theorem inj_on_of_nodup_map {f : Î± â†’ Î²} {l : List Î±} (d : Nodup (map f l)) :
    âˆ€ â¦ƒxâ¦„, x âˆˆ l â†’ âˆ€ â¦ƒyâ¦„, y âˆˆ l â†’ f x = f y â†’ x = y ",":= by
  induction' l with hd tl ih
  Â· simp
  Â· simp only [map, nodup_cons, mem_map, not_exists, not_and, â† Ne.eq_def] at d
    simp only [mem_cons]
    rintro _ (rfl | hâ‚) _ (rfl | hâ‚‚) hâ‚ƒ
    Â· rfl
    Â· apply (d.1 _ hâ‚‚ hâ‚ƒ.symm).elim
    Â· apply (d.1 _ hâ‚ hâ‚ƒ).elim
    Â· apply ih d.2 hâ‚ hâ‚‚ hâ‚ƒ"
Mathlib/Computability/Primrec.lean,Primrec.nat_add,nat_add,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  Primrec.unpaired'.1 Nat.Primrec.add","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Primrec
has type
  (?m.87671 â†’ ?m.87672) â†’ Prop",theorem nat_add : Primrecâ‚‚ ((Â· + Â·) : â„• â†’ â„• â†’ â„•) ,":=
  Primrecâ‚‚.unpaired'.1 Nat.Primrec.add"
Mathlib/Data/Complex/Order.lean,Complex.re_eq_abs,re_eq_abs,399f04bf3c57d43d9f70a32662007a7562003890,":=
  have : 0 â‰¤ abs z := map_nonneg abs z
  âŸ¨fun h â†¦ âŸ¨h.symm â–¸ this, (abs_re_eq_abs.1 <| h.symm â–¸ _root_.abs_of_nonneg this).symmâŸ©,
    fun âŸ¨hâ‚, hâ‚‚âŸ© â†¦ by rw [â† abs_re_eq_abs.2 hâ‚‚.symm, _root_.abs_of_nonneg hâ‚]âŸ©","error:  application type mismatch
  map_nonneg abs z
argument
  z
has type
  â„‚ : Type
but is expected to have type
  0 â‰¤ z : Prop
error:  failed to synthesize
  OrderHomClass (AbsoluteValue â„‚ â„) â„‚ â„
use `set_option diagnostics true` to get diagnostic information",lemma re_eq_abs {z : â„‚} : z.re = abs z â†” 0 â‰¤ z ,":=
  have : 0 â‰¤ abs z := apply_nonneg abs z
  âŸ¨fun h â†¦ âŸ¨h.symm â–¸ this, (abs_re_eq_abs.1 <| h.symm â–¸ _root_.abs_of_nonneg this).symmâŸ©,
    fun âŸ¨hâ‚, hâ‚‚âŸ© â†¦ by rw [â† abs_re_eq_abs.2 hâ‚‚.symm, _root_.abs_of_nonneg hâ‚]âŸ©"
Mathlib/RingTheory/Jacobson.lean,Ideal.MvPolynomial.quotient_mk_comp_C_isIntegral_of_jacobson,quotient_mk_comp_C_isIntegral_of_jacobson,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  refine (isIntegral_quotientMap_iff _).mp ?_
  let P' : Ideal R := P.comap C
  obtain âŸ¨pX, hpX, hp0âŸ© :=
    exists_nonzero_mem_of_ne_bot (ne_of_lt (bot_lt_of_maximal P polynomial_not_isField)).symm hP'
  let a : R â§¸ P' := (pX.map (Quotient.mk P')).leadingCoeff
  let M : Submonoid (R â§¸ P') := Submonoid.powers a
  let Ï† : R â§¸ P' â†’+* R[X] â§¸ P := quotientMap P C le_rfl
  haveI hP'_prime : P'.IsPrime := comap_isPrime C P
  have hM : (0 : R â§¸ P') âˆ‰ M := fun âŸ¨n, hnâŸ© => hp0 <| leadingCoeff_eq_zero.mp (pow_eq_zero hn)
  let M' : Submonoid (R[X] â§¸ P) := M.map Ï†
  refine RingHom.IsIntegral.tower_bot Ï† (algebraMap _ (Localization M')) ?_ ?_
  Â· refine IsLocalization.injective (Localization M')
      (show M' â‰¤ _ from le_nonZeroDivisors_of_noZeroDivisors fun hM' => hM ?_)
    exact
      let âŸ¨z, zM, z0âŸ© := hM'
      quotientMap_injective (_root_.trans z0 Ï†.map_zero.symm) â–¸ zM
  Â· suffices RingHom.comp (algebraMap (R[X] â§¸ P) (Localization M')) Ï† =
      (IsLocalization.map (Localization M') Ï† M.le_comap_map).comp
        (algebraMap (R â§¸ P') (Localization M)) by
      rw [this]
      refine RingHom.IsIntegral.trans (algebraMap (R â§¸ P') (Localization M))
        (IsLocalization.map (Localization M') Ï† M.le_comap_map) ?_ ?_
      Â· exact (algebraMap (R â§¸ P') (Localization M)).isIntegral_of_surjective
          (IsField.localization_map_bijective hM ((Quotient.maximal_ideal_iff_isField_quotient _).mp
            (isMaximal_comap_C_of_isMaximal P hP'))).2
      Â· 
        have isloc : IsLocalization M' (Localization M') := by infer_instance
        exact @isIntegral_isLocalization_polynomial_quotient R _
          (Localization M) (Localization M') _ _ P pX hpX _ _ _ _ _ isloc
    rw [IsLocalization.map_comp M.le_comap_map]","error:  function expected at
  isIntegral_isLocalization_polynomial_quotient P pX hpX ?m.188873
term has type
  (IsLocalization.map (Localization M') (quotientMap P C â‹¯) â‹¯).IsIntegralElem ?m.188873","theorem quotient_mk_comp_C_isIntegral_of_jacobson' [Nontrivial R] (hR : IsJacobson R)
    (hP' : âˆ€ x : R, C x âˆˆ P â†’ x = 0) : ((Quotient.mk P).comp C : R â†’+* R[X] â§¸ P).IsIntegral ",":= by
  refine (isIntegral_quotientMap_iff _).mp ?_
  let P' : Ideal R := P.comap C
  obtain âŸ¨pX, hpX, hp0âŸ© :=
    exists_nonzero_mem_of_ne_bot (ne_of_lt (bot_lt_of_maximal P polynomial_not_isField)).symm hP'
  let a : R â§¸ P' := (pX.map (Quotient.mk P')).leadingCoeff
  let M : Submonoid (R â§¸ P') := Submonoid.powers a
  let Ï† : R â§¸ P' â†’+* R[X] â§¸ P := quotientMap P C le_rfl
  haveI hP'_prime : P'.IsPrime := comap_isPrime C P
  have hM : (0 : R â§¸ P') âˆ‰ M := fun âŸ¨n, hnâŸ© => hp0 <| leadingCoeff_eq_zero.mp (pow_eq_zero hn)
  let M' : Submonoid (R[X] â§¸ P) := M.map Ï†
  refine RingHom.IsIntegral.tower_bot Ï† (algebraMap _ (Localization M')) ?_ ?_
  Â· refine IsLocalization.injective (Localization M')
      (show M' â‰¤ _ from le_nonZeroDivisors_of_noZeroDivisors fun hM' => hM ?_)
    exact
      let âŸ¨z, zM, z0âŸ© := hM'
      quotientMap_injective (_root_.trans z0 Ï†.map_zero.symm) â–¸ zM
  Â· suffices RingHom.comp (algebraMap (R[X] â§¸ P) (Localization M')) Ï† =
      (IsLocalization.map (Localization M') Ï† M.le_comap_map).comp
        (algebraMap (R â§¸ P') (Localization M)) by
      rw [this]
      refine RingHom.IsIntegral.trans (algebraMap (R â§¸ P') (Localization M))
        (IsLocalization.map (Localization M') Ï† M.le_comap_map) ?_ ?_
      Â· exact (algebraMap (R â§¸ P') (Localization M)).isIntegral_of_surjective
          (IsField.localization_map_bijective hM ((Quotient.maximal_ideal_iff_isField_quotient _).mp
            (isMaximal_comap_C_of_isMaximal P hP'))).2
      Â· 
        have isloc : IsLocalization M' (Localization M') := by infer_instance
        exact @isIntegral_isLocalization_polynomial_quotient R _
          (Localization M) (Localization M') _ _ P pX hpX _ _ _ isloc
    rw [IsLocalization.map_comp M.le_comap_map]"
Mathlib/LinearAlgebra/Prod.lean,LinearMap.range_prod_eq,range_prod_eq,9f6d33884de569540c527b667d1573e1b97e1347,":= by
  refine' le_antisymm (f.range_prod_le g) _
  simp only [SetLike.le_def, prod_apply, mem_range, SetLike.mem_coe, mem_prod, exists_imp, and_imp,
    Prod.forall, Pi.prod]
  rintro _ _ x rfl y rfl
  simp only [Prod.mk.inj_iff, â† sub_mem_ker_iff]
  have : y - x âˆˆ ker f âŠ” ker g := by simp only [h, mem_top]
  rcases mem_sup.1 this with âŸ¨x', hx', y', hy', HâŸ©
  refine' âŸ¨x' + x, _, _âŸ©
  Â· rwa [add_sub_cancel]
  Â· simp [â† eq_sub_iff_add_eq.1 H, map_add, add_left_inj, self_eq_add_right, mem_ker.mp hy']","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a + (?b - ?a)
case intro.intro.intro.intro.refine'_1
R : Type u
K : Type u'
M : Type v
V : Type v'
Mâ‚‚ : Type w
Vâ‚‚ : Type w'
Mâ‚ƒ : Type y
Vâ‚ƒ : Type y'
Mâ‚„ : Type z
Î¹ : Type x
Mâ‚… : Type u_1
Mâ‚† : Type u_2
instâœâ¶ : Ring R
instâœâµ : AddCommGroup M
instâœâ´ : AddCommGroup Mâ‚‚
instâœÂ³ : AddCommGroup Mâ‚ƒ
instâœÂ² : Module R M
instâœÂ¹ : Module R Mâ‚‚
instâœ : Module R Mâ‚ƒ
f : M â†’â‚—[R] Mâ‚‚
g : M â†’â‚—[R] Mâ‚ƒ
h : ker f âŠ” ker g = âŠ¤
x y : M
this : y - x âˆˆ ker f âŠ” ker g
x' : M
hx' : x' âˆˆ ker f
y' : M
hy' : y' âˆˆ ker g
H : x' + y' = y - x
âŠ¢ x' + x - x âˆˆ ker f
warning:  `LinearMap.tunnelAux` has been deprecated
warning:  `LinearMap.tunnelAux` has been deprecated
warning:  `LinearMap.tunnelAux_injective` has been deprecated
warning:  `LinearMap.tunnel'` has been deprecated
warning:  `LinearMap.tunnel'` has been deprecated
warning:  `LinearMap.tunnelAux` has been deprecated
warning:  `LinearMap.tunnelAux` has been deprecated
warning:  `LinearMap.tunnel'` has been deprecated
warning:  `LinearMap.tailing` has been deprecated
warning:  `LinearMap.tunnelAux_injective` has been deprecated
warning:  `LinearMap.tunnel'` has been deprecated
warning:  `LinearMap.tailing` has been deprecated
warning:  `LinearMap.tunnel` has been deprecated
warning:  `LinearMap.tailing` has been deprecated
warning:  `LinearMap.tunnelAux` has been deprecated
warning:  `LinearMap.tailing` has been deprecated
warning:  `LinearMap.tunnel` has been deprecated
warning:  `LinearMap.tailing` has been deprecated
warning:  `LinearMap.tunnel` has been deprecated
warning:  `LinearMap.tunnel'` has been deprecated
warning:  `LinearMap.tunnelAux_injective` has been deprecated
warning:  `LinearMap.tailing` has been deprecated
warning:  `LinearMap.tunnel` has been deprecated
warning:  `LinearMap.tunnel` has been deprecated
warning:  `LinearMap.tailing` has been deprecated
warning:  `LinearMap.tunnel` has been deprecated
warning:  `LinearMap.tunnel'` has been deprecated
warning:  `LinearMap.tunnelAux` has been deprecated
warning:  `LinearMap.tailing` has been deprecated
warning:  `LinearMap.tailings` has been deprecated
warning:  `LinearMap.tailing` has been deprecated
warning:  `LinearMap.tailings` has been deprecated
warning:  `LinearMap.tailings` has been deprecated
warning:  `LinearMap.tailings` has been deprecated
warning:  `LinearMap.tailing` has been deprecated
warning:  `LinearMap.tailings` has been deprecated
warning:  `LinearMap.tailings` has been deprecated
warning:  `LinearMap.tunnel` has been deprecated
warning:  `LinearMap.tailings_zero` has been deprecated
warning:  `LinearMap.tailing_disjoint_tunnel_succ` has been deprecated
warning:  `LinearMap.tailings_succ` has been deprecated
warning:  `LinearMap.tailing_disjoint_tunnel_succ` has been deprecated
warning:  `LinearMap.tailing_sup_tunnel_succ_le_tunnel` has been deprecated
warning:  `LinearMap.tailings` has been deprecated
warning:  `LinearMap.tailing` has been deprecated
warning:  `LinearMap.tailing_le_tunnel` has been deprecated
warning:  `LinearMap.tailings_disjoint_tunnel` has been deprecated","theorem range_prod_eq {f : M â†’â‚—[R] Mâ‚‚} {g : M â†’â‚—[R] Mâ‚ƒ} (h : ker f âŠ” ker g = âŠ¤) :
    range (prod f g) = (range f).prod (range g) ",":= by
  refine le_antisymm (f.range_prod_le g) ?_
  simp only [SetLike.le_def, prod_apply, mem_range, SetLike.mem_coe, mem_prod, exists_imp, and_imp,
    Prod.forall, Pi.prod]
  rintro _ _ x rfl y rfl
  simp only [Prod.mk.inj_iff, â† sub_mem_ker_iff (f := f)]
  have : y - x âˆˆ ker f âŠ” ker g := by simp only [h, mem_top]
  rcases mem_sup.1 this with âŸ¨x', hx', y', hy', HâŸ©
  refine âŸ¨x' + x, ?_, ?_âŸ©
  Â· rwa [add_sub_cancel_right]
  Â· simp [â† eq_sub_iff_add_eq.1 H, map_add, add_left_inj, self_eq_add_right, mem_ker.mp hy']"
Mathlib/NumberTheory/Cyclotomic/Rat.lean,IsCyclotomicExtension.Rat.isIntegralClosure_adjoin_singleton_of_prime,isIntegralClosure_adjoin_singleton_of_prime,878024beabe74d3476b6e31acfd90d64e274a958,":= by
  refine' âŸ¨Subtype.val_injective, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, _âŸ©, rflâŸ©, _âŸ©âŸ©
  swap
  Â· rintro âŸ¨y, rflâŸ©
    exact
      IsIntegral.algebraMap
        (le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hÎ¶.isIntegral (p ^ k).pos)) _)
  let B := hÎ¶.subOnePowerBasis â„š
  have hint : IsIntegral â„¤ B.gen := isIntegral_sub (hÎ¶.isIntegral (p ^ k).pos) isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} â„š K
  have H := discr_mul_isIntegral_mem_adjoin â„š hint h
  obtain âŸ¨u, n, hunâŸ© := discr_prime_pow_eq_unit_mul_pow' hÎ¶
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [â† smul_assoc, â† smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, â† Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  Â· haveI : IsCyclotomicExtension {1} â„š K := by simpa using hcycl
    have : x âˆˆ (âŠ¥ : Subalgebra â„š K) := by
      rw [singleton_one â„š K]
      exact mem_top
    obtain âŸ¨y, rflâŸ© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap â„š K).injective).1 h
    obtain âŸ¨z, hzâŸ© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [â† hz, â† IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  Â· have hmin : (minpoly â„¤ B.gen).IsEisensteinAt (Submodule.span â„¤ {((p : â„•) : â„¤)}) := by
      have hâ‚ := minpoly.isIntegrallyClosed_eq_field_fractions' â„š hint
      have hâ‚‚ := hÎ¶.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at hâ‚
      rw [hâ‚, â† map_cyclotomic_int, show Int.castRingHom â„š = algebraMap â„¤ â„š by rfl,
        show X + 1 = map (algebraMap â„¤ â„š) (X + 1) by simp, â† map_comp] at hâ‚‚
      haveI : CharZero â„š := StrictOrderedSemiring.to_charZero
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap â„¤ â„š) (algebraMap â„¤ â„š).injective_int hâ‚‚]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine'
      adjoin_le _
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton â„¤ _) (Subalgebra.one_mem _)","error:  function expected at
  le_integralClosure_iff_isIntegral.mp (adjoin_le_integralClosure (IsPrimitiveRoot.isIntegral hÎ¶ (PNat.pos (p ^ k))))
term has type
  Algebra.IsIntegral â„¤ â†¥(adjoin â„¤ {Î¶})
error:  unknown identifier 'isIntegral_sub'
error:  unknown constant 'StrictOrderedSemiring.to_charZero'","theorem isIntegralClosure_adjoin_singleton_of_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} â„š K]
    (hÎ¶ : IsPrimitiveRoot Î¶ â†‘(p ^ k)) : IsIntegralClosure (adjoin â„¤ ({Î¶} : Set K)) â„¤ K ",":= by
  refine âŸ¨Subtype.val_injective, @fun x => âŸ¨fun h => âŸ¨âŸ¨x, ?_âŸ©, rflâŸ©, ?_âŸ©âŸ©
  swap
  Â· rintro âŸ¨y, rflâŸ©
    exact
      IsIntegral.algebraMap
        ((le_integralClosure_iff_isIntegral.1
          (adjoin_le_integralClosure (hÎ¶.isIntegral (p ^ k).pos))).isIntegral _)
  let B := hÎ¶.subOnePowerBasis â„š
  have hint : IsIntegral â„¤ B.gen := (hÎ¶.isIntegral (p ^ k).pos).sub isIntegral_one
  letI := IsCyclotomicExtension.finiteDimensional {p ^ k} â„š K
  have H := discr_mul_isIntegral_mem_adjoin â„š hint h
  obtain âŸ¨u, n, hunâŸ© := discr_prime_pow_eq_unit_mul_pow' hÎ¶
  rw [hun] at H
  replace H := Subalgebra.smul_mem _ H u.inv
  rw [â† smul_assoc, â† smul_mul_assoc, Units.inv_eq_val_inv, zsmul_eq_mul, â† Int.cast_mul,
    Units.inv_mul, Int.cast_one, one_mul, smul_def, map_pow] at H
  cases k
  Â· haveI : IsCyclotomicExtension {1} â„š K := by simpa using hcycl
    have : x âˆˆ (âŠ¥ : Subalgebra â„š K) := by
      rw [singleton_one â„š K]
      exact mem_top
    obtain âŸ¨y, rflâŸ© := mem_bot.1 this
    replace h := (isIntegral_algebraMap_iff (algebraMap â„š K).injective).1 h
    obtain âŸ¨z, hzâŸ© := IsIntegrallyClosed.isIntegral_iff.1 h
    rw [â† hz, â† IsScalarTower.algebraMap_apply]
    exact Subalgebra.algebraMap_mem _ _
  Â· have hmin : (minpoly â„¤ B.gen).IsEisensteinAt (Submodule.span â„¤ {((p : â„•) : â„¤)}) := by
      have hâ‚ := minpoly.isIntegrallyClosed_eq_field_fractions' â„š hint
      have hâ‚‚ := hÎ¶.minpoly_sub_one_eq_cyclotomic_comp (cyclotomic.irreducible_rat (p ^ _).pos)
      rw [IsPrimitiveRoot.subOnePowerBasis_gen] at hâ‚
      rw [hâ‚, â† map_cyclotomic_int, show Int.castRingHom â„š = algebraMap â„¤ â„š by rfl,
        show X + 1 = map (algebraMap â„¤ â„š) (X + 1) by simp, â† map_comp] at hâ‚‚
      rw [IsPrimitiveRoot.subOnePowerBasis_gen,
        map_injective (algebraMap â„¤ â„š) (algebraMap â„¤ â„š).injective_int hâ‚‚]
      exact cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt p _
    refine
      adjoin_le ?_
        (mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt (n := n)
          (Nat.prime_iff_prime_int.1 hp.out) hint h (by simpa using H) hmin)
    simp only [Set.singleton_subset_iff, SetLike.mem_coe]
    exact Subalgebra.sub_mem _ (self_mem_adjoin_singleton â„¤ _) (Subalgebra.one_mem _)"
Mathlib/Geometry/Manifold/ContMDiff/Defs.lean,contMDiffOn_iff_target,contMDiffOn_iff_target,bbc6e56d76341e236fa4e15748bebff612b5cb4f,":= by
  simp only [contMDiffOn_iff, ModelWithCorners.source_eq, chartAt_self_eq,
    PartialHomeomorph.refl_localEquiv, LocalEquiv.refl_trans, extChartAt, PartialHomeomorph.extend,
    Set.preimage_univ, Set.inter_univ, and_congr_right_iff]
  intro h
  constructor
  Â· refine' fun h' y => âŸ¨_, fun x _ => h' x yâŸ©
    have h'' : ContinuousOn _ univ := (ModelWithCorners.continuous I').continuousOn
    convert (h''.comp' (chartAt H' y).continuousOn_toFun).comp' h
    simp
  Â· exact fun h' x y => (h' y).2 x 0","error:  unknown constant 'PartialHomeomorph.refl_localEquiv'
error:  unknown identifier 'LocalEquiv.refl_trans'
error:  type mismatch
  h' x y
has type
  ContDiffOn ğ•œ n
    (â†‘((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv) âˆ˜ f âˆ˜ â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm)
    (((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).target âˆ©
      â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm â»Â¹'
        (s âˆ© f â»Â¹' ((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv).source)) : Prop
but is expected to have type
  ContDiffOn ğ•œ n
    (â†‘((PartialHomeomorph.refl E').toPartialEquiv â‰« ğ“˜(ğ•œ, E').toPartialEquiv) âˆ˜
      (â†‘((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv) âˆ˜ f) âˆ˜
        â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm)
    (((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).target âˆ©
      â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm â»Â¹'
        (s âˆ© f â»Â¹' ((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv).source âˆ©
          â†‘((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv) âˆ˜ f â»Â¹'
            ((PartialHomeomorph.refl E').toPartialEquiv â‰« ğ“˜(ğ•œ, E').toPartialEquiv).source)) : Prop
error:  type mismatch
  (h' y).right x 0
has type
  ContDiffOn ğ•œ n
    (â†‘((PartialHomeomorph.refl E').toPartialEquiv â‰« ğ“˜(ğ•œ, E').toPartialEquiv) âˆ˜
      (â†‘((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv) âˆ˜ f) âˆ˜
        â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm)
    (((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).target âˆ©
      â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm â»Â¹'
        (s âˆ© f â»Â¹' ((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv).source âˆ©
          â†‘((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv) âˆ˜ f â»Â¹'
            ((PartialHomeomorph.refl E').toPartialEquiv â‰« ğ“˜(ğ•œ, E').toPartialEquiv).source)) : Prop
but is expected to have type
  ContDiffOn ğ•œ n
    (â†‘((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv) âˆ˜ f âˆ˜ â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm)
    (((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).target âˆ©
      â†‘((chartAt H x).toPartialEquiv â‰« I.toPartialEquiv).symm â»Â¹'
        (s âˆ© f â»Â¹' ((chartAt H' y).toPartialEquiv â‰« I'.toPartialEquiv).source)) : Prop","theorem contMDiffOn_iff_target :
    ContMDiffOn I I' n f s â†”
      ContinuousOn f s âˆ§
        âˆ€ y : M',
          ContMDiffOn I ğ“˜(ğ•œ, E') n (extChartAt I' y âˆ˜ f) (s âˆ© f â»Â¹' (extChartAt I' y).source) ",":= by
  simp only [contMDiffOn_iff, ModelWithCorners.source_eq, chartAt_self_eq,
    PartialHomeomorph.refl_partialEquiv, PartialEquiv.refl_trans, extChartAt,
    PartialHomeomorph.extend, Set.preimage_univ, Set.inter_univ, and_congr_right_iff]
  intro h
  constructor
  Â· refine fun h' y => âŸ¨?_, fun x _ => h' x yâŸ©
    have h'' : ContinuousOn _ univ := (ModelWithCorners.continuous I').continuousOn
    convert (h''.comp' (chartAt H' y).continuousOn_toFun).comp' h
    simp
  Â· exact fun h' x y => (h' y).2 x 0"
Mathlib/Analysis/Analytic/Inverse.lean,FormalMultilinearSeries.leftInv_comp,leftInv_comp,b50a8b2e9760b6f582390d3948a953c553480df1,":= by
  ext (n v)
  match n with
  | 0 =>
    simp only [leftInv_coeff_zero, ContinuousMultilinearMap.zero_apply, id_apply_ne_one, Ne,
      not_false_iff, zero_ne_one, comp_coeff_zero']
  | 1 =>
    simp only [leftInv_coeff_one, comp_coeff_one, h, id_apply_one, ContinuousLinearEquiv.coe_apply,
      ContinuousLinearEquiv.symm_apply_apply, continuousMultilinearCurryFin1_symm_apply]
  | n + 2 =>
    have A :
      (Finset.univ : Finset (Composition (n + 2))) =
        {c | Composition.length c < n + 2}.toFinset âˆª {Composition.ones (n + 2)} := by
      refine' Subset.antisymm (fun c _ => _) (subset_univ _)
      by_cases h : c.length < n + 2
      Â· simp [h, Set.mem_toFinset (s := {c | Composition.length c < n + 2})]
      Â· simp [Composition.eq_ones_iff_le_length.2 (not_lt.1 h)]
    have B :
      Disjoint ({c | Composition.length c < n + 2} : Set (Composition (n + 2))).toFinset
        {Composition.ones (n + 2)} := by
      simp [Set.mem_toFinset (s := {c | Composition.length c < n + 2})]
    have C :
      ((p.leftInv i (Composition.ones (n + 2)).length)
          fun j : Fin (Composition.ones n.succ.succ).length =>
          p 1 fun _ => v ((Fin.castLE (Composition.length_le _)) j)) =
        p.leftInv i (n + 2) fun j : Fin (n + 2) => p 1 fun _ => v j := by
      apply FormalMultilinearSeries.congr _ (Composition.ones_length _) fun j hj1 hj2 => ?_
      exact FormalMultilinearSeries.congr _ rfl fun k _ _ => by congr
    have D :
      (p.leftInv i (n + 2) fun j : Fin (n + 2) => p 1 fun _ => v j) =
        -âˆ‘ c : Composition (n + 2) in {c : Composition (n + 2) | c.length < n + 2}.toFinset,
            (p.leftInv i c.length) (p.applyComposition c v) := by
      simp only [leftInv, ContinuousMultilinearMap.neg_apply, neg_inj,
        ContinuousMultilinearMap.sum_apply]
      convert
        (sum_toFinset_eq_subtype
          (fun c : Composition (n + 2) => c.length < n + 2)
          (fun c : Composition (n + 2) =>
          (ContinuousMultilinearMap.compAlongComposition
            (p.compContinuousLinearMap (i.symm : F â†’L[ğ•œ] E)) c (p.leftInv i c.length))
            fun j : Fin (n + 2) => p 1 fun _ : Fin 1 => v j)).symm.trans
          _
      simp only [compContinuousLinearMap_applyComposition,
        ContinuousMultilinearMap.compAlongComposition_apply]
      congr
      ext c
      congr
      ext k
      simp [h, Function.comp]
    simp [FormalMultilinearSeries.comp, show n + 2 â‰  1 by norm_num, A, Finset.sum_union B,
      applyComposition_ones, C, D, -Set.toFinset_setOf]","error:  unsolved goals
ğ•œ : Type u_1
instâœâ´ : NontriviallyNormedField ğ•œ
E : Type u_2
instâœÂ³ : NormedAddCommGroup E
instâœÂ² : NormedSpace ğ•œ E
F : Type u_3
instâœÂ¹ : NormedAddCommGroup F
instâœ : NormedSpace ğ•œ F
p : FormalMultilinearSeries ğ•œ E F
i : E â‰ƒL[ğ•œ] F
h : p 1 = (continuousMultilinearCurryFin1 ğ•œ E F).symm â†‘i
nâœ n : â„•
v : Fin (n + 2) â†’ E
A : univ = {c | c.length < n + 2}.toFinset âˆª {Composition.ones (n + 2)}
B : Disjoint {c | c.length < n + 2}.toFinset {Composition.ones (n + 2)}
C :
  ((p.leftInv i (Composition.ones (n + 2)).length) fun j â†¦ (p 1) fun x â†¦ v (Fin.castLE â‹¯ j)) =
    (p.leftInv i (n + 2)) fun j â†¦ (p 1) fun x â†¦ v j
D :
  ((p.leftInv i (n + 2)) fun j â†¦ (p 1) fun x â†¦ v j) =
    -âˆ‘ c âˆˆ {c | c.length < n + 2}.toFinset, (p.leftInv i c.length) (p.applyComposition c v)
âŠ¢ Â¬n + 2 = 1","theorem leftInv_comp (p : FormalMultilinearSeries ğ•œ E F) (i : E â‰ƒL[ğ•œ] F)
    (h : p 1 = (continuousMultilinearCurryFin1 ğ•œ E F).symm i) : (leftInv p i).comp p = id ğ•œ E ",":= by
  ext (n v)
  match n with
  | 0 =>
    simp only [leftInv_coeff_zero, ContinuousMultilinearMap.zero_apply, id_apply_ne_one, Ne,
      not_false_iff, zero_ne_one, comp_coeff_zero']
  | 1 =>
    simp only [leftInv_coeff_one, comp_coeff_one, h, id_apply_one, ContinuousLinearEquiv.coe_apply,
      ContinuousLinearEquiv.symm_apply_apply, continuousMultilinearCurryFin1_symm_apply]
  | n + 2 =>
    have A :
      (Finset.univ : Finset (Composition (n + 2))) =
        {c | Composition.length c < n + 2}.toFinset âˆª {Composition.ones (n + 2)} := by
      refine Subset.antisymm (fun c _ => ?_) (subset_univ _)
      by_cases h : c.length < n + 2
      Â· simp [h, Set.mem_toFinset (s := {c | Composition.length c < n + 2})]
      Â· simp [Composition.eq_ones_iff_le_length.2 (not_lt.1 h)]
    have B :
      Disjoint ({c | Composition.length c < n + 2} : Set (Composition (n + 2))).toFinset
        {Composition.ones (n + 2)} := by
      simp [Set.mem_toFinset (s := {c | Composition.length c < n + 2})]
    have C :
      ((p.leftInv i (Composition.ones (n + 2)).length)
          fun j : Fin (Composition.ones n.succ.succ).length =>
          p 1 fun _ => v ((Fin.castLE (Composition.length_le _)) j)) =
        p.leftInv i (n + 2) fun j : Fin (n + 2) => p 1 fun _ => v j := by
      apply FormalMultilinearSeries.congr _ (Composition.ones_length _) fun j hj1 hj2 => ?_
      exact FormalMultilinearSeries.congr _ rfl fun k _ _ => by congr
    have D :
      (p.leftInv i (n + 2) fun j : Fin (n + 2) => p 1 fun _ => v j) =
        -âˆ‘ c âˆˆ {c : Composition (n + 2) | c.length < n + 2}.toFinset,
            (p.leftInv i c.length) (p.applyComposition c v) := by
      simp only [leftInv, ContinuousMultilinearMap.neg_apply, neg_inj,
        ContinuousMultilinearMap.sum_apply]
      convert
        (sum_toFinset_eq_subtype
          (fun c : Composition (n + 2) => c.length < n + 2)
          (fun c : Composition (n + 2) =>
          (ContinuousMultilinearMap.compAlongComposition
            (p.compContinuousLinearMap (i.symm : F â†’L[ğ•œ] E)) c (p.leftInv i c.length))
            fun j : Fin (n + 2) => p 1 fun _ : Fin 1 => v j)).symm.trans
          _
      simp only [compContinuousLinearMap_applyComposition,
        ContinuousMultilinearMap.compAlongComposition_apply]
      congr
      ext c
      congr
      ext k
      simp [h, Function.comp]
    simp [FormalMultilinearSeries.comp, show n + 2 â‰  1 by omega, A, Finset.sum_union B,
      applyComposition_ones, C, D, -Set.toFinset_setOf]"
Mathlib/Data/Set/Finite.lean,Set.infinite_range_iff,infinite_range_iff,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rw [â† image_univ, infinite_image_iff (hi.injOn _), infinite_univ_iff]","error:  application type mismatch
  infinite_image_iff (Injective.injOn hi ?m.157937)
argument
  Injective.injOn hi ?m.157937
has type
  âˆ€ â¦ƒxâ‚‚ : Î±â¦„, xâ‚‚ âˆˆ ?m.157935 â†’ f ?m.157936 = f xâ‚‚ â†’ ?m.157936 = xâ‚‚ : Prop
but is expected to have type
  InjOn ?m.157914 ?m.157913 : Prop","theorem infinite_range_iff {f : Î± â†’ Î²} (hi : Injective f) :
    (range f).Infinite â†” Infinite Î± ",":= by
  rw [â† image_univ, infinite_image_iff hi.injOn, infinite_univ_iff]"
Mathlib/AlgebraicGeometry/EllipticCurve/Group.lean,WeierstrassCurve.Affine.CoordinateRing.degree_norm_smul_basis,degree_norm_smul_basis,26dcb0a78bda63252389cd8290cafcd2d953c437,":= by
  have hdp : (p ^ 2).degree = 2 â€¢ p.degree := degree_pow p 2
  have hdpq : (p * q * (C W.aâ‚ * X + C W.aâ‚ƒ)).degree â‰¤ p.degree + q.degree + 1 := by
    simpa only [degree_mul] using add_le_add_left degree_linear_le (p.degree + q.degree)
  have hdq :
      (q ^ 2 * (X ^ 3 + C W.aâ‚‚ * X ^ 2 + C W.aâ‚„ * X + C W.aâ‚†)).degree = 2 â€¢ q.degree + 3 := by
    rw [degree_mul, degree_pow, â† one_mul <| X ^ 3, â† C_1, degree_cubic <| one_ne_zero' R]
  rw [norm_smul_basis]
  by_cases hp : p = 0
  Â· simpa only [hp, hdq, neg_zero, zero_sub, zero_mul, zero_pow two_ne_zero, degree_neg] using
      (max_bot_left _).symm
  Â· by_cases hq : q = 0
    Â· simpa only [hq, hdp, sub_zero, zero_mul, mul_zero, zero_pow two_ne_zero] using
        (max_bot_right _).symm
    Â· rw [â† not_congr degree_eq_bot] at hp hq
      rcases hp' : p.degree with _ | dp 
      Â· exact (hp hp').elim 
      Â· rw [hp'] at hdp hdpq 
        rcases hq' : q.degree with _ | dq 
        Â· exact (hq hq').elim 
        Â· rw [hq'] at hdpq hdq 
          rcases le_or_lt dp (dq + 1) with hpq | hpq
          Â· convert (degree_sub_eq_right_of_degree_lt <| (degree_sub_le _ _).trans_lt <|
                      max_lt_iff.mpr âŸ¨hdp.trans_lt _, hdpq.trans_lt _âŸ©).trans
              (max_eq_right_of_lt _).symm <;> rw [hdq] <;>
                exact WithBot.coe_lt_coe.mpr <| by linarith only [hpq]
          Â· rw [sub_sub]
            convert (degree_sub_eq_left_of_degree_lt <| (degree_add_le _ _).trans_lt <|
                      max_lt_iff.mpr âŸ¨hdpq.trans_lt _, hdq.trans_lt _âŸ©).trans
              (max_eq_left_of_lt _).symm <;> rw [hdp] <;>
                exact WithBot.coe_lt_coe.mpr <| by linarith only [hpq]","error:  linarith failed to find a contradiction
case h
R : Type u
S : Type v
instâœÂ² : CommRing R
instâœÂ¹ : CommRing S
W : Affine R
f : R â†’+* S
instâœ : IsDomain R
p q : R[X]
hp : Â¬p.degree = âŠ¥
hq : Â¬q.degree = âŠ¥
dp : â„•
hdp : (p ^ 2).degree = 2 â€¢ some dp
hp' : p.degree = some dp
dq : â„•
hdq : (q ^ 2 * (X ^ 3 + C W.aâ‚‚ * X ^ 2 + C W.aâ‚„ * X + C W.aâ‚†)).degree = 2 â€¢ some dq + 3
hdpq : (p * q * (C W.aâ‚ * X + C W.aâ‚ƒ)).degree â‰¤ some dp + some dq + 1
hq' : q.degree = some dq
hpq : dp â‰¤ dq + 1
aâœ : 2 â€¢ dp â‰¥ (fun x x_1 â†¦ x + x_1) (2 â€¢ dq) â†‘3
âŠ¢ False
failed
error:  linarith failed to find a contradiction
case h
R : Type u
S : Type v
instâœÂ² : CommRing R
instâœÂ¹ : CommRing S
W : Affine R
f : R â†’+* S
instâœ : IsDomain R
p q : R[X]
hp : Â¬p.degree = âŠ¥
hq : Â¬q.degree = âŠ¥
dp : â„•
hdp : (p ^ 2).degree = 2 â€¢ some dp
hp' : p.degree = some dp
dq : â„•
hdq : (q ^ 2 * (X ^ 3 + C W.aâ‚‚ * X ^ 2 + C W.aâ‚„ * X + C W.aâ‚†)).degree = 2 â€¢ some dq + 3
hdpq : (p * q * (C W.aâ‚ * X + C W.aâ‚ƒ)).degree â‰¤ some dp + some dq + 1
hq' : q.degree = some dq
hpq : dp â‰¤ dq + 1
aâœ : (fun x x_1 â†¦ x + x_1) ((fun x x_1 â†¦ x + x_1) dp dq) 1 â‰¥ (fun x x_1 â†¦ x + x_1) (2 â€¢ dq) â†‘3
âŠ¢ False
failed
error:  linarith failed to find a contradiction
case h
R : Type u
S : Type v
instâœÂ² : CommRing R
instâœÂ¹ : CommRing S
W : Affine R
f : R â†’+* S
instâœ : IsDomain R
p q : R[X]
hp : Â¬p.degree = âŠ¥
hq : Â¬q.degree = âŠ¥
dp : â„•
hdp : (p ^ 2).degree = 2 â€¢ some dp
hp' : p.degree = some dp
dq : â„•
hdq : (q ^ 2 * (X ^ 3 + C W.aâ‚‚ * X ^ 2 + C W.aâ‚„ * X + C W.aâ‚†)).degree = 2 â€¢ some dq + 3
hdpq : (p * q * (C W.aâ‚ * X + C W.aâ‚ƒ)).degree â‰¤ some dp + some dq + 1
hq' : q.degree = some dq
hpq : dp â‰¤ dq + 1
aâœ : 2 â€¢ dp â‰¥ (fun x x_1 â†¦ x + x_1) (2 â€¢ dq) â†‘3
âŠ¢ False
failed
error:  linarith failed to find a contradiction
case h
R : Type u
S : Type v
instâœÂ² : CommRing R
instâœÂ¹ : CommRing S
W : Affine R
f : R â†’+* S
instâœ : IsDomain R
p q : R[X]
hp : Â¬p.degree = âŠ¥
hq : Â¬q.degree = âŠ¥
dp : â„•
hdp : (p ^ 2).degree = 2 â€¢ some dp
hp' : p.degree = some dp
dq : â„•
hdq : (q ^ 2 * (X ^ 3 + C W.aâ‚‚ * X ^ 2 + C W.aâ‚„ * X + C W.aâ‚†)).degree = 2 â€¢ some dq + 3
hdpq : (p * q * (C W.aâ‚ * X + C W.aâ‚ƒ)).degree â‰¤ some dp + some dq + 1
hq' : q.degree = some dq
hpq : dq + 1 < dp
aâœ : (fun x x_1 â†¦ x + x_1) ((fun x x_1 â†¦ x + x_1) dp dq) 1 â‰¥ 2 â€¢ dp
âŠ¢ False
failed
error:  linarith failed to find a contradiction
case h
R : Type u
S : Type v
instâœÂ² : CommRing R
instâœÂ¹ : CommRing S
W : Affine R
f : R â†’+* S
instâœ : IsDomain R
p q : R[X]
hp : Â¬p.degree = âŠ¥
hq : Â¬q.degree = âŠ¥
dp : â„•
hdp : (p ^ 2).degree = 2 â€¢ some dp
hp' : p.degree = some dp
dq : â„•
hdq : (q ^ 2 * (X ^ 3 + C W.aâ‚‚ * X ^ 2 + C W.aâ‚„ * X + C W.aâ‚†)).degree = 2 â€¢ some dq + 3
hdpq : (p * q * (C W.aâ‚ * X + C W.aâ‚ƒ)).degree â‰¤ some dp + some dq + 1
hq' : q.degree = some dq
hpq : dq + 1 < dp
aâœ : (fun x x_1 â†¦ x + x_1) (2 â€¢ dq) â†‘3 â‰¥ 2 â€¢ dp
âŠ¢ False
failed
error:  linarith failed to find a contradiction
case h
R : Type u
S : Type v
instâœÂ² : CommRing R
instâœÂ¹ : CommRing S
W : Affine R
f : R â†’+* S
instâœ : IsDomain R
p q : R[X]
hp : Â¬p.degree = âŠ¥
hq : Â¬q.degree = âŠ¥
dp : â„•
hdp : (p ^ 2).degree = 2 â€¢ some dp
hp' : p.degree = some dp
dq : â„•
hdq : (q ^ 2 * (X ^ 3 + C W.aâ‚‚ * X ^ 2 + C W.aâ‚„ * X + C W.aâ‚†)).degree = 2 â€¢ some dq + 3
hdpq : (p * q * (C W.aâ‚ * X + C W.aâ‚ƒ)).degree â‰¤ some dp + some dq + 1
hq' : q.degree = some dq
hpq : dq + 1 < dp
aâœ : (fun x x_1 â†¦ x + x_1) (2 â€¢ dq) â†‘3 â‰¥ 2 â€¢ dp
âŠ¢ False
failed","lemma degree_norm_smul_basis [IsDomain R] (p q : R[X]) :
    (Algebra.norm R[X] <| p â€¢ (1 : W.CoordinateRing) + q â€¢ mk W Y).degree =
      max (2 â€¢ p.degree) (2 â€¢ q.degree + 3) ",":= by
  have hdp : (p ^ 2).degree = 2 â€¢ p.degree := degree_pow p 2
  have hdpq : (p * q * (C W.aâ‚ * X + C W.aâ‚ƒ)).degree â‰¤ p.degree + q.degree + 1 := by
    simpa only [degree_mul] using add_le_add_left degree_linear_le (p.degree + q.degree)
  have hdq :
      (q ^ 2 * (X ^ 3 + C W.aâ‚‚ * X ^ 2 + C W.aâ‚„ * X + C W.aâ‚†)).degree = 2 â€¢ q.degree + 3 := by
    rw [degree_mul, degree_pow, â† one_mul <| X ^ 3, â† C_1, degree_cubic <| one_ne_zero' R]
  rw [norm_smul_basis]
  by_cases hp : p = 0
  Â· simpa only [hp, hdq, neg_zero, zero_sub, zero_mul, zero_pow two_ne_zero, degree_neg] using
      (max_bot_left _).symm
  Â· by_cases hq : q = 0
    Â· simpa only [hq, hdp, sub_zero, zero_mul, mul_zero, zero_pow two_ne_zero] using
        (max_bot_right _).symm
    Â· rw [â† not_congr degree_eq_bot] at hp hq
      rcases hp' : p.degree with _ | dp 
      Â· exact (hp hp').elim 
      Â· rw [hp'] at hdp hdpq 
        rcases hq' : q.degree with _ | dq 
        Â· exact (hq hq').elim 
        Â· rw [hq'] at hdpq hdq 
          rcases le_or_lt dp (dq + 1) with hpq | hpq
          Â· convert (degree_sub_eq_right_of_degree_lt <| (degree_sub_le _ _).trans_lt <|
                      max_lt_iff.mpr âŸ¨hdp.trans_lt _, hdpq.trans_lt _âŸ©).trans
              (max_eq_right_of_lt _).symm <;> rw [hdq] <;>
                exact WithBot.coe_lt_coe.mpr <| by dsimp; linarith only [hpq]
          Â· rw [sub_sub]
            convert (degree_sub_eq_left_of_degree_lt <| (degree_add_le _ _).trans_lt <|
                      max_lt_iff.mpr âŸ¨hdpq.trans_lt _, hdq.trans_lt _âŸ©).trans
              (max_eq_left_of_lt _).symm <;> rw [hdp] <;>
                exact WithBot.coe_lt_coe.mpr <| by dsimp; linarith only [hpq]"
Mathlib/Algebra/Polynomial/Roots.lean,Polynomial.Monic.irreducible_iff_degree_lt,Monic.irreducible_iff_degree_lt,ede0480e17a20274bfc92c1bb86c545f2389270c,":= by
  simp only [p_monic.irreducible_iff_lt_natDegree_lt p_1, Finset.mem_Ioc, and_imp,
    natDegree_pos_iff_degree_pos, natDegree_le_iff_degree_le]
  constructor
  Â· rintro h q deg_le dvd
    by_contra q_unit
    have := degree_pos_of_not_isUnit_of_dvd_monic q_unit dvd p_monic
    have hu := p_monic.isUnit_leadingCoeff_of_dvd dvd
    refine (h _ (monic_of_isUnit_leadingCoeff_inv_smul hu) ?_ ?_ (dvd_trans ?_ dvd)).elim
    Â· rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    Â· rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    Â· rw [Units.smul_def, Polynomial.smul_eq_C_mul, (isUnit_C.mpr (Units.isUnit _)).mul_left_dvd]
  Â· rintro h q _ deg_pos deg_le dvd
    exact deg_pos.ne' <| degree_eq_zero_of_isUnit (h q deg_le dvd)","error:  application type mismatch
  degree_pos_of_not_isUnit_of_dvd_monic q_unit
argument
  q_unit
has type
  Â¬IsUnit q : Prop
but is expected to have type
  ?m.254336.Monic : Prop","theorem Monic.irreducible_iff_degree_lt {p : R[X]} (p_monic : Monic p) (p_1 : p â‰  1) :
    Irreducible p â†” âˆ€ q, degree q â‰¤ â†‘(p.natDegree / 2) â†’ q âˆ£ p â†’ IsUnit q ",":= by
  simp only [p_monic.irreducible_iff_lt_natDegree_lt p_1, Finset.mem_Ioc, and_imp,
    natDegree_pos_iff_degree_pos, natDegree_le_iff_degree_le]
  constructor
  Â· rintro h q deg_le dvd
    by_contra q_unit
    have := degree_pos_of_not_isUnit_of_dvd_monic p_monic q_unit dvd
    have hu := p_monic.isUnit_leadingCoeff_of_dvd dvd
    refine (h _ (monic_of_isUnit_leadingCoeff_inv_smul hu) ?_ ?_ (dvd_trans ?_ dvd)).elim
    Â· rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    Â· rwa [degree_smul_of_smul_regular _ (isSMulRegular_of_group _)]
    Â· rw [Units.smul_def, Polynomial.smul_eq_C_mul, (isUnit_C.mpr (Units.isUnit _)).mul_left_dvd]
  Â· rintro h q _ deg_pos deg_le dvd
    exact deg_pos.ne' <| degree_eq_zero_of_isUnit (h q deg_le dvd)"
Mathlib/MeasureTheory/Measure/Lebesgue/Basic.lean,Real.volume_preserving_transvectionStruct,volume_preserving_transvectionStruct,4b292e8968c43193b3dbd022dfbc7ddc03b3a7a8,":= by
  let p : Î¹ â†’ Prop := fun i => i â‰  t.i
  let Î± : Type _ := { x // p x }
  let Î² : Type _ := { x // Â¬p x }
  let g : (Î± â†’ â„) â†’ (Î² â†’ â„) â†’ Î² â†’ â„ := fun a b => (fun _ => t.c * a âŸ¨t.j, t.hij.symmâŸ©) + b
  let F : (Î± â†’ â„) Ã— (Î² â†’ â„) â†’ (Î± â†’ â„) Ã— (Î² â†’ â„) := fun p => (id p.1, g p.1 p.2)
  let e : (Î¹ â†’ â„) â‰ƒáµ (Î± â†’ â„) Ã— (Î² â†’ â„) := MeasurableEquiv.piEquivPiSubtypeProd (fun _ : Î¹ => â„) p
  have : (toLin' t.toMatrix : (Î¹ â†’ â„) â†’ Î¹ â†’ â„) = e.symm âˆ˜ F âˆ˜ e := by
    cases t with | mk t_i t_j t_hij t_c =>
    ext f k
    simp only [LinearEquiv.map_smul, dite_eq_ite, LinearMap.id_coe, ite_not,
      Algebra.id.smul_eq_mul, one_mul, dotProduct, stdBasisMatrix,
      MeasurableEquiv.piEquivPiSubtypeProd_symm_apply, id.def, transvection, Pi.add_apply,
      zero_mul, LinearMap.smul_apply, Function.comp_apply,
      MeasurableEquiv.piEquivPiSubtypeProd_apply, Matrix.TransvectionStruct.toMatrix_mk,
      Matrix.mulVec, LinearEquiv.map_add, ite_mul, Matrix.toLin'_apply, Pi.smul_apply,
      Subtype.coe_mk, LinearMap.add_apply, Finset.sum_congr, Matrix.toLin'_one]
    by_cases h : t_i = k
    Â· simp only [h, true_and_iff, Finset.mem_univ, if_true, eq_self_iff_true, Finset.sum_ite_eq,
        one_apply, boole_mul, add_comm]
    Â· simp only [h, Ne.symm h, add_zero, if_false, Finset.sum_const_zero, false_and_iff,
        mul_zero]
  rw [this]
  have A : MeasurePreserving e := by
    convert volume_preserving_piEquivPiSubtypeProd (fun _ : Î¹ => â„) p
  have B : MeasurePreserving F :=
    haveI g_meas : Measurable (Function.uncurry g) := by
      have : Measurable fun c : Î± â†’ â„ => c âŸ¨t.j, t.hij.symmâŸ© :=
        measurable_pi_apply âŸ¨t.j, t.hij.symmâŸ©
      refine Measurable.add ?_ measurable_snd
      refine measurable_pi_lambda _ fun _ => Measurable.const_mul ?_ _
      exact this.comp measurable_fst
    (MeasurePreserving.id _).skew_product g_meas
      (eventually_of_forall fun a => map_add_left_eq_self
        (Measure.pi fun _ => (stdOrthonormalBasis â„ â„).toBasis.addHaar) _)
  exact ((A.symm e).comp B).comp A","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.142828 â†’ ?m.142828
error:  unsolved goals
case pos
Î¹ : Type u_1
instâœÂ¹ : Fintype Î¹
instâœ : DecidableEq Î¹
t_i t_j : Î¹
t_hij : t_i â‰  t_j
t_c : â„
p : Î¹ â†’ Prop := fun i â†¦ i â‰  { i := t_i, j := t_j, hij := t_hij, c := t_c }.i
Î± : Type u_1 := { x // p x }
Î² : Type u_1 := { x // Â¬p x }
g : (Î± â†’ â„) â†’ (Î² â†’ â„) â†’ Î² â†’ â„ :=
  fun a b â†¦
    (fun x â†¦
        { i := t_i, j := t_j, hij := t_hij, c := t_c }.c * a âŸ¨{ i := t_i, j := t_j, hij := t_hij, c := t_c }.j, â‹¯âŸ©) +
      b
F : (Î± â†’ â„) Ã— (Î² â†’ â„) â†’ (Î± â†’ â„) Ã— (Î² â†’ â„) := fun p â†¦ (id p.1, g p.1 p.2)
e : (Î¹ â†’ â„) â‰ƒáµ (Î± â†’ â„) Ã— (Î² â†’ â„) := MeasurableEquiv.piEquivPiSubtypeProd (fun x â†¦ â„) p
f : Î¹ â†’ â„
k : Î¹
h : t_i = k
âŠ¢ t_c * f t_j + id f k = e.symm (F (e f)) k
error:  unsolved goals
case neg
Î¹ : Type u_1
instâœÂ¹ : Fintype Î¹
instâœ : DecidableEq Î¹
t_i t_j : Î¹
t_hij : t_i â‰  t_j
t_c : â„
p : Î¹ â†’ Prop := fun i â†¦ i â‰  { i := t_i, j := t_j, hij := t_hij, c := t_c }.i
Î± : Type u_1 := { x // p x }
Î² : Type u_1 := { x // Â¬p x }
g : (Î± â†’ â„) â†’ (Î² â†’ â„) â†’ Î² â†’ â„ :=
  fun a b â†¦
    (fun x â†¦
        { i := t_i, j := t_j, hij := t_hij, c := t_c }.c * a âŸ¨{ i := t_i, j := t_j, hij := t_hij, c := t_c }.j, â‹¯âŸ©) +
      b
F : (Î± â†’ â„) Ã— (Î² â†’ â„) â†’ (Î± â†’ â„) Ã— (Î² â†’ â„) := fun p â†¦ (id p.1, g p.1 p.2)
e : (Î¹ â†’ â„) â‰ƒáµ (Î± â†’ â„) Ã— (Î² â†’ â„) := MeasurableEquiv.piEquivPiSubtypeProd (fun x â†¦ â„) p
f : Î¹ â†’ â„
k : Î¹
h : Â¬t_i = k
âŠ¢ id f k = e.symm (F (e f)) k","theorem volume_preserving_transvectionStruct [DecidableEq Î¹] (t : TransvectionStruct Î¹ â„) :
    MeasurePreserving (toLin' t.toMatrix) ",":= by
  have ht : Measurable (toLin' t.toMatrix) :=
    (toLin' t.toMatrix).continuous_of_finiteDimensional.measurable
  refine âŸ¨ht, ?_âŸ©
  refine (pi_eq fun s hs â†¦ ?_).symm
  have h2s : MeasurableSet (univ.pi s) := .pi countable_univ fun i _ â†¦ hs i
  simp_rw [â† pi_pi, â† lintegral_indicator_one h2s]
  rw [lintegral_map (measurable_one.indicator h2s) ht, volume_pi]
  refine lintegral_eq_of_lmarginal_eq {t.i} ((measurable_one.indicator h2s).comp ht)
    (measurable_one.indicator h2s) ?_
  simp_rw [lmarginal_singleton]
  ext x
  cases t with | mk t_i t_j t_hij t_c =>
  simp [transvection, mulVec_stdBasisMatrix, t_hij.symm, â† Function.update_add,
    lintegral_add_right_eq_self fun xáµ¢ â†¦ indicator (univ.pi s) 1 (Function.update x t_i xáµ¢)]"
Mathlib/Algebra/Module/Defs.lean,nsmul_eq_smul_cast,nsmul_eq_smul_cast,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' n with n ih
  Â· rw [Nat.zero_eq, Nat.cast_zero, zero_smul, zero_smul]
  Â· rw [Nat.succ_eq_add_one, Nat.cast_succ, add_smul, add_smul, one_smul, ih, one_smul]","warning:  `bit0` has been deprecated
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
case zero
Î± : Type u_1
R : Type u_2
k : Type u_3
S : Type u_4
M : Type u_5
Mâ‚‚ : Type u_6
Mâ‚ƒ : Type u_7
Î¹ : Type u_8
instâœÂ² : Semiring R
instâœÂ¹ : AddCommMonoid M
instâœ : Module R M
b : M
âŠ¢ 0 â€¢ b = â†‘0 â€¢ b
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ
Î± : Type u_1
R : Type u_2
k : Type u_3
S : Type u_4
M : Type u_5
Mâ‚‚ : Type u_6
Mâ‚ƒ : Type u_7
Î¹ : Type u_8
instâœÂ² : Semiring R
instâœÂ¹ : AddCommMonoid M
instâœ : Module R M
b : M
n : â„•
ih : n â€¢ b = â†‘n â€¢ b
âŠ¢ (n + 1) â€¢ b = â†‘(n + 1) â€¢ b",theorem nsmul_eq_smul_cast (n : â„•) (b : M) : n â€¢ b = (n : R) â€¢ b ,":= by
  induction' n with n ih
  Â· rw [Nat.cast_zero, zero_smul, zero_smul]
  Â· rw [Nat.cast_succ, add_smul, add_smul, one_smul, ih, one_smul]"
Mathlib/CategoryTheory/Preadditive/Yoneda/Injective.lean,CategoryTheory.Injective.injective_iff_preservesEpimorphisms_preadditiveYoneda_obj,injective_iff_preservesEpimorphisms_preadditiveYoneda_obj,bad931b7fc9f31f5ff5b8f408dd19bbe20a9f0e1,":= by
  rw [injective_iff_preservesEpimorphisms_yoneda_obj]
  refine
    âŸ¨fun h : (preadditiveYoneda.obj J â‹™ (forget AddCommGroupCat)).PreservesEpimorphisms => ?_, ?_âŸ©
  Â· exact
      Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveYoneda.obj J) (forget _)
  Â· intro
    exact (inferInstance : (preadditiveYoneda.obj J â‹™ forget _).PreservesEpimorphisms)","error:  unknown identifier 'AddCommGroupCat'
error:  failed to synthesize
  (preadditiveYoneda.obj J â‹™ forget AddCommGrp).PreservesEpimorphisms
use `set_option diagnostics true` to get diagnostic information
error:  no goals to be solved","theorem injective_iff_preservesEpimorphisms_preadditiveYoneda_obj (J : C) :
    Injective J â†” (preadditiveYoneda.obj J).PreservesEpimorphisms ",":= by
  rw [injective_iff_preservesEpimorphisms_yoneda_obj]
  refine
    âŸ¨fun h : (preadditiveYoneda.obj J â‹™ (forget AddCommGrp)).PreservesEpimorphisms => ?_, ?_âŸ©
  Â· exact
      Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveYoneda.obj J) (forget _)
  Â· intro
    exact (inferInstance : (preadditiveYoneda.obj J â‹™ forget _).PreservesEpimorphisms)"
Mathlib/LinearAlgebra/Matrix/Transvection.lean,Matrix.Pivot.listTransvecCol_mul_last_col,listTransvecCol_mul_last_col,9f4034ab38e4815706a7d12c61d5e009e2c84ba9,":= by
  suffices H :
    âˆ€ k : â„•,
      k â‰¤ r â†’
        (((listTransvecCol M).drop k).prod * M) (inl i) (inr unit) =
          if k â‰¤ i then 0 else M (inl i) (inr unit) by
    simpa only [List.drop, _root_.zero_le, ite_true] using H 0 (zero_le _)
  intro k hk
  refine' Nat.decreasingInduction' _ hk _
  Â· intro n hn hk IH
    have hn' : n < (listTransvecCol M).length := by simpa [listTransvecCol] using hn
    let n' : Fin r := âŸ¨n, hnâŸ©
    rw [â† @List.cons_get_drop_succ _ _ âŸ¨n, hn'âŸ©]
    have A :
      (listTransvecCol M).get âŸ¨n, hn'âŸ© =
        transvection (inl n') (inr unit) (-M (inl n') (inr unit) / M (inr unit) (inr unit)) :=
      by simp [listTransvecCol]
    simp only [Matrix.mul_assoc, A, List.prod_cons]
    by_cases h : n' = i
    Â· have hni : n = i := by
        cases i
        simp only [Fin.mk_eq_mk] at h
        simp [h]
      simp only [h, transvection_mul_apply_same, IH, â† hni, add_le_iff_nonpos_right,
          listTransvecCol_mul_last_row_drop _ _ hn]
      field_simp [hM]
    Â· have hni : n â‰  i := by
        rintro rfl
        cases i
        simp at h
      simp only [ne_eq, inl.injEq, Ne.symm h, not_false_eq_true, transvection_mul_apply_of_ne]
      rw [IH]
      rcases le_or_lt (n + 1) i with (hi | hi)
      Â· simp only [hi, n.le_succ.trans hi, if_true]
      Â· rw [if_neg, if_neg]
        Â· simpa only [hni.symm, not_le, or_false_iff] using Nat.lt_succ_iff_lt_or_eq.1 hi
        Â· simpa only [not_le] using hi
  Â· simp only [listTransvecCol, List.length_ofFn, le_refl, List.drop_eq_nil_of_le, List.prod_nil,
      Matrix.one_mul]
    rw [if_neg]
    simpa only [not_le] using i.2",error:  simp made no progress,"theorem listTransvecCol_mul_last_col (hM : M (inr unit) (inr unit) â‰  0) (i : Fin r) :
    ((listTransvecCol M).prod * M) (inl i) (inr unit) = 0 ",":= by
  suffices H :
    âˆ€ k : â„•,
      k â‰¤ r â†’
        (((listTransvecCol M).drop k).prod * M) (inl i) (inr unit) =
          if k â‰¤ i then 0 else M (inl i) (inr unit) by
    simpa only [List.drop, _root_.zero_le, ite_true] using H 0 (zero_le _)
  intro k hk
  refine Nat.decreasingInduction' ?_ hk ?_
  Â· intro n hn hk IH
    have hn' : n < (listTransvecCol M).length := by simpa [listTransvecCol] using hn
    let n' : Fin r := âŸ¨n, hnâŸ©
    rw [List.drop_eq_getElem_cons hn']
    have A :
      (listTransvecCol M)[n] =
        transvection (inl n') (inr unit) (-M (inl n') (inr unit) / M (inr unit) (inr unit)) := by
      simp [listTransvecCol]
    simp only [Matrix.mul_assoc, A, List.prod_cons]
    by_cases h : n' = i
    Â· have hni : n = i := by
        cases i
        simp only [n', Fin.mk_eq_mk] at h
        simp [h]
      simp only [h, transvection_mul_apply_same, IH, â† hni, add_le_iff_nonpos_right,
          listTransvecCol_mul_last_row_drop _ _ hn]
      field_simp [hM]
    Â· have hni : n â‰  i := by
        rintro rfl
        cases i
        simp at h
      simp only [ne_eq, inl.injEq, Ne.symm h, not_false_eq_true, transvection_mul_apply_of_ne]
      rw [IH]
      rcases le_or_lt (n + 1) i with (hi | hi)
      Â· simp only [hi, n.le_succ.trans hi, if_true]
      Â· rw [if_neg, if_neg]
        Â· simpa only [hni.symm, not_le, or_false_iff] using Nat.lt_succ_iff_lt_or_eq.1 hi
        Â· simpa only [not_le] using hi
  Â· simp only [listTransvecCol, List.length_ofFn, le_refl, List.drop_eq_nil_of_le, List.prod_nil,
      Matrix.one_mul]
    rw [if_neg]
    simpa only [not_le] using i.2"
Mathlib/RingTheory/FiniteType.lean,AlgHom.FiniteType.comp,comp,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  letI : SMul A B := f.toSMul
  letI : Algebra A B := f.toAlgebra
  letI : SMul A C := (g.comp f).toSMul
  letI : Algebra A C := (g.comp f).toAlgebra
  exact Algebra.FiniteType.of_surjective hf
    { g with
      toFun := g
      commutes' := fun a => rfl }
    hg","error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  f
has type
  A â†’+* B
error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  g.comp f
has type
  A â†’+* C","theorem comp_surjective {f : A â†’+* B} {g : B â†’+* C} (hf : f.FiniteType) (hg : Surjective g) :
    (g.comp f).FiniteType ",":= by
  let _ : Algebra A B := f.toAlgebra
  let _ : Algebra A C := (g.comp f).toAlgebra
  exact Algebra.FiniteType.of_surjective hf
    { g with
      toFun := g
      commutes' := fun a => rfl }
    hg"
Mathlib/Data/List/OfFn.lean,List.get?_ofFn,get?_ofFn,5068808d2b4c25cf905cf7fee10ded8e447c2346,":=
  if h : i < (ofFn f).length
  then by
    rw [get?_eq_get h, get_ofFn]
    . simp at h; simp [ofFnNthVal, h]
  else by
    rw [ofFnNthVal, dif_neg] <;>
    simpa using h","error:  type mismatch
  hâœ
has type
  n â‰¤ i : Prop
but is expected to have type
  ofFnNthVal f i = none : Prop
error:  unsolved goals
Î± : Type u
n : â„•
f : Fin n â†’ Î±
i : â„•
h : Â¬i < (ofFn f).length
âŠ¢ (ofFn f).get? i = none
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_ofFn` has been deprecated, use `List.get_ofFn` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead",theorem get?_ofFn {n} (f : Fin n â†’ Î±) (i) : get? (ofFn f) i = ofFnNthVal f i ,":= by
  simp"
Mathlib/Order/BooleanGenerators.lean,IsCompactlyGenerated.BooleanGenerators.mono,mono,569eedc47d978b2b327a361cd2e6ebd058c0c061,"  isAtom I hI := hS.isAtom I (hTS hI)
  setIndependent := hS.setIndependent.mono hTS
  finitelyAtomistic := fun s a hs â†¦ hS.finitelyAtomistic s a (le_trans hs hTS)","error:  'setIndependent' is not a field of structure 'IsCompactlyGenerated.BooleanGenerators'
error:  invalid field notation, function 'IsCompactlyGenerated.BooleanGenerators.mono' does not have argument with type (IsCompactlyGenerated.BooleanGenerators ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'IsCompactlyGenerated.BooleanGenerators.mono' does not have argument with type (IsCompactlyGenerated.BooleanGenerators ...) that can be used, it must be explicit or implicit with a unique name
error:  invalid field notation, function 'IsCompactlyGenerated.BooleanGenerators.mono' does not have argument with type (IsCompactlyGenerated.BooleanGenerators ...) that can be used, it must be explicit or implicit with a unique name","lemma mono {T : Set Î±} (hTS : T âŠ† S) : BooleanGenerators T where
","  isAtom I hI := hS.isAtom I (hTS hI)
  finitelyAtomistic := fun s a hs â†¦ hS.finitelyAtomistic s a (le_trans hs hTS)"
Mathlib/Analysis/Calculus/MeanValue.lean,Convex.exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt_of_nnnorm_lt,exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt_of_nnnorm_lt,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  obtain âŸ¨Îµ, Îµ0, hÎµâŸ© : âˆƒ Îµ > 0, ball x Îµ âˆ© s âŠ† { y | HasFDerivWithinAt f (f' y) s y âˆ§ â€–f' yâ€–â‚Š < K }
  exact mem_nhdsWithin_iff.1 (hder.and <| hcont.nnnorm.eventually (gt_mem_nhds hK))
  rw [inter_comm] at hÎµ
  refine' âŸ¨s âˆ© ball x Îµ, inter_mem_nhdsWithin _ (ball_mem_nhds _ Îµ0), _âŸ©
  exact
    (hs.inter (convex_ball _ _)).lipschitzOnWith_of_nnnorm_hasFDerivWithin_le
      (fun y hy => (hÎµ hy).1.mono (inter_subset_left _ _)) fun y hy => (hÎµ hy).2.le","error:  function expected at
  inter_subset_left ?m.109832
term has type
  ?m.109831 âˆˆ ?m.109829","theorem exists_nhdsWithin_lipschitzOnWith_of_hasFDerivWithinAt_of_nnnorm_lt (hs : Convex â„ s)
    {f : E â†’ G} (hder : âˆ€á¶  y in ğ“[s] x, HasFDerivWithinAt f (f' y) s y)
    (hcont : ContinuousWithinAt f' s x) (K : â„â‰¥0) (hK : â€–f' xâ€–â‚Š < K) :
    âˆƒ t âˆˆ ğ“[s] x, LipschitzOnWith K f t ",":= by
  obtain âŸ¨Îµ, Îµ0, hÎµâŸ© : âˆƒ Îµ > 0,
      ball x Îµ âˆ© s âŠ† { y | HasFDerivWithinAt f (f' y) s y âˆ§ â€–f' yâ€–â‚Š < K } :=
    mem_nhdsWithin_iff.1 (hder.and <| hcont.nnnorm.eventually (gt_mem_nhds hK))
  rw [inter_comm] at hÎµ
  refine âŸ¨s âˆ© ball x Îµ, inter_mem_nhdsWithin _ (ball_mem_nhds _ Îµ0), ?_âŸ©
  exact
    (hs.inter (convex_ball _ _)).lipschitzOnWith_of_nnnorm_hasFDerivWithin_le
      (fun y hy => (hÎµ hy).1.mono inter_subset_left) fun y hy => (hÎµ hy).2.le"
Mathlib/Algebra/Polynomial/Basic.lean,Polynomial.monomial_mul_X_pow,monomial_mul_X_pow,0c824fb54f74f0c66db893166b73e377be2feb6f,":= by
  induction' k with k ih
  Â· simp
  Â· simp [ih, pow_succ, â† mul_assoc, Nat.succ_eq_add_one]","warning:  Polynomial does not have a doc string
error:  unsolved goals
case succ
R : Type u
a b : R
m nâœ : â„•
instâœ : Semiring R
p q : R[X]
n : â„•
r : R
k : â„•
ih : (monomial n) r * X ^ k = (monomial (n + k)) r
âŠ¢ (monomial (n + k + 1)) r = (monomial (n + (k + 1))) r","theorem monomial_mul_X_pow (n : â„•) (r : R) (k : â„•) :
    monomial n r * X ^ k = monomial (n + k) r ",":= by
  induction' k with k ih
  Â· simp
  Â· simp [ih, pow_succ, â† mul_assoc, add_assoc]"
Mathlib/Analysis/Convex/Cone/Proper.lean,ProperCone.hyperplane_separation,hyperplane_separation,e9a39a32b654a1485acbad2fc16ec13a695fbc99,":=
  Iff.intro
    (by
      simp_rw [mem_map, PointedCone.mem_closure, PointedCone.coe_map, coe_coe,
        mem_closure_iff_seq_limit, mem_image, SetLike.mem_coe, mem_coe, mem_dual,
        adjoint_inner_right, forall_exists_index, and_imp]
      rintro seq hmem htends y hinner
      suffices h : âˆ€ n, 0 â‰¤ âŸªy, seq nâŸ«_â„ from
        ge_of_tendsto'
          (Continuous.seqContinuous (Continuous.inner (@continuous_const _ _ _ _ y) continuous_id)
            htends)
          h
      intro n
      obtain âŸ¨_, h, hseqâŸ© := hmem n
      simpa only [â† hseq, real_inner_comm] using hinner h)
    (by
      intro h
      contrapose! h
      let C := @PointedCone.toConvexCone â„ F _ _ _ (K.map f)
      obtain âŸ¨y, hxy, hybâŸ© :=
        @ConvexCone.hyperplane_separation_of_nonempty_of_isClosed_of_nmem
        _ _ _ _ C (K.map f).nonempty (K.map f).isClosed b h
      refine' âŸ¨y, _, hybâŸ©
      simp_rw [ProperCone.mem_dual, adjoint_inner_right]
      intro x hxK
      apply hxy (f x)
      simp_rw [coe_map]
      apply subset_closure
      simp_rw [PointedCone.toConvexCone_map, ConvexCone.coe_map, coe_coe, mem_image,
        SetLike.mem_coe]
      exact âŸ¨x, hxK, rflâŸ©)",error:  simp made no progress,"theorem hyperplane_separation (K : ProperCone â„ E) {f : E â†’L[â„] F} {b : F} :
    b âˆˆ K.map f â†” âˆ€ y : F, adjoint f y âˆˆ K.dual â†’ 0 â‰¤ âŸªy, bâŸ«_â„ ",":=
  Iff.intro
    (by
      simp_rw [mem_map, PointedCone.mem_closure, PointedCone.coe_map, coe_coe,
        mem_closure_iff_seq_limit, mem_image, SetLike.mem_coe, mem_coe, mem_dual,
        adjoint_inner_right, forall_exists_index, and_imp]
      rintro seq hmem htends y hinner
      suffices h : âˆ€ n, 0 â‰¤ âŸªy, seq nâŸ«_â„ from
        ge_of_tendsto'
          (Continuous.seqContinuous (Continuous.inner (@continuous_const _ _ _ _ y) continuous_id)
            htends)
          h
      intro n
      obtain âŸ¨_, h, hseqâŸ© := hmem n
      simpa only [â† hseq, real_inner_comm] using hinner h)
    (by
      intro h
      contrapose! h
      let C := @PointedCone.toConvexCone â„ F _ _ _ (K.map f)
      obtain âŸ¨y, hxy, hybâŸ© :=
        @ConvexCone.hyperplane_separation_of_nonempty_of_isClosed_of_nmem
        _ _ _ _ C (K.map f).nonempty (K.map f).isClosed b h
      refine âŸ¨y, ?_, hybâŸ©
      simp_rw [ProperCone.mem_dual, adjoint_inner_right]
      intro x hxK
      apply hxy (f x)
      simp_rw [C, coe_map]
      apply subset_closure
      simp_rw [PointedCone.toConvexCone_map, ConvexCone.coe_map, coe_coe, mem_image,
        SetLike.mem_coe]
      exact âŸ¨x, hxK, rflâŸ©)"
Mathlib/MeasureTheory/Integral/Average.lean,MeasureTheory.measure_le_setAverage_pos,measure_le_setAverage_pos,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  refine pos_iff_ne_zero.2 fun H => ?_
  replace H : (Î¼.restrict s) {x | f x â‰¤ â¨ a in s, f a âˆ‚Î¼} = 0 := by
    rwa [restrict_applyâ‚€, inter_comm]
    exact AEStronglyMeasurable.nullMeasurableSet_le hf.1 aestronglyMeasurable_const
  haveI := Fact.mk hÎ¼â‚.lt_top
  refine (integral_sub_average (Î¼.restrict s) f).not_gt ?_
  refine (setIntegral_pos_iff_support_of_nonneg_ae ?_ ?_).?2 _
  Â· refine measure_mono_null (fun x hx â†¦ ?_) H
    simp only [Pi.zero_apply, sub_nonneg, mem_compl_iff, mem_setOf_eq, not_le] at hx
    exact hx.le
  Â· exact hf.sub (integrableOn_const.2 <| Or.inr <| lt_top_iff_ne_top.2 hÎ¼â‚)
  Â· rwa [pos_iff_ne_zero, inter_comm, â† diff_compl, â† diff_inter_self_eq_diff, measure_diff_null]
    refine measure_mono_null ?_ (measure_inter_eq_zero_of_restrict H)
    exact inter_subset_inter_left _ fun a ha => (sub_eq_zero.1 <| of_not_not ha).le","error:  invalid field notation, identifier or numeral expected
error:  unexpected token '?'; expected 'binder_predicate'","theorem measure_le_setAverage_pos (hÎ¼ : Î¼ s â‰  0) (hÎ¼â‚ : Î¼ s â‰  âˆ) (hf : IntegrableOn f s Î¼) :
    0 < Î¼ ({x âˆˆ s | f x â‰¤ â¨ a in s, f a âˆ‚Î¼}) ",":= by
  refine pos_iff_ne_zero.2 fun H => ?_
  replace H : (Î¼.restrict s) {x | f x â‰¤ â¨ a in s, f a âˆ‚Î¼} = 0 := by
    rwa [restrict_applyâ‚€, inter_comm]
    exact AEStronglyMeasurable.nullMeasurableSet_le hf.1 aestronglyMeasurable_const
  haveI := Fact.mk hÎ¼â‚.lt_top
  refine (integral_sub_average (Î¼.restrict s) f).not_gt ?_
  refine (setIntegral_pos_iff_support_of_nonneg_ae ?_ ?_).2 ?_
  Â· refine measure_mono_null (fun x hx â†¦ ?_) H
    simp only [Pi.zero_apply, sub_nonneg, mem_compl_iff, mem_setOf_eq, not_le] at hx
    exact hx.le
  Â· exact hf.sub (integrableOn_const.2 <| Or.inr <| lt_top_iff_ne_top.2 hÎ¼â‚)
  Â· rwa [pos_iff_ne_zero, inter_comm, â† diff_compl, â† diff_inter_self_eq_diff, measure_diff_null]
    refine measure_mono_null ?_ (measure_inter_eq_zero_of_restrict H)
    exact inter_subset_inter_left _ fun a ha => (sub_eq_zero.1 <| of_not_not ha).le"
Mathlib/RingTheory/IntegralRestrict.lean,Algebra.intTrace_eq_of_isLocalization,Algebra.intTrace_eq_of_isLocalization,25527279cf0fc38a336bb3b3d913a403b5f38ac1,":= by
  by_cases hM : 0 âˆˆ M
  Â· subsingleton [IsLocalization.uniqueOfZeroMem (S := Aâ‚˜) hM]
  replace hM : M â‰¤ Aâ° := fun x hx â†¦ mem_nonZeroDivisors_iff_ne_zero.mpr (fun e â†¦ hM (e â–¸ hx))
  let K := FractionRing A
  let L := FractionRing B
  have : IsIntegralClosure B A L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsLocalization (algebraMapSubmonoid B Aâ°) L :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  let f : Aâ‚˜ â†’+* K := IsLocalization.map _ (T := Aâ°) (RingHom.id A) hM
  letI := f.toAlgebra
  have : IsScalarTower A Aâ‚˜ K := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aâ‚˜ K
  let g : Bâ‚˜ â†’+* L := IsLocalization.map _
      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B Aâ°)
      (RingHom.id B) (Submonoid.monotone_map hM)
  letI := g.toAlgebra
  have : IsScalarTower B Bâ‚˜ L := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := ((algebraMap K L).comp f).toAlgebra
  have : IsScalarTower Aâ‚˜ K L := IsScalarTower.of_algebraMap_eq' rfl
  have : IsScalarTower Aâ‚˜ Bâ‚˜ L := by
    apply IsScalarTower.of_algebraMap_eq'
    apply IsLocalization.ringHom_ext M
    rw [RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra (R := Bâ‚˜), RingHom.comp_assoc,
      RingHom.comp_assoc, â† IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq A B Bâ‚˜,
      IsLocalization.map_comp, RingHom.comp_id, â† RingHom.comp_assoc, IsLocalization.map_comp,
      RingHom.comp_id, â† IsScalarTower.algebraMap_eq, â† IsScalarTower.algebraMap_eq]
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization
    (algebraMapSubmonoid B M) Bâ‚˜ L
  have : FiniteDimensional K L := Module.Finite_of_isLocalization A B _ _ Aâ°
  have : IsIntegralClosure Bâ‚˜ Aâ‚˜ L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  apply IsFractionRing.injective Aâ‚˜ K
  rw [â† IsScalarTower.algebraMap_apply, Algebra.algebraMap_intTrace_fractionRing,
    Algebra.algebraMap_intTrace (L := L), â† IsScalarTower.algebraMap_apply]","error:  unknown tactic
error:  unsolved goals
case pos
A : Type u_1
K : Type u_2
L : Type u_3
B : Type u_4
instâœÂ³âµ : CommRing A
instâœÂ³â´ : CommRing B
instâœÂ³Â³ : Algebra A B
instâœÂ³Â² : Field K
instâœÂ³Â¹ : Field L
instâœÂ³â° : Algebra A K
instâœÂ²â¹ : IsFractionRing A K
instâœÂ²â¸ : Algebra B L
instâœÂ²â· : Algebra K L
instâœÂ²â¶ : Algebra A L
instâœÂ²âµ : IsScalarTower A B L
instâœÂ²â´ : IsScalarTower A K L
instâœÂ²Â³ : IsIntegralClosure B A L
instâœÂ²Â² : FiniteDimensional K L
Aâ‚˜ : Type u_5
Bâ‚˜ : Type u_6
instâœÂ²Â¹ : CommRing Aâ‚˜
instâœÂ²â° : CommRing Bâ‚˜
instâœÂ¹â¹ : Algebra Aâ‚˜ Bâ‚˜
instâœÂ¹â¸ : Algebra A Aâ‚˜
instâœÂ¹â· : Algebra B Bâ‚˜
instâœÂ¹â¶ : Algebra A Bâ‚˜
instâœÂ¹âµ : IsScalarTower A Aâ‚˜ Bâ‚˜
instâœÂ¹â´ : IsScalarTower A B Bâ‚˜
M : Submonoid A
instâœÂ¹Â³ : IsLocalization M Aâ‚˜
instâœÂ¹Â² : IsLocalization (algebraMapSubmonoid B M) Bâ‚˜
instâœÂ¹Â¹ : IsDomain A
instâœÂ¹â° : IsIntegrallyClosed A
instâœâ¹ : IsDomain B
instâœâ¸ : IsIntegrallyClosed B
instâœâ· : Module.Finite A B
instâœâ¶ : NoZeroSMulDivisors A B
instâœâµ : IsDomain Aâ‚˜
instâœâ´ : IsIntegrallyClosed Aâ‚˜
instâœÂ³ : IsDomain Bâ‚˜
instâœÂ² : IsIntegrallyClosed Bâ‚˜
instâœÂ¹ : NoZeroSMulDivisors Aâ‚˜ Bâ‚˜
instâœ : Module.Finite Aâ‚˜ Bâ‚˜
x : B
hM : 0 âˆˆ M
âŠ¢ (algebraMap A Aâ‚˜) ((intTrace A B) x) = (intTrace Aâ‚˜ Bâ‚˜) ((algebraMap B Bâ‚˜) x)
error:  unsolved goals
case neg
A : Type u_1
K : Type u_2
L : Type u_3
B : Type u_4
instâœÂ³âµ : CommRing A
instâœÂ³â´ : CommRing B
instâœÂ³Â³ : Algebra A B
instâœÂ³Â² : Field K
instâœÂ³Â¹ : Field L
instâœÂ³â° : Algebra A K
instâœÂ²â¹ : IsFractionRing A K
instâœÂ²â¸ : Algebra B L
instâœÂ²â· : Algebra K L
instâœÂ²â¶ : Algebra A L
instâœÂ²âµ : IsScalarTower A B L
instâœÂ²â´ : IsScalarTower A K L
instâœÂ²Â³ : IsIntegralClosure B A L
instâœÂ²Â² : FiniteDimensional K L
Aâ‚˜ : Type u_5
Bâ‚˜ : Type u_6
instâœÂ²Â¹ : CommRing Aâ‚˜
instâœÂ²â° : CommRing Bâ‚˜
instâœÂ¹â¹ : Algebra Aâ‚˜ Bâ‚˜
instâœÂ¹â¸ : Algebra A Aâ‚˜
instâœÂ¹â· : Algebra B Bâ‚˜
instâœÂ¹â¶ : Algebra A Bâ‚˜
instâœÂ¹âµ : IsScalarTower A Aâ‚˜ Bâ‚˜
instâœÂ¹â´ : IsScalarTower A B Bâ‚˜
M : Submonoid A
instâœÂ¹Â³ : IsLocalization M Aâ‚˜
instâœÂ¹Â² : IsLocalization (algebraMapSubmonoid B M) Bâ‚˜
instâœÂ¹Â¹ : IsDomain A
instâœÂ¹â° : IsIntegrallyClosed A
instâœâ¹ : IsDomain B
instâœâ¸ : IsIntegrallyClosed B
instâœâ· : Module.Finite A B
instâœâ¶ : NoZeroSMulDivisors A B
instâœâµ : IsDomain Aâ‚˜
instâœâ´ : IsIntegrallyClosed Aâ‚˜
instâœÂ³ : IsDomain Bâ‚˜
instâœÂ² : IsIntegrallyClosed Bâ‚˜
instâœÂ¹ : NoZeroSMulDivisors Aâ‚˜ Bâ‚˜
instâœ : Module.Finite Aâ‚˜ Bâ‚˜
x : B
hM : 0 âˆ‰ M
âŠ¢ (algebraMap A Aâ‚˜) ((intTrace A B) x) = (intTrace Aâ‚˜ Bâ‚˜) ((algebraMap B Bâ‚˜) x)","lemma Algebra.intTrace_eq_of_isLocalization
    (x : B) :
    algebraMap A Aâ‚˜ (Algebra.intTrace A B x) = Algebra.intTrace Aâ‚˜ Bâ‚˜ (algebraMap B Bâ‚˜ x) ",":= by
  by_cases hM : 0 âˆˆ M
  Â· have := IsLocalization.uniqueOfZeroMem (S := Aâ‚˜) hM
    exact Subsingleton.elim _ _
  replace hM : M â‰¤ Aâ° := fun x hx â†¦ mem_nonZeroDivisors_iff_ne_zero.mpr (fun e â†¦ hM (e â–¸ hx))
  let K := FractionRing A
  let L := FractionRing B
  have : IsIntegralClosure B A L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  have : IsLocalization (algebraMapSubmonoid B Aâ°) L :=
    IsIntegralClosure.isLocalization _ (FractionRing A) _ _
  let f : Aâ‚˜ â†’+* K := IsLocalization.map _ (T := Aâ°) (RingHom.id A) hM
  letI := f.toAlgebra
  have : IsScalarTower A Aâ‚˜ K := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M Aâ‚˜ K
  let g : Bâ‚˜ â†’+* L := IsLocalization.map _
      (M := algebraMapSubmonoid B M) (T := algebraMapSubmonoid B Aâ°)
      (RingHom.id B) (Submonoid.monotone_map hM)
  letI := g.toAlgebra
  have : IsScalarTower B Bâ‚˜ L := IsScalarTower.of_algebraMap_eq'
    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])
  letI := ((algebraMap K L).comp f).toAlgebra
  have : IsScalarTower Aâ‚˜ K L := IsScalarTower.of_algebraMap_eq' rfl
  have : IsScalarTower Aâ‚˜ Bâ‚˜ L := by
    apply IsScalarTower.of_algebraMap_eq'
    apply IsLocalization.ringHom_ext M
    rw [RingHom.algebraMap_toAlgebra, RingHom.algebraMap_toAlgebra (R := Bâ‚˜), RingHom.comp_assoc,
      RingHom.comp_assoc, â† IsScalarTower.algebraMap_eq, IsScalarTower.algebraMap_eq A B Bâ‚˜,
      IsLocalization.map_comp, RingHom.comp_id, â† RingHom.comp_assoc, IsLocalization.map_comp,
      RingHom.comp_id, â† IsScalarTower.algebraMap_eq, â† IsScalarTower.algebraMap_eq]
  letI := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization
    (algebraMapSubmonoid B M) Bâ‚˜ L
  have : FiniteDimensional K L := Module.Finite_of_isLocalization A B _ _ Aâ°
  have : IsIntegralClosure Bâ‚˜ Aâ‚˜ L :=
    IsIntegralClosure.of_isIntegrallyClosed _ _ _
  apply IsFractionRing.injective Aâ‚˜ K
  rw [â† IsScalarTower.algebraMap_apply, Algebra.algebraMap_intTrace_fractionRing,
    Algebra.algebraMap_intTrace (L := L), â† IsScalarTower.algebraMap_apply]"
Mathlib/Topology/Order/ScottTopology.lean,Topology.IsScott.lowerClosure_subset_closure,lowerClosure_subset_closure,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  convert closure.mono (@upperSet_le_scott Î± _)
  Â· rw [@IsUpperSet.closure_eq_lowerClosure Î± _ (upperSet Î±) ?_ s]
    exact instIsUpperSetUpperSet
  Â· exact topology_eq Î±",error:  unknown identifier 'instIsUpperSetUpperSet',lemma lowerClosure_subset_closure : â†‘(lowerClosure s) âŠ† closure s ,":= by
  convert closure.mono (@upperSet_le_scott Î± _)
  Â· rw [@IsUpperSet.closure_eq_lowerClosure Î± _ (upperSet Î±) ?_ s]
    infer_instance
  Â· exact topology_eq Î±"
Mathlib/Algebra/Order/BigOperators/Group/Finset.lean,Fintype.prod_eq_one_iff_of_le_one,prod_eq_one_iff_of_le_one,86c762d1ca57ea625eb76415b5e2df14780ea4c3,":=
  @prod_eq_one_iff_of_one_le' _ Náµ’áµˆ _ _ _ _","error:  type mismatch
  prod_eq_one_iff_of_one_le' ?m.29846
has type
  âˆ i âˆˆ ?m.29845, ?m.29844 i = 1 â†” âˆ€ i âˆˆ ?m.29845, ?m.29844 i = 1 : Prop
but is expected to have type
  (âˆ€ i âˆˆ s, f i â‰¤ 1) â†’ (âˆ i âˆˆ s, f i = 1 â†” âˆ€ i âˆˆ s, f i = 1) : Prop","theorem prod_eq_one_iff_of_le_one' :
    (âˆ€ i âˆˆ s, f i â‰¤ 1) â†’ ((âˆ i âˆˆ s, f i) = 1 â†” âˆ€ i âˆˆ s, f i = 1) ",":=
  @prod_eq_one_iff_of_one_le' _ Náµ’áµˆ _ _ _"
Mathlib/Data/Sigma/Basic.lean,Sigma.exists',exists',366aa49a421213f1ab22157d84299da19895f452,:=,error:  unexpected token 'lemma'; expected term,"lemma exists' {p : âˆ€ a, Î² a â†’ Prop} : (âˆƒ a b, p a b) â†” âˆƒ x : Î£ a, Î² a, p x.1 x.2 ",":=
  (Sigma.exists (p := fun x â†¦ p x.1 x.2)).symm"
Mathlib/AlgebraicGeometry/Morphisms/RingHomProperties.lean,AlgebraicGeometry.sourceAffineLocally_isLocal,sourceAffineLocally_isLocal,4209dc8f278089a5b27c0d4aeb13dbe1dd2fad04,":= by
  constructor
  Â· exact sourceAffineLocally_respectsIso hâ‚
  Â· introv H U
    apply scheme_restrict_basicOpen_of_localizationPreserves hâ‚ hâ‚‚; assumption
  Â· introv hs hs' U
    apply hâ‚ƒ _ _ hs
    intro r
    have := hs' r âŸ¨(Opens.map (X.ofRestrict _).1.base).obj U.1, ?_âŸ©
    Â· rwa [hâ‚.ofRestrict_morphismRestrict_iff] at this
      Â· exact U.2
      Â· rfl
      Â· suffices âˆ€ (V) (_ : V = (Opens.map f.val.base).obj (Y.basicOpen r.val)),
            IsAffineOpen ((Opens.map (X.ofRestrict V.openEmbedding).1.base).obj U.1) by
          exact this _ rfl
        intro V hV
        rw [Scheme.preimage_basicOpen] at hV
        subst hV
        exact U.2.Î¹Opens_preimage (Scheme.Î“.map f.op r.1)","error:  no goals to be solved
error:  unsolved goals
case ofBasicOpenCover.refine_1
P : {R S : Type u} â†’ [inst : CommRing R] â†’ [inst_1 : CommRing S] â†’ (R â†’+* S) â†’ Prop
hâ‚ : RingHom.RespectsIso P
hâ‚‚ : RingHom.LocalizationPreserves P
hâ‚ƒ : RingHom.OfLocalizationSpan P
X Y : Scheme
instâœ : IsAffine Y
f : X âŸ¶ Y
s : Finset â†‘Î“(Y, âŠ¤)
hs : Ideal.span â†‘s = âŠ¤
hs' : âˆ€ (r : { x // x âˆˆ s }), sourceAffineLocally P (f âˆ£_ Y.basicOpen â†‘r)
U : â†‘X.affineOpens
r : â†‘â†‘s
âŠ¢ X.ofRestrict â‹¯ â»Â¹áµ â†‘U âˆˆ (X âˆ£_áµ¤ f â»Â¹áµ Y.basicOpen â†‘r).affineOpens","theorem sourceAffineLocally_isLocal (hâ‚ : RingHom.RespectsIso @P)
    (hâ‚‚ : RingHom.LocalizationPreserves @P) (hâ‚ƒ : RingHom.OfLocalizationSpan @P) :
    (sourceAffineLocally @P).IsLocal ",":= by
  constructor
  Â· exact sourceAffineLocally_respectsIso hâ‚
  Â· introv H U
    apply scheme_restrict_basicOpen_of_localizationPreserves hâ‚ hâ‚‚; assumption
  Â· introv hs hs' U
    apply hâ‚ƒ _ _ hs
    intro r
    have := hs' r âŸ¨(Opens.map (X.ofRestrict _).1.base).obj U.1, ?_âŸ©
    Â· rwa [hâ‚.ofRestrict_morphismRestrict_iff] at this
      Â· exact U.2
      Â· rfl
    Â· suffices âˆ€ (V) (_ : V = (Opens.map f.val.base).obj (Y.basicOpen r.val)),
          IsAffineOpen ((Opens.map (X.ofRestrict V.openEmbedding).1.base).obj U.1) by
        exact this _ rfl
      intro V hV
      rw [Scheme.preimage_basicOpen] at hV
      subst hV
      exact U.2.Î¹Opens_basicOpen_preimage (Scheme.Î“.map f.op r.1)"
Mathlib/MeasureTheory/Measure/Restrict.lean,MeasureTheory.Measure.restrict_union_congr,restrict_union_congr,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  refine
    âŸ¨fun h =>
      âŸ¨restrict_congr_mono (subset_union_left _ _) h,
        restrict_congr_mono (subset_union_right _ _) hâŸ©,
      ?_âŸ©
  rintro âŸ¨hs, htâŸ©
  ext1 u hu
  simp only [restrict_apply hu, inter_union_distrib_left]
  rcases exists_measurable_supersetâ‚‚ Î¼ Î½ (u âˆ© s) with âŸ¨US, hsub, hm, hÎ¼, hÎ½âŸ©
  calc
    Î¼ (u âˆ© s âˆª u âˆ© t) = Î¼ (US âˆª u âˆ© t) :=
      measure_union_congr_of_subset hsub hÎ¼.le Subset.rfl le_rfl
    _ = Î¼ US + Î¼ ((u âˆ© t) \ US) := (measure_add_diff hm _).symm
    _ = restrict Î¼ s u + restrict Î¼ t (u \ US) := by
      simp only [restrict_apply, hu, hu.diff hm, hÎ¼, â† inter_comm t, inter_diff_assoc]
    _ = restrict Î½ s u + restrict Î½ t (u \ US) := by rw [hs, ht]
    _ = Î½ US + Î½ ((u âˆ© t) \ US) := by
      simp only [restrict_apply, hu, hu.diff hm, hÎ½, â† inter_comm t, inter_diff_assoc]
    _ = Î½ (US âˆª u âˆ© t) := measure_add_diff hm _
    _ = Î½ (u âˆ© s âˆª u âˆ© t) := Eq.symm <| measure_union_congr_of_subset hsub hÎ½.le Subset.rfl le_rfl","error:  function expected at
  subset_union_left ?m.54948
term has type
  ?m.54947 âˆˆ ?m.54945 âˆª ?m.54946
error:  function expected at
  subset_union_right ?m.54997
term has type
  ?m.54996 âˆˆ ?m.54994 âˆª ?m.54995","theorem restrict_union_congr :
    Î¼.restrict (s âˆª t) = Î½.restrict (s âˆª t) â†”
      Î¼.restrict s = Î½.restrict s âˆ§ Î¼.restrict t = Î½.restrict t ",":= by
  refine
    âŸ¨fun h =>
      âŸ¨restrict_congr_mono subset_union_left h,
        restrict_congr_mono subset_union_right hâŸ©,
      ?_âŸ©
  rintro âŸ¨hs, htâŸ©
  ext1 u hu
  simp only [restrict_apply hu, inter_union_distrib_left]
  rcases exists_measurable_supersetâ‚‚ Î¼ Î½ (u âˆ© s) with âŸ¨US, hsub, hm, hÎ¼, hÎ½âŸ©
  calc
    Î¼ (u âˆ© s âˆª u âˆ© t) = Î¼ (US âˆª u âˆ© t) :=
      measure_union_congr_of_subset hsub hÎ¼.le Subset.rfl le_rfl
    _ = Î¼ US + Î¼ ((u âˆ© t) \ US) := (measure_add_diff hm _).symm
    _ = restrict Î¼ s u + restrict Î¼ t (u \ US) := by
      simp only [restrict_apply, hu, hu.diff hm, hÎ¼, â† inter_comm t, inter_diff_assoc]
    _ = restrict Î½ s u + restrict Î½ t (u \ US) := by rw [hs, ht]
    _ = Î½ US + Î½ ((u âˆ© t) \ US) := by
      simp only [restrict_apply, hu, hu.diff hm, hÎ½, â† inter_comm t, inter_diff_assoc]
    _ = Î½ (US âˆª u âˆ© t) := measure_add_diff hm _
    _ = Î½ (u âˆ© s âˆª u âˆ© t) := Eq.symm <| measure_union_congr_of_subset hsub hÎ½.le Subset.rfl le_rfl"
Mathlib/MeasureTheory/Covering/Differentiation.lean,VitaliFamily.ae_tendsto_lintegral_nnnorm_sub_div'_of_integrable,ae_tendsto_lintegral_nnnorm_sub_div'_of_integrable,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  let A := MeasureTheory.Measure.finiteSpanningSetsInOpen' Î¼
  rcases h'f.isSeparable_range with âŸ¨t, t_count, htâŸ©
  have main :
    âˆ€áµ x âˆ‚Î¼,
      âˆ€áµ‰ (n : â„•) (c âˆˆ t),
        Tendsto (fun a => (âˆ«â» y in a, â€–f y - (A.set n).indicator (fun _ => c) yâ€–â‚Š âˆ‚Î¼) / Î¼ a)
          (v.filterAt x) (ğ“ â€–f x - (A.set n).indicator (fun _ => c) xâ€–â‚Š) := by
    simp_rw [ae_all_iff, ae_ball_iff t_count]
    intro n c _
    apply ae_tendsto_lintegral_div'
    Â· refine' (h'f.sub _).ennnorm
      exact stronglyMeasurable_const.indicator (IsOpen.measurableSet (A.set_mem n))
    Â· apply ne_of_lt
      calc
        (âˆ«â» y, â†‘â€–f y - (A.set n).indicator (fun _ : Î± => c) yâ€–â‚Š âˆ‚Î¼) â‰¤
            âˆ«â» y, â€–f yâ€–â‚Š + â€–(A.set n).indicator (fun _ : Î± => c) yâ€–â‚Š âˆ‚Î¼ := by
          apply lintegral_mono
          intro x
          dsimp
          rw [â† ENNReal.coe_add]
          exact ENNReal.coe_le_coe.2 (nnnorm_sub_le _ _)
        _ = (âˆ«â» y, â€–f yâ€–â‚Š âˆ‚Î¼) + âˆ«â» y, â€–(A.set n).indicator (fun _ : Î± => c) yâ€–â‚Š âˆ‚Î¼ :=
          (lintegral_add_left h'f.ennnorm _)
        _ < âˆ + âˆ :=
          haveI I : Integrable ((A.set n).indicator fun _ : Î± => c) Î¼ := by
            simp only [integrable_indicator_iff (IsOpen.measurableSet (A.set_mem n)),
              integrableOn_const, A.finite n, or_true_iff]
          ENNReal.add_lt_add hf.2 I.2
  filter_upwards [main, v.ae_eventually_measure_pos] with x hx h'x
  have M :
    âˆ€ c âˆˆ t, Tendsto (fun a => (âˆ«â» y in a, â€–f y - câ€–â‚Š âˆ‚Î¼) / Î¼ a)
      (v.filterAt x) (ğ“ â€–f x - câ€–â‚Š) := by
    intro c hc
    obtain âŸ¨n, xnâŸ© : âˆƒ n, x âˆˆ A.set n := by simpa [â† A.spanning] using mem_univ x
    specialize hx n c hc
    simp only [xn, indicator_of_mem] at hx
    apply hx.congr' _
    filter_upwards [v.eventually_filterAt_subset_of_nhds (IsOpen.mem_nhds (A.set_mem n) xn),
      v.eventually_filterAt_measurableSet x] with a ha h'a
    congr 1
    apply set_lintegral_congr_fun h'a
    filter_upwards with y hy using (by simp only [ha hy, indicator_of_mem])
  apply ENNReal.tendsto_nhds_zero.2 fun Îµ Îµpos => ?_
  obtain âŸ¨c, ct, xcâŸ© : âˆƒ c âˆˆ t, (â€–f x - câ€–â‚Š : â„â‰¥0âˆ) < Îµ / 2 := by
    simp_rw [â† edist_eq_coe_nnnorm_sub]
    have : f x âˆˆ closure t := ht (mem_range_self _)
    exact EMetric.mem_closure_iff.1 this (Îµ / 2) (ENNReal.half_pos (ne_of_gt Îµpos))
  filter_upwards [(tendsto_order.1 (M c ct)).2 (Îµ / 2) xc, h'x, v.eventually_measure_lt_top x] with
    a ha h'a h''a
  apply ENNReal.div_le_of_le_mul
  calc
    (âˆ«â» y in a, â€–f y - f xâ€–â‚Š âˆ‚Î¼) â‰¤ âˆ«â» y in a, â€–f y - câ€–â‚Š + â€–f x - câ€–â‚Š âˆ‚Î¼ := by
      apply lintegral_mono fun x => ?_
      simpa only [â† edist_eq_coe_nnnorm_sub] using edist_triangle_right _ _ _
    _ = (âˆ«â» y in a, â€–f y - câ€–â‚Š âˆ‚Î¼) + âˆ«â» _ in a, â€–f x - câ€–â‚Š âˆ‚Î¼ :=
      (lintegral_add_right _ measurable_const)
    _ â‰¤ Îµ / 2 * Î¼ a + Îµ / 2 * Î¼ a := by
      gcongr
      Â· rw [ENNReal.div_lt_iff (Or.inl h'a.ne') (Or.inl h''a.ne)] at ha
        exact ha.le
      Â· simp only [lintegral_const, Measure.restrict_apply, MeasurableSet.univ, univ_inter]
        gcongr
    _ = Îµ * Î¼ a := by rw [â† add_mul, ENNReal.add_halves]","error:  simp made no progress
warning:  `MeasureTheory.set_lintegral_congr_fun` has been deprecated, use `MeasureTheory.setLIntegral_congr_fun` instead","theorem ae_tendsto_lintegral_nnnorm_sub_div'_of_integrable {f : Î± â†’ E} (hf : Integrable f Î¼)
    (h'f : StronglyMeasurable f) :
    âˆ€áµ x âˆ‚Î¼, Tendsto (fun a => (âˆ«â» y in a, â€–f y - f xâ€–â‚Š âˆ‚Î¼) / Î¼ a) (v.filterAt x) (ğ“ 0) ",":= by
  let A := MeasureTheory.Measure.finiteSpanningSetsInOpen' Î¼
  rcases h'f.isSeparable_range with âŸ¨t, t_count, htâŸ©
  have main :
    âˆ€áµ x âˆ‚Î¼,
      âˆ€áµ‰ (n : â„•) (c âˆˆ t),
        Tendsto (fun a => (âˆ«â» y in a, â€–f y - (A.set n).indicator (fun _ => c) yâ€–â‚Š âˆ‚Î¼) / Î¼ a)
          (v.filterAt x) (ğ“ â€–f x - (A.set n).indicator (fun _ => c) xâ€–â‚Š) := by
    simp_rw [ae_all_iff]
    intro x; rw [ae_ball_iff t_count]; revert x
    intro n c _
    apply ae_tendsto_lintegral_div'
    Â· refine (h'f.sub ?_).ennnorm
      exact stronglyMeasurable_const.indicator (IsOpen.measurableSet (A.set_mem n))
    Â· apply ne_of_lt
      calc
        (âˆ«â» y, â†‘â€–f y - (A.set n).indicator (fun _ : Î± => c) yâ€–â‚Š âˆ‚Î¼) â‰¤
            âˆ«â» y, â€–f yâ€–â‚Š + â€–(A.set n).indicator (fun _ : Î± => c) yâ€–â‚Š âˆ‚Î¼ := by
          apply lintegral_mono
          intro x
          dsimp
          rw [â† ENNReal.coe_add]
          exact ENNReal.coe_le_coe.2 (nnnorm_sub_le _ _)
        _ = (âˆ«â» y, â€–f yâ€–â‚Š âˆ‚Î¼) + âˆ«â» y, â€–(A.set n).indicator (fun _ : Î± => c) yâ€–â‚Š âˆ‚Î¼ :=
          (lintegral_add_left h'f.ennnorm _)
        _ < âˆ + âˆ :=
          haveI I : Integrable ((A.set n).indicator fun _ : Î± => c) Î¼ := by
            simp only [integrable_indicator_iff (IsOpen.measurableSet (A.set_mem n)),
              integrableOn_const, A.finite n, or_true_iff]
          ENNReal.add_lt_add hf.2 I.2
  filter_upwards [main, v.ae_eventually_measure_pos] with x hx h'x
  have M :
    âˆ€ c âˆˆ t, Tendsto (fun a => (âˆ«â» y in a, â€–f y - câ€–â‚Š âˆ‚Î¼) / Î¼ a)
      (v.filterAt x) (ğ“ â€–f x - câ€–â‚Š) := by
    intro c hc
    obtain âŸ¨n, xnâŸ© : âˆƒ n, x âˆˆ A.set n := by simpa [â† A.spanning] using mem_univ x
    specialize hx n c hc
    simp only [xn, indicator_of_mem] at hx
    apply hx.congr' _
    filter_upwards [v.eventually_filterAt_subset_of_nhds (IsOpen.mem_nhds (A.set_mem n) xn),
      v.eventually_filterAt_measurableSet x] with a ha h'a
    congr 1
    apply setLIntegral_congr_fun h'a
    filter_upwards with y hy using (by simp only [ha hy, indicator_of_mem])
  apply ENNReal.tendsto_nhds_zero.2 fun Îµ Îµpos => ?_
  obtain âŸ¨c, ct, xcâŸ© : âˆƒ c âˆˆ t, (â€–f x - câ€–â‚Š : â„â‰¥0âˆ) < Îµ / 2 := by
    simp_rw [â† edist_eq_coe_nnnorm_sub]
    have : f x âˆˆ closure t := ht (mem_range_self _)
    exact EMetric.mem_closure_iff.1 this (Îµ / 2) (ENNReal.half_pos (ne_of_gt Îµpos))
  filter_upwards [(tendsto_order.1 (M c ct)).2 (Îµ / 2) xc, h'x, v.eventually_measure_lt_top x] with
    a ha h'a h''a
  apply ENNReal.div_le_of_le_mul
  calc
    (âˆ«â» y in a, â€–f y - f xâ€–â‚Š âˆ‚Î¼) â‰¤ âˆ«â» y in a, â€–f y - câ€–â‚Š + â€–f x - câ€–â‚Š âˆ‚Î¼ := by
      apply lintegral_mono fun x => ?_
      simpa only [â† edist_eq_coe_nnnorm_sub] using edist_triangle_right _ _ _
    _ = (âˆ«â» y in a, â€–f y - câ€–â‚Š âˆ‚Î¼) + âˆ«â» _ in a, â€–f x - câ€–â‚Š âˆ‚Î¼ :=
      (lintegral_add_right _ measurable_const)
    _ â‰¤ Îµ / 2 * Î¼ a + Îµ / 2 * Î¼ a := by
      gcongr
      Â· rw [ENNReal.div_lt_iff (Or.inl h'a.ne') (Or.inl h''a.ne)] at ha
        exact ha.le
      Â· simp only [lintegral_const, Measure.restrict_apply, MeasurableSet.univ, univ_inter]
        gcongr
    _ = Îµ * Î¼ a := by rw [â† add_mul, ENNReal.add_halves]"
Mathlib/Data/Set/Function.lean,Function.Injective.comp_injOn,Injective.comp_injOn,ea1b2576466eb49ae109b64acf312f52285dafce,":=
  (hg.injOn univ).comp hf (mapsTo_univ _ _)","error:  application type mismatch
  injOn hg univ
argument
  univ
has type
  Set ?m.125935 : Type ?u.125934
but is expected to have type
  ?m.125933 âˆˆ ?m.125932 : Prop",theorem Injective.comp_injOn (hg : Injective g) (hf : s.InjOn f) : s.InjOn (g âˆ˜ f) ,":=
  hg.injOn.comp hf (mapsTo_univ _ _)"
Mathlib/Topology/Bases.lean,TopologicalSpace.IsTopologicalBasis.diff_empty,IsTopologicalBasis.diff_empty,b0906f1a9f950f5731cad2defb88e9843a7e3fc9,":= by
  refine' âŸ¨_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], _âŸ©
  Â· rintro tâ‚ âŸ¨hâ‚, -âŸ© tâ‚‚ âŸ¨hâ‚‚, -âŸ© x hx
    obtain âŸ¨tâ‚ƒ, hâ‚ƒ, hsâŸ© := h.exists_subset_inter _ hâ‚ _ hâ‚‚ x hx
    exact âŸ¨tâ‚ƒ, âŸ¨hâ‚ƒ, Nonempty.ne_empty âŸ¨x, hs.1âŸ©âŸ©, hsâŸ©
  Â· rw [h.eq_generateFrom]
    refine' le_antisymm (generateFrom_anti <| diff_subset s _) (le_generateFrom fun t ht => _)
    obtain rfl | he := eq_or_ne t âˆ…
    Â· exact @isOpen_empty _ (generateFrom _)
    Â· exact .basic t âŸ¨ht, heâŸ©","error:  application type mismatch
  diff_subset s
argument
  s
has type
  Set (Set Î±) : Type u
but is expected to have type
  ?m.1865 âˆˆ ?m.1863 \ ?m.1864 : Prop","theorem IsTopologicalBasis.diff_empty {s : Set (Set Î±)} (h : IsTopologicalBasis s) :
    IsTopologicalBasis (s \ {âˆ…}) ",":= by
  refine âŸ¨?_, by rw [sUnion_diff_singleton_empty, h.sUnion_eq], ?_âŸ©
  Â· rintro tâ‚ âŸ¨hâ‚, -âŸ© tâ‚‚ âŸ¨hâ‚‚, -âŸ© x hx
    obtain âŸ¨tâ‚ƒ, hâ‚ƒ, hsâŸ© := h.exists_subset_inter _ hâ‚ _ hâ‚‚ x hx
    exact âŸ¨tâ‚ƒ, âŸ¨hâ‚ƒ, Nonempty.ne_empty âŸ¨x, hs.1âŸ©âŸ©, hsâŸ©
  Â· rw [h.eq_generateFrom]
    refine le_antisymm (generateFrom_anti diff_subset) (le_generateFrom fun t ht => ?_)
    obtain rfl | he := eq_or_ne t âˆ…
    Â· exact @isOpen_empty _ (generateFrom _)
    Â· exact .basic t âŸ¨ht, heâŸ©"
Mathlib/GroupTheory/Exponent.lean,Monoid.exponent_eq_prime_iff,exponent_eq_prime_iff,554c20d1eb6d2f1f6a5b53ccd3a727a93147a4de,":= by
  refine âŸ¨fun hG g hg â†¦ ?_, fun h â†¦ dvd_antisymm ?_ ?_âŸ©
  Â· rw [Ne.def, â† orderOf_eq_one_iff] at hg
    exact Eq.symm <| (hp.dvd_iff_eq hg).mp <| hG â–¸ Monoid.order_dvd_exponent g
  Â· apply Monoid.exponent_dvd_of_forall_pow_eq_one G p fun g â†¦ ?_
    by_cases hg : g = 1
    Â· simp [hg]
    Â· simpa [h g hg] using pow_orderOf_eq_one g
  Â· obtain âŸ¨g, hgâŸ© := exists_ne (1 : G)
    simpa [h g hg] using Monoid.order_dvd_exponent g","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.32850 â†’ ?m.32850 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.32852
case refine_1
Gâœ : Type u
instâœÂ² : Monoid Gâœ
G : Type u_1
instâœÂ¹ : Monoid G
instâœ : Nontrivial G
p : â„•
hp : Nat.Prime p
hG : exponent G = p
g : G
hg : g â‰  1
âŠ¢ orderOf g = p
error:  application type mismatch
  exponent_dvd_of_forall_pow_eq_one G
argument
  G
has type
  Type u_1 : Type (u_1 + 1)
but is expected to have type
  âˆ€ (g : ?m.32854), g ^ ?m.32856 = 1 : Prop","lemma exponent_eq_prime_iff {G : Type*} [Monoid G] [Nontrivial G] {p : â„•} (hp : p.Prime) :
    Monoid.exponent G = p â†” âˆ€ g : G, g â‰  1 â†’ orderOf g = p ",":= by
  refine âŸ¨fun hG g hg â†¦ ?_, fun h â†¦ dvd_antisymm ?_ ?_âŸ©
  Â· rw [Ne, â† orderOf_eq_one_iff] at hg
    exact Eq.symm <| (hp.dvd_iff_eq hg).mp <| hG â–¸ Monoid.order_dvd_exponent g
  Â· rw [exponent_dvd]
    intro g
    by_cases hg : g = 1
    Â· simp [hg]
    Â· rw [h g hg]
  Â· obtain âŸ¨g, hgâŸ© := exists_ne (1 : G)
    simpa [h g hg] using Monoid.order_dvd_exponent g"
Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean,HomogeneousIdeal.toIdeal_iInf,toIdeal_iInf,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":=
  HomogeneousSubmodule.toSubmodule_iInf s",error:  unknown identifier 'HomogeneousSubmodule.toSubmodule_iInf',"theorem toIdeal_iInf {Îº : Sort*} (s : Îº â†’ HomogeneousIdeal ğ’œ) :
    (â¨… i, s i).toIdeal = â¨… i, (s i).toIdeal ",":= by
  rw [iInf, toIdeal_sInf, iInf_range]"
Mathlib/RingTheory/IntegralDomain.lean,sum_hom_units,sum_hom_units,9e34a191034458a56331f976ff7400a26407c888,":= by
  classical
    obtain âŸ¨x, hxâŸ© :
      âˆƒ x : MonoidHom.range f.toHomUnits,
        âˆ€ y : MonoidHom.range f.toHomUnits, y âˆˆ Submonoid.powers x
    exact IsCyclic.exists_monoid_generator
    have hx1 : x â‰  1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx âŸ¨f.toHomUnits g, g, rflâŸ© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 â‰  0  
    exact fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      âˆ‘ g : G, f g = âˆ‘ g : G, (f.toHomUnits g : R) := rfl
      _ = âˆ‘ u : RË£ in univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card â€¢ (u : R) :=
        (sum_comp ((â†‘) : RË£ â†’ R) f.toHomUnits)
      _ = âˆ‘ u : RË£ in univ.image f.toHomUnits, c â€¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_argâ‚‚ _ ?_ rfl)
      _ = âˆ‘ b : MonoidHom.range f.toHomUnits, c â€¢ ((b : RË£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c â€¢ âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R) := smul_sum.symm
      _ = c â€¢ (0 : R) := (congr_argâ‚‚ _ rfl ?_)
      _ = (0 : R) := smul_zero _
    Â· 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply card_fiber_eq_of_mem_range f.toHomUnits
      Â· simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      Â· exact âŸ¨1, f.toHomUnits.map_oneâŸ©
    show (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R)) = 0
    calc
      (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R))
        = âˆ‘ n in range (orderOf x), ((x : RË£) : R) ^ n :=
        Eq.symm <|
          sum_bij (fun n _ => x ^ n) (by simp only [mem_univ, forall_true_iff])
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
            (fun m n hm hn =>
              pow_injective_of_lt_orderOf _ (by simpa only [mem_range] using hm)
                (by simpa only [mem_range] using hn))
            (fun b _ => let âŸ¨n, hnâŸ© := hx b
              âŸ¨n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn âŠ¢; rw [â† pow_eq_mod_orderOf, hn]âŸ©)
      _ = 0 := ?_

    rw [â† mul_left_inj' hx1, MulZeroClass.zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]","error:  unexpected identifier; expected '|'
error:  unsolved goals
case intro
R : Type u_1
G : Type u_2
instâœÂ³ : CommRing R
instâœÂ² : IsDomain R
instâœÂ¹ : Group G
instâœ : Fintype G
f : G â†’* R
hf : f â‰  1
x : â†¥f.toHomUnits.range
hx : âˆ€ (y : â†¥f.toHomUnits.range), y âˆˆ Submonoid.powers x
hx1 : â†‘â†‘x - 1 â‰  0
âŠ¢ âˆ‘ g : G, f g = 0","theorem sum_hom_units_eq_zero (f : G â†’* R) (hf : f â‰  1) : âˆ‘ g : G, f g = 0 ",":= by
  classical
    obtain âŸ¨x, hxâŸ© : âˆƒ x : MonoidHom.range f.toHomUnits,
        âˆ€ y : MonoidHom.range f.toHomUnits, y âˆˆ Submonoid.powers x :=
      IsCyclic.exists_monoid_generator
    have hx1 : x â‰  1 := by
      rintro rfl
      apply hf
      ext g
      rw [MonoidHom.one_apply]
      cases' hx âŸ¨f.toHomUnits g, g, rflâŸ© with n hn
      rwa [Subtype.ext_iff, Units.ext_iff, Subtype.coe_mk, MonoidHom.coe_toHomUnits, one_pow,
        eq_comm] at hn
    replace hx1 : (x.val : R) - 1 â‰  0 := 
      fun h => hx1 (Subtype.eq (Units.ext (sub_eq_zero.1 h)))
    let c := (univ.filter fun g => f.toHomUnits g = 1).card
    calc
      âˆ‘ g : G, f g = âˆ‘ g : G, (f.toHomUnits g : R) := rfl
      _ = âˆ‘ u âˆˆ univ.image f.toHomUnits,
            (univ.filter fun g => f.toHomUnits g = u).card â€¢ (u : R) :=
        (sum_comp ((â†‘) : RË£ â†’ R) f.toHomUnits)
      _ = âˆ‘ u âˆˆ univ.image f.toHomUnits, c â€¢ (u : R) :=
        (sum_congr rfl fun u hu => congr_argâ‚‚ _ ?_ rfl)
      _ = âˆ‘ b : MonoidHom.range f.toHomUnits, c â€¢ ((b : RË£) : R) :=
        (Finset.sum_subtype _ (by simp) _)
      _ = c â€¢ âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R) := smul_sum.symm
      _ = c â€¢ (0 : R) := congr_argâ‚‚ _ rfl ?_
      _ = (0 : R) := smul_zero _
    Â· 
      show (univ.filter fun g : G => f.toHomUnits g = u).card = c
      apply MonoidHom.card_fiber_eq_of_mem_range f.toHomUnits
      Â· simpa only [mem_image, mem_univ, true_and, Set.mem_range] using hu
      Â· exact âŸ¨1, f.toHomUnits.map_oneâŸ©
    show (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R)) = 0
    calc
      (âˆ‘ b : MonoidHom.range f.toHomUnits, ((b : RË£) : R))
        = âˆ‘ n âˆˆ range (orderOf x), ((x : RË£) : R) ^ n :=
        Eq.symm <|
          sum_nbij (x ^ Â·) (by simp only [mem_univ, forall_true_iff])
            (by simpa using pow_injOn_Iio_orderOf)
            (fun b _ => let âŸ¨n, hnâŸ© := hx b
              âŸ¨n % orderOf x, mem_range.2 (Nat.mod_lt _ (orderOf_pos _)),
               by dsimp at hn âŠ¢; rw [pow_mod_orderOf, hn]âŸ©)
            (by simp only [imp_true_iff, eq_self_iff_true, Subgroup.coe_pow,
                Units.val_pow_eq_pow_val])
      _ = 0 := ?_

    rw [â† mul_left_inj' hx1, zero_mul, geom_sum_mul]
    norm_cast
    simp [pow_orderOf_eq_one]"
Mathlib/GroupTheory/GroupAction/Blocks.lean,MulAction.IsBlock.iInter,IsBlock.iInter,136957ac82beac101e5f1ca9001a19b64087d22c,":= by
  rw [IsBlock.def_one]
  cases' em (IsEmpty Î¹) with hÎ¹ hÎ¹
  Â· 
    suffices (â‹‚ i : Î¹, B i) = Set.univ by
      rw [this]
      exact IsBlock.def_one.mp (top_IsBlock X)
    simp only [Set.top_eq_univ, Set.iInter_eq_univ]
    intro i; exfalso; apply hÎ¹.false; exact i
  intro g
  rw [Set.smul_set_iInter]
  cases' em (âˆƒ i : Î¹, Disjoint (g â€¢ B i) (B i)) with h h
  Â· obtain âŸ¨j, hjâŸ© := h
    apply Or.intro_right
    refine' Disjoint.mono _ _ hj
    apply Set.iInter_subset
    apply Set.iInter_subset
  simp only [not_exists] at h
  apply Or.intro_left
  have : âˆ€ i : Î¹, g â€¢ B i = B i := fun i => Or.resolve_right (IsBlock.def_one.mp (hB i) g) (h i)
  rw [Set.iInter_congr this]",error:  unknown identifier 'top_IsBlock',"theorem IsBlock.iInter {Î¹ : Type*} {B : Î¹ â†’ Set X} (hB : âˆ€ i : Î¹, IsBlock G (B i)) :
    IsBlock G (â‹‚ i, B i) ",":= by
  by_cases hÎ¹ : (IsEmpty Î¹)
  Â· 
    suffices (â‹‚ i : Î¹, B i) = Set.univ by simpa only [this] using isBlock_top X
    simpa only [Set.top_eq_univ, Set.iInter_eq_univ] using (hÎ¹.elim' Â·)
  rw [IsBlock.def_one]
  intro g
  rw [Set.smul_set_iInter]
  by_cases h : âˆƒ i : Î¹, Disjoint (g â€¢ B i) (B i)
  Â· right
    obtain âŸ¨j, hjâŸ© := h
    refine Disjoint.mono ?_ ?_ hj <;> apply Set.iInter_subset
  Â· left
    simp only [not_exists] at h
    have : âˆ€ i : Î¹, g â€¢ B i = B i := fun i => ((hB i).smul_eq_or_disjoint g).resolve_right (h i)
    rw [Set.iInter_congr this]"
Mathlib/MeasureTheory/Function/Jacobian.lean,MeasureTheory.addHaar_image_le_lintegral_abs_det_fderiv_aux1,addHaar_image_le_lintegral_abs_det_fderiv_aux1,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  have :
    âˆ€ A : E â†’L[â„] E,
      âˆƒ Î´ : â„â‰¥0,
        0 < Î´ âˆ§
          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§
            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’
              Î¼ (g '' t) â‰¤ (ENNReal.ofReal |A.det| + Îµ) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©
    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt Îµ Îµpos
    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©
    refine' âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), _, _âŸ©
    Â· intro B hB
      rw [â† Real.dist_eq]
      apply (hÎ´' B _).le
      rw [dist_eq_norm]
      calc
        â€–B - Aâ€– â‰¤ (min Î´ Î´'' : â„â‰¥0) := hB
        _ â‰¤ Î´'' := by simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
        _ < Î´' := half_lt_self Î´'pos
    Â· intro t g htg
      exact h t g (htg.mono_num (min_le_left _ _))
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (ENNReal.ofReal |(A n).det| + Îµ) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2.2
      exact ht n
    _ = âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by
      simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
    _ â‰¤ âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono (inter_subset_left _ _)]
      intro x hx
      have I : |(A n).det| â‰¤ |(f' x).det| + Îµ :=
        calc
          |(A n).det| = |(f' x).det - ((f' x).det - (A n).det)| := by congr 1; abel
          _ â‰¤ |(f' x).det| + |(f' x).det - (A n).det| := abs_sub _ _
          _ â‰¤ |(f' x).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(A n).det| + Îµ â‰¤ ENNReal.ofReal (|(f' x).det| + Îµ) + Îµ :=
          add_le_add (ENNReal.ofReal_le_ofReal I) le_rfl
        _ = ENNReal.ofReal |(f' x).det| + 2 * Îµ := by
          simp only [ENNReal.ofReal_add, abs_nonneg, two_mul, add_assoc, NNReal.zero_le_coe,
            ENNReal.ofReal_coe_nnreal]
    _ = âˆ«â» x in â‹ƒ n, s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      have M : âˆ€ n : â„•, MeasurableSet (s âˆ© t n) := fun n => hs.inter (t_meas n)
      rw [lintegral_iUnion M]
      exact pairwise_disjoint_mono t_disj fun n => inter_subset_right _ _
    _ = âˆ«â» x in s, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      have : s = â‹ƒ n, s âˆ© t n := by
        rw [â† inter_iUnion]
        exact Subset.antisymm (subset_inter Subset.rfl t_cover) (inter_subset_left _ _)
      rw [â† this]
    _ = (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s := by
      simp only [lintegral_add_right' _ aemeasurable_const, set_lintegral_const]","error:  function expected at
  inter_subset_left ?m.432033
term has type
  ?m.432032 âˆˆ ?m.432030
error:  function expected at
  inter_subset_right ?m.438719
term has type
  ?m.438718 âˆˆ ?m.438717
error:  function expected at
  inter_subset_left ?m.438934
term has type
  ?m.438933 âˆˆ ?m.438931
warning:  `MeasureTheory.set_lintegral_const` has been deprecated, use `MeasureTheory.setLIntegral_const` instead","theorem addHaar_image_le_lintegral_abs_det_fderiv_aux1 (hs : MeasurableSet s)
    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) {Îµ : â„â‰¥0} (Îµpos : 0 < Îµ) :
    Î¼ (f '' s) â‰¤ (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s ",":= by
  have :
    âˆ€ A : E â†’L[â„] E,
      âˆƒ Î´ : â„â‰¥0,
        0 < Î´ âˆ§
          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§
            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’
              Î¼ (g '' t) â‰¤ (ENNReal.ofReal |A.det| + Îµ) * Î¼ t := by
    intro A
    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ
    have I : ENNReal.ofReal |A.det| < m := by
      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]
    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©
    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ :=
      continuousAt_iff.1 ContinuousLinearMap.continuous_det.continuousAt Îµ Îµpos
    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©
    refine âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), ?_, ?_âŸ©
    Â· intro B hB
      rw [â† Real.dist_eq]
      apply (hÎ´' B _).le
      rw [dist_eq_norm]
      calc
        â€–B - Aâ€– â‰¤ (min Î´ Î´'' : â„â‰¥0) := hB
        _ â‰¤ Î´'' := by simp only [le_refl, NNReal.coe_min, min_le_iff, or_true_iff]
        _ < Î´' := half_lt_self Î´'pos
    Â· intro t g htg
      exact h t g (htg.mono_num (min_le_left _ _))
  choose Î´ hÎ´ using this
  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :
    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),
      Pairwise (Disjoint on t) âˆ§
        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§
          (s âŠ† â‹ƒ n : â„•, t n) âˆ§
            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§
              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=
    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'
  calc
    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by
      apply measure_mono
      rw [â† image_iUnion, â† inter_iUnion]
      exact image_subset f (subset_inter Subset.rfl t_cover)
    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _
    _ â‰¤ âˆ‘' n, (ENNReal.ofReal |(A n).det| + Îµ) * Î¼ (s âˆ© t n) := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply (hÎ´ (A n)).2.2
      exact ht n
    _ = âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by
      simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]
    _ â‰¤ âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      apply ENNReal.tsum_le_tsum fun n => ?_
      apply lintegral_mono_ae
      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>
          (hf' x hx.1).mono inter_subset_left]
      intro x hx
      have I : |(A n).det| â‰¤ |(f' x).det| + Îµ :=
        calc
          |(A n).det| = |(f' x).det - ((f' x).det - (A n).det)| := by congr 1; abel
          _ â‰¤ |(f' x).det| + |(f' x).det - (A n).det| := abs_sub _ _
          _ â‰¤ |(f' x).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)
      calc
        ENNReal.ofReal |(A n).det| + Îµ â‰¤ ENNReal.ofReal (|(f' x).det| + Îµ) + Îµ := by gcongr
        _ = ENNReal.ofReal |(f' x).det| + 2 * Îµ := by
          simp only [ENNReal.ofReal_add, abs_nonneg, two_mul, add_assoc, NNReal.zero_le_coe,
            ENNReal.ofReal_coe_nnreal]
    _ = âˆ«â» x in â‹ƒ n, s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      have M : âˆ€ n : â„•, MeasurableSet (s âˆ© t n) := fun n => hs.inter (t_meas n)
      rw [lintegral_iUnion M]
      exact pairwise_disjoint_mono t_disj fun n => inter_subset_right
    _ = âˆ«â» x in s, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by
      rw [â† inter_iUnion, inter_eq_self_of_subset_left t_cover]
    _ = (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s := by
      simp only [lintegral_add_right' _ aemeasurable_const, setLIntegral_const]"
Mathlib/Topology/MetricSpace/HausdorffDistance.lean,EMetric.hausdorffEdist_self,hausdorffEdist_self,75499222cc11ae5a47a99ba69c3066b962a0dc6f,":= by
  simp only [hausdorffEdist_def, sup_idem, ENNReal.supáµ¢_eq_zero]
  exact fun x hx => infEdist_zero_of_mem hx","error:  unknown constant 'ENNReal.supáµ¢_eq_zero'
error:  type mismatch
  fun x hx â†¦ infEdist_zero_of_mem hx
has type
  âˆ€ (x : ?m.38268) (hx : ?m.38303 x âˆˆ ?m.38304 x), infEdist (?m.38303 x) (?m.38304 x) = 0 : Prop
but is expected to have type
  â¨† x âˆˆ s, infEdist x s = 0 : Prop",theorem hausdorffEdist_self : hausdorffEdist s s = 0 ,":= by
  simp only [hausdorffEdist_def, sup_idem, ENNReal.iSup_eq_zero]
  exact fun x hx => infEdist_zero_of_mem hx"
Mathlib/AlgebraicGeometry/EllipticCurve/DivisionPolynomial/Degree.lean,WeierstrassCurve.coeff_Î¨Sq,coeff_Î¨Sq,409be1ff4c306030afd38a2641547686c28f2646,":= by
  induction n using Int.negInduction with
  | nat n => exact_mod_cast (W.natDegree_coeff_Î¨Sq_ofNat n).right
  | neg ih => simp_rw [Î¨Sq_neg, Int.natAbs_neg, â† Int.cast_pow, neg_sq, Int.cast_pow, ih]","error:  invalid argument, variable is not a proposition or let-declaration
error:  simp made no progress",lemma coeff_Î¨Sq (n : â„¤) : (W.Î¨Sq n).coeff (n.natAbs ^ 2 - 1) = n ^ 2 ,":= by
  induction n using Int.negInduction with
  | nat n => exact_mod_cast (W.natDegree_coeff_Î¨Sq_ofNat n).right
  | neg => rwa [Î¨Sq_neg, Int.natAbs_neg, â† Int.cast_pow, neg_sq, Int.cast_pow]"
Mathlib/Data/Nat/Hyperoperation.lean,hyperoperation_one,hyperoperation_one,dc0b2fb410ce57ee8ea5b9ce5b357ce030465e7a,":= by
  ext m k
  induction' k with bn bih
  Â· rw [Nat.add_zero m, hyperoperation]
  Â· rw [hyperoperation_recursion, bih, hyperoperation_zero]
    exact â† Nat.add_assoc' m bn 1","error:  invalid use of `(<- ...)`, must be nested inside a 'do' expression",theorem hyperoperation_one : hyperoperation 1 = (Â· + Â·) ,":= by
  ext m k
  induction' k with bn bih
  Â· rw [Nat.add_zero m, hyperoperation]
  Â· rw [hyperoperation_recursion, bih, hyperoperation_zero]
    exact Nat.add_assoc m bn 1"
Mathlib/LinearAlgebra/Matrix/Block.lean,Matrix.blockTriangular_inv_of_blockTriangular,blockTriangular_inv_of_blockTriangular,55d59ba16b6157dd1f4809bc6f28b8597e2db8d2,":= by
  clear N
  induction' hs : univ.image b using Finset.strongInduction with s ih generalizing m
  subst hs
  intro i j hij
  haveI : Inhabited m := âŸ¨iâŸ©
  let k := (univ.image b).max' (univ_nonempty.image _)
  let b' := fun i : { a // b a < k } => b â†‘i
  let A := M.toBlock (fun i => b i < k) fun j => b j < k
  obtain hbi | hi : b i = k âˆ¨ _ := (le_max' _ (b i) <| mem_image_of_mem _ <| mem_univ _).eq_or_lt
  Â· have : Mâ»Â¹.toBlock (fun i => k â‰¤ b i) (fun i => b i < k) âŸ¨i, hbi.geâŸ© âŸ¨j, hbi â–¸ hijâŸ© = 0 := by
      simp only [toBlock_inverse_eq_zero hM k, Matrix.zero_apply]
    simp [this.symm]
  haveI : Invertible A := hM.invertibleToBlock _
  have hA : A.BlockTriangular b' := hM.submatrix
  have hb' : image b' univ âŠ‚ image b univ := by
    convert image_subtype_univ_ssubset_image_univ k b _ (fun a => a < k) (lt_irrefl _)
    convert max'_mem (Î± := Î±) _ _
  have hij' : b' âŸ¨j, hij.trans hiâŸ© < b' âŸ¨i, hiâŸ© := by simp_rw [Subtype.coe_mk, hij]
  simp [hM.inv_toBlock k, (ih (image b' univ) hb' hA rfl hij').symm]",error:  simp made no progress,"theorem blockTriangular_inv_of_blockTriangular [LinearOrder Î±] [Invertible M]
    (hM : BlockTriangular M b) : BlockTriangular Mâ»Â¹ b ",":= by
  clear N
  induction' hs : univ.image b using Finset.strongInduction with s ih generalizing m
  subst hs
  intro i j hij
  haveI : Inhabited m := âŸ¨iâŸ©
  let k := (univ.image b).max' (univ_nonempty.image _)
  let b' := fun i : { a // b a < k } => b â†‘i
  let A := M.toBlock (fun i => b i < k) fun j => b j < k
  obtain hbi | hi : b i = k âˆ¨ _ := (le_max' _ (b i) <| mem_image_of_mem _ <| mem_univ _).eq_or_lt
  Â· have : Mâ»Â¹.toBlock (fun i => k â‰¤ b i) (fun i => b i < k) âŸ¨i, hbi.geâŸ© âŸ¨j, hbi â–¸ hijâŸ© = 0 := by
      simp only [toBlock_inverse_eq_zero hM k, Matrix.zero_apply]
    simp [this.symm]
  haveI : Invertible A := hM.invertibleToBlock _
  have hA : A.BlockTriangular b' := hM.submatrix
  have hb' : image b' univ âŠ‚ image b univ := by
    convert image_subtype_univ_ssubset_image_univ k b _ (fun a => a < k) (lt_irrefl _)
    convert max'_mem (Î± := Î±) _ _
  have hij' : b' âŸ¨j, hij.trans hiâŸ© < b' âŸ¨i, hiâŸ© := by simp_rw [hij]
  simp [hM.inv_toBlock k, (ih (image b' univ) hb' hA rfl hij').symm]"
Mathlib/Analysis/NormedSpace/MazurUlam.lean,IsometryEquiv.midpoint_fixed,midpoint_fixed,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  set z := midpoint â„ x y
  set s := { e : PE â‰ƒáµ¢ PE | e x = x âˆ§ e y = y }
  haveI : Nonempty s := âŸ¨âŸ¨IsometryEquiv.refl PE, rfl, rflâŸ©âŸ©
  have h_bdd : BddAbove (range fun e : s => dist ((e : PE â‰ƒáµ¢ PE) z) z) := by
    refine' âŸ¨dist x z + dist x z, forall_range_iff.2 <| Subtype.forall.2 _âŸ©
    rintro e âŸ¨hx, _âŸ©
    calc
      dist (e z) z â‰¤ dist (e z) x + dist x z := dist_triangle (e z) x z
      _ = dist (e x) (e z) + dist x z := by rw [hx, dist_comm]
      _ = dist x z + dist x z := by erw [e.dist_eq x z]
  set R : PE â‰ƒáµ¢ PE := (pointReflection â„ z).toIsometryEquiv
  set f : PE â‰ƒáµ¢ PE â†’ PE â‰ƒáµ¢ PE := fun e => ((e.trans R).trans e.symm).trans R
  have hf_dist : âˆ€ e, dist (f e z) z = 2 * dist (e z) z := by
    intro e
    dsimp
    rw [dist_pointReflection_fixed, â† e.dist_eq, e.apply_symm_apply,
      dist_pointReflection_self_real, dist_comm]
  have hf_maps_to : MapsTo f s s := by
    rintro e âŸ¨hx, hyâŸ©
    constructor <;> simp [hx, hy, e.symm_apply_eq.2 hx.symm, e.symm_apply_eq.2 hy.symm]
  set c := â¨† e : s, dist ((e : PE â‰ƒáµ¢ PE) z) z
  have : c â‰¤ c / 2 := by
    apply ciSup_le
    rintro âŸ¨e, heâŸ©
    simp only [Subtype.coe_mk, le_div_iff' (zero_lt_two' â„), â† hf_dist]
    exact le_ciSup h_bdd âŸ¨f e, hf_maps_to heâŸ©
  replace : c â‰¤ 0 := by linarith
  refine' fun e hx hy => dist_le_zero.1 (le_trans _ this)
  exact le_ciSup h_bdd âŸ¨e, hx, hyâŸ©","warning:  `Set.forall_range_iff` has been deprecated, use `Set.forall_mem_range` instead
error:  dsimp made no progress
error:  simp made no progress
error:  simp made no progress
error:  unsolved goals
case intro.left
E : Type u_1
PE : Type u_2
F : Type u_3
PF : Type u_4
instâœâ· : NormedAddCommGroup E
instâœâ¶ : NormedSpace â„ E
instâœâµ : MetricSpace PE
instâœâ´ : NormedAddTorsor E PE
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : NormedSpace â„ F
instâœÂ¹ : MetricSpace PF
instâœ : NormedAddTorsor F PF
x y : PE
z : PE := midpoint â„ x y
s : Set (PE â‰ƒáµ¢ PE) := {e | e x = x âˆ§ e y = y}
this : Nonempty â†‘s
h_bdd : BddAbove (range fun e â†¦ dist (â†‘e z) z)
R : PE â‰ƒáµ¢ PE := (pointReflection â„ z).toIsometryEquiv
f : PE â‰ƒáµ¢ PE â†’ PE â‰ƒáµ¢ PE := fun e â†¦ ((e.trans R).trans e.symm).trans R
hf_dist : âˆ€ (e : PE â‰ƒáµ¢ PE), dist ((f e) z) z = 2 * dist (e z) z
e : PE â‰ƒáµ¢ PE
hx : e x = x
hy : e y = y
âŠ¢ (f e) x = x

case intro.right
E : Type u_1
PE : Type u_2
F : Type u_3
PF : Type u_4
instâœâ· : NormedAddCommGroup E
instâœâ¶ : NormedSpace â„ E
instâœâµ : MetricSpace PE
instâœâ´ : NormedAddTorsor E PE
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : NormedSpace â„ F
instâœÂ¹ : MetricSpace PF
instâœ : NormedAddTorsor F PF
x y : PE
z : PE := midpoint â„ x y
s : Set (PE â‰ƒáµ¢ PE) := {e | e x = x âˆ§ e y = y}
this : Nonempty â†‘s
h_bdd : BddAbove (range fun e â†¦ dist (â†‘e z) z)
R : PE â‰ƒáµ¢ PE := (pointReflection â„ z).toIsometryEquiv
f : PE â‰ƒáµ¢ PE â†’ PE â‰ƒáµ¢ PE := fun e â†¦ ((e.trans R).trans e.symm).trans R
hf_dist : âˆ€ (e : PE â‰ƒáµ¢ PE), dist ((f e) z) z = 2 * dist (e z) z
e : PE â‰ƒáµ¢ PE
hx : e x = x
hy : e y = y
âŠ¢ (f e) y = y","theorem midpoint_fixed {x y : PE} :
    âˆ€ e : PE â‰ƒáµ¢ PE, e x = x â†’ e y = y â†’ e (midpoint â„ x y) = midpoint â„ x y ",":= by
  set z := midpoint â„ x y
  set s := { e : PE â‰ƒáµ¢ PE | e x = x âˆ§ e y = y }
  haveI : Nonempty s := âŸ¨âŸ¨IsometryEquiv.refl PE, rfl, rflâŸ©âŸ©
  have h_bdd : BddAbove (range fun e : s => dist ((e : PE â‰ƒáµ¢ PE) z) z) := by
    refine âŸ¨dist x z + dist x z, forall_mem_range.2 <| Subtype.forall.2 ?_âŸ©
    rintro e âŸ¨hx, _âŸ©
    calc
      dist (e z) z â‰¤ dist (e z) x + dist x z := dist_triangle (e z) x z
      _ = dist (e x) (e z) + dist x z := by rw [hx, dist_comm]
      _ = dist x z + dist x z := by erw [e.dist_eq x z]
  set R : PE â‰ƒáµ¢ PE := (pointReflection â„ z).toIsometryEquiv
  set f : PE â‰ƒáµ¢ PE â†’ PE â‰ƒáµ¢ PE := fun e => ((e.trans R).trans e.symm).trans R
  have hf_dist : âˆ€ e, dist (f e z) z = 2 * dist (e z) z := by
    intro e
    dsimp [f, R]
    rw [dist_pointReflection_fixed, â† e.dist_eq, e.apply_symm_apply,
      dist_pointReflection_self_real, dist_comm]
  have hf_maps_to : MapsTo f s s := by
    rintro e âŸ¨hx, hyâŸ©
    constructor <;> simp [f, R, z, hx, hy, e.symm_apply_eq.2 hx.symm, e.symm_apply_eq.2 hy.symm]
  set c := â¨† e : s, dist ((e : PE â‰ƒáµ¢ PE) z) z
  have : c â‰¤ c / 2 := by
    apply ciSup_le
    rintro âŸ¨e, heâŸ©
    simp only [Subtype.coe_mk, le_div_iff' (zero_lt_two' â„), â† hf_dist]
    exact le_ciSup h_bdd âŸ¨f e, hf_maps_to heâŸ©
  replace : c â‰¤ 0 := by linarith
  refine fun e hx hy => dist_le_zero.1 (le_trans ?_ this)
  exact le_ciSup h_bdd âŸ¨e, hx, hyâŸ©"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,1bab9e3823740c27026995d4c01c24399c2a8dfa,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine' âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, _âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, âŸ¨_, _, _âŸ©, _âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· 
      sorry
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero, Nat.zero_eq,
          Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 âˆˆ ?m.116759 âˆª ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.123443 â†’ ?m.123443
error:  unsolved goals
case zero
Î± : Type u_1
instâœâµ : MetricSpace Î±
Î² : Type u
instâœâ´ : SecondCountableTopology Î±
instâœÂ³ : MeasurableSpace Î±
instâœÂ² : OpensMeasurableSpace Î±
instâœÂ¹ : HasBesicovitchCovering Î±
Î¼ : Measure Î±
instâœ : IsFiniteMeasure Î¼
f : Î± â†’ Set â„
s : Set Î±
hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty
N : â„•
Ï„ : â„
hÏ„ : 1 < Ï„
hN : IsEmpty (SatelliteConfig Î± N Ï„)
P : Finset (Î± Ã— â„) â†’ Prop :=
  fun t â†¦ ((â†‘t).PairwiseDisjoint fun p â†¦ closedBall p.1 p.2) âˆ§ (âˆ€ p âˆˆ t, p.1 âˆˆ s) âˆ§ âˆ€ p âˆˆ t, p.2 âˆˆ f p.1
F : Finset (Î± Ã— â„) â†’ Finset (Î± Ã— â„)
hF :
  âˆ€ (t : Finset (Î± Ã— â„)),
    P t â†’
      t âŠ† F t âˆ§ P (F t) âˆ§ Î¼ (s \ â‹ƒ p âˆˆ F t, closedBall p.1 p.2) â‰¤ â†‘N / (â†‘N + 1) * Î¼ (s \ â‹ƒ p âˆˆ t, closedBall p.1 p.2)
u : â„• â†’ Finset (Î± Ã— â„) := fun n â†¦ F^[n] âˆ…
u_succ : âˆ€ (n : â„•), u n.succ = F (u n)
Pu : âˆ€ (n : â„•), P (u n)
A : âˆ€ (n : â„•), Î¼ (s \ â‹ƒ p âˆˆ â‹ƒ n, â†‘(u n), closedBall p.1 p.2) â‰¤ Î¼ (s \ â‹ƒ p âˆˆ u n, closedBall p.1 p.2)
âŠ¢ Î¼ (s \ â‹ƒ p âˆˆ id âˆ…, closedBall p.1 p.2) â‰¤ Î¼ s
error:  type mismatch
  mul_le_mul_left' IH (â†‘N / (â†‘N + 1))
has type
  â†‘N / (â†‘N + 1) * Î¼ (s \ â‹ƒ p âˆˆ u n, closedBall p.1 p.2) â‰¤ â†‘N / (â†‘N + 1) * ((â†‘N / (â†‘N + 1)) ^ n * Î¼ s) : Prop
but is expected to have type
  â†‘N / (â†‘N + 1) * Î¼ (s \ â‹ƒ p âˆˆ u n, closedBall p.1 p.2) â‰¤ (â†‘N / (â†‘N + 1)) ^ n * (â†‘N / (â†‘N + 1) * Î¼ s) : Prop
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133298 â†’ ?m.133298 â†’ Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.133434 â†’ ?m.133434 â†’ Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Î¼ : Measure Î±)
    [IsFiniteMeasure Î¼] (f : Î± â†’ Set â„) (s : Set Î±)
    (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty) :
    âˆƒ t : Set (Î± Ã— â„), t.Countable âˆ§ (âˆ€ p âˆˆ t, p.1 âˆˆ s) âˆ§ (âˆ€ p âˆˆ t, p.2 âˆˆ f p.1) âˆ§
      Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) = 0 âˆ§
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, ?_âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, âŸ¨?_, ?_, ?_âŸ©, ?_âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Î¼ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/MeasureTheory/Constructions/Polish.lean,MeasureTheory.measurableSet_range_of_continuous_injective,measurableSet_range_of_continuous_injective,ded82be28af61da8cf3266077ac67ad9bf41c841,":= by
  letI := upgradePolishSpace Î³
  obtain âŸ¨b, b_count, b_nonempty, hbâŸ© :
    âˆƒ b : Set (Set Î³), b.Countable âˆ§ âˆ… âˆ‰ b âˆ§ IsTopologicalBasis b := exists_countable_basis Î³
  haveI : Encodable b := b_count.toEncodable
  let A := { p : b Ã— b // Disjoint (p.1 : Set Î³) p.2 }
  have : âˆ€ p : A, âˆƒ q : Set Î²,
      f '' (p.1.1 : Set Î³) âŠ† q âˆ§ Disjoint (f '' (p.1.2 : Set Î³)) q âˆ§ MeasurableSet q := by
    intro p
    apply
      AnalyticSet.measurablySeparable ((hb.isOpen p.1.1.2).analyticSet_image f_cont)
        ((hb.isOpen p.1.2.2).analyticSet_image f_cont)
    exact Disjoint.image p.2 (f_inj.injOn univ) (subset_univ _) (subset_univ _)
  choose q hq1 hq2 q_meas using this
  let E : b â†’ Set Î² := fun s =>
    closure (f '' s) âˆ© â‹‚ (t : b) (ht : Disjoint s.1 t.1), q âŸ¨(s, t), htâŸ© \ q âŸ¨(t, s), ht.symmâŸ©
  obtain âŸ¨u, u_anti, u_pos, u_limâŸ© :
      âˆƒ u : â„• â†’ â„, StrictAnti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=
    exists_seq_strictAnti_tendsto (0 : â„)
  let F : â„• â†’ Set Î² := fun n => â‹ƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), E s
  suffices range f = â‹‚ n, F n by
    have E_meas : âˆ€ s : b, MeasurableSet (E s) := by
      intro b
      refine isClosed_closure.measurableSet.inter ?_
      refine MeasurableSet.iInter fun s => ?_
      exact MeasurableSet.iInter fun hs => (q_meas _).diff (q_meas _)
    have F_meas : âˆ€ n, MeasurableSet (F n) := by
      intro n
      refine MeasurableSet.iUnion fun s => ?_
      exact MeasurableSet.iUnion fun _ => E_meas _
    rw [this]
    exact MeasurableSet.iInter fun n => F_meas n
  apply Subset.antisymm
  Â· rintro x âŸ¨y, rflâŸ©
    refine mem_iInter.2 fun n => ?_
    obtain âŸ¨s, sb, ys, hsâŸ© : âˆƒ (s : Set Î³), s âˆˆ b âˆ§ y âˆˆ s âˆ§ s âŠ† ball y (u n / 2) := by
      apply hb.mem_nhds_iff.1
      exact ball_mem_nhds _ (half_pos (u_pos n))
    have diam_s : diam s â‰¤ u n := by
      apply (diam_mono hs isBounded_ball).trans
      convert diam_ball (x := y) (half_pos (u_pos n)).le
      ring
    refine mem_iUnion.2 âŸ¨âŸ¨s, sbâŸ©, ?_âŸ©
    refine mem_iUnion.2 âŸ¨âŸ¨isBounded_ball.subset hs, diam_sâŸ©, ?_âŸ©
    apply mem_inter (subset_closure (mem_image_of_mem _ ys))
    refine mem_iInter.2 fun t => mem_iInter.2 fun ht => âŸ¨?_,? _âŸ©
    Â· apply hq1
      exact mem_image_of_mem _ ys
    Â· apply disjoint_left.1 (hq2 âŸ¨(t, âŸ¨s, sbâŸ©), ht.symmâŸ©)
      exact mem_image_of_mem _ ys
  Â· intro x hx
    have C1 : âˆ€ n, âˆƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), x âˆˆ E s := fun n => by
      simpa only [F, mem_iUnion] using mem_iInter.1 hx n
    choose s hs hxs using C1
    have C2 : âˆ€ n, (s n).1.Nonempty := by
      intro n
      rw [nonempty_iff_ne_empty]
      intro hn
      have := (s n).2
      rw [hn] at this
      exact b_nonempty this
    choose y hy using C2
    have I : âˆ€ m n, ((s m).1 âˆ© (s n).1).Nonempty := by
      intro m n
      rw [â† not_disjoint_iff_nonempty_inter]
      by_contra! h
      have A : x âˆˆ q âŸ¨(s m, s n), hâŸ© \ q âŸ¨(s n, s m), h.symmâŸ© :=
        haveI := mem_iInter.1 (hxs m).2 (s n)
        (mem_iInter.1 this h : _)
      have B : x âˆˆ q âŸ¨(s n, s m), h.symmâŸ© \ q âŸ¨(s m, s n), hâŸ© :=
        haveI := mem_iInter.1 (hxs n).2 (s m)
        (mem_iInter.1 this h.symm : _)
      exact A.2 B.1
    have cauchy_y : CauchySeq y := by
      have : Tendsto (fun n => 2 * u n) atTop (ğ“ 0) := by
        simpa only [mul_zero] using u_lim.const_mul 2
      refine cauchySeq_of_le_tendsto_0' (fun n => 2 * u n) (fun m n hmn => ?_) this
      rcases I m n with âŸ¨z, zsm, zsnâŸ©
      calc
        dist (y m) (y n) â‰¤ dist (y m) z + dist z (y n) := dist_triangle _ _ _
        _ â‰¤ u m + u n :=
          (add_le_add ((dist_le_diam_of_mem (hs m).1 (hy m) zsm).trans (hs m).2)
            ((dist_le_diam_of_mem (hs n).1 zsn (hy n)).trans (hs n).2))
        _ â‰¤ 2 * u m := by linarith [u_anti.antitone hmn]
    haveI : Nonempty Î³ := âŸ¨y 0âŸ©
    let z := limUnder atTop y
    have y_lim : Tendsto y atTop (ğ“ z) := cauchy_y.tendsto_limUnder
    suffices f z = x by
      rw [â† this]
      exact mem_range_self _
    by_contra! hne
    obtain âŸ¨v, w, v_open, w_open, fzv, xw, hvwâŸ© := t2_separation hne
    obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´ > (0 : â„), ball z Î´ âŠ† f â»Â¹' v := by
      apply Metric.mem_nhds_iff.1
      exact f_cont.continuousAt.preimage_mem_nhds (v_open.mem_nhds fzv)
    obtain âŸ¨n, hnâŸ© : âˆƒ n, u n + dist (y n) z < Î´ :=
      haveI : Tendsto (fun n => u n + dist (y n) z) atTop (ğ“ 0) := by
        simpa only [add_zero] using u_lim.add (tendsto_iff_dist_tendsto_zero.1 y_lim)
      ((tendsto_order.1 this).2 _ Î´pos).exists
    have fsnv : f '' s n âŠ† v := by
      rw [image_subset_iff]
      apply Subset.trans _ hÎ´
      intro a ha
      calc
        dist a z â‰¤ dist a (y n) + dist (y n) z := dist_triangle _ _ _
        _ â‰¤ u n + dist (y n) z :=
          (add_le_add_right ((dist_le_diam_of_mem (hs n).1 ha (hy n)).trans (hs n).2) _)
        _ < Î´ := hn
    have : x âˆˆ closure v := closure_mono fsnv (hxs n).1
    exact disjoint_left.1 (hvw.closure_left w_open) this xw","error:  application type mismatch
  Disjoint.image p.property (Injective.injOn f_inj ?m.51560)
argument
  Injective.injOn f_inj ?m.51560
has type
  âˆ€ â¦ƒxâ‚‚ : Î³â¦„, xâ‚‚ âˆˆ ?m.51281 â†’ f ?m.51282 = f xâ‚‚ â†’ ?m.51282 = xâ‚‚ : Prop
but is expected to have type
  InjOn f ?m.51227 : Prop
error:  application type mismatch
  Injective.injOn f_inj univ
argument
  univ
has type
  Set ?m.51284 : Type ?u.51283
but is expected to have type
  ?m.51282 âˆˆ ?m.51281 : Prop","theorem measurableSet_range_of_continuous_injective {Î² : Type*} [TopologicalSpace Î³]
    [PolishSpace Î³] [TopologicalSpace Î²] [T2Space Î²] [MeasurableSpace Î²] [OpensMeasurableSpace Î²]
    {f : Î³ â†’ Î²} (f_cont : Continuous f) (f_inj : Injective f) :
    MeasurableSet (range f) ",":= by
  letI := upgradePolishSpace Î³
  obtain âŸ¨b, b_count, b_nonempty, hbâŸ© :
    âˆƒ b : Set (Set Î³), b.Countable âˆ§ âˆ… âˆ‰ b âˆ§ IsTopologicalBasis b := exists_countable_basis Î³
  haveI : Encodable b := b_count.toEncodable
  let A := { p : b Ã— b // Disjoint (p.1 : Set Î³) p.2 }
  have : âˆ€ p : A, âˆƒ q : Set Î²,
      f '' (p.1.1 : Set Î³) âŠ† q âˆ§ Disjoint (f '' (p.1.2 : Set Î³)) q âˆ§ MeasurableSet q := by
    intro p
    apply
      AnalyticSet.measurablySeparable ((hb.isOpen p.1.1.2).analyticSet_image f_cont)
        ((hb.isOpen p.1.2.2).analyticSet_image f_cont)
    exact Disjoint.image p.2 f_inj.injOn (subset_univ _) (subset_univ _)
  choose q hq1 hq2 q_meas using this
  let E : b â†’ Set Î² := fun s =>
    closure (f '' s) âˆ© â‹‚ (t : b) (ht : Disjoint s.1 t.1), q âŸ¨(s, t), htâŸ© \ q âŸ¨(t, s), ht.symmâŸ©
  obtain âŸ¨u, u_anti, u_pos, u_limâŸ© :
      âˆƒ u : â„• â†’ â„, StrictAnti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=
    exists_seq_strictAnti_tendsto (0 : â„)
  let F : â„• â†’ Set Î² := fun n => â‹ƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), E s
  suffices range f = â‹‚ n, F n by
    have E_meas : âˆ€ s : b, MeasurableSet (E s) := by
      intro b
      refine isClosed_closure.measurableSet.inter ?_
      refine MeasurableSet.iInter fun s => ?_
      exact MeasurableSet.iInter fun hs => (q_meas _).diff (q_meas _)
    have F_meas : âˆ€ n, MeasurableSet (F n) := by
      intro n
      refine MeasurableSet.iUnion fun s => ?_
      exact MeasurableSet.iUnion fun _ => E_meas _
    rw [this]
    exact MeasurableSet.iInter fun n => F_meas n
  apply Subset.antisymm
  Â· rintro x âŸ¨y, rflâŸ©
    refine mem_iInter.2 fun n => ?_
    obtain âŸ¨s, sb, ys, hsâŸ© : âˆƒ (s : Set Î³), s âˆˆ b âˆ§ y âˆˆ s âˆ§ s âŠ† ball y (u n / 2) := by
      apply hb.mem_nhds_iff.1
      exact ball_mem_nhds _ (half_pos (u_pos n))
    have diam_s : diam s â‰¤ u n := by
      apply (diam_mono hs isBounded_ball).trans
      convert diam_ball (x := y) (half_pos (u_pos n)).le
      ring
    refine mem_iUnion.2 âŸ¨âŸ¨s, sbâŸ©, ?_âŸ©
    refine mem_iUnion.2 âŸ¨âŸ¨isBounded_ball.subset hs, diam_sâŸ©, ?_âŸ©
    apply mem_inter (subset_closure (mem_image_of_mem _ ys))
    refine mem_iInter.2 fun t => mem_iInter.2 fun ht => âŸ¨?_, ?_âŸ©
    Â· apply hq1
      exact mem_image_of_mem _ ys
    Â· apply disjoint_left.1 (hq2 âŸ¨(t, âŸ¨s, sbâŸ©), ht.symmâŸ©)
      exact mem_image_of_mem _ ys
  Â· intro x hx
    have C1 : âˆ€ n, âˆƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), x âˆˆ E s := fun n => by
      simpa only [F, mem_iUnion] using mem_iInter.1 hx n
    choose s hs hxs using C1
    have C2 : âˆ€ n, (s n).1.Nonempty := by
      intro n
      rw [nonempty_iff_ne_empty]
      intro hn
      have := (s n).2
      rw [hn] at this
      exact b_nonempty this
    choose y hy using C2
    have I : âˆ€ m n, ((s m).1 âˆ© (s n).1).Nonempty := by
      intro m n
      rw [â† not_disjoint_iff_nonempty_inter]
      by_contra! h
      have A : x âˆˆ q âŸ¨(s m, s n), hâŸ© \ q âŸ¨(s n, s m), h.symmâŸ© :=
        haveI := mem_iInter.1 (hxs m).2 (s n)
        (mem_iInter.1 this h : _)
      have B : x âˆˆ q âŸ¨(s n, s m), h.symmâŸ© \ q âŸ¨(s m, s n), hâŸ© :=
        haveI := mem_iInter.1 (hxs n).2 (s m)
        (mem_iInter.1 this h.symm : _)
      exact A.2 B.1
    have cauchy_y : CauchySeq y := by
      have : Tendsto (fun n => 2 * u n) atTop (ğ“ 0) := by
        simpa only [mul_zero] using u_lim.const_mul 2
      refine cauchySeq_of_le_tendsto_0' (fun n => 2 * u n) (fun m n hmn => ?_) this
      rcases I m n with âŸ¨z, zsm, zsnâŸ©
      calc
        dist (y m) (y n) â‰¤ dist (y m) z + dist z (y n) := dist_triangle _ _ _
        _ â‰¤ u m + u n :=
          (add_le_add ((dist_le_diam_of_mem (hs m).1 (hy m) zsm).trans (hs m).2)
            ((dist_le_diam_of_mem (hs n).1 zsn (hy n)).trans (hs n).2))
        _ â‰¤ 2 * u m := by linarith [u_anti.antitone hmn]
    haveI : Nonempty Î³ := âŸ¨y 0âŸ©
    let z := limUnder atTop y
    have y_lim : Tendsto y atTop (ğ“ z) := cauchy_y.tendsto_limUnder
    suffices f z = x by
      rw [â† this]
      exact mem_range_self _
    by_contra! hne
    obtain âŸ¨v, w, v_open, w_open, fzv, xw, hvwâŸ© := t2_separation hne
    obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´ > (0 : â„), ball z Î´ âŠ† f â»Â¹' v := by
      apply Metric.mem_nhds_iff.1
      exact f_cont.continuousAt.preimage_mem_nhds (v_open.mem_nhds fzv)
    obtain âŸ¨n, hnâŸ© : âˆƒ n, u n + dist (y n) z < Î´ :=
      haveI : Tendsto (fun n => u n + dist (y n) z) atTop (ğ“ 0) := by
        simpa only [add_zero] using u_lim.add (tendsto_iff_dist_tendsto_zero.1 y_lim)
      ((tendsto_order.1 this).2 _ Î´pos).exists
    have fsnv : f '' s n âŠ† v := by
      rw [image_subset_iff]
      apply Subset.trans _ hÎ´
      intro a ha
      calc
        dist a z â‰¤ dist a (y n) + dist (y n) z := dist_triangle _ _ _
        _ â‰¤ u n + dist (y n) z :=
          (add_le_add_right ((dist_le_diam_of_mem (hs n).1 ha (hy n)).trans (hs n).2) _)
        _ < Î´ := hn
    have : x âˆˆ closure v := closure_mono fsnv (hxs n).1
    exact disjoint_left.1 (hvw.closure_left w_open) this xw"
Mathlib/Data/List/Perm.lean,List.get_permutations'Aux,get_permutations'Aux,087c7941921ce27045d4981c5b9573d28ea036fd,":= by
  induction' s with y s IH generalizing n
  Â· simp only [length, Nat.zero_add, Nat.lt_one_iff] at hn
    simp [hn]
  Â· cases n
    Â· simp [get]
    Â· simpa [get] using IH _ _","error:  don't know how to synthesize placeholder for argument 'hn'
context:
Î± : Type u_1
Î² : Type u_2
l lâ‚ lâ‚‚ : List Î±
a x y : Î±
s : List Î±
IH : âˆ€ (n : â„•) (hn : n < (permutations'Aux x s).length), (permutations'Aux x s).get âŸ¨n, hnâŸ© = insertNth n x s
nâœ : â„•
hn : nâœ + 1 < (permutations'Aux x (y :: s)).length
âŠ¢ nâœ < (permutations'Aux x s).length
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_of_mem` has been deprecated, use `List.get_of_mem` instead
warning:  `List.nodup_iff_nthLe_inj` has been deprecated, use `List.nodup_iff_injective_get` instead
warning:  `List.nthLe_permutations'Aux` has been deprecated, use `List.get_permutations'Aux` instead
warning:  `List.nthLe_permutations'Aux` has been deprecated, use `List.get_permutations'Aux` instead
warning:  `List.ext_nthLe` has been deprecated, use `List.ext_get` instead
warning:  `List.nthLe_insertNth_of_lt` has been deprecated, use `List.get_insertNth_of_lt` instead
warning:  `List.nthLe_insertNth_of_lt` has been deprecated, use `List.get_insertNth_of_lt` instead
warning:  `List.nthLe_insertNth_self` has been deprecated, use `List.get_insertNth_self` instead
warning:  `List.nthLe_insertNth_of_lt` has been deprecated, use `List.get_insertNth_of_lt` instead
warning:  `List.nthLe_insertNth_self` has been deprecated, use `List.get_insertNth_self` instead
warning:  `List.nthLe_insertNth_add_succ` has been deprecated, use `List.get_insertNth_add_succ` instead
warning:  `List.nthLe_insertNth_add_succ` has been deprecated, use `List.get_insertNth_add_succ` instead
warning:  `List.nthLe_insertNth_add_succ` has been deprecated, use `List.get_insertNth_add_succ` instead
warning:  `List.nthLe_permutations'Aux` has been deprecated, use `List.get_permutations'Aux` instead
warning:  `List.nthLe_permutations'Aux` has been deprecated, use `List.get_permutations'Aux` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_insertNth_of_lt` has been deprecated, use `List.get_insertNth_of_lt` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead
warning:  `List.nthLe_insertNth_of_lt` has been deprecated, use `List.get_insertNth_of_lt` instead
warning:  `List.nthLe_mem` has been deprecated, use `List.get_mem` instead","theorem get_permutations'Aux (s : List Î±) (x : Î±) (n : â„•)
    (hn : n < length (permutations'Aux x s)) :
    (permutations'Aux x s).get âŸ¨n, hnâŸ© = s.insertNth n x ",":= by
  simp [getElem_permutations'Aux]"
Mathlib/NumberTheory/ZetaValues.lean,bernoulliFourierCoeff_recurrence,bernoulliFourierCoeff_recurrence,55c626459c9c1251ad39f10c1b3a315a24c59132,":= by
  unfold bernoulliFourierCoeff
  rw [fourierCoeffOn_of_hasDerivAt zero_lt_one hn
      (fun x _ => (hasDerivAt_bernoulliFun k x).ofReal_comp)
      ((continuous_ofReal.comp <|
            continuous_const.mul <| Polynomial.continuous _).intervalIntegrable
        _ _)]
  simp_rw [ofReal_one, ofReal_zero, sub_zero, one_mul]
  rw [QuotientAddGroup.mk_zero, fourier_eval_zero, one_mul, â† ofReal_sub, bernoulliFun_eval_one,
    add_sub_cancel']
  congr 2
  Â· split_ifs <;> simp only [ofReal_one, ofReal_zero, one_mul]
  Â· simp_rw [ofReal_mul, ofReal_nat_cast, fourierCoeffOn.const_mul]","warning:  `add_sub_cancel'` has been deprecated, use `add_sub_cancel_left` instead
error:  unknown identifier 'ofReal_nat_cast'
error:  simp made no progress","theorem bernoulliFourierCoeff_recurrence (k : â„•) {n : â„¤} (hn : n â‰  0) :
    bernoulliFourierCoeff k n =
      1 / (-2 * Ï€ * I * n) * (ite (k = 1) 1 0 - k * bernoulliFourierCoeff (k - 1) n) ",":= by
  unfold bernoulliFourierCoeff
  rw [fourierCoeffOn_of_hasDerivAt zero_lt_one hn
      (fun x _ => (hasDerivAt_bernoulliFun k x).ofReal_comp)
      ((continuous_ofReal.comp <|
            continuous_const.mul <| Polynomial.continuous _).intervalIntegrable
        _ _)]
  simp_rw [ofReal_one, ofReal_zero, sub_zero, one_mul]
  rw [QuotientAddGroup.mk_zero, fourier_eval_zero, one_mul, â† ofReal_sub, bernoulliFun_eval_one,
    add_sub_cancel_left]
  congr 2
  Â· split_ifs <;> simp only [ofReal_one, ofReal_zero, one_mul]
  Â· simp_rw [ofReal_mul, ofReal_natCast, fourierCoeffOn.const_mul]"
Mathlib/AlgebraicGeometry/Morphisms/Basic.lean,AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.stableUnderBaseChange,IsLocal.stableUnderBaseChange,c3ca36af4af4d7c1439b381b6f8944434fdb73ce,":=
  MorphismProperty.StableUnderBaseChange.mk (targetAffineLocally_respectsIso hP.RespectsIso)
    (fun X Y S f g H => by
      have h01 := (hP.targetAffineLocallyIsLocal.openCover_TFAE
        (pullback.fst : pullback f g âŸ¶ X)).out 0 1
      rw [h01]
      use S.affineCover.pullbackCover f
      intro i
      have h03 := (hP.affine_openCover_TFAE g).out 0 3
      rw [h03] at H
      let e : pullback (pullback.fst : pullback f g âŸ¶ _) ((S.affineCover.pullbackCover f).map i) â‰…
          _ := by
        refine pullbackSymmetry _ _ â‰ªâ‰« pullbackRightPullbackFstIso f g _ â‰ªâ‰« ?_ â‰ªâ‰«
          (pullbackRightPullbackFstIso (S.affineCover.map i) g
            (pullback.snd : pullback f (S.affineCover.map i) âŸ¶ _)).symm
        exact asIso
          (pullback.map _ _ _ _ (ğŸ™ _) (ğŸ™ _) (ğŸ™ _) (by simpa using pullback.condition) (by simp))
      have : e.hom â‰« pullback.fst = pullback.snd := by simp [e]
      rw [â† this, (targetAffineLocally_respectsIso hP.1).cancel_left_isIso]
      apply hP.targetAffineLocallyPullbackFstOfRightOfStableUnderBaseChange hP'
      rw [â† pullbackSymmetry_hom_comp_snd, affine_cancel_left_isIso hP.1]
      apply H)","error:  invalid field 'targetAffineLocallyIsLocal', the environment does not contain 'AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.targetAffineLocallyIsLocal'
  hP
has type
  P.IsLocal
error:  unsolved goals
P : AffineTargetMorphismProperty
hP : P.IsLocal
hP' : P.StableUnderBaseChange
X Y S : Scheme
f : X âŸ¶ S
g : Y âŸ¶ S
H : targetAffineLocally P g
âŠ¢ targetAffineLocally P pullback.fst","theorem IsLocal.stableUnderBaseChange {P : AffineTargetMorphismProperty} (hP : P.IsLocal)
    (hP' : P.StableUnderBaseChange) : (targetAffineLocally P).StableUnderBaseChange ",":=
  MorphismProperty.StableUnderBaseChange.mk (targetAffineLocally_respectsIso hP.RespectsIso)
    (fun X Y S f g H => by
      have h01 := (hP.targetAffineLocally_isLocal.openCover_TFAE
        (pullback.fst : pullback f g âŸ¶ X)).out 0 1
      rw [h01]
      use S.affineCover.pullbackCover f
      intro i
      have h03 := (hP.affine_openCover_TFAE g).out 0 3
      rw [h03] at H
      let e : pullback (pullback.fst : pullback f g âŸ¶ _) ((S.affineCover.pullbackCover f).map i) â‰…
          _ := by
        refine pullbackSymmetry _ _ â‰ªâ‰« pullbackRightPullbackFstIso f g _ â‰ªâ‰« ?_ â‰ªâ‰«
          (pullbackRightPullbackFstIso (S.affineCover.map i) g
            (pullback.snd : pullback f (S.affineCover.map i) âŸ¶ _)).symm
        exact asIso
          (pullback.map _ _ _ _ (ğŸ™ _) (ğŸ™ _) (ğŸ™ _) (by simpa using pullback.condition) (by simp))
      have : e.hom â‰« pullback.fst = pullback.snd := by simp [e]
      rw [â† this, (targetAffineLocally_respectsIso hP.1).cancel_left_isIso]
      apply hP.targetAffineLocally_pullback_fst_of_right_of_stableUnderBaseChange hP'
      rw [â† pullbackSymmetry_hom_comp_snd, affine_cancel_left_isIso hP.1]
      apply H)"
Mathlib/Analysis/Convex/Slope.lean,ConvexOn.slope_mono_adjacent,ConvexOn.slope_mono_adjacent,009b0477e0161944b3592293b39c80c15ae7a75a,":= by
  have hxz := hxy.trans hyz
  rw [â† sub_pos] at hxy hxz hyz
  suffices f y / (y - x) + f y / (z - y) â‰¤ f x / (y - x) + f z / (z - y) by
    ring_nf  at thisâŠ¢
    linarith
  set a := (z - y) / (z - x)
  set b := (y - x) / (z - x)
  have hy : a â€¢ x + b â€¢ z = y := by
    field_simp
    rw [div_eq_iff] <;> [ring; linarith]
  have key :=
    hf.2 hx hz (show 0 â‰¤ a by apply div_nonneg <;> linarith)
      (show 0 â‰¤ b by apply div_nonneg <;> linarith)
      (show a + b = 1 by
        field_simp
        rw [div_eq_iff] <;> [ring; linarith])
  rw [hy] at key
  replace key := mul_le_mul_of_nonneg_left key hxz.le
  field_simp [hxy.ne', hyz.ne', hxz.ne', mul_comm (z - x) _]  at keyâŠ¢
  rw [div_le_div_right]
  Â· linarith
  Â· nlinarith","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?m.8171 / ?m.8172 = ?m.8173
ğ•œ : Type u_1
instâœ : LinearOrderedField ğ•œ
s : Set ğ•œ
f : ğ•œ â†’ ğ•œ
hf : ConvexOn ğ•œ s f
x y z : ğ•œ
hx : x âˆˆ s
hz : z âˆˆ s
hxy : 0 < y - x
hyz : 0 < z - y
hxz : 0 < z - x
a : ğ•œ := (z - y) / (z - x)
b : ğ•œ := (y - x) / (z - x)
âŠ¢ a * x + b * z = y
error:  simp made no progress
error:  linarith failed to find a contradiction
case a
ğ•œ : Type u_1
instâœ : LinearOrderedField ğ•œ
s : Set ğ•œ
f : ğ•œ â†’ ğ•œ
hf : ConvexOn ğ•œ s f
x y z : ğ•œ
hx : x âˆˆ s
hz : z âˆˆ s
hxy : 0 < y - x
hyz : 0 < z - y
hxz : 0 < z - x
a : ğ•œ := (z - y) / (z - x)
b : ğ•œ := (y - x) / (z - x)
hy : a â€¢ x + b â€¢ z = y
key : f y â‰¤ a * f x + b * f z
aâœ : f y * (z - y) + f y * (y - x) > f x * (z - y) + f z * (y - x)
âŠ¢ False
failed","theorem ConvexOn.slope_mono_adjacent (hf : ConvexOn ğ•œ s f) {x y z : ğ•œ} (hx : x âˆˆ s) (hz : z âˆˆ s)
    (hxy : x < y) (hyz : y < z) : (f y - f x) / (y - x) â‰¤ (f z - f y) / (z - y) ",":= by
  have hxz := hxy.trans hyz
  rw [â† sub_pos] at hxy hxz hyz
  suffices f y / (y - x) + f y / (z - y) â‰¤ f x / (y - x) + f z / (z - y) by
    ring_nf at this âŠ¢
    linarith
  set a := (z - y) / (z - x)
  set b := (y - x) / (z - x)
  have hy : a â€¢ x + b â€¢ z = y := by field_simp [a, b]; ring
  have key :=
    hf.2 hx hz (show 0 â‰¤ a by apply div_nonneg <;> linarith)
      (show 0 â‰¤ b by apply div_nonneg <;> linarith)
      (show a + b = 1 by field_simp [a, b])
  rw [hy] at key
  replace key := mul_le_mul_of_nonneg_left key hxz.le
  field_simp [a, b, mul_comm (z - x) _] at key âŠ¢
  rw [div_le_div_right]
  Â· linarith
  Â· nlinarith"
Mathlib/Topology/Metrizable/Uniformity.lean,PseudoMetricSpace.le_two_mul_dist_ofPreNNDist,le_two_mul_dist_ofPreNNDist,6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  rw [dist_ofPreNNDist, â† NNReal.coe_two, â† NNReal.coe_mul, NNReal.mul_iInf, NNReal.coe_le_coe]
  refine le_ciInf fun l => ?_
  have hdâ‚€_trans : Transitive fun x y => d x y = 0 := by
    intro a b c hab hbc
    rw [â† nonpos_iff_eq_zero]
    simpa only [nonpos_iff_eq_zero, hab, hbc, dist_self c, max_self, mul_zero] using hd a b c c
  haveI : IsTrans X fun x y => d x y = 0 := âŸ¨hdâ‚€_transâŸ©
  induction' hn : length l using Nat.strong_induction_on with n ihn generalizing x y l
  simp only at ihn
  subst n
  set L := zipWith d (x::l) (l ++ [y])
  have hL_len : length L = length l + 1 := by simp [L]
  rcases eq_or_ne (d x y) 0 with hdâ‚€ | hdâ‚€
  Â· simp only [hdâ‚€, zero_le]
  rsuffices âŸ¨z, z', hxz, hzz', hz'yâŸ© : âˆƒ z z' : X, d x z â‰¤ L.sum âˆ§ d z z' â‰¤ L.sum âˆ§ d z' y â‰¤ L.sum
  Â· exact (hd x z z' y).trans (mul_le_mul_left' (max_le hxz (max_le hzz' hz'y)) _)
  set s : Set â„• := { m : â„• | 2 * (take m L).sum â‰¤ L.sum }
  have hsâ‚€ : 0 âˆˆ s := by simp [s]
  have hsne : s.Nonempty := âŸ¨0, hsâ‚€âŸ©
  obtain âŸ¨M, hMl, hMsâŸ© : âˆƒ M â‰¤ length l, IsGreatest s M := by
    have hs_ub : length l âˆˆ upperBounds s := by
      intro m hm
      rw [â† not_lt, Nat.lt_iff_add_one_le, â† hL_len]
      intro hLm
      rw [mem_setOf_eq, take_all_of_le hLm, two_mul, add_le_iff_nonpos_left, nonpos_iff_eq_zero,
          sum_eq_zero_iff, â† forall_iff_forall_mem, forall_zipWith,
          â† chain_append_singleton_iff_forallâ‚‚]
          at hm <;>
        [skip; simp]
      exact hdâ‚€ (hm.rel (mem_append.2 <| Or.inr <| mem_singleton_self _))
    have hs_bdd : BddAbove s := âŸ¨length l, hs_ubâŸ©
    exact âŸ¨sSup s, csSup_le hsne hs_ub, âŸ¨Nat.sSup_mem hsne hs_bdd, fun k => le_csSup hs_bddâŸ©âŸ©
  have hM_lt : M < length L := by rwa [hL_len, Nat.lt_succ_iff]
  have hM_ltx : M < length (x::l) := lt_length_left_of_zipWith hM_lt
  have hM_lty : M < length (l ++ [y]) := lt_length_right_of_zipWith hM_lt
  refine' âŸ¨(x::l).get âŸ¨M, hM_ltxâŸ©, (l ++ [y]).get âŸ¨M, hM_ltyâŸ©, _, _, _âŸ©
  Â· cases M with
    | zero =>
      simp [dist_self, List.get]
    | succ M =>
      rw [Nat.succ_le_iff] at hMl
      have hMl' : length (take M l) = M := (length_take _ _).trans (min_eq_left hMl.le)
      simp only [List.get]
      refine' (ihn _ hMl _ _ _ hMl').trans _
      convert hMs.1.out
      rw [zipWith_distrib_take, take, take_succ, get?_append hMl, get?_eq_get hMl, â† Option.coe_def,
        Option.toList_some, take_append_of_le_length hMl.le]
  Â· exact single_le_sum (fun x _ => zero_le x) _ (mem_iff_get.2 âŸ¨âŸ¨M, hM_ltâŸ©, get_zipWithâŸ©)
  Â· rcases hMl.eq_or_lt with (rfl | hMl)
    Â· simp only [get_append_right' le_rfl, sub_self, get_singleton, dist_self, zero_le]
    rw [get_append _ hMl]
    have hlen : length (drop (M + 1) l) = length l - (M + 1) := length_drop _ _
    have hlen_lt : length l - (M + 1) < length l := Nat.sub_lt_of_pos_le M.succ_pos hMl
    refine' (ihn _ hlen_lt _ y _ hlen).trans _
    rw [cons_get_drop_succ]
    have hMs' : L.sum â‰¤ 2 * (L.take (M + 1)).sum :=
      not_lt.1 fun h => (hMs.2 h.le).not_lt M.lt_succ_self
    rw [â† sum_take_add_sum_drop L (M + 1), two_mul, add_le_add_iff_left, â† add_le_add_iff_right,
      sum_take_add_sum_drop, â† two_mul] at hMs'
    convert hMs'
    rwa [zipWith_distrib_drop, drop, drop_append_of_le_length]","warning:  `List.get?_append` has been deprecated
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (l ++ ?m.18110).get? M
case h.e'_3.h.e'_6.h.e'_4
X : Type u_1
d : X â†’ X â†’ â„â‰¥0
dist_self : âˆ€ (x : X), d x x = 0
dist_comm : âˆ€ (x y : X), d x y = d y x
hd : âˆ€ (xâ‚ xâ‚‚ xâ‚ƒ xâ‚„ : X), d xâ‚ xâ‚„ â‰¤ 2 * max (d xâ‚ xâ‚‚) (max (d xâ‚‚ xâ‚ƒ) (d xâ‚ƒ xâ‚„))
hdâ‚€_trans : Transitive fun x y â†¦ d x y = 0
this : IsTrans X fun x y â†¦ d x y = 0
x y : X
l : List X
ihn : âˆ€ m < l.length, âˆ€ (x y : X) (l : List X), l.length = m â†’ d x y â‰¤ 2 * (zipWith d (x :: l) (l ++ [y])).sum
L : List â„â‰¥0 := zipWith d (x :: l) (l ++ [y])
hL_len : L.length = l.length + 1
hdâ‚€ : d x y â‰  0
s : Set â„• := {m | 2 * (take m L).sum â‰¤ L.sum}
hsâ‚€ : 0 âˆˆ s
hsne : s.Nonempty
M : â„•
hMl : M < l.length
hMs : IsGreatest s (M + 1)
hM_lt : M + 1 < L.length
hM_ltx : M + 1 < (x :: l).length
hM_lty : M + 1 < (l ++ [y]).length
hMl' : (take M l).length = M
âŠ¢ zipWith d (x :: take M l) (take M l ++ [l.get âŸ¨M, â‹¯âŸ©]) =
    zipWith d (x :: take M l) (take M (l ++ [y]) ++ (l ++ [y])[M]?.toList)
warning:  `List.get_zipWith` has been deprecated, use `List.getElem_zipWith` instead
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.get_append` has been deprecated, use `List.getElem_append` instead","theorem le_two_mul_dist_ofPreNNDist (d : X â†’ X â†’ â„â‰¥0) (dist_self : âˆ€ x, d x x = 0)
    (dist_comm : âˆ€ x y, d x y = d y x)
    (hd : âˆ€ xâ‚ xâ‚‚ xâ‚ƒ xâ‚„, d xâ‚ xâ‚„ â‰¤ 2 * max (d xâ‚ xâ‚‚) (max (d xâ‚‚ xâ‚ƒ) (d xâ‚ƒ xâ‚„))) (x y : X) :
    â†‘(d x y) â‰¤ 2 * @dist X
      (@PseudoMetricSpace.toDist X (PseudoMetricSpace.ofPreNNDist d dist_self dist_comm)) x y ",":= by
  rw [dist_ofPreNNDist, â† NNReal.coe_two, â† NNReal.coe_mul, NNReal.mul_iInf, NNReal.coe_le_coe]
  refine le_ciInf fun l => ?_
  have hdâ‚€_trans : Transitive fun x y => d x y = 0 := by
    intro a b c hab hbc
    rw [â† nonpos_iff_eq_zero]
    simpa only [nonpos_iff_eq_zero, hab, hbc, dist_self c, max_self, mul_zero] using hd a b c c
  haveI : IsTrans X fun x y => d x y = 0 := âŸ¨hdâ‚€_transâŸ©
  induction' hn : length l using Nat.strong_induction_on with n ihn generalizing x y l
  simp only at ihn
  subst n
  set L := zipWith d (x::l) (l ++ [y])
  have hL_len : length L = length l + 1 := by simp [L]
  rcases eq_or_ne (d x y) 0 with hdâ‚€ | hdâ‚€
  Â· simp only [hdâ‚€, zero_le]
  rsuffices âŸ¨z, z', hxz, hzz', hz'yâŸ© : âˆƒ z z' : X, d x z â‰¤ L.sum âˆ§ d z z' â‰¤ L.sum âˆ§ d z' y â‰¤ L.sum
  Â· exact (hd x z z' y).trans (mul_le_mul_left' (max_le hxz (max_le hzz' hz'y)) _)
  set s : Set â„• := { m : â„• | 2 * (take m L).sum â‰¤ L.sum }
  have hsâ‚€ : 0 âˆˆ s := by simp [s]
  have hsne : s.Nonempty := âŸ¨0, hsâ‚€âŸ©
  obtain âŸ¨M, hMl, hMsâŸ© : âˆƒ M â‰¤ length l, IsGreatest s M := by
    have hs_ub : length l âˆˆ upperBounds s := by
      intro m hm
      rw [â† not_lt, Nat.lt_iff_add_one_le, â† hL_len]
      intro hLm
      rw [mem_setOf_eq, take_all_of_le hLm, two_mul, add_le_iff_nonpos_left, nonpos_iff_eq_zero,
          sum_eq_zero_iff, â† forall_iff_forall_mem, forall_zipWith,
          â† chain_append_singleton_iff_forallâ‚‚]
          at hm <;>
        [skip; simp]
      exact hdâ‚€ (hm.rel (mem_append.2 <| Or.inr <| mem_singleton_self _))
    have hs_bdd : BddAbove s := âŸ¨length l, hs_ubâŸ©
    exact âŸ¨sSup s, csSup_le hsne hs_ub, âŸ¨Nat.sSup_mem hsne hs_bdd, fun k => le_csSup hs_bddâŸ©âŸ©
  have hM_lt : M < length L := by rwa [hL_len, Nat.lt_succ_iff]
  have hM_ltx : M < length (x::l) := lt_length_left_of_zipWith hM_lt
  have hM_lty : M < length (l ++ [y]) := lt_length_right_of_zipWith hM_lt
  refine âŸ¨(x::l)[M], (l ++ [y])[M], ?_, ?_, ?_âŸ©
  Â· cases M with
    | zero =>
      simp [dist_self, List.get]
    | succ M =>
      rw [Nat.succ_le_iff] at hMl
      have hMl' : length (take M l) = M := (length_take _ _).trans (min_eq_left hMl.le)
      refine (ihn _ hMl _ _ _ hMl').trans ?_
      convert hMs.1.out
      rw [zipWith_distrib_take, take, take_succ, getElem?_append hMl, getElem?_eq_getElem hMl,
        â† Option.coe_def, Option.toList_some, take_append_of_le_length hMl.le, getElem_cons_succ]
  Â· exact single_le_sum (fun x _ => zero_le x) _ (mem_iff_get.2 âŸ¨âŸ¨M, hM_ltâŸ©, getElem_zipWithâŸ©)
  Â· rcases hMl.eq_or_lt with (rfl | hMl)
    Â· simp only [getElem_append_right' le_rfl, sub_self, getElem_singleton, dist_self, zero_le]
    rw [getElem_append _ hMl]
    have hlen : length (drop (M + 1) l) = length l - (M + 1) := length_drop _ _
    have hlen_lt : length l - (M + 1) < length l := Nat.sub_lt_of_pos_le M.succ_pos hMl
    refine (ihn _ hlen_lt _ y _ hlen).trans ?_
    rw [cons_getElem_drop_succ]
    have hMs' : L.sum â‰¤ 2 * (L.take (M + 1)).sum :=
      not_lt.1 fun h => (hMs.2 h.le).not_lt M.lt_succ_self
    rw [â† sum_take_add_sum_drop L (M + 1), two_mul, add_le_add_iff_left, â† add_le_add_iff_right,
      sum_take_add_sum_drop, â† two_mul] at hMs'
    convert hMs'
    rwa [zipWith_distrib_drop, drop, drop_append_of_le_length]"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,LipschitzWith.hausdorffMeasure_image_le,hausdorffMeasure_image_le,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine' iSup_le fun R => iSup_le fun hR => _
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine' ENNReal.tsum_le_tsum fun n => _
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left s) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set X : Type u_2
but is expected to have type
  ?m.169595 âˆˆ t n âˆ© ?m.169594 : Prop
error:  simp made no progress","theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s ",":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.LiftRel.trans,LiftRel.trans,88f252d9ef6777980e9cb4396094e178f3ed4acb,":=
  fun s t u h1 h2 => by
  refine âŸ¨fun s u => âˆƒ t, LiftRel R s t âˆ§ LiftRel R t u, âŸ¨t, h1, h2âŸ©, fun {s u} h => ?_âŸ©
  rcases h with âŸ¨t, h1, h2âŸ©
  have h1 := liftRel_dest h1
  have h2 := liftRel_dest h2
  refine
    Computation.liftRel_def.2
      âŸ¨(Computation.terminates_of_liftRel h1).trans (Computation.terminates_of_liftRel h2),
        fun {a c} ha hc => ?_âŸ©
  rcases h1.left ha with âŸ¨b, hb, t1âŸ©
  have t2 := Computation.rel_of_liftRel h2 hb hc
  cases' a with a <;> cases' c with c
  Â· trivial
  Â· cases b
    Â· cases t2
    Â· cases t1
  Â· cases a
    cases' b with b
    Â· cases t1
    Â· cases b
      cases t2
  Â· cases' a with a s
    cases' b with b
    Â· cases t1
    cases' b with b t
    cases' c with c u
    cases' t1 with ab st
    cases' t2 with bc tu
    exact âŸ¨H ab bc, t, st, tuâŸ©","error:  unknown identifier 'liftRel_dest'
error:  unsolved goals
case intro.intro
Î± : Type u
Î² : Type v
Î³ : Type w
R : Î± â†’ Î± â†’ Prop
H : Transitive R
sâœ tâœ uâœ : WSeq Î±
h1âœ : LiftRel R sâœ tâœ
h2âœ : LiftRel R tâœ uâœ
s u t : WSeq Î±
h1 : LiftRel R s t
h2 : LiftRel R t u
âŠ¢ Computation.LiftRel (LiftRelO R fun s u â†¦ âˆƒ t, LiftRel R s t âˆ§ LiftRel R t u) s.destruct u.destruct",theorem LiftRel.trans (R : Î± â†’ Î± â†’ Prop) (H : Transitive R) : Transitive (LiftRel R) ,":=
  fun s t u h1 h2 => by
  refine âŸ¨fun s u => âˆƒ t, LiftRel R s t âˆ§ LiftRel R t u, âŸ¨t, h1, h2âŸ©, fun {s u} h => ?_âŸ©
  rcases h with âŸ¨t, h1, h2âŸ©
  have h1 := liftRel_destruct h1
  have h2 := liftRel_destruct h2
  refine
    Computation.liftRel_def.2
      âŸ¨(Computation.terminates_of_liftRel h1).trans (Computation.terminates_of_liftRel h2),
        fun {a c} ha hc => ?_âŸ©
  rcases h1.left ha with âŸ¨b, hb, t1âŸ©
  have t2 := Computation.rel_of_liftRel h2 hb hc
  cases' a with a <;> cases' c with c
  Â· trivial
  Â· cases b
    Â· cases t2
    Â· cases t1
  Â· cases a
    cases' b with b
    Â· cases t1
    Â· cases b
      cases t2
  Â· cases' a with a s
    cases' b with b
    Â· cases t1
    cases' b with b t
    cases' c with c u
    cases' t1 with ab st
    cases' t2 with bc tu
    exact âŸ¨H ab bc, t, st, tuâŸ©"
Mathlib/SetTheory/Cardinal/Divisibility.lean,Cardinal.nat_is_prime_iff,nat_is_prime_iff,9b5d788d575748c82ffdfc08ef4aaf0a3c6023f0,":= by
  simp only [Prime, Nat.prime_iff]
  refine and_congr (by simp) (and_congr ?_ âŸ¨fun h b c hbc => ?_, fun h b c hbc => ?_âŸ©)
  Â· simp only [isUnit_iff, Nat.isUnit_iff]
    exact mod_cast Iff.rfl
  Â· exact mod_cast h b c (mod_cast hbc)
  cases' lt_or_le (b * c) â„µâ‚€ with h' h'
  Â· rcases mul_lt_aleph0_iff.mp h' with (rfl | rfl | âŸ¨hb, hcâŸ©)
    Â· simp
    Â· simp
    lift b to â„• using hb
    lift c to â„• using hc
    exact mod_cast h b c (mod_cast hbc)
  rcases aleph0_le_mul_iff.mp h' with âŸ¨hb, hc, hâ„µâ‚€âŸ©
  have hn : (n : Cardinal) â‰  0 := by
    intro h
    rw [h, zero_dvd_iff, mul_eq_zero] at hbc
    cases hbc <;> contradiction
  wlog hâ„µâ‚€b : â„µâ‚€ â‰¤ b
  refine (this h c b ?_ ?_ hc hb hâ„µâ‚€.symm hn (hâ„µâ‚€.resolve_left hâ„µâ‚€b)).symm <;> try assumption
  Â· rwa [mul_comm] at hbc
  Â· rwa [mul_comm] at h'
  Â· exact Or.inl (dvd_of_le_of_aleph0_le hn ((nat_lt_aleph0 n).le.trans hâ„µâ‚€b) hâ„µâ‚€b)","error:  don't know how to synthesize implicit argument 'm'
  @this ?m.21864 ?m.21865 n ?m.21867 h c b ?m.21881 ?m.21882 hc hb (Or.symm hâ„µâ‚€) hn (Or.resolve_left hâ„µâ‚€ hâ„µâ‚€b)
context:
a bâœ : Cardinal.{u}
n m : â„•
h : âˆ€ (a b : â„•), n âˆ£ a * b â†’ n âˆ£ a âˆ¨ n âˆ£ b
b c : Cardinal.{u_1}
hbc : â†‘n âˆ£ b * c
h' : â„µâ‚€ â‰¤ b * c
hb : b â‰  0
hc : c â‰  0
hâ„µâ‚€ : â„µâ‚€ â‰¤ b âˆ¨ â„µâ‚€ â‰¤ c
hn : â†‘n â‰  0
this :
  âˆ€ {a b : Cardinal.{u}} {n : â„•} {m : â„•},
    (âˆ€ (a b : â„•), n âˆ£ a * b â†’ n âˆ£ a âˆ¨ n âˆ£ b) â†’
      âˆ€ (b c : Cardinal.{u_1}),
        â†‘n âˆ£ b * c â†’ â„µâ‚€ â‰¤ b * c â†’ b â‰  0 â†’ c â‰  0 â†’ â„µâ‚€ â‰¤ b âˆ¨ â„µâ‚€ â‰¤ c â†’ â†‘n â‰  0 â†’ â„µâ‚€ â‰¤ b â†’ â†‘n âˆ£ b âˆ¨ â†‘n âˆ£ c
hâ„µâ‚€b : Â¬â„µâ‚€ â‰¤ b
âŠ¢ â„•
error:  don't know how to synthesize implicit argument 'b'
  @this ?m.21864 ?m.21865 n ?m.21867 h c b ?m.21881 ?m.21882 hc hb (Or.symm hâ„µâ‚€) hn (Or.resolve_left hâ„µâ‚€ hâ„µâ‚€b)
context:
a bâœ : Cardinal.{u}
n m : â„•
h : âˆ€ (a b : â„•), n âˆ£ a * b â†’ n âˆ£ a âˆ¨ n âˆ£ b
b c : Cardinal.{u_1}
hbc : â†‘n âˆ£ b * c
h' : â„µâ‚€ â‰¤ b * c
hb : b â‰  0
hc : c â‰  0
hâ„µâ‚€ : â„µâ‚€ â‰¤ b âˆ¨ â„µâ‚€ â‰¤ c
hn : â†‘n â‰  0
this :
  âˆ€ {a b : Cardinal.{u}} {n : â„•} {m : â„•},
    (âˆ€ (a b : â„•), n âˆ£ a * b â†’ n âˆ£ a âˆ¨ n âˆ£ b) â†’
      âˆ€ (b c : Cardinal.{u_1}),
        â†‘n âˆ£ b * c â†’ â„µâ‚€ â‰¤ b * c â†’ b â‰  0 â†’ c â‰  0 â†’ â„µâ‚€ â‰¤ b âˆ¨ â„µâ‚€ â‰¤ c â†’ â†‘n â‰  0 â†’ â„µâ‚€ â‰¤ b â†’ â†‘n âˆ£ b âˆ¨ â†‘n âˆ£ c
hâ„µâ‚€b : Â¬â„µâ‚€ â‰¤ b
âŠ¢ Cardinal.{u}
error:  don't know how to synthesize implicit argument 'a'
  @this ?m.21864 ?m.21865 n ?m.21867 h c b ?m.21881 ?m.21882 hc hb (Or.symm hâ„µâ‚€) hn (Or.resolve_left hâ„µâ‚€ hâ„µâ‚€b)
context:
a bâœ : Cardinal.{u}
n m : â„•
h : âˆ€ (a b : â„•), n âˆ£ a * b â†’ n âˆ£ a âˆ¨ n âˆ£ b
b c : Cardinal.{u_1}
hbc : â†‘n âˆ£ b * c
h' : â„µâ‚€ â‰¤ b * c
hb : b â‰  0
hc : c â‰  0
hâ„µâ‚€ : â„µâ‚€ â‰¤ b âˆ¨ â„µâ‚€ â‰¤ c
hn : â†‘n â‰  0
this :
  âˆ€ {a b : Cardinal.{u}} {n : â„•} {m : â„•},
    (âˆ€ (a b : â„•), n âˆ£ a * b â†’ n âˆ£ a âˆ¨ n âˆ£ b) â†’
      âˆ€ (b c : Cardinal.{u_1}),
        â†‘n âˆ£ b * c â†’ â„µâ‚€ â‰¤ b * c â†’ b â‰  0 â†’ c â‰  0 â†’ â„µâ‚€ â‰¤ b âˆ¨ â„µâ‚€ â‰¤ c â†’ â†‘n â‰  0 â†’ â„µâ‚€ â‰¤ b â†’ â†‘n âˆ£ b âˆ¨ â†‘n âˆ£ c
hâ„µâ‚€b : Â¬â„µâ‚€ â‰¤ b
âŠ¢ Cardinal.{u}
error:  unsolved goals
case refine_3.inr.intro.intro.inr
a bâœ : Cardinal.{u}
n m : â„•
h : âˆ€ (a b : â„•), n âˆ£ a * b â†’ n âˆ£ a âˆ¨ n âˆ£ b
b c : Cardinal.{u_1}
hbc : â†‘n âˆ£ b * c
h' : â„µâ‚€ â‰¤ b * c
hb : b â‰  0
hc : c â‰  0
hâ„µâ‚€ : â„µâ‚€ â‰¤ b âˆ¨ â„µâ‚€ â‰¤ c
hn : â†‘n â‰  0
this :
  âˆ€ {a b : Cardinal.{u}} {n : â„•} {m : â„•},
    (âˆ€ (a b : â„•), n âˆ£ a * b â†’ n âˆ£ a âˆ¨ n âˆ£ b) â†’
      âˆ€ (b c : Cardinal.{u_1}),
        â†‘n âˆ£ b * c â†’ â„µâ‚€ â‰¤ b * c â†’ b â‰  0 â†’ c â‰  0 â†’ â„µâ‚€ â‰¤ b âˆ¨ â„µâ‚€ â‰¤ c â†’ â†‘n â‰  0 â†’ â„µâ‚€ â‰¤ b â†’ â†‘n âˆ£ b âˆ¨ â†‘n âˆ£ c
hâ„µâ‚€b : Â¬â„µâ‚€ â‰¤ b
âŠ¢ â†‘n âˆ£ b âˆ¨ â†‘n âˆ£ c",theorem nat_is_prime_iff : Prime (n : Cardinal) â†” n.Prime ,":= by
  simp only [Prime, Nat.prime_iff]
  refine and_congr (by simp) (and_congr ?_ âŸ¨fun h b c hbc => ?_, fun h b c hbc => ?_âŸ©)
  Â· simp only [isUnit_iff, Nat.isUnit_iff]
    exact mod_cast Iff.rfl
  Â· exact mod_cast h b c (mod_cast hbc)
  cases' lt_or_le (b * c) â„µâ‚€ with h' h'
  Â· rcases mul_lt_aleph0_iff.mp h' with (rfl | rfl | âŸ¨hb, hcâŸ©)
    Â· simp
    Â· simp
    lift b to â„• using hb
    lift c to â„• using hc
    exact mod_cast h b c (mod_cast hbc)
  rcases aleph0_le_mul_iff.mp h' with âŸ¨hb, hc, hâ„µâ‚€âŸ©
  have hn : (n : Cardinal) â‰  0 := by
    intro h
    rw [h, zero_dvd_iff, mul_eq_zero] at hbc
    cases hbc <;> contradiction
  wlog hâ„µâ‚€b : â„µâ‚€ â‰¤ b
  apply (this h c b _ _ hc hb hâ„µâ‚€.symm hn (hâ„µâ‚€.resolve_left hâ„µâ‚€b)).symm <;> try assumption
  Â· rwa [mul_comm] at hbc
  Â· rwa [mul_comm] at h'
  Â· exact Or.inl (dvd_of_le_of_aleph0_le hn ((nat_lt_aleph0 n).le.trans hâ„µâ‚€b) hâ„µâ‚€b)"
Mathlib/Analysis/LocallyConvex/Basic.lean,Balanced.absorbs_self,Balanced.absorbs_self,513593924376092791e22fba3b83ac9cd9eb3061,":= by
  refine' âŸ¨1, fun a ha x hx => _âŸ©
  rw [mem_smul_set_iff_inv_smul_memâ‚€ (norm_pos_iff.1 <| zero_lt_one.trans_le ha)]
  refine' hA aâ»Â¹ _ (smul_mem_smul_set hx)
  rw [norm_inv]
  exact inv_le_one ha","error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  (Bornology.cobounded ğ•œ).1 {x | (fun a â†¦ A âŠ† a â€¢ A) x}
error:  no goals to be solved",theorem Balanced.absorbs_self (hA : Balanced ğ•œ A) : Absorbs ğ•œ A A ,":=
  .of_norm âŸ¨1, fun _ => hA.subset_smulâŸ©"
Mathlib/Analysis/SpecialFunctions/Pow/Real.lean,Complex.norm_natCast_cpow_of_pos,norm_natCast_cpow_of_pos,5972f1186b2ca6a1d047e1c045628b6e94c2181b,":= by
  rw [norm_eq_abs, â† ofReal_nat_cast, abs_cpow_eq_rpow_re_of_pos (Nat.cast_pos.mpr hn) _]","error:  unknown identifier 'ofReal_nat_cast'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.65118
n : â„•
hn : 0 < n
s : â„‚
âŠ¢ abs (â†‘n ^ s) = â†‘n ^ s.re","lemma norm_natCast_cpow_of_pos {n : â„•} (hn : 0 < n) (s : â„‚) :
    â€–(n : â„‚) ^ sâ€– = (n : â„) ^ (s.re) ",":= by
  rw [norm_eq_abs, â† ofReal_natCast, abs_cpow_eq_rpow_re_of_pos (Nat.cast_pos.mpr hn) _]"
Mathlib/Analysis/NormedSpace/Star/ContinuousFunctionalCalculus/Instances.lean,RCLike.nonUnitalContinuousFunctionalCalculus,RCLike.nonUnitalContinuousFunctionalCalculus,713f6374616d8f404b431a6a891b65b82cbbc913,"  predicate_zero := by
    rw [â† hpâ‚, Unitization.inr_zero ğ•œ]
    exact cfc_predicate_zero ğ•œ
  exists_cfc_of_predicate a ha := by
    let Ïˆ : C(Ïƒâ‚™ ğ•œ a, ğ•œ)â‚€ â†’â‹†â‚™â‚[ğ•œ] A := comp (inrRangeEquiv ğ•œ A).symm <|
      codRestrict (cfcâ‚™Aux hpâ‚ a ha) _ (cfcâ‚™Aux_mem_range_inr hpâ‚ a ha)
    have coe_Ïˆ (f : C(Ïƒâ‚™ ğ•œ a, ğ•œ)â‚€) : Ïˆ f = cfcâ‚™Aux hpâ‚ a ha f :=
      congr_arg Subtype.val <| (inrRangeEquiv ğ•œ A).apply_symm_apply
        âŸ¨cfcâ‚™Aux hpâ‚ a ha f, cfcâ‚™Aux_mem_range_inr hpâ‚ a ha fâŸ©
    refine âŸ¨Ïˆ, ?closedEmbedding, ?map_id, fun f â†¦ ?map_spec, fun f â†¦ ?isStarNormalâŸ©
    case closedEmbedding =>
      apply isometry_inr (ğ•œ := ğ•œ) (A := A) |>.closedEmbedding |>.of_comp_iff.mp
      have : inr âˆ˜ Ïˆ = cfcâ‚™Aux hpâ‚ a ha := by ext1; rw [Function.comp_apply, coe_Ïˆ]
      exact this â–¸ closedEmbedding_cfcâ‚™Aux hpâ‚ a ha
    case map_id => exact inr_injective (R := ğ•œ) <| coe_Ïˆ _ â–¸ cfcâ‚™Aux_id hpâ‚ a ha
    case map_spec =>
      exact quasispectrum_eq_spectrum_inr' ğ•œ ğ•œ (Ïˆ f) â–¸ coe_Ïˆ _ â–¸ spec_cfcâ‚™Aux hpâ‚ a ha f
    case isStarNormal => exact hpâ‚.mp <| coe_Ïˆ _ â–¸ cfcHom_predicate (R := ğ•œ) (hpâ‚.mpr ha) _","error:  'predicate_zero' is not a field of structure 'NonUnitalContinuousFunctionalCalculus'
error:  function expected at
  RCLike.nonUnitalContinuousFunctionalCalculus
term has type
  NonUnitalContinuousFunctionalCalculus ?m.317140 ?m.317148","theorem RCLike.nonUnitalContinuousFunctionalCalculus :
    NonUnitalContinuousFunctionalCalculus ğ•œ (p : A â†’ Prop) where
","  exists_cfc_of_predicate a ha := by
    let Ïˆ : C(Ïƒâ‚™ ğ•œ a, ğ•œ)â‚€ â†’â‹†â‚™â‚[ğ•œ] A := comp (inrRangeEquiv ğ•œ A).symm <|
      codRestrict (cfcâ‚™Aux hpâ‚ a ha) _ (cfcâ‚™Aux_mem_range_inr hpâ‚ a ha)
    have coe_Ïˆ (f : C(Ïƒâ‚™ ğ•œ a, ğ•œ)â‚€) : Ïˆ f = cfcâ‚™Aux hpâ‚ a ha f :=
      congr_arg Subtype.val <| (inrRangeEquiv ğ•œ A).apply_symm_apply
        âŸ¨cfcâ‚™Aux hpâ‚ a ha f, cfcâ‚™Aux_mem_range_inr hpâ‚ a ha fâŸ©
    refine âŸ¨Ïˆ, ?closedEmbedding, ?map_id, fun f â†¦ ?map_spec, fun f â†¦ ?isStarNormalâŸ©
    case closedEmbedding =>
      apply isometry_inr (ğ•œ := ğ•œ) (A := A) |>.closedEmbedding |>.of_comp_iff.mp
      have : inr âˆ˜ Ïˆ = cfcâ‚™Aux hpâ‚ a ha := by ext1; rw [Function.comp_apply, coe_Ïˆ]
      exact this â–¸ closedEmbedding_cfcâ‚™Aux hpâ‚ a ha
    case map_id => exact inr_injective (R := ğ•œ) <| coe_Ïˆ _ â–¸ cfcâ‚™Aux_id hpâ‚ a ha
    case map_spec =>
      exact quasispectrum_eq_spectrum_inr' ğ•œ ğ•œ (Ïˆ f) â–¸ coe_Ïˆ _ â–¸ spec_cfcâ‚™Aux hpâ‚ a ha f
    case isStarNormal => exact hpâ‚.mp <| coe_Ïˆ _ â–¸ cfcHom_predicate (R := ğ•œ) (hpâ‚.mpr ha) _"
Mathlib/RingTheory/Ideal/LocalRing.lean,LocalRing.surjective_units_map_of_local_ringHom,surjective_units_map_of_local_ringHom,41a78df6e2e4e32513e96b5c7c85aac6ed23ac1e,":= by
  intro a
  obtain âŸ¨b, hbâŸ© := hf (a : S)
  use (isUnit_of_isUnit_map f b (by rw [hb]; exact Units.isUnit _)).unit
  ext
  exact hb",error:  unknown identifier 'isUnit_of_isUnit_map',"theorem surjective_units_map_of_local_ringHom [CommRing R] [CommRing S] (f : R â†’+* S)
    (hf : Function.Surjective f) (h : IsLocalRingHom f) :
    Function.Surjective (Units.map <| f.toMonoidHom) ",":= by
  intro a
  obtain âŸ¨b, hbâŸ© := hf (a : S)
  use (isUnit_of_map_unit f b (by rw [hb]; exact Units.isUnit _)).unit
  ext
  exact hb"
Mathlib/FieldTheory/ChevalleyWarning.lean,char_dvd_card_solutions,char_dvd_card_solutions,2eaabc8998929678aa5be0e0139f3ea37acc7a44,":= by
  have hq : 0 < q - 1 := by rw [â† Fintype.card_units, Fintype.card_pos_iff]; exact âŸ¨1âŸ©
  let S : Finset (Ïƒ â†’ K) := {x | âˆ€ i âˆˆ s, eval x (f i) = 0}
  have hS (x : Ïƒ â†’ K) : x âˆˆ S â†” âˆ€ i âˆˆ s, eval x (f i) = 0 := by simp [S]
  let F : MvPolynomial Ïƒ K := âˆ i âˆˆ s, (1 - f i ^ (q - 1))
  have hF : âˆ€ x, eval x F = if x âˆˆ S then 1 else 0 := by
    intro x
    calc
      eval x F = âˆ i âˆˆ s, eval x (1 - f i ^ (q - 1)) := eval_prod s _ x
      _ = if x âˆˆ S then 1 else 0 := ?_
    simp only [(eval x).map_sub, (eval x).map_pow, (eval x).map_one]
    split_ifs with hx
    Â· apply Finset.prod_eq_one
      intro i hi
      rw [hS] at hx
      rw [hx i hi, zero_pow hq.ne', sub_zero]
    Â· obtain âŸ¨i, hi, hxâŸ© : âˆƒ i âˆˆ s, eval x (f i) â‰  0 := by
        simpa [hS, not_forall, Classical.not_imp] using hx
      apply Finset.prod_eq_zero hi
      rw [pow_card_sub_one_eq_one (eval x (f i)) hx, sub_self]
  have key : âˆ‘ x, eval x F = Fintype.card { x : Ïƒ â†’ K // âˆ€ i âˆˆ s, eval x (f i) = 0 } := by
    rw [Fintype.card_of_subtype S hS, card_eq_sum_ones, Nat.cast_sum, Nat.cast_one, â†
      Fintype.sum_extend_by_zero S, sum_congr rfl fun x _ => hF x]
  show p âˆ£ Fintype.card { x // âˆ€ i : Î¹, i âˆˆ s â†’ eval x (f i) = 0 }
  rw [â† CharP.cast_eq_zero_iff K, â† key]
  show (âˆ‘ x, eval x F) = 0
  apply F.sum_eval_eq_zero
  show F.totalDegree < (q - 1) * Fintype.card Ïƒ
  calc
    F.totalDegree â‰¤ âˆ‘ i âˆˆ s, (1 - f i ^ (q - 1)).totalDegree := totalDegree_finset_prod s _
    _ â‰¤ âˆ‘ i âˆˆ s, (q - 1) * (f i).totalDegree := sum_le_sum fun i _ => ?_
    _ = (q - 1) * âˆ‘ i âˆˆ s, (f i).totalDegree := (mul_sum ..).symm
    _ < (q - 1) * Fintype.card Ïƒ := by rwa [mul_lt_mul_left hq]
  show (1 - f i ^ (q - 1)).totalDegree â‰¤ (q - 1) * (f i).totalDegree
  calc
    (1 - f i ^ (q - 1)).totalDegree â‰¤
        max (1 : MvPolynomial Ïƒ K).totalDegree (f i ^ (q - 1)).totalDegree := totalDegree_sub _ _
    _ â‰¤ (f i ^ (q - 1)).totalDegree := by simp
    _ â‰¤ (q - 1) * (f i).totalDegree := totalDegree_pow _ _","error:  type mismatch
  {x | âˆ€ i âˆˆ s, (eval x) (f i) = 0}
has type
  Set (Ïƒ â†’ K) : Type (max u_2 u_1)
but is expected to have type
  Finset (Ïƒ â†’ K) : Type (max u_1 u_2)
error:  unsolved goals
K : Type u_1
Ïƒ : Type u_2
Î¹ : Type u_3
instâœâµ : Fintype K
instâœâ´ : Field K
instâœÂ³ : Fintype Ïƒ
instâœÂ² : DecidableEq Ïƒ
instâœÂ¹ : DecidableEq K
p : â„•
instâœ : CharP K p
s : Finset Î¹
f : Î¹ â†’ MvPolynomial Ïƒ K
h : âˆ‘ i âˆˆ s, (f i).totalDegree < Fintype.card Ïƒ
hq : 0 < q - 1
S : Finset (Ïƒ â†’ K) := sorryAx (Finset (Ïƒ â†’ K)) true
x : Ïƒ â†’ K
âŠ¢ x âˆˆ sorryAx (Finset (Ïƒ â†’ K)) true â†” âˆ€ i âˆˆ s, (eval x) (f i) = 0","theorem char_dvd_card_solutions_of_sum_lt {s : Finset Î¹} {f : Î¹ â†’ MvPolynomial Ïƒ K}
    (h : (âˆ‘ i âˆˆ s, (f i).totalDegree) < Fintype.card Ïƒ) :
    p âˆ£ Fintype.card { x : Ïƒ â†’ K // âˆ€ i âˆˆ s, eval x (f i) = 0 } ",":= by
  have hq : 0 < q - 1 := by rw [â† Fintype.card_units, Fintype.card_pos_iff]; exact âŸ¨1âŸ©
  let S : Finset (Ïƒ â†’ K) := { x âˆˆ univ | âˆ€ i âˆˆ s, eval x (f i) = 0 }.toFinset
  have hS : âˆ€ x : Ïƒ â†’ K, x âˆˆ S â†” âˆ€ i : Î¹, i âˆˆ s â†’ eval x (f i) = 0 := by
    intro x
    simp only [S, Set.toFinset_setOf, mem_univ, true_and, mem_filter]
  let F : MvPolynomial Ïƒ K := âˆ i âˆˆ s, (1 - f i ^ (q - 1))
  have hF : âˆ€ x, eval x F = if x âˆˆ S then 1 else 0 := by
    intro x
    calc
      eval x F = âˆ i âˆˆ s, eval x (1 - f i ^ (q - 1)) := eval_prod s _ x
      _ = if x âˆˆ S then 1 else 0 := ?_
    simp only [(eval x).map_sub, (eval x).map_pow, (eval x).map_one]
    split_ifs with hx
    Â· apply Finset.prod_eq_one
      intro i hi
      rw [hS] at hx
      rw [hx i hi, zero_pow hq.ne', sub_zero]
    Â· obtain âŸ¨i, hi, hxâŸ© : âˆƒ i âˆˆ s, eval x (f i) â‰  0 := by
        simpa [hS, not_forall, Classical.not_imp] using hx
      apply Finset.prod_eq_zero hi
      rw [pow_card_sub_one_eq_one (eval x (f i)) hx, sub_self]
  have key : âˆ‘ x, eval x F = Fintype.card { x : Ïƒ â†’ K // âˆ€ i âˆˆ s, eval x (f i) = 0 } := by
    rw [Fintype.card_of_subtype S hS, card_eq_sum_ones, Nat.cast_sum, Nat.cast_one, â†
      Fintype.sum_extend_by_zero S, sum_congr rfl fun x _ => hF x]
  show p âˆ£ Fintype.card { x // âˆ€ i : Î¹, i âˆˆ s â†’ eval x (f i) = 0 }
  rw [â† CharP.cast_eq_zero_iff K, â† key]
  show (âˆ‘ x, eval x F) = 0
  apply F.sum_eval_eq_zero
  show F.totalDegree < (q - 1) * Fintype.card Ïƒ
  calc
    F.totalDegree â‰¤ âˆ‘ i âˆˆ s, (1 - f i ^ (q - 1)).totalDegree := totalDegree_finset_prod s _
    _ â‰¤ âˆ‘ i âˆˆ s, (q - 1) * (f i).totalDegree := sum_le_sum fun i _ => ?_
    _ = (q - 1) * âˆ‘ i âˆˆ s, (f i).totalDegree := (mul_sum ..).symm
    _ < (q - 1) * Fintype.card Ïƒ := by rwa [mul_lt_mul_left hq]
  show (1 - f i ^ (q - 1)).totalDegree â‰¤ (q - 1) * (f i).totalDegree
  calc
    (1 - f i ^ (q - 1)).totalDegree â‰¤
        max (1 : MvPolynomial Ïƒ K).totalDegree (f i ^ (q - 1)).totalDegree := totalDegree_sub _ _
    _ â‰¤ (f i ^ (q - 1)).totalDegree := by simp
    _ â‰¤ (q - 1) * (f i).totalDegree := totalDegree_pow _ _"
Mathlib/NumberTheory/ArithmeticFunction.lean,ArithmeticFunction.sum_eq_iff_sum_smul_moebius_eq_on,sum_eq_iff_sum_smul_moebius_eq_on,8c86ef2b0a8795edffe59cd63522c7b3c716bd02,":= by
  constructor
  Â· intro h
    let G : = fun (n : â„•) => (âˆ‘ i âˆˆ n.divisors, f i)
    intro n hn hnP
    suffices âˆ‘ d âˆˆ n.divisors, Î¼ (n/d) â€¢ G d = f n from by
      rw [Nat.sum_divisorsAntidiagonal' (f := fun x y => Î¼ x â€¢ g y), â† this, sum_congr rfl]
      intro d hd
      rw [â† h d (Nat.pos_of_mem_divisors hd) <| hs d n (Nat.dvd_of_mem_divisors hd) hnP]
    rw [â† Nat.sum_divisorsAntidiagonal' (f := fun x y => Î¼ x â€¢ G y)]
    apply sum_eq_iff_sum_smul_moebius_eq.mp _ n hn
    intro _ _; rfl
  Â· intro h
    let F : = fun (n : â„•) => âˆ‘ x âˆˆ n.divisorsAntidiagonal, Î¼ x.fst â€¢ g x.snd
    intro n hn hnP
    suffices âˆ‘ d âˆˆ n.divisors, F d = g n from by
      rw [â† this, sum_congr rfl]
      intro d hd
      rw [â† h d (Nat.pos_of_mem_divisors hd) <| hs d n (Nat.dvd_of_mem_divisors hd) hnP]
    apply sum_eq_iff_sum_smul_moebius_eq.mpr _ n hn
    intro _ _; rfl","warning:  zeta does not have a doc string
warning:  Î¶ does not have a doc string
warning:  sigma does not have a doc string
warning:  Ïƒ does not have a doc string
warning:  cardFactors does not have a doc string
warning:  Î© does not have a doc string
warning:  cardDistinctFactors does not have a doc string
warning:  Ï‰ does not have a doc string
warning:  moebius does not have a doc string
warning:  Î¼ does not have a doc string
error:  unexpected token '='; expected term
error:  unsolved goals
case mp
R : Type u_1
instâœ : AddCommGroup R
f g : â„• â†’ R
s : Set â„•
hs : âˆ€ (m n : â„•), m âˆ£ n â†’ n âˆˆ s â†’ m âˆˆ s
h : âˆ€ n > 0, n âˆˆ s â†’ âˆ‘ i âˆˆ n.divisors, f i = g n
G : sorryAx (Sort ?u.556345) true := nomatch
âŠ¢ âˆ€ n > 0, n âˆˆ s â†’ âˆ‘ x âˆˆ n.divisorsAntidiagonal, Î¼ x.1 â€¢ g x.2 = f n
error:  unsolved goals
case mpr
R : Type u_1
instâœ : AddCommGroup R
f g : â„• â†’ R
s : Set â„•
hs : âˆ€ (m n : â„•), m âˆ£ n â†’ n âˆˆ s â†’ m âˆˆ s
âŠ¢ (âˆ€ n > 0, n âˆˆ s â†’ âˆ‘ x âˆˆ n.divisorsAntidiagonal, Î¼ x.1 â€¢ g x.2 = f n) â†’ âˆ€ n > 0, n âˆˆ s â†’ âˆ‘ i âˆˆ n.divisors, f i = g n","theorem sum_eq_iff_sum_smul_moebius_eq_on [AddCommGroup R] {f g : â„• â†’ R}
    (s : Set â„•) (hs : âˆ€ m n, m âˆ£ n â†’ n âˆˆ s â†’ m âˆˆ s) :
    (âˆ€ n > 0, n âˆˆ s â†’ (âˆ‘ i âˆˆ n.divisors, f i) = g n) â†”
      âˆ€ n > 0, n âˆˆ s â†’ (âˆ‘ x âˆˆ n.divisorsAntidiagonal, Î¼ x.fst â€¢ g x.snd) = f n ",":= by
  constructor
  Â· intro h
    let G := fun (n:â„•) => (âˆ‘ i âˆˆ n.divisors, f i)
    intro n hn hnP
    suffices âˆ‘ d âˆˆ n.divisors, Î¼ (n/d) â€¢ G d = f n from by
      rw [Nat.sum_divisorsAntidiagonal' (f := fun x y => Î¼ x â€¢ g y), â† this, sum_congr rfl]
      intro d hd
      rw [â† h d (Nat.pos_of_mem_divisors hd) <| hs d n (Nat.dvd_of_mem_divisors hd) hnP]
    rw [â† Nat.sum_divisorsAntidiagonal' (f := fun x y => Î¼ x â€¢ G y)]
    apply sum_eq_iff_sum_smul_moebius_eq.mp _ n hn
    intro _ _; rfl
  Â· intro h
    let F := fun (n:â„•) => âˆ‘ x âˆˆ n.divisorsAntidiagonal, Î¼ x.fst â€¢ g x.snd
    intro n hn hnP
    suffices âˆ‘ d âˆˆ n.divisors, F d = g n from by
      rw [â† this, sum_congr rfl]
      intro d hd
      rw [â† h d (Nat.pos_of_mem_divisors hd) <| hs d n (Nat.dvd_of_mem_divisors hd) hnP]
    apply sum_eq_iff_sum_smul_moebius_eq.mpr _ n hn
    intro _ _; rfl"
Mathlib/Data/Set/Sups.lean,Set.subset_infs_self,subset_infs_self,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= Î» _a ha â†¦ mem_infs.2 âŸ¨_, ha, _, ha, inf_idemâŸ©","warning:  @HasSups.sups does not have a doc string
warning:  @HasInfs.infs does not have a doc string
error:  application type mismatch
  âŸ¨ha, inf_idemâŸ©
argument
  inf_idem
has type
  âˆ€ (a : ?m.115960), a âŠ“ a = a : Prop
but is expected to have type
  _a âŠ“ _a = _a : Prop",lemma subset_infs_self : s âŠ† s âŠ¼ s ,":= fun _a ha â†¦ mem_infs.2 âŸ¨_, ha, _, ha, inf_idem _âŸ©"
Mathlib/CategoryTheory/Preadditive/Yoneda/Injective.lean,CategoryTheory.Injective.injective_iff_preservesEpimorphisms_preadditiveYoneda_obj,injective_iff_preservesEpimorphisms_preadditiveYoneda_obj,4da4e0ebfbf51ecc2e064d04970434177efdead3,":= by
  rw [injective_iff_preservesEpimorphisms_yoneda_obj]
  refine
    âŸ¨fun h : (preadditiveYoneda.obj J â‹™ (forget AddCommGroupCat)).PreservesEpimorphisms => ?_,? _âŸ©
  Â· exact
      Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveYoneda.obj J) (forget _)
  Â· intro
    exact (inferInstance : (preadditiveYoneda.obj J â‹™ forget _).PreservesEpimorphisms)","error:  unknown identifier 'AddCommGroupCat'
error:  failed to synthesize
  (preadditiveYoneda.obj J â‹™ forget AddCommGrp).PreservesEpimorphisms
use `set_option diagnostics true` to get diagnostic information
error:  no goals to be solved","theorem injective_iff_preservesEpimorphisms_preadditiveYoneda_obj (J : C) :
    Injective J â†” (preadditiveYoneda.obj J).PreservesEpimorphisms ",":= by
  rw [injective_iff_preservesEpimorphisms_yoneda_obj]
  refine
    âŸ¨fun h : (preadditiveYoneda.obj J â‹™ (forget AddCommGrp)).PreservesEpimorphisms => ?_, ?_âŸ©
  Â· exact
      Functor.preservesEpimorphisms_of_preserves_of_reflects (preadditiveYoneda.obj J) (forget _)
  Â· intro
    exact (inferInstance : (preadditiveYoneda.obj J â‹™ forget _).PreservesEpimorphisms)"
Mathlib/Algebra/CharP/CharAndCard.lean,isUnit_iff_not_dvd_char_of_ringChar_ne_zero,isUnit_iff_not_dvd_char_of_ringChar_ne_zero,00de3ade6a26cc42bd76ef77ae7951d738982567,":= by
  have hch := CharP.cast_eq_zero R (ringChar R)
  have hp : p.Prime := Fact.out
  constructor
  Â· rintro hâ‚ âŸ¨q, hqâŸ©
    rcases IsUnit.exists_left_inv hâ‚ with âŸ¨a, haâŸ©
    have hâ‚ƒ : Â¬ringChar R âˆ£ q := by
      rintro âŸ¨r, hrâŸ©
      rw [hr, â† mul_assoc, mul_comm p, mul_assoc] at hq
      nth_rw 1 [â† mul_one (ringChar R)] at hq
      exact Nat.Prime.not_dvd_one hp âŸ¨r, mul_left_cancelâ‚€ hR hqâŸ©
    have hâ‚„ := mt (CharP.int_cast_eq_zero_iff R (ringChar R) q).mp
    apply_fun ((â†‘) : â„• â†’ R) at hq
    apply_fun (Â· * Â·) a at hq
    rw [Nat.cast_mul, hch, mul_zero, â† mul_assoc, ha, one_mul] at hq
    norm_cast at hâ‚„
    exact hâ‚„ hâ‚ƒ hq.symm
  Â· intro h
    rcases (hp.coprime_iff_not_dvd.mpr h).isCoprime with âŸ¨a, b, habâŸ©
    apply_fun ((â†‘) : â„¤ â†’ R) at hab
    push_cast at hab
    rw [hch, mul_zero, add_zero, mul_comm] at hab
    exact isUnit_of_mul_eq_one (p : R) a hab",error:  unknown constant 'CharP.int_cast_eq_zero_iff',"theorem isUnit_iff_not_dvd_char_of_ringChar_ne_zero (R : Type*) [CommRing R] (p : â„•) [Fact p.Prime]
    (hR : ringChar R â‰  0) : IsUnit (p : R) â†” Â¬p âˆ£ ringChar R ",":= by
  have hch := CharP.cast_eq_zero R (ringChar R)
  have hp : p.Prime := Fact.out
  constructor
  Â· rintro hâ‚ âŸ¨q, hqâŸ©
    rcases IsUnit.exists_left_inv hâ‚ with âŸ¨a, haâŸ©
    have hâ‚ƒ : Â¬ringChar R âˆ£ q := by
      rintro âŸ¨r, hrâŸ©
      rw [hr, â† mul_assoc, mul_comm p, mul_assoc] at hq
      nth_rw 1 [â† mul_one (ringChar R)] at hq
      exact Nat.Prime.not_dvd_one hp âŸ¨r, mul_left_cancelâ‚€ hR hqâŸ©
    have hâ‚„ := mt (CharP.intCast_eq_zero_iff R (ringChar R) q).mp
    apply_fun ((â†‘) : â„• â†’ R) at hq
    apply_fun (Â· * Â·) a at hq
    rw [Nat.cast_mul, hch, mul_zero, â† mul_assoc, ha, one_mul] at hq
    norm_cast at hâ‚„
    exact hâ‚„ hâ‚ƒ hq.symm
  Â· intro h
    rcases (hp.coprime_iff_not_dvd.mpr h).isCoprime with âŸ¨a, b, habâŸ©
    apply_fun ((â†‘) : â„¤ â†’ R) at hab
    push_cast at hab
    rw [hch, mul_zero, add_zero, mul_comm] at hab
    exact isUnit_of_mul_eq_one (p : R) a hab"
Mathlib/Data/Seq/WSeq.lean,Stream'.WSeq.eq_or_mem_iff_mem,eq_or_mem_iff_mem,938069ac7c83a4980c46ca108d9947ab788c12ee,":= by
  generalize e : destruct s = c; intro h
  revert s
  apply Computation.memRecOn h <;> [skip; intro c IH] <;> intro s <;>
    induction' s using WSeq.recOn with x s s <;>
    intro m <;>
    have := congr_arg Computation.destruct m <;>
    simp at this
  Â· cases' this with i1 i2
    rw [i1, i2]
    cases' s' with f al
    dsimp only [cons, (Â· âˆˆ Â·), WSeq.Mem, Seq'.Mem, Seq'.cons]
    have h_a_eq_a' : a = a' â†” some (some a) = some (some a') := by simp
    rw [h_a_eq_a']
    refine âŸ¨Stream'.eq_or_mem_of_mem_cons, fun o => ?_âŸ©
    Â· cases' o with e m
      Â· rw [e]
        apply Stream'.mem_cons
      Â· exact Stream'.mem_cons_of_mem _ m
  Â· simp [IH this]","error:  unknown identifier 'Seq'.Mem'
error:  unknown identifier 'Seq'.cons'
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  some (some a)
case h1.h2.intro.mk.inl
Î± : Type u
Î² : Type v
Î³ : Type w
a a' : Î±
c : Computation (Option (Î± Ã— WSeq Î±))
x : Î±
s : WSeq Î±
i1 : x = a'
f : Stream' (Option (Option Î±))
al : f.IsSeq
h : some (a', âŸ¨f, alâŸ©) âˆˆ c
m : (cons x s).destruct = Computation.pure (some (a', âŸ¨f, alâŸ©))
i2 : s = âŸ¨f, alâŸ©
h_a_eq_a' : a = a' â†” some (some a) = some (some a')
e : some (some a) = some (some a')
âŠ¢ Seq.Mem (some a) (Seq.cons (some a') âŸ¨f, alâŸ©)","theorem eq_or_mem_iff_mem {s : WSeq Î±} {a a' s'} :
    some (a', s') âˆˆ destruct s â†’ (a âˆˆ s â†” a = a' âˆ¨ a âˆˆ s') ",":= by
  generalize e : destruct s = c; intro h
  revert s
  apply Computation.memRecOn h <;> [skip; intro c IH] <;> intro s <;>
    induction' s using WSeq.recOn with x s s <;>
    intro m <;>
    have := congr_arg Computation.destruct m <;>
    simp at this
  Â· cases' this with i1 i2
    rw [i1, i2]
    cases' s' with f al
    dsimp only [cons, (Â· âˆˆ Â·), WSeq.Mem, Seq.Mem, Seq.cons]
    have h_a_eq_a' : a = a' â†” some (some a) = some (some a') := by simp
    rw [h_a_eq_a']
    refine âŸ¨Stream'.eq_or_mem_of_mem_cons, fun o => ?_âŸ©
    Â· cases' o with e m
      Â· rw [e]
        apply Stream'.mem_cons
      Â· exact Stream'.mem_cons_of_mem _ m
  Â· simp [IH this]"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,a380f5a603bf5030bc30e58b1aed19567f67b98d,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine' âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, _âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, âŸ¨_, _, _âŸ©, _âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 âˆˆ ?m.116759 âˆª ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120516 â†’ ?m.120516
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.124403 â†’ ?m.124403
error:  unsolved goals
case zero
Î± : Type u_1
instâœâµ : MetricSpace Î±
Î² : Type u
instâœâ´ : SecondCountableTopology Î±
instâœÂ³ : MeasurableSpace Î±
instâœÂ² : OpensMeasurableSpace Î±
instâœÂ¹ : HasBesicovitchCovering Î±
Î¼ : Measure Î±
instâœ : IsFiniteMeasure Î¼
f : Î± â†’ Set â„
s : Set Î±
hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty
N : â„•
Ï„ : â„
hÏ„ : 1 < Ï„
hN : IsEmpty (SatelliteConfig Î± N Ï„)
P : Finset (Î± Ã— â„) â†’ Prop :=
  fun t â†¦ ((â†‘t).PairwiseDisjoint fun p â†¦ closedBall p.1 p.2) âˆ§ (âˆ€ p âˆˆ t, p.1 âˆˆ s) âˆ§ âˆ€ p âˆˆ t, p.2 âˆˆ f p.1
F : Finset (Î± Ã— â„) â†’ Finset (Î± Ã— â„)
hF :
  âˆ€ (t : Finset (Î± Ã— â„)),
    P t â†’
      t âŠ† F t âˆ§ P (F t) âˆ§ Î¼ (s \ â‹ƒ p âˆˆ F t, closedBall p.1 p.2) â‰¤ â†‘N / (â†‘N + 1) * Î¼ (s \ â‹ƒ p âˆˆ t, closedBall p.1 p.2)
u : â„• â†’ Finset (Î± Ã— â„) := fun n â†¦ F^[n] âˆ…
u_succ : âˆ€ (n : â„•), u n.succ = F (u n)
Pu : âˆ€ (n : â„•), P (u n)
A : âˆ€ (n : â„•), Î¼ (s \ â‹ƒ p âˆˆ â‹ƒ n, â†‘(u n), closedBall p.1 p.2) â‰¤ Î¼ (s \ â‹ƒ p âˆˆ u n, closedBall p.1 p.2)
âŠ¢ Î¼ (s \ â‹ƒ p âˆˆ id âˆ…, closedBall p.1 p.2) â‰¤ Î¼ s
error:  type mismatch
  mul_le_mul_left' IH (â†‘N / (â†‘N + 1))
has type
  â†‘N / (â†‘N + 1) * Î¼ (s \ â‹ƒ p âˆˆ u n, closedBall p.1 p.2) â‰¤ â†‘N / (â†‘N + 1) * ((â†‘N / (â†‘N + 1)) ^ n * Î¼ s) : Prop
but is expected to have type
  â†‘N / (â†‘N + 1) * Î¼ (s \ â‹ƒ p âˆˆ u n, closedBall p.1 p.2) â‰¤ (â†‘N / (â†‘N + 1)) ^ n * (â†‘N / (â†‘N + 1) * Î¼ s) : Prop
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.134258 â†’ ?m.134258 â†’ Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.134394 â†’ ?m.134394 â†’ Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Î¼ : Measure Î±)
    [IsFiniteMeasure Î¼] (f : Î± â†’ Set â„) (s : Set Î±)
    (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty) :
    âˆƒ t : Set (Î± Ã— â„), t.Countable âˆ§ (âˆ€ p âˆˆ t, p.1 âˆˆ s) âˆ§ (âˆ€ p âˆˆ t, p.2 âˆˆ f p.1) âˆ§
      Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) = 0 âˆ§
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, ?_âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, âŸ¨?_, ?_, ?_âŸ©, ?_âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Î¼ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/Order/Monotone/Odd.lean,strictAnti_of_odd_strictAntiOn_nonneg,strictAnti_of_odd_strictAntiOn_nonneg,571e842d55864d9e0851a5bc5675a71391b31d48,":=
  @strictMono_of_odd_strictMonoOn_nonneg G Háµ’áµˆ _ _ _ _ _ hâ‚ hâ‚‚","error:  application type mismatch
  @strictMono_of_odd_strictMonoOn_nonneg G Háµ’áµˆ ?m.1487 ?m.1488 ?m.1489 ?m.1490 ?m.1491 hâ‚
argument
  hâ‚
has type
  âˆ€ (x : G), f (-x) = -f x : Prop
but is expected to have type
  G : Type u_1","theorem strictAnti_of_odd_strictAntiOn_nonneg {f : G â†’ H} (hâ‚ : âˆ€ x, f (-x) = -f x)
    (hâ‚‚ : StrictAntiOn f (Ici 0)) : StrictAnti f ",":=
  @strictMono_of_odd_strictMonoOn_nonneg G Háµ’áµˆ _ _ _ hâ‚ hâ‚‚"
Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean,Real.GammaIntegral_convergent,GammaIntegral_convergent,397ec08ba044ea258e3316ca4aa474486236cb51,":= by
  rw [â† Ioc_union_Ioi_eq_Ioi (@zero_le_one â„ _ _ _ _), integrableOn_union]
  constructor
  Â· rw [â† integrableOn_Icc_iff_integrableOn_Ioc]
    refine' IntegrableOn.continuousOn_mul continuousOn_id.neg.exp _ isCompact_Icc
    refine' (intervalIntegrable_iff_integrable_Icc_of_le zero_le_one).mp _
    exact intervalIntegrable_rpow' (by linarith)
  Â· refine' integrable_of_isBigO_exp_neg one_half_pos _ (Gamma_integrand_isLittleO _).isBigO
    refine' continuousOn_id.neg.exp.mul (continuousOn_id.rpow_const _)
    intro x hx
    exact Or.inl ((zero_lt_one : (0 : â„) < 1).trans_le hx).ne'","warning:  `ContinuousOn.exp` has been deprecated, use `ContinuousOn.rexp` instead
error:  unknown identifier 'intervalIntegrable_iff_integrable_Icc_of_le'
error:  no goals to be solved
warning:  `ContinuousOn.exp` has been deprecated, use `ContinuousOn.rexp` instead","theorem GammaIntegral_convergent {s : â„} (h : 0 < s) :
    IntegrableOn (fun x : â„ => exp (-x) * x ^ (s - 1)) (Ioi 0) ",":= by
  rw [â† Ioc_union_Ioi_eq_Ioi (@zero_le_one â„ _ _ _ _), integrableOn_union]
  constructor
  Â· rw [â† integrableOn_Icc_iff_integrableOn_Ioc]
    refine IntegrableOn.continuousOn_mul continuousOn_id.neg.rexp ?_ isCompact_Icc
    refine (intervalIntegrable_iff_integrableOn_Icc_of_le zero_le_one).mp ?_
    exact intervalIntegrable_rpow' (by linarith)
  Â· refine integrable_of_isBigO_exp_neg one_half_pos ?_ (Gamma_integrand_isLittleO _).isBigO
    refine continuousOn_id.neg.rexp.mul (continuousOn_id.rpow_const ?_)
    intro x hx
    exact Or.inl ((zero_lt_one : (0 : â„) < 1).trans_le hx).ne'"
Mathlib/MeasureTheory/Covering/Besicovitch.lean,Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux,50f79eaf0f5e360632afea97f3cefd2b1eab4c46,":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine' âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, _âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine' âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left _ _, âŸ¨_, _, _âŸ©, _âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine' hv p'v q'v fun hp'q' => _
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id.def, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine' âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, _, _, _, _âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      apply measure_mono
      apply diff_subset_diff (Subset.refl _)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero, Nat.zero_eq,
          Function.iterate_zero, id.def, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ, mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.nat_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne.def, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.nat_ne_top, Ne.def, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine' (pairwiseDisjoint_iUnion _).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1","error:  function expected at
  Finset.subset_union_left ?m.116762
term has type
  ?m.116761 âˆˆ ?m.116759 âˆª ?m.116760
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.120516 â†’ ?m.120516
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  id
has type
  ?m.124403 â†’ ?m.124403
error:  unsolved goals
case zero
Î± : Type u_1
instâœâµ : MetricSpace Î±
Î² : Type u
instâœâ´ : SecondCountableTopology Î±
instâœÂ³ : MeasurableSpace Î±
instâœÂ² : OpensMeasurableSpace Î±
instâœÂ¹ : HasBesicovitchCovering Î±
Î¼ : Measure Î±
instâœ : IsFiniteMeasure Î¼
f : Î± â†’ Set â„
s : Set Î±
hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty
N : â„•
Ï„ : â„
hÏ„ : 1 < Ï„
hN : IsEmpty (SatelliteConfig Î± N Ï„)
P : Finset (Î± Ã— â„) â†’ Prop :=
  fun t â†¦ ((â†‘t).PairwiseDisjoint fun p â†¦ closedBall p.1 p.2) âˆ§ (âˆ€ p âˆˆ t, p.1 âˆˆ s) âˆ§ âˆ€ p âˆˆ t, p.2 âˆˆ f p.1
F : Finset (Î± Ã— â„) â†’ Finset (Î± Ã— â„)
hF :
  âˆ€ (t : Finset (Î± Ã— â„)),
    P t â†’
      t âŠ† F t âˆ§ P (F t) âˆ§ Î¼ (s \ â‹ƒ p âˆˆ F t, closedBall p.1 p.2) â‰¤ â†‘N / (â†‘N + 1) * Î¼ (s \ â‹ƒ p âˆˆ t, closedBall p.1 p.2)
u : â„• â†’ Finset (Î± Ã— â„) := fun n â†¦ F^[n] âˆ…
u_succ : âˆ€ (n : â„•), u n.succ = F (u n)
Pu : âˆ€ (n : â„•), P (u n)
A : âˆ€ (n : â„•), Î¼ (s \ â‹ƒ p âˆˆ â‹ƒ n, â†‘(u n), closedBall p.1 p.2) â‰¤ Î¼ (s \ â‹ƒ p âˆˆ u n, closedBall p.1 p.2)
âŠ¢ Î¼ (s \ â‹ƒ p âˆˆ id âˆ…, closedBall p.1 p.2) â‰¤ Î¼ s
error:  type mismatch
  mul_le_mul_left' IH (â†‘N / (â†‘N + 1))
has type
  â†‘N / (â†‘N + 1) * Î¼ (s \ â‹ƒ p âˆˆ u n, closedBall p.1 p.2) â‰¤ â†‘N / (â†‘N + 1) * ((â†‘N / (â†‘N + 1)) ^ n * Î¼ s) : Prop
but is expected to have type
  â†‘N / (â†‘N + 1) * Î¼ (s \ â‹ƒ p âˆˆ u n, closedBall p.1 p.2) â‰¤ (â†‘N / (â†‘N + 1)) ^ n * (â†‘N / (â†‘N + 1) * Î¼ s) : Prop
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.134258 â†’ ?m.134258 â†’ Prop
error:  simp made no progress
warning:  `ENNReal.nat_ne_top` has been deprecated, use `ENNReal.natCast_ne_top` instead
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.134394 â†’ ?m.134394 â†’ Prop
error:  simp made no progress","theorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (Î¼ : Measure Î±)
    [IsFiniteMeasure Î¼] (f : Î± â†’ Set â„) (s : Set Î±)
    (hf : âˆ€ x âˆˆ s, âˆ€ Î´ > 0, (f x âˆ© Ioo 0 Î´).Nonempty) :
    âˆƒ t : Set (Î± Ã— â„), t.Countable âˆ§ (âˆ€ p âˆˆ t, p.1 âˆˆ s) âˆ§ (âˆ€ p âˆˆ t, p.2 âˆˆ f p.1) âˆ§
      Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) = 0 âˆ§
        t.PairwiseDisjoint fun p => closedBall p.1 p.2 ",":= by
  rcases HasBesicovitchCovering.no_satelliteConfig (Î± := Î±) with âŸ¨N, Ï„, hÏ„, hNâŸ©
  let P : Finset (Î± Ã— â„) â†’ Prop := fun t =>
    ((t : Set (Î± Ã— â„)).PairwiseDisjoint fun p => closedBall p.1 p.2) âˆ§
      (âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.1 âˆˆ s) âˆ§ âˆ€ p : Î± Ã— â„, p âˆˆ t â†’ p.2 âˆˆ f p.1
  have :
      âˆ€ t : Finset (Î± Ã— â„), P t â†’ âˆƒ u : Finset (Î± Ã— â„), t âŠ† u âˆ§ P u âˆ§
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u), closedBall p.1 p.2) â‰¤
          N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2) := by
    intro t ht
    set B := â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ t), closedBall p.1 p.2 with hB
    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball
    set s' := s \ B
    have : âˆ€ x âˆˆ s', âˆƒ r âˆˆ f x âˆ© Ioo 0 1, Disjoint B (closedBall x r) := by
      intro x hx
      have xs : x âˆˆ s := ((mem_diff x).1 hx).1
      rcases eq_empty_or_nonempty B with (hB | hB)
      Â· rcases hf x xs 1 zero_lt_one with âŸ¨r, hr, h'râŸ©
        exact âŸ¨r, âŸ¨hr, h'râŸ©, by simp only [hB, empty_disjoint]âŸ©
      Â· let r := infDist x B
        have : 0 < min r 1 :=
          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one
        rcases hf x xs _ this with âŸ¨r, hr, h'râŸ©
        refine âŸ¨r, âŸ¨hr, âŸ¨h'r.1, h'r.2.trans_le (min_le_right _ _)âŸ©âŸ©, ?_âŸ©
        rw [disjoint_comm]
        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))
    choose! r hr using this
    obtain âŸ¨v, vs', hÎ¼v, hvâŸ© :
      âˆƒ v : Finset Î±,
        â†‘v âŠ† s' âˆ§
          Î¼ (s' \ â‹ƒ x âˆˆ v, closedBall x (r x)) â‰¤ N / (N + 1) * Î¼ s' âˆ§
            (v : Set Î±).PairwiseDisjoint fun x : Î± => closedBall x (r x) :=
      haveI rI : âˆ€ x âˆˆ s', r x âˆˆ Ioo (0 : â„) 1 := fun x hx => (hr x hx).1.2
      exist_finset_disjoint_balls_large_measure Î¼ hÏ„ hN s' r (fun x hx => (rI x hx).1) fun x hx =>
        (rI x hx).2.le
    refine âŸ¨t âˆª Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, âŸ¨?_, ?_, ?_âŸ©, ?_âŸ©
    Â· simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and_iff, Finset.coe_image]
      constructor
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hp with âŸ¨p', p'v, rflâŸ©
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        refine hv p'v q'v fun hp'q' => ?_
        rw [hp'q'] at hpq
        exact hpq rfl
      Â· intro p hp q hq hpq
        rcases (mem_image _ _ _).1 hq with âŸ¨q', q'v, rflâŸ©
        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2
        rw [hB, â† Finset.set_biUnion_coe]
        exact subset_biUnion_of_mem (u := fun x : Î± Ã— â„ => closedBall x.1 x.2) hp
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.1 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1
    Â· intro p hp
      rcases Finset.mem_union.1 hp with (h'p | h'p)
      Â· exact ht.2.2 p h'p
      Â· rcases Finset.mem_image.1 h'p with âŸ¨p', p'v, rflâŸ©
        exact (hr p' (vs' p'v)).1.1
    Â· convert hÎ¼v using 2
      rw [Finset.set_biUnion_union, â† diff_diff, Finset.set_biUnion_finset_image]
  choose! F hF using this
  let u n := F^[n] âˆ…
  have u_succ : âˆ€ n : â„•, u n.succ = F (u n) := fun n => by
    simp only [u, Function.comp_apply, Function.iterate_succ']
  have Pu : âˆ€ n, P (u n) := by
    intro n
    induction' n with n IH
    Â· simp only [P, u, Prod.forall, id, Function.iterate_zero, Nat.zero_eq]
      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forallâ‚‚_true_iff,
        and_self_iff, pairwiseDisjoint_empty]
    Â· rw [u_succ]
      exact (hF (u n) IH).2.1
  refine âŸ¨â‹ƒ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_âŸ©
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)
  Â· intro p hp
    rcases mem_iUnion.1 hp with âŸ¨n, hnâŸ©
    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)
  Â· have A :
      âˆ€ n,
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ â‹ƒ n : â„•, (u n : Set (Î± Ã— â„))), closedBall p.fst p.snd) â‰¤
          Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
      intro n
      gcongr Î¼ (s \ ?_)
      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (Î± Ã— â„))) n)
    have B :
        âˆ€ n, Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) â‰¤
          (N / (N + 1) : â„â‰¥0âˆ) ^ n * Î¼ s := by
      intro n
      induction' n with n IH
      Â· simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,
          Nat.zero_eq, Function.iterate_zero, id, Finset.not_mem_empty]
      calc
        Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n.succ), closedBall p.fst p.snd) â‰¤
            N / (N + 1) * Î¼ (s \ â‹ƒ (p : Î± Ã— â„) (_ : p âˆˆ u n), closedBall p.fst p.snd) := by
          rw [u_succ]; exact (hF (u n) (Pu n)).2.2
        _ â‰¤ (N / (N + 1) : â„â‰¥0âˆ) ^ n.succ * Î¼ s := by
          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _
    have C : Tendsto (fun n : â„• => ((N : â„â‰¥0âˆ) / (N + 1)) ^ n * Î¼ s) atTop (ğ“ (0 * Î¼ s)) := by
      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top Î¼ s).ne)
      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one
      rw [ENNReal.div_lt_iff, one_mul]
      Â· conv_lhs => rw [â† add_zero (N : â„â‰¥0âˆ)]
        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one
      Â· simp only [true_or_iff, add_eq_zero_iff, Ne, not_false_iff, one_ne_zero, and_false_iff]
      Â· simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true_iff]
    rw [zero_mul] at C
    apply le_bot_iff.1
    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)
  Â· refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1
    apply (monotone_nat_of_le_succ fun n => ?_).directed_le
    rw [â† Nat.succ_eq_add_one, u_succ]
    exact (hF (u n) (Pu n)).1"
Mathlib/Analysis/NormedSpace/Banach.lean,ContinuousLinearMap.exists_preimage_norm_le,exists_preimage_norm_le,eaa83c6685ef1ea5f937bbcf33f93c81fbc9bdb7,":= by
  obtain âŸ¨C, C0, hCâŸ© := exists_approx_preimage_norm_le f surj
  choose g hg using hC
  let h y := y - f (g y)
  have hle : âˆ€ y, â€–h yâ€– â‰¤ 1 / 2 * â€–yâ€– := by
    intro y
    rw [â† dist_eq_norm, dist_comm]
    exact (hg y).1
  refine' âŸ¨2 * C + 1, by linarith, fun y => _âŸ©
  have hnle : âˆ€ n : â„•, â€–h^[n] yâ€– â‰¤ (1 / 2) ^ n * â€–yâ€– := by
    intro n
    induction' n with n IH
    Â· simp only [one_div, Nat.zero_eq, one_mul, iterate_zero_apply, pow_zero, le_rfl]
    Â· rw [iterate_succ']
      apply le_trans (hle _) _
      rw [pow_succ, mul_assoc]
      apply mul_le_mul_of_nonneg_left IH
      norm_num
  let u n := g (h^[n] y)
  have ule : âˆ€ n, â€–u nâ€– â‰¤ (1 / 2) ^ n * (C * â€–yâ€–) := by
    intro n
    apply le_trans (hg _).2 _
    calc
      C * â€–h^[n] yâ€– â‰¤ C * ((1 / 2) ^ n * â€–yâ€–) := by grw [hnle]
      _ = (1 / 2) ^ n * (C * â€–yâ€–) := by ring
  have sNu : Summable fun n => â€–u nâ€– := by
    refine' .of_nonneg_of_le (fun n => norm_nonneg _) ule _
    exact Summable.mul_right _ (summable_geometric_of_lt_1 (by norm_num) (by norm_num))
  have su : Summable u := sNu.of_norm
  let x := tsum u
  have x_ineq : â€–xâ€– â‰¤ (2 * C + 1) * â€–yâ€– :=
    calc
      â€–xâ€– â‰¤ âˆ‘' n, â€–u nâ€– := norm_tsum_le_tsum_norm sNu
      _ â‰¤ âˆ‘' n, (1 / 2) ^ n * (C * â€–yâ€–) :=
        tsum_le_tsum ule sNu (Summable.mul_right _ summable_geometric_two)
      _ = (âˆ‘' n, (1 / 2) ^ n) * (C * â€–yâ€–) := tsum_mul_right
      _ = 2 * C * â€–yâ€– := by rw [tsum_geometric_two, mul_assoc]
      _ â‰¤ 2 * C * â€–yâ€– + â€–yâ€– := (le_add_of_nonneg_right (norm_nonneg y))
      _ = (2 * C + 1) * â€–yâ€– := by ring
  have fsumeq : âˆ€ n : â„•, f (âˆ‘ i in Finset.range n, u i) = y - h^[n] y := by
    intro n
    induction' n with n IH
    Â· simp [f.map_zero]
    Â· rw [sum_range_succ, f.map_add, IH, iterate_succ_apply', sub_add]
  have : Tendsto (fun n => âˆ‘ i in Finset.range n, u i) atTop (ğ“ x) := su.hasSum.tendsto_sum_nat
  have Lâ‚ : Tendsto (fun n => f (âˆ‘ i in Finset.range n, u i)) atTop (ğ“ (f x)) :=
    (f.continuous.tendsto _).comp this
  simp only [fsumeq] at Lâ‚
  have Lâ‚‚ : Tendsto (fun n => y - h^[n] y) atTop (ğ“ (y - 0)) := by
    refine' tendsto_const_nhds.sub _
    rw [tendsto_iff_norm_sub_tendsto_zero]
    simp only [sub_zero]
    refine' squeeze_zero (fun _ => norm_nonneg _) hnle _
    rw [â† zero_mul â€–yâ€–]
    refine' (_root_.tendsto_pow_atTop_nhds_0_of_lt_1 _ _).mul tendsto_const_nhds <;> norm_num
  have feq : f x = y - 0 := tendsto_nhds_unique Lâ‚ Lâ‚‚
  rw [sub_zero] at feq
  exact âŸ¨x, feq, x_ineqâŸ©","error:  unknown tactic
error:  unsolved goals
ğ•œ : Type u_1
ğ•œ' : Type u_2
instâœÂ¹Â¹ : NontriviallyNormedField ğ•œ
instâœÂ¹â° : NontriviallyNormedField ğ•œ'
Ïƒ : ğ•œ â†’+* ğ•œ'
Ïƒ' : ğ•œ' â†’+* ğ•œ
instâœâ¹ : RingHomInvPair Ïƒ Ïƒ'
instâœâ¸ : RingHomInvPair Ïƒ' Ïƒ
instâœâ· : RingHomIsometric Ïƒ
instâœâ¶ : RingHomIsometric Ïƒ'
E : Type u_3
instâœâµ : NormedAddCommGroup E
instâœâ´ : NormedSpace ğ•œ E
F : Type u_4
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : NormedSpace ğ•œ' F
f : E â†’SL[Ïƒ] F
instâœÂ¹ : CompleteSpace F
instâœ : CompleteSpace E
surj : Surjective â‡‘f
C : â„
C0 : C â‰¥ 0
g : F â†’ E
hg : âˆ€ (y : F), dist (f (g y)) y â‰¤ 1 / 2 * â€–yâ€– âˆ§ â€–g yâ€– â‰¤ C * â€–yâ€–
h : F â†’ F := fun y â†¦ y - f (g y)
hle : âˆ€ (y : F), â€–h yâ€– â‰¤ 1 / 2 * â€–yâ€–
y : F
hnle : âˆ€ (n : â„•), â€–h^[n] yâ€– â‰¤ (1 / 2) ^ n * â€–yâ€–
u : â„• â†’ E := fun n â†¦ g (h^[n] y)
n : â„•
âŠ¢ C * â€–h^[n] yâ€– â‰¤ C * ((1 / 2) ^ n * â€–yâ€–)
error:  unsolved goals
case calc.step
ğ•œ : Type u_1
ğ•œ' : Type u_2
instâœÂ¹Â¹ : NontriviallyNormedField ğ•œ
instâœÂ¹â° : NontriviallyNormedField ğ•œ'
Ïƒ : ğ•œ â†’+* ğ•œ'
Ïƒ' : ğ•œ' â†’+* ğ•œ
instâœâ¹ : RingHomInvPair Ïƒ Ïƒ'
instâœâ¸ : RingHomInvPair Ïƒ' Ïƒ
instâœâ· : RingHomIsometric Ïƒ
instâœâ¶ : RingHomIsometric Ïƒ'
E : Type u_3
instâœâµ : NormedAddCommGroup E
instâœâ´ : NormedSpace ğ•œ E
F : Type u_4
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : NormedSpace ğ•œ' F
f : E â†’SL[Ïƒ] F
instâœÂ¹ : CompleteSpace F
instâœ : CompleteSpace E
surj : Surjective â‡‘f
C : â„
C0 : C â‰¥ 0
g : F â†’ E
hg : âˆ€ (y : F), dist (f (g y)) y â‰¤ 1 / 2 * â€–yâ€– âˆ§ â€–g yâ€– â‰¤ C * â€–yâ€–
h : F â†’ F := fun y â†¦ y - f (g y)
hle : âˆ€ (y : F), â€–h yâ€– â‰¤ 1 / 2 * â€–yâ€–
y : F
hnle : âˆ€ (n : â„•), â€–h^[n] yâ€– â‰¤ (1 / 2) ^ n * â€–yâ€–
u : â„• â†’ E := fun n â†¦ g (h^[n] y)
n : â„•
âŠ¢ C * ((1 / 2) ^ n * â€–yâ€–) â‰¤ (1 / 2) ^ n * (C * â€–yâ€–)
error:  unsolved goals
case intro.intro
ğ•œ : Type u_1
ğ•œ' : Type u_2
instâœÂ¹Â¹ : NontriviallyNormedField ğ•œ
instâœÂ¹â° : NontriviallyNormedField ğ•œ'
Ïƒ : ğ•œ â†’+* ğ•œ'
Ïƒ' : ğ•œ' â†’+* ğ•œ
instâœâ¹ : RingHomInvPair Ïƒ Ïƒ'
instâœâ¸ : RingHomInvPair Ïƒ' Ïƒ
instâœâ· : RingHomIsometric Ïƒ
instâœâ¶ : RingHomIsometric Ïƒ'
E : Type u_3
instâœâµ : NormedAddCommGroup E
instâœâ´ : NormedSpace ğ•œ E
F : Type u_4
instâœÂ³ : NormedAddCommGroup F
instâœÂ² : NormedSpace ğ•œ' F
f : E â†’SL[Ïƒ] F
instâœÂ¹ : CompleteSpace F
instâœ : CompleteSpace E
surj : Surjective â‡‘f
C : â„
C0 : C â‰¥ 0
g : F â†’ E
hg : âˆ€ (y : F), dist (f (g y)) y â‰¤ 1 / 2 * â€–yâ€– âˆ§ â€–g yâ€– â‰¤ C * â€–yâ€–
h : F â†’ F := fun y â†¦ y - f (g y)
hle : âˆ€ (y : F), â€–h yâ€– â‰¤ 1 / 2 * â€–yâ€–
y : F
hnle : âˆ€ (n : â„•), â€–h^[n] yâ€– â‰¤ (1 / 2) ^ n * â€–yâ€–
u : â„• â†’ E := fun n â†¦ g (h^[n] y)
ule : âˆ€ (n : â„•), â€–u nâ€– â‰¤ (1 / 2) ^ n * (C * â€–yâ€–)
âŠ¢ âˆƒ x, f x = y âˆ§ â€–xâ€– â‰¤ (2 * C + 1) * â€–yâ€–","theorem exists_preimage_norm_le (surj : Surjective f) :
    âˆƒ C > 0, âˆ€ y, âˆƒ x, f x = y âˆ§ â€–xâ€– â‰¤ C * â€–yâ€– ",":= by
  obtain âŸ¨C, C0, hCâŸ© := exists_approx_preimage_norm_le f surj
  choose g hg using hC
  let h y := y - f (g y)
  have hle : âˆ€ y, â€–h yâ€– â‰¤ 1 / 2 * â€–yâ€– := by
    intro y
    rw [â† dist_eq_norm, dist_comm]
    exact (hg y).1
  refine âŸ¨2 * C + 1, by linarith, fun y => ?_âŸ©
  have hnle : âˆ€ n : â„•, â€–h^[n] yâ€– â‰¤ (1 / 2) ^ n * â€–yâ€– := by
    intro n
    induction' n with n IH
    Â· simp only [one_div, Nat.zero_eq, one_mul, iterate_zero_apply, pow_zero, le_rfl]
    Â· rw [iterate_succ']
      apply le_trans (hle _) _
      rw [pow_succ', mul_assoc]
      gcongr
  let u n := g (h^[n] y)
  have ule : âˆ€ n, â€–u nâ€– â‰¤ (1 / 2) ^ n * (C * â€–yâ€–) := fun n â†¦ by
    apply le_trans (hg _).2
    calc
      C * â€–h^[n] yâ€– â‰¤ C * ((1 / 2) ^ n * â€–yâ€–) := mul_le_mul_of_nonneg_left (hnle n) C0
      _ = (1 / 2) ^ n * (C * â€–yâ€–) := by ring
  have sNu : Summable fun n => â€–u nâ€– := by
    refine .of_nonneg_of_le (fun n => norm_nonneg _) ule ?_
    exact Summable.mul_right _ (summable_geometric_of_lt_one (by norm_num) (by norm_num))
  have su : Summable u := sNu.of_norm
  let x := tsum u
  have x_ineq : â€–xâ€– â‰¤ (2 * C + 1) * â€–yâ€– :=
    calc
      â€–xâ€– â‰¤ âˆ‘' n, â€–u nâ€– := norm_tsum_le_tsum_norm sNu
      _ â‰¤ âˆ‘' n, (1 / 2) ^ n * (C * â€–yâ€–) :=
        tsum_le_tsum ule sNu (Summable.mul_right _ summable_geometric_two)
      _ = (âˆ‘' n, (1 / 2) ^ n) * (C * â€–yâ€–) := tsum_mul_right
      _ = 2 * C * â€–yâ€– := by rw [tsum_geometric_two, mul_assoc]
      _ â‰¤ 2 * C * â€–yâ€– + â€–yâ€– := le_add_of_nonneg_right (norm_nonneg y)
      _ = (2 * C + 1) * â€–yâ€– := by ring
  have fsumeq : âˆ€ n : â„•, f (âˆ‘ i âˆˆ Finset.range n, u i) = y - h^[n] y := by
    intro n
    induction' n with n IH
    Â· simp [f.map_zero]
    Â· rw [sum_range_succ, f.map_add, IH, iterate_succ_apply', sub_add]
  have : Tendsto (fun n => âˆ‘ i âˆˆ Finset.range n, u i) atTop (ğ“ x) := su.hasSum.tendsto_sum_nat
  have Lâ‚ : Tendsto (fun n => f (âˆ‘ i âˆˆ Finset.range n, u i)) atTop (ğ“ (f x)) :=
    (f.continuous.tendsto _).comp this
  simp only [fsumeq] at Lâ‚
  have Lâ‚‚ : Tendsto (fun n => y - h^[n] y) atTop (ğ“ (y - 0)) := by
    refine tendsto_const_nhds.sub ?_
    rw [tendsto_iff_norm_sub_tendsto_zero]
    simp only [sub_zero]
    refine squeeze_zero (fun _ => norm_nonneg _) hnle ?_
    rw [â† zero_mul â€–yâ€–]
    refine (_root_.tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num
  have feq : f x = y - 0 := tendsto_nhds_unique Lâ‚ Lâ‚‚
  rw [sub_zero] at feq
  exact âŸ¨x, feq, x_ineqâŸ©"
Mathlib/Geometry/Manifold/IntegralCurve.lean,isIntegralCurveAt_comp_mul_ne_zero,isIntegralCurveAt_comp_mul_ne_zero,d996ccc73f1b6d1a1ff24ec47ca70ad7ceadb135,":= by
  refine âŸ¨fun hÎ³ â†¦ hÎ³.comp_mul_ne_zero ha, fun hÎ³ â†¦ ?_âŸ©
  convert hÎ³.comp_mul_ne_zero (inv_ne_zero ha)
  ext t
  Â· simp only [Function.comp_apply, mul_assoc, inv_mul_eq_div, div_self ha, mul_one]
  Â· simp only [smul_smul, inv_mul_eq_div, div_self ha, one_smul]
  Â· simp only [div_inv_eq_mul, div_mul_cancel _ ha]","error:  application type mismatch
  div_mul_cancel ?m.259285 ha
argument
  ha
has type
  a â‰  0 : Prop
but is expected to have type
  ?m.259283 : Type ?u.259282
error:  unsolved goals
case h.e'_13
E : Type u_1
instâœâ¶ : NormedAddCommGroup E
instâœâµ : NormedSpace â„ E
instâœâ´ : CompleteSpace E
H : Type u_2
instâœÂ³ : TopologicalSpace H
I : ModelWithCorners â„ E H
M : Type u_3
instâœÂ² : TopologicalSpace M
instâœÂ¹ : ChartedSpace H M
instâœ : SmoothManifoldWithCorners I M
Î³ Î³' : â„ â†’ M
v : (x : M) â†’ TangentSpace I x
s s' : Set â„
tâ‚€ a : â„
ha : a â‰  0
hÎ³ : IsIntegralCurveAt (Î³ âˆ˜ fun x â†¦ x * a) (a â€¢ v) (tâ‚€ / a)
âŠ¢ tâ‚€ = tâ‚€ / a * a","lemma isIntegralCurveAt_comp_mul_ne_zero {a : â„} (ha : a â‰  0) :
    IsIntegralCurveAt Î³ v tâ‚€ â†” IsIntegralCurveAt (Î³ âˆ˜ (Â· * a)) (a â€¢ v) (tâ‚€ / a) ",":= by
  refine âŸ¨fun hÎ³ â†¦ hÎ³.comp_mul_ne_zero ha, fun hÎ³ â†¦ ?_âŸ©
  convert hÎ³.comp_mul_ne_zero (inv_ne_zero ha)
  Â· ext t
    simp only [Function.comp_apply, mul_assoc, inv_mul_eq_div, div_self ha, mul_one]
  Â· simp only [smul_smul, inv_mul_eq_div, div_self ha, one_smul]
  Â· simp only [div_inv_eq_mul, div_mul_cancelâ‚€ _ ha]"
Mathlib/Data/Set/Pointwise/Interval.lean,Set.Ioc_mul_Ico_subset',Ioc_mul_Ico_subset',0d653eb0b05ba674b43555022f52c4b5f1e97748,":= by
  haveI := mulLeftMono_of_mulLeftStrictMono Î±
  haveI := mulRightMono_of_mulRightStrictMono Î±
  rintro x âŸ¨y, âŸ¨hya, hybâŸ©, z, âŸ¨hzc, hzdâŸ©, rflâŸ©
  exact âŸ¨mul_lt_mul_of_lt_of_le hya hzc, mul_lt_mul_of_le_of_lt hyb hzdâŸ©","error:  unknown identifier 'mulLeftMono_of_mulLeftStrictMono'
error:  unsolved goals
Î± : Type u_1
instâœÂ³ : Mul Î±
instâœÂ² : PartialOrder Î±
instâœÂ¹ : CovariantClass Î± Î± (fun x x_1 â†¦ x * x_1) fun x x_1 â†¦ x < x_1
instâœ : CovariantClass Î± Î± (Function.swap HMul.hMul) LT.lt
a b c d : Î±
âŠ¢ Ioc a b * Ico c d âŠ† Ioo (a * c) (b * d)",theorem Ioc_mul_Ico_subset' (a b c d : Î±) : Ioc a b * Ico c d âŠ† Ioo (a * c) (b * d) ,":= by
  haveI := covariantClass_le_of_lt
  rintro x âŸ¨y, âŸ¨hya, hybâŸ©, z, âŸ¨hzc, hzdâŸ©, rflâŸ©
  exact âŸ¨mul_lt_mul_of_lt_of_le hya hzc, mul_lt_mul_of_le_of_lt hyb hzdâŸ©"
Mathlib/Computability/AkraBazzi/AkraBazzi.lean,AkraBazziRecurrence.one_add_smoothingFn_le_two,one_add_smoothingFn_le_two,a785b32da038aa1563f8f1bf8eeff3ac26202167,":= by
  simp only [smoothingFn, â† one_add_one_eq_two]
  gcongr
  have : 1 < x := by
    calc 1 = exp 0 := by simp
         _ < exp 1 := by simp
         _ â‰¤ x := hx
  rw [div_le_one (log_pos this)]
  calc 1 = log (exp 1) := by simp
       _ â‰¤ log x := log_le_log' (exp_pos _) hx",error:  unknown identifier 'log_le_log'',lemma one_add_smoothingFn_le_two {x : â„} (hx : exp 1 â‰¤ x) : 1 + Îµ x â‰¤ 2 ,":= by
  simp only [smoothingFn, â† one_add_one_eq_two]
  gcongr
  have : 1 < x := by
    calc 1 = exp 0 := by simp
         _ < exp 1 := by simp
         _ â‰¤ x := hx
  rw [div_le_one (log_pos this)]
  calc 1 = log (exp 1) := by simp
       _ â‰¤ log x := log_le_log (exp_pos _) hx"
Mathlib/Probability/Martingale/Upcrossing.lean,MeasureTheory.Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part,Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part,9e34a191034458a56331f976ff7400a26407c888,":= by
  by_cases hab : a < b
  Â· simp_rw [upcrossings]
    have : âˆ€ N, âˆ«â» Ï‰, ENNReal.ofReal ((f N Ï‰ - a)âº) âˆ‚Î¼ = ENNReal.ofReal (âˆ« Ï‰, (f N Ï‰ - a)âº âˆ‚Î¼) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      Â· exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      Â· exact eventually_of_forall fun Ï‰ => LatticeOrderedGroup.pos_nonneg _
    rw [lintegral_iSup']
    Â· simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          âˆ«â» Ï‰, upcrossingsBefore a b f N Ï‰ âˆ‚Î¼ = âˆ«â» Ï‰, â†‘(upcrossingsBefore a b f N Ï‰ : â„â‰¥0) âˆ‚Î¼),
        lintegral_coe_eq_integral, â† ENNReal.ofReal_mul (sub_pos.2 hab).le]
      Â· simp_rw [NNReal.coe_nat_cast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (Î± := â„â‰¥0âˆ) _ N)
      Â· simp only [NNReal.coe_nat_cast, hf.adapted.integrable_upcrossingsBefore hab]
    Â· exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    Â· refine' eventually_of_forall fun Ï‰ N M hNM => _
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM Ï‰
  Â· rw [not_lt, â† sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, MulZeroClass.zero_mul]
    exact zero_le _","error:  unknown identifier 'LatticeOrderedGroup.pos_nonneg'
warning:  `NNReal.coe_nat_cast` has been deprecated, use `NNReal.coe_natCast` instead
warning:  `NNReal.coe_nat_cast` has been deprecated, use `NNReal.coe_natCast` instead","theorem Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part [IsFiniteMeasure Î¼] (a b : â„)
    (hf : Submartingale f â„± Î¼) : ENNReal.ofReal (b - a) * âˆ«â» Ï‰, upcrossings a b f Ï‰ âˆ‚Î¼ â‰¤
      â¨† N, âˆ«â» Ï‰, ENNReal.ofReal ((f N Ï‰ - a)âº) âˆ‚Î¼ ",":= by
  by_cases hab : a < b
  Â· simp_rw [upcrossings]
    have : âˆ€ N, âˆ«â» Ï‰, ENNReal.ofReal ((f N Ï‰ - a)âº) âˆ‚Î¼ = ENNReal.ofReal (âˆ« Ï‰, (f N Ï‰ - a)âº âˆ‚Î¼) := by
      intro N
      rw [ofReal_integral_eq_lintegral_ofReal]
      Â· exact (hf.sub_martingale (martingale_const _ _ _)).pos.integrable _
      Â· exact eventually_of_forall fun Ï‰ => posPart_nonneg _
    rw [lintegral_iSup']
    Â· simp_rw [this, ENNReal.mul_iSup, iSup_le_iff]
      intro N
      rw [(by simp :
          âˆ«â» Ï‰, upcrossingsBefore a b f N Ï‰ âˆ‚Î¼ = âˆ«â» Ï‰, â†‘(upcrossingsBefore a b f N Ï‰ : â„â‰¥0) âˆ‚Î¼),
        lintegral_coe_eq_integral, â† ENNReal.ofReal_mul (sub_pos.2 hab).le]
      Â· simp_rw [NNReal.coe_natCast]
        exact (ENNReal.ofReal_le_ofReal
          (hf.mul_integral_upcrossingsBefore_le_integral_pos_part a b N)).trans
            (le_iSup (Î± := â„â‰¥0âˆ) _ N)
      Â· simp only [NNReal.coe_natCast, hf.adapted.integrable_upcrossingsBefore hab]
    Â· exact fun n => measurable_from_top.comp_aemeasurable
        (hf.adapted.measurable_upcrossingsBefore hab).aemeasurable
    Â· filter_upwards with Ï‰ N M hNM
      rw [Nat.cast_le]
      exact upcrossingsBefore_mono hab hNM Ï‰
  Â· rw [not_lt, â† sub_nonpos] at hab
    rw [ENNReal.ofReal_of_nonpos hab, zero_mul]
    exact zero_le _"
Mathlib/Analysis/Distribution/AEEqOfIntegralContDiff.lean,ae_eq_zero_of_integral_smooth_smul_eq_zero,ae_eq_zero_of_integral_smooth_smul_eq_zero,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  have := I.locallyCompactSpace
  have := ChartedSpace.locallyCompactSpace H M
  have := I.secondCountableTopology
  have := ChartedSpace.secondCountable_of_sigma_compact H M
  have := ManifoldWithCorners.metrizableSpace I M
  let _ : MetricSpace M := TopologicalSpace.metrizableSpaceMetric M
  apply ae_eq_zero_of_forall_set_integral_isCompact_eq_zero' hf (fun s hs â†¦ Eq.symm ?_)
  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´, 0 < Î´ âˆ§ IsCompact (cthickening Î´ s) := hs.exists_isCompact_cthickening
  obtain âŸ¨u, -, u_pos, u_limâŸ© : âˆƒ u, StrictAnti u âˆ§ (âˆ€ (n : â„•), u n âˆˆ Ioo 0 Î´)
    âˆ§ Tendsto u atTop (ğ“ 0) := exists_seq_strictAnti_tendsto' Î´pos
  let v : â„• â†’ Set M := fun n â†¦ thickening (u n) s
  obtain âŸ¨K, K_compact, vKâŸ© : âˆƒ K, IsCompact K âˆ§ âˆ€ n, v n âŠ† K :=
    âŸ¨_, hÎ´, fun n â†¦ thickening_subset_cthickening_of_le (u_pos n).2.le _âŸ©
  have : âˆ€ n, âˆƒ (g : M â†’ â„), support g = v n âˆ§ Smooth I ğ“˜(â„) g âˆ§ Set.range g âŠ† Set.Icc 0 1
          âˆ§ âˆ€ x âˆˆ s, g x = 1 := by
    intro n
    rcases exists_msmooth_support_eq_eq_one_iff I isOpen_thickening hs.isClosed
      (self_subset_thickening (u_pos n).1 s) with âŸ¨g, g_smooth, g_range, g_supp, hgâŸ©
    exact âŸ¨g, g_supp, g_smooth, g_range, fun x hx â†¦ (hg x).1 hxâŸ©
  choose g g_supp g_diff g_range hg using this
  have L : Tendsto (fun n â†¦ âˆ« x, g n x â€¢ f x âˆ‚Î¼) atTop (ğ“ (âˆ« x in s, f x âˆ‚Î¼)) := by
    rw [â† integral_indicator hs.measurableSet]
    let bound : M â†’ â„ := K.indicator (fun x â†¦ â€–f xâ€–)
    have A : âˆ€ n, AEStronglyMeasurable (fun x â†¦ g n x â€¢ f x) Î¼ :=
      fun n â†¦ (g_diff n).continuous.aestronglyMeasurable.smul hf.aestronglyMeasurable
    have B : Integrable bound Î¼ := by
      rw [integrable_indicator_iff K_compact.measurableSet]
      exact (hf.integrableOn_isCompact K_compact).norm
    have C : âˆ€ n, âˆ€áµ x âˆ‚Î¼, â€–g n x â€¢ f xâ€– â‰¤ bound x := by
      intro n
      apply eventually_of_forall (fun x â†¦ ?_)
      rw [norm_smul]
      refine le_indicator_apply (fun _ â†¦ ?_) (fun hxK â†¦ ?_)
      Â· have : â€–g n xâ€– â‰¤ 1 := by
          have := g_range n (mem_range_self (f := g n) x)
          rw [Real.norm_of_nonneg this.1]
          exact this.2
        exact mul_le_of_le_one_left (norm_nonneg _) this
      Â· have : g n x = 0 := by rw [â† nmem_support, g_supp]; contrapose! hxK; exact vK n hxK
        simp [this]
    have D : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => g n x â€¢ f x) atTop (ğ“ (s.indicator f x)) := by
      apply eventually_of_forall (fun x â†¦ ?_)
      by_cases hxs : x âˆˆ s
      Â· have : âˆ€ n, g n x = 1 := fun n â†¦ hg n x hxs
        simp [this, indicator_of_mem hxs f]
      Â· simp_rw [indicator_of_not_mem hxs f]
        apply tendsto_const_nhds.congr'
        suffices H : âˆ€á¶  n in atTop, g n x = 0 by
          filter_upwards [H] with n hn using by simp [hn]
        obtain âŸ¨Îµ, Îµpos, hÎµâŸ© : âˆƒ Îµ, 0 < Îµ âˆ§ x âˆ‰ thickening Îµ s := by
          rw [â† hs.isClosed.closure_eq, closure_eq_iInter_thickening s] at hxs
          simpa using hxs
        filter_upwards [(tendsto_order.1 u_lim).2 _ Îµpos] with n hn
        rw [â† nmem_support, g_supp]
        contrapose! hÎµ
        exact thickening_mono hn.le s hÎµ
    exact tendsto_integral_of_dominated_convergence bound A B C D
  have : âˆ€ n, âˆ« x, g n x â€¢ f x âˆ‚Î¼ = 0 := by
    refine' fun n â†¦ h _ (g_diff n) _
    apply HasCompactSupport.of_support_subset_isCompact K_compact
    simpa [g_supp] using vK n
  simpa [this] using L",error:  unknown identifier 'ae_eq_zero_of_forall_set_integral_isCompact_eq_zero'',"theorem ae_eq_zero_of_integral_smooth_smul_eq_zero (hf : LocallyIntegrable f Î¼)
    (h : âˆ€ g : M â†’ â„, Smooth I ğ“˜(â„) g â†’ HasCompactSupport g â†’ âˆ« x, g x â€¢ f x âˆ‚Î¼ = 0) :
    âˆ€áµ x âˆ‚Î¼, f x = 0 ",":= by
  have := I.locallyCompactSpace
  have := ChartedSpace.locallyCompactSpace H M
  have := I.secondCountableTopology
  have := ChartedSpace.secondCountable_of_sigma_compact H M
  have := ManifoldWithCorners.metrizableSpace I M
  let _ : MetricSpace M := TopologicalSpace.metrizableSpaceMetric M
  apply ae_eq_zero_of_forall_setIntegral_isCompact_eq_zero' hf (fun s hs â†¦ Eq.symm ?_)
  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´, 0 < Î´ âˆ§ IsCompact (cthickening Î´ s) := hs.exists_isCompact_cthickening
  obtain âŸ¨u, -, u_pos, u_limâŸ© : âˆƒ u, StrictAnti u âˆ§ (âˆ€ (n : â„•), u n âˆˆ Ioo 0 Î´)
    âˆ§ Tendsto u atTop (ğ“ 0) := exists_seq_strictAnti_tendsto' Î´pos
  let v : â„• â†’ Set M := fun n â†¦ thickening (u n) s
  obtain âŸ¨K, K_compact, vKâŸ© : âˆƒ K, IsCompact K âˆ§ âˆ€ n, v n âŠ† K :=
    âŸ¨_, hÎ´, fun n â†¦ thickening_subset_cthickening_of_le (u_pos n).2.le _âŸ©
  have : âˆ€ n, âˆƒ (g : M â†’ â„), support g = v n âˆ§ Smooth I ğ“˜(â„) g âˆ§ Set.range g âŠ† Set.Icc 0 1
          âˆ§ âˆ€ x âˆˆ s, g x = 1 := by
    intro n
    rcases exists_msmooth_support_eq_eq_one_iff I isOpen_thickening hs.isClosed
      (self_subset_thickening (u_pos n).1 s) with âŸ¨g, g_smooth, g_range, g_supp, hgâŸ©
    exact âŸ¨g, g_supp, g_smooth, g_range, fun x hx â†¦ (hg x).1 hxâŸ©
  choose g g_supp g_diff g_range hg using this
  have L : Tendsto (fun n â†¦ âˆ« x, g n x â€¢ f x âˆ‚Î¼) atTop (ğ“ (âˆ« x in s, f x âˆ‚Î¼)) := by
    rw [â† integral_indicator hs.measurableSet]
    let bound : M â†’ â„ := K.indicator (fun x â†¦ â€–f xâ€–)
    have A : âˆ€ n, AEStronglyMeasurable (fun x â†¦ g n x â€¢ f x) Î¼ :=
      fun n â†¦ (g_diff n).continuous.aestronglyMeasurable.smul hf.aestronglyMeasurable
    have B : Integrable bound Î¼ := by
      rw [integrable_indicator_iff K_compact.measurableSet]
      exact (hf.integrableOn_isCompact K_compact).norm
    have C : âˆ€ n, âˆ€áµ x âˆ‚Î¼, â€–g n x â€¢ f xâ€– â‰¤ bound x := by
      intro n
      filter_upwards with x
      rw [norm_smul]
      refine le_indicator_apply (fun _ â†¦ ?_) (fun hxK â†¦ ?_)
      Â· have : â€–g n xâ€– â‰¤ 1 := by
          have := g_range n (mem_range_self (f := g n) x)
          rw [Real.norm_of_nonneg this.1]
          exact this.2
        exact mul_le_of_le_one_left (norm_nonneg _) this
      Â· have : g n x = 0 := by rw [â† nmem_support, g_supp]; contrapose! hxK; exact vK n hxK
        simp [this]
    have D : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => g n x â€¢ f x) atTop (ğ“ (s.indicator f x)) := by
      filter_upwards with x
      by_cases hxs : x âˆˆ s
      Â· have : âˆ€ n, g n x = 1 := fun n â†¦ hg n x hxs
        simp [this, indicator_of_mem hxs f]
      Â· simp_rw [indicator_of_not_mem hxs f]
        apply tendsto_const_nhds.congr'
        suffices H : âˆ€á¶  n in atTop, g n x = 0 by
          filter_upwards [H] with n hn using by simp [hn]
        obtain âŸ¨Îµ, Îµpos, hÎµâŸ© : âˆƒ Îµ, 0 < Îµ âˆ§ x âˆ‰ thickening Îµ s := by
          rw [â† hs.isClosed.closure_eq, closure_eq_iInter_thickening s] at hxs
          simpa using hxs
        filter_upwards [(tendsto_order.1 u_lim).2 _ Îµpos] with n hn
        rw [â† nmem_support, g_supp]
        contrapose! hÎµ
        exact thickening_mono hn.le s hÎµ
    exact tendsto_integral_of_dominated_convergence bound A B C D
  have : âˆ€ n, âˆ« x, g n x â€¢ f x âˆ‚Î¼ = 0 := by
    refine fun n â†¦ h _ (g_diff n) ?_
    apply HasCompactSupport.of_support_subset_isCompact K_compact
    simpa [g_supp] using vK n
  simpa [this] using L"
Mathlib/Computability/Halting.lean,Nat.Partrec.merge',merge',b912476b37f2ea41ee51af7e63439f4a769be095,":= by
  obtain âŸ¨cf, rflâŸ© := Code.exists_code.1 hf
  obtain âŸ¨cg, rflâŸ© := Code.exists_code.1 hg
  have := Primrec.option_orElse.to_comp.toâ‚‚.compâ‚‚
    (Code.evaln_prim.to_comp.comp <| (snd.pair (const cf)).pair fst)
    (Code.evaln_prim.to_comp.comp <| (snd.pair (const cg)).pair fst)
  refine âŸ¨_, Partrec.nat_iff.1 <| Partrec.rfindOpt this.toâ‚‚, fun n => ?_âŸ©
  have (x)
      (h : x âˆˆ rfindOpt fun k â†¦ HOrElse.hOrElse (Code.evaln k cf n) fun _x â†¦ Code.evaln k cg n) :
      x âˆˆ Code.eval cf n âˆ¨ x âˆˆ Code.eval cg n := by
    let âŸ¨k, eâŸ© := Nat.rfindOpt_spec h
    revert e
    simp only [Option.mem_def]
    cases e' : cf.evaln k n
    Â· exact fun e => Or.inr (Code.evaln_sound e)
    Â· rintro âŸ¨âŸ©; exact Or.inl (Code.evaln_sound e')
  refine âŸ¨this, âŸ¨fun h => (this _ âŸ¨h, rflâŸ©).imp Exists.fst Exists.fst, ?_âŸ©âŸ©
  intro h
  rw [Nat.rfindOpt_dom]
  simp only [dom_iff_mem, Code.evaln_complete, Option.mem_def] at h
  obtain âŸ¨x, k, eâŸ© | âŸ¨x, k, eâŸ© := h
  Â· refine âŸ¨k, x, ?_âŸ©
    simp only [e, Option.some_orElse, Option.mem_def]
  Â· refine âŸ¨k, ?_âŸ©
    cases cf.evaln k n with
    | none => exact âŸ¨x, by simp only [e, Option.mem_def, Option.none_orElse]âŸ©
    | some y => exact âŸ¨y, by simp only [Option.some_orElse, Option.mem_def]âŸ©","error:  application type mismatch
  Computableâ‚‚.compâ‚‚ (toâ‚‚ (Primrecâ‚‚.to_comp Primrec.option_orElse))
    (Computable.comp (Primrec.to_comp Code.evaln_prim) (Computable.pair (Computable.pair snd (const cf)) fst))
argument
  Computable.comp (Primrec.to_comp Code.evaln_prim) (Computable.pair (Computable.pair snd (const cf)) fst)
has type
  Computable fun a â†¦ Code.evaln ((a.2, cf), a.1).1.1 ((a.2, cf), a.1).1.2 ((a.2, cf), a.1).2 : Prop
but is expected to have type
  Computableâ‚‚ ?m.421 : Prop
error:  unsolved goals
case intro.intro
cf : Code
hf : Partrec cf.eval
cg : Code
hg : Partrec cg.eval
âŠ¢ âˆƒ h,
    Partrec h âˆ§ âˆ€ (a : â„•), (âˆ€ x âˆˆ h a, x âˆˆ cf.eval a âˆ¨ x âˆˆ cg.eval a) âˆ§ ((h a).Dom â†” (cf.eval a).Dom âˆ¨ (cg.eval a).Dom)","theorem merge' {f g} (hf : Nat.Partrec f) (hg : Nat.Partrec g) :
    âˆƒ h, Nat.Partrec h âˆ§
      âˆ€ a, (âˆ€ x âˆˆ h a, x âˆˆ f a âˆ¨ x âˆˆ g a) âˆ§ ((h a).Dom â†” (f a).Dom âˆ¨ (g a).Dom) ",":= by
  obtain âŸ¨cf, rflâŸ© := Code.exists_code.1 hf
  obtain âŸ¨cg, rflâŸ© := Code.exists_code.1 hg
  have : Nat.Partrec fun n => Nat.rfindOpt fun k => cf.evaln k n <|> cg.evaln k n :=
    Partrec.nat_iff.1
      (Partrec.rfindOpt <|
        Primrec.option_orElse.to_comp.comp
          (Code.evaln_prim.to_comp.comp <| (snd.pair (const cf)).pair fst)
          (Code.evaln_prim.to_comp.comp <| (snd.pair (const cg)).pair fst))
  refine âŸ¨_, this, fun n => ?_âŸ©
  have : âˆ€ x âˆˆ rfindOpt fun k â†¦ HOrElse.hOrElse (Code.evaln k cf n) fun _x â†¦ Code.evaln k cg n,
      x âˆˆ Code.eval cf n âˆ¨ x âˆˆ Code.eval cg n := by
    intro x h
    obtain âŸ¨k, eâŸ© := Nat.rfindOpt_spec h
    revert e
    simp only [Option.mem_def]
    cases' e' : cf.evaln k n with y <;> simp <;> intro e
    Â· exact Or.inr (Code.evaln_sound e)
    Â· subst y
      exact Or.inl (Code.evaln_sound e')
  refine âŸ¨this, âŸ¨fun h => (this _ âŸ¨h, rflâŸ©).imp Exists.fst Exists.fst, ?_âŸ©âŸ©
  intro h
  rw [Nat.rfindOpt_dom]
  simp only [dom_iff_mem, Code.evaln_complete, Option.mem_def] at h
  obtain âŸ¨x, k, eâŸ© | âŸ¨x, k, eâŸ© := h
  Â· refine âŸ¨k, x, ?_âŸ©
    simp only [e, Option.some_orElse, Option.mem_def]
  Â· refine âŸ¨k, ?_âŸ©
    cases' cf.evaln k n with y
    Â· exact âŸ¨x, by simp only [e, Option.mem_def, Option.none_orElse]âŸ©
    Â· exact âŸ¨y, by simp only [Option.some_orElse, Option.mem_def]âŸ©"
Mathlib/Probability/Distributions/Gaussian.lean,ProbabilityTheory.gaussianReal_map_const_mul,gaussianReal_map_const_mul,b59290a60c46dde5929497c93a9814bf43d45c31,":= by
  by_cases hv : v = 0
  Â· simp only [hv, mul_zero, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.const_mul c) Î¼
  by_cases hc : c = 0
  Â· simp only [hc, zero_mul, ne_eq, abs_zero, mul_eq_zero]
    rw [Measure.map_const]
    simp only [ne_eq, measure_univ, one_smul, mul_eq_zero]
    convert (gaussianReal_zero_var 0).symm
    simp only [ne_eq, zero_pow', mul_eq_zero, hv, or_false]
    rfl
  let e : â„ â‰ƒáµ â„ := (Homeomorph.mulLeftâ‚€ c hc).symm.toMeasurableEquiv
  have he' : âˆ€ x, HasDerivAt e ((fun _ â†¦ câ»Â¹) x) x := by
    suffices âˆ€ x, HasDerivAt (fun x => câ»Â¹ * x) (câ»Â¹ * 1) x by rwa [mul_one] at this
    exact fun _ â†¦ HasDerivAt.const_mul _ (hasDerivAt_id _)
  change (gaussianReal Î¼ v).map e.symm = gaussianReal (c * Î¼) (âŸ¨c^2, sq_nonneg _âŸ© * v)
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs']
  simp only [MeasurableEquiv.coe_mk, Equiv.coe_fn_mk, ne_eq, mul_eq_zero]
  rw [gaussianReal_apply_eq_integral _ _ hs']
  swap
  Â· simp only [ne_eq, mul_eq_zero, hv, or_false]
    rw [â† NNReal.coe_eq]
    simp [hc]
  simp only [Homeomorph.mulLeftâ‚€, Equiv.toFun_as_coe, Equiv.mulLeftâ‚€_apply, Equiv.invFun_as_coe,
    Equiv.mulLeftâ‚€_symm_apply, Homeomorph.toMeasurableEquiv_coe, Homeomorph.homeomorph_mk_coe_symm,
    Equiv.coe_fn_symm_mk, gaussianPdfReal_inv_mul hc]
  congr with x
  suffices |câ»Â¹| * |c| = 1 by rw [â† mul_assoc, this, one_mul]
  rw [abs_inv, inv_mul_cancel]
  rwa [ne_eq, abs_eq_zero]","error:  unknown identifier 'zero_pow''
error:  The rfl tactic failed. Possible reasons:
- The goal is not a reflexive relation (neither `=` nor a relation with a @[refl] lemma).
- The arguments of the relation are not equal.
Try using the reflexivity lemma for your relation explicitly, e.g. `exact Eq.refl _` or
`exact HEq.rfl` etc.
case h.e'_3.h.e'_2
Î¼ : â„
v : â„â‰¥0
c : â„
hv : Â¬v = 0
hc : c = 0
âŠ¢ âŸ¨0 ^ 2, â‹¯âŸ© = 0
error:  simp made no progress","lemma gaussianReal_map_const_mul (c : â„) :
    (gaussianReal Î¼ v).map (c * Â·) = gaussianReal (c * Î¼) (âŸ¨c^2, sq_nonneg _âŸ© * v) ",":= by
  by_cases hv : v = 0
  Â· simp only [hv, mul_zero, ne_eq, not_true, gaussianReal_zero_var]
    exact Measure.map_dirac (measurable_id'.const_mul c) Î¼
  by_cases hc : c = 0
  Â· simp only [hc, zero_mul, ne_eq, abs_zero, mul_eq_zero]
    rw [Measure.map_const]
    simp only [ne_eq, measure_univ, one_smul, mul_eq_zero]
    convert (gaussianReal_zero_var 0).symm
    simp only [ne_eq, zero_pow, mul_eq_zero, hv, or_false, not_false_eq_true]
    rfl
  let e : â„ â‰ƒáµ â„ := (Homeomorph.mulLeftâ‚€ c hc).symm.toMeasurableEquiv
  have he' : âˆ€ x, HasDerivAt e ((fun _ â†¦ câ»Â¹) x) x := by
    suffices âˆ€ x, HasDerivAt (fun x => câ»Â¹ * x) (câ»Â¹ * 1) x by rwa [mul_one] at this
    exact fun _ â†¦ HasDerivAt.const_mul _ (hasDerivAt_id _)
  change (gaussianReal Î¼ v).map e.symm = gaussianReal (c * Î¼) (âŸ¨c^2, sq_nonneg _âŸ© * v)
  ext s' hs'
  rw [MeasurableEquiv.gaussianReal_map_symm_apply hv e he' hs',
    gaussianReal_apply_eq_integral _ _ s']
  swap
  Â· simp only [ne_eq, mul_eq_zero, hv, or_false]
    rw [â† NNReal.coe_inj]
    simp [hc]
  simp only [e, Homeomorph.mulLeftâ‚€, Equiv.toFun_as_coe, Equiv.mulLeftâ‚€_apply, Equiv.invFun_as_coe,
    Equiv.mulLeftâ‚€_symm_apply, Homeomorph.toMeasurableEquiv_coe, Homeomorph.homeomorph_mk_coe_symm,
    Equiv.coe_fn_symm_mk, gaussianPDFReal_inv_mul hc]
  congr with x
  suffices |câ»Â¹| * |c| = 1 by rw [â† mul_assoc, this, one_mul]
  rw [abs_inv, inv_mul_cancel]
  rwa [ne_eq, abs_eq_zero]"
Mathlib/FieldTheory/IsAlgClosed/Classification.lean,Algebra.IsAlgebraic.cardinal_mk_le_max,cardinal_mk_le_max,6dc60c317fd4bd55afd839f27f348a3136ee1fdc,":=
  calc
    #L â‰¤ #(Î£ p : R[X], { x : L // x âˆˆ p.[L]-roots }) :=
      cardinal_mk_le_sigma_polynomial R L halg
    _ = Cardinal.sum fun p : R[X] => #{x : L | x âˆˆ p.[L]-roots} := by
      rw [â† mk_sigma]; rfl
    _ â‰¤ Cardinal.sum.{u, u} fun _ : R[X] => â„µâ‚€ :=
      (sum_le_sum _ _ fun p => (Multiset.finite_toSet _).lt_aleph0.le)
    _ = #(R[X]) * â„µâ‚€ := (sum_const' _ _)
    _ â‰¤ max (max #(R[X]) â„µâ‚€) â„µâ‚€ := (mul_le_max _ _)
    _ â‰¤ max (max (max #R â„µâ‚€) â„µâ‚€) â„µâ‚€ :=
      (max_le_max (max_le_max Polynomial.cardinal_mk_le_max le_rfl) le_rfl)
    _ = max #R â„µâ‚€ := by simp only [max_assoc, max_comm â„µâ‚€, max_left_comm â„µâ‚€, max_self]","error:  invalid field notation, identifier or numeral expected
error:  unknown identifier 'roots'
error:  function expected at
  cardinal_mk_le_sigma_polynomial R L
term has type
  #L â‰¤ #((p : R[X]) Ã— { x // x âˆˆ p.aroots L })
error:  invalid field notation, identifier or numeral expected
error:  unknown identifier 'roots'
error:  failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
R L : Type u
instâœâµ : CommRing R
instâœâ´ : CommRing L
instâœÂ³ : IsDomain L
instâœÂ² : Algebra R L
instâœÂ¹ : NoZeroSMulDivisors R L
instâœ : Algebra.IsAlgebraic R L
p : R[X]
x : L
âŠ¢ ?m.8280 p x (sorryAx (?m.8279 p x) true) L
error:  failed to prove index is valid, possible solutions:
  - Use `have`-expressions to prove the index is valid
  - Use `a[i]!` notation instead, runtime check is perfomed, and 'Panic' error message is produced if index is not valid
  - Use `a[i]?` notation instead, result is an `Option` type
  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid
R L : Type u
instâœâµ : CommRing R
instâœâ´ : CommRing L
instâœÂ³ : IsDomain L
instâœÂ² : Algebra R L
instâœÂ¹ : NoZeroSMulDivisors R L
instâœ : Algebra.IsAlgebraic R L
p : R[X]
x : L
âŠ¢ ?m.8854 p x (sorryAx (?m.8853 p x) true) L",theorem cardinal_mk_le_max : #L â‰¤ max #R â„µâ‚€ ,":=
  calc
    #L â‰¤ #(Î£ p : R[X], { x : L // x âˆˆ p.aroots L }) :=
      cardinal_mk_le_sigma_polynomial R L
    _ = Cardinal.sum fun p : R[X] => #{x : L | x âˆˆ p.aroots L} := by
      rw [â† mk_sigma]; rfl
    _ â‰¤ Cardinal.sum.{u, u} fun _ : R[X] => â„µâ‚€ :=
      (sum_le_sum _ _ fun p => (Multiset.finite_toSet _).lt_aleph0.le)
    _ = #(R[X]) * â„µâ‚€ := sum_const' _ _
    _ â‰¤ max (max #(R[X]) â„µâ‚€) â„µâ‚€ := mul_le_max _ _
    _ â‰¤ max (max (max #R â„µâ‚€) â„µâ‚€) â„µâ‚€ :=
      (max_le_max (max_le_max Polynomial.cardinal_mk_le_max le_rfl) le_rfl)
    _ = max #R â„µâ‚€ := by simp only [max_assoc, max_comm â„µâ‚€, max_left_comm â„µâ‚€, max_self]"
Mathlib/Data/Fin/Basic.lean,Fin.castLE_injective,castLE_injective,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,:= (strictMono_castLE _).injective,"warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `Fin.val_bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit0` has been deprecated
error:  unknown identifier 'strictMono_castLE'",lemma castLE_injective (hmn : m â‰¤ n) : Injective (castLE hmn) ,":=
  fun a b hab â†¦ ext (by have := congr_arg val hab; exact this)"
Mathlib/Data/Fin/Tuple/Basic.lean,Fin.cons_snoc_eq_snoc_cons,cons_snoc_eq_snoc_cons,328a7a8a86c3962b66c14b64d6f32023f67a064c,":= by
  ext i
  by_cases h : i = 0
  Â· rw [h]
    simp [snoc, castLT]
  set j := pred i h with ji
  have : i = j.succ := by rw [ji, succ_pred]
  rw [this, cons_succ]
  by_cases h' : j.val < n
  Â· set k := castLT j h' with jk
    have : j = castSucc k := by rw [jk, castSucc_castLT]
    rw [this, â† castSucc_fin_succ, snoc]
    simp [pred, snoc, cons]
    rfl
  rw [eq_last_of_not_lt h', succ_last]
  simp",error:  no goals to be solved,"theorem cons_snoc_eq_snoc_cons {Î² : Type*} (a : Î²) (q : Fin n â†’ Î²) (b : Î²) :
    @cons n.succ (fun _ â†¦ Î²) a (snoc q b) = snoc (cons a q) b ",":= by
  ext i
  by_cases h : i = 0
  Â· rw [h]
    simp [snoc, castLT]
  set j := pred i h with ji
  have : i = j.succ := by rw [ji, succ_pred]
  rw [this, cons_succ]
  by_cases h' : j.val < n
  Â· set k := castLT j h' with jk
    have : j = castSucc k := by rw [jk, castSucc_castLT]
    rw [this, â† castSucc_fin_succ, snoc]
    simp [pred, snoc, cons]
  rw [eq_last_of_not_lt h', succ_last]
  simp"
Mathlib/GroupTheory/Index.lean,Subgroup.index_ne_zero_of_finite,index_ne_zero_of_finite,472fb92f63066ff13dff749c4cc2b850d1d35a92,":= by
  cases nonempty_fintype (G â§¸ H)
  rw [index_eq_card]
  exact Nat.card_pos.ne'","error:  typeclass instance problem is stuck, it is often due to metavariables
  Finite ?m.51954",theorem index_ne_zero_of_finite [hH : Finite (G â§¸ H)] : H.index â‰  0 ,":= by
  cases nonempty_fintype (G â§¸ H)
  rw [index_eq_card]
  exact Fintype.card_ne_zero"
Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean,jacobiSym.mod_right,mod_right,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  rcases eq_or_ne a 0 with (rfl | haâ‚€)
  Â· rw [mul_zero, mod_zero]
  have hb' : Odd (b % (4 * a)) := hb.mod_even (Even.mul_right (by norm_num) _)
  rcases exists_eq_pow_mul_and_not_dvd haâ‚€ 2 (by norm_num) with âŸ¨e, a', haâ‚', haâ‚‚âŸ©
  have haâ‚ := odd_iff.mpr (two_dvd_ne_zero.mp haâ‚')
  nth_rw 2 [haâ‚‚]; nth_rw 1 [haâ‚‚]
  rw [Nat.cast_mul, mul_left, mul_left, quadratic_reciprocity' haâ‚ hb,
    quadratic_reciprocity' haâ‚ hb', Nat.cast_pow, pow_left, pow_left, Nat.cast_two, at_two hb,
    at_two hb']
  congr 1; swap; congr 1
  Â· simp_rw [qrSign]
    rw [Ï‡â‚„_nat_mod_four, Ï‡â‚„_nat_mod_four (b % (4 * a)), mod_mod_of_dvd b (dvd_mul_right 4 a)]
  Â· rw [mod_left â†‘(b % _), mod_left b, Int.coe_nat_mod, Int.emod_emod_of_dvd b]
    simp only [haâ‚‚, Nat.cast_mul, â† mul_assoc]
    exact dvd_mul_left (a' : â„¤) (â†‘4 * â†‘(2 ^ e))
  cases' e with e; Â· rfl
  Â· rw [Ï‡â‚ˆ_nat_mod_eight, Ï‡â‚ˆ_nat_mod_eight (b % (4 * a)), mod_mod_of_dvd b]
    use 2 ^ e * a'; rw [haâ‚‚, Nat.pow_succ]; ring","warning:  jacobiSym does not have a doc string
error:  unsolved goals
a b : â„•
hb : Odd b
haâ‚€ : a â‰  0
âŠ¢ Even 4
error:  unknown constant 'Int.coe_nat_mod'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.71657
case inr.intro.intro.intro.e_a.e_a
a b : â„•
hb : Odd b
haâ‚€ : a â‰  0
hb' : Odd (b % (4 * a))
e a' : â„•
haâ‚' : Â¬2 âˆ£ a'
haâ‚‚ : a = 2 ^ e * a'
haâ‚ : Odd a'
âŠ¢ J(â†‘b % â†‘a' | a') = J(â†‘(b % (4 * a)) % â†‘a' | a')",theorem mod_right' (a : â„•) {b : â„•} (hb : Odd b) : J(a | b) = J(a | b % (4 * a)) ,":= by
  rcases eq_or_ne a 0 with (rfl | haâ‚€)
  Â· rw [mul_zero, mod_zero]
  have hb' : Odd (b % (4 * a)) := hb.mod_even (Even.mul_right (by decide) _)
  rcases exists_eq_pow_mul_and_not_dvd haâ‚€ 2 (by norm_num) with âŸ¨e, a', haâ‚', haâ‚‚âŸ©
  have haâ‚ := odd_iff.mpr (two_dvd_ne_zero.mp haâ‚')
  nth_rw 2 [haâ‚‚]; nth_rw 1 [haâ‚‚]
  rw [Nat.cast_mul, mul_left, mul_left, quadratic_reciprocity' haâ‚ hb,
    quadratic_reciprocity' haâ‚ hb', Nat.cast_pow, pow_left, pow_left, Nat.cast_two, at_two hb,
    at_two hb']
  congr 1; swap;
  Â· congr 1
    Â· simp_rw [qrSign]
      rw [Ï‡â‚„_nat_mod_four, Ï‡â‚„_nat_mod_four (b % (4 * a)), mod_mod_of_dvd b (dvd_mul_right 4 a)]
    Â· rw [mod_left â†‘(b % _), mod_left b, Int.natCast_mod, Int.emod_emod_of_dvd b]
      simp only [haâ‚‚, Nat.cast_mul, â† mul_assoc]
      apply dvd_mul_left
  cases' e with e; Â· rfl
  Â· rw [Ï‡â‚ˆ_nat_mod_eight, Ï‡â‚ˆ_nat_mod_eight (b % (4 * a)), mod_mod_of_dvd b]
    use 2 ^ e * a'; rw [haâ‚‚, Nat.pow_succ]; ring"
Mathlib/Geometry/Euclidean/Circumcenter.lean,EuclideanGeometry.exists_circumcenter_eq_of_cospherical,exists_circumcenter_eq_of_cospherical,2ac7d87c221020b247729b180bbe2575cceb0700,":= by
  rw [cospherical_iff_exists_mem_of_finiteDimensional h] at hc
  rcases hc with âŸ¨c, hc, r, hcrâŸ©
  use c
  intro sx hsxps
  have hsx : affineSpan â„ (Set.range sx.points) = s := by
    refine'
      sx.Independent.affineSpan_eq_of_le_of_card_eq_finrank_add_one
        (spanPoints_subset_coe_of_subset_coe (hsxps.trans h)) _
    simp [hd]
  have hc : c âˆˆ affineSpan â„ (Set.range sx.points) := hsx.symm â–¸ hc
  exact
    (sx.eq_circumcenter_of_dist_eq hc fun i =>
        hcr (sx.points i) (hsxps (Set.mem_range_self i))).symm","error:  invalid field 'Independent', the environment does not contain 'Affine.Simplex.Independent'
  sx
has type
  Simplex â„ P n
error:  no goals to be solved","theorem exists_circumcenter_eq_of_cospherical_subset {s : AffineSubspace â„ P} {ps : Set P}
    (h : ps âŠ† s) [Nonempty s] {n : â„•} [FiniteDimensional â„ s.direction]
    (hd : finrank â„ s.direction = n) (hc : Cospherical ps) :
    âˆƒ c : P, âˆ€ sx : Simplex â„ P n, Set.range sx.points âŠ† ps â†’ sx.circumcenter = c ",":= by
  rw [cospherical_iff_exists_mem_of_finiteDimensional h] at hc
  rcases hc with âŸ¨c, hc, r, hcrâŸ©
  use c
  intro sx hsxps
  have hsx : affineSpan â„ (Set.range sx.points) = s := by
    refine
      sx.independent.affineSpan_eq_of_le_of_card_eq_finrank_add_one
        (spanPoints_subset_coe_of_subset_coe (hsxps.trans h)) ?_
    simp [hd]
  have hc : c âˆˆ affineSpan â„ (Set.range sx.points) := hsx.symm â–¸ hc
  exact
    (sx.eq_circumcenter_of_dist_eq hc fun i =>
        hcr (sx.points i) (hsxps (Set.mem_range_self i))).symm"
Mathlib/Topology/NoetherianSpace.lean,TopologicalSpace.noetherianSpace_TFAE,noetherianSpace_TFAE,d04897a61efc29f2393f448154f212472c91b47d,":= by
  tfae_have 1 â†” 2
  Â· refine' (noetherianSpace_iff Î±).trans (Surjective.wellFounded_iff Opens.compl_bijective.2 _)
    exact (@OrderIso.compl (Set Î±)).lt_iff_lt.symm
  tfae_have 1 â†” 4
  Â· exact noetherianSpace_iff_opens Î±
  tfae_have 1 â†’ 3
  Â· exact @NoetherianSpace.isCompact Î± _
  tfae_have 3 â†’ 4
  Â· exact fun h s => h s
  tfae_finish","error:  unknown identifier 'Surjective.wellFounded_iff'
error:  no goals to be solved","theorem noetherianSpace_TFAE :
    TFAE [NoetherianSpace Î±,
      WellFounded fun s t : Closeds Î± => s < t,
      âˆ€ s : Set Î±, IsCompact s,
      âˆ€ s : Opens Î±, IsCompact (s : Set Î±)] ",":= by
  tfae_have 1 â†” 2
  Â· refine (noetherianSpace_iff Î±).trans (Opens.compl_bijective.2.wellFounded_iff ?_)
    exact (@OrderIso.compl (Set Î±)).lt_iff_lt.symm
  tfae_have 1 â†” 4
  Â· exact noetherianSpace_iff_opens Î±
  tfae_have 1 â†’ 3
  Â· exact @NoetherianSpace.isCompact Î± _
  tfae_have 3 â†’ 4
  Â· exact fun h s => h s
  tfae_finish"
Mathlib/Algebra/Group/Opposite.lean,AddMonoidHom.mul_op_ext,AddMonoidHom.mul_op_ext,2b42dc7c3f9ebf6e7f17bff850d9c0bc3f1cf75e,":=
  AddMonoidHom.ext <| MulOpposite.rec fun x => (FunLike.congr_fun h : _) x",error:  unknown constant 'MulOpposite.rec',"theorem AddMonoidHom.mul_op_ext {Î± Î²} [AddZeroClass Î±] [AddZeroClass Î²] (f g : Î±áµáµ’áµ– â†’+ Î²)
    (h :
      f.comp (opAddEquiv : Î± â‰ƒ+ Î±áµáµ’áµ–).toAddMonoidHom =
        g.comp (opAddEquiv : Î± â‰ƒ+ Î±áµáµ’áµ–).toAddMonoidHom) :
    f = g ",":=
  AddMonoidHom.ext <| MulOpposite.rec' fun x => (DFunLike.congr_fun h : _) x"
Mathlib/CategoryTheory/Sites/CompatiblePlus.lean,CategoryTheory.GrothendieckTopology.plusCompIso_whiskerRight,plusCompIso_whiskerRight,fcf529d7b3138e5580a1be7c6dc3317d3f207d59,":= by
  ext X
  apply (isColimitOfPreserves F (colimit.isColimit (J.diagram P X.unop))).hom_ext
  intro W
  dsimp [plusObj, plusMap]
  simp only [Î¹_colimMap, whiskerRight_app, Î¹_plusCompIso_hom_assoc,
    GrothendieckTopology.diagramNatTrans_app]
  simp only [â† Category.assoc, â† F.map_comp]
  dsimp [colimMap, IsColimit.map]
  simp only [colimit.Î¹_desc]
  dsimp [Cocones.precompose]
  simp only [Functor.map_comp, Category.assoc, Î¹_plusCompIso_hom]
  simp only [â† Category.assoc]
  congr 1
  apply Multiequalizer.hom_ext
  intro a
  dsimp
  simp only [diagramCompIso_hom_proj_assoc, Multiequalizer.lift_proj, diagramCompIso_hom_proj,
    Category.assoc]
  simp only [â† F.map_comp, Multiequalizer.lift_proj]","error:  unknown identifier 'diagramCompIso_hom_proj_assoc'
error:  unknown identifier 'Multiequalizer.lift_proj'
error:  unknown identifier 'diagramCompIso_hom_proj'
error:  unknown identifier 'Multiequalizer.lift_proj'
error:  simp made no progress","theorem plusCompIso_whiskerRight {P Q : Cáµ’áµ– â¥¤ D} (Î· : P âŸ¶ Q) :
    whiskerRight (J.plusMap Î·) F â‰« (J.plusCompIso F Q).hom =
      (J.plusCompIso F P).hom â‰« J.plusMap (whiskerRight Î· F) ",":= by
  ext X
  apply (isColimitOfPreserves F (colimit.isColimit (J.diagram P X.unop))).hom_ext
  intro W
  dsimp [plusObj, plusMap]
  simp only [Î¹_colimMap, whiskerRight_app, Î¹_plusCompIso_hom_assoc,
    GrothendieckTopology.diagramNatTrans_app]
  simp only [â† Category.assoc, â† F.map_comp]
  dsimp [colimMap, IsColimit.map]
  simp only [colimit.Î¹_desc]
  dsimp [Cocones.precompose]
  simp only [Functor.map_comp, Category.assoc, Î¹_plusCompIso_hom]
  simp only [â† Category.assoc]
  congr 1
  apply Multiequalizer.hom_ext
  intro a
  dsimp
  simp only [diagramCompIso_hom_Î¹_assoc, Multiequalizer.lift_Î¹, diagramCompIso_hom_Î¹,
    Category.assoc]
  simp only [â† F.map_comp, Multiequalizer.lift_Î¹]"
Mathlib/Data/Seq/Parallel.lean,Computation.terminates_parallel,terminates_parallel,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  have lem1 :
    âˆ€ l S, (âˆƒ a : Î±, parallel.aux2 l = Sum.inl a) â†’ Terminates (corec parallel.aux1 (l, S)) := by
    intro l S e
    cases' e with a e
    have : corec parallel.aux1 (l, S) = return a := by
      apply destruct_eq_pure
      simp only [parallel.aux1, rmap, corec_eq]
      rw [e]
    rw [this]
    exact ret_terminates a
  intro l S c m T
  revert l S
  apply @terminatesRecOn _ _ c T _ _
  Â· intro a l S m
    apply lem1
    induction' l with c l IH <;> simp at m
    cases' m with e m
    Â· rw [â† e]
      simp only [parallel.aux2, rmap, List.foldr_cons, destruct_pure]
      split <;> simp
    Â· cases' IH m with a' e
      simp only [parallel.aux2, rmap, List.foldr_cons]
      simp? [parallel.aux2] at e says simp only [parallel.aux2, rmap] at e
      rw [e]
      exact âŸ¨a', rflâŸ©
  Â· intro s IH l S m
    have H1 : âˆ€ l', parallel.aux2 l = Sum.inr l' â†’ s âˆˆ l' := by
      induction' l with c l IH' <;> intro l' e' <;> simp at m
      cases' m with e m <;> simp [parallel.aux2] at e'
      Â· rw [â† e] at e'
        revert e'
        split
        Â· simp
        Â· simp only [destruct_think, Sum.inr.injEq]
          rintro rfl
          simp
      Â· induction' e : List.foldr (fun c o =>
            match o with
            | Sum.inl a => Sum.inl a
            | Sum.inr ls => rmap (fun c' => c' :: ls) (destruct c))
          (Sum.inr List.nil) l with a' ls <;> erw [e] at e'
        Â· contradiction
        have := IH' m _ e
        revert e'
        cases destruct c <;> intro e' <;> [injection e'; injection e' with h']
        rw [â† h']
        simp [this]
    induction' h : parallel.aux2 l with a l'
    Â· exact lem1 _ _ âŸ¨a, hâŸ©
    Â· have H2 : corec parallel.aux1 (l, S) = think _ := by
        apply destruct_eq_think
        simp only [parallel.aux1, rmap, corec_eq]
        rw [h]
      rw [H2]
      refine @Computation.think_terminates _ _ ?_
      have := H1 _ h
      rcases Seq.destruct S with (_ | âŸ¨_ | c, S'âŸ©) <;> simp [parallel.aux1] <;> apply IH <;>
        simp [this]","error:  don't know how to synthesize placeholder for argument 'c'
context:
Î± : Type u
Î² : Type v
lem1 :
  âˆ€ (l : List (Computation Î±)) (S : WSeq (Computation Î±)),
    (âˆƒ a, parallel.aux2 l = Sum.inl a) â†’ (corec parallel.aux1 (l, S)).Terminates
c : Computation Î±
T : c.Terminates
s : Computation Î±
IH : âˆ€ {l : List (Computation Î±)} {S : WSeq (Computation Î±)}, s âˆˆ l â†’ (corec parallel.aux1 (l, S)).Terminates
l : List (Computation Î±)
S : WSeq (Computation Î±)
m : s.think âˆˆ l
H1 : âˆ€ (l' : List (Computation Î±)), parallel.aux2 l = Sum.inr l' â†’ s âˆˆ l'
l' : List (Computation Î±)
h : parallel.aux2 l = Sum.inr l'
âŠ¢ Computation Î±","theorem terminates_parallel.aux :
    âˆ€ {l : List (Computation Î±)} {S c},
      c âˆˆ l â†’ Terminates c â†’ Terminates (corec parallel.aux1 (l, S)) ",":= by
  have lem1 :
    âˆ€ l S, (âˆƒ a : Î±, parallel.aux2 l = Sum.inl a) â†’ Terminates (corec parallel.aux1 (l, S)) := by
    intro l S e
    cases' e with a e
    have : corec parallel.aux1 (l, S) = return a := by
      apply destruct_eq_pure
      simp only [parallel.aux1, rmap, corec_eq]
      rw [e]
    rw [this]
    exact ret_terminates a
  intro l S c m T
  revert l S
  apply @terminatesRecOn _ _ c T _ _
  Â· intro a l S m
    apply lem1
    induction' l with c l IH <;> simp at m
    cases' m with e m
    Â· rw [â† e]
      simp only [parallel.aux2, rmap, List.foldr_cons, destruct_pure]
      split <;> simp
    Â· cases' IH m with a' e
      simp only [parallel.aux2, rmap, List.foldr_cons]
      simp? [parallel.aux2] at e says simp only [parallel.aux2, rmap] at e
      rw [e]
      exact âŸ¨a', rflâŸ©
  Â· intro s IH l S m
    have H1 : âˆ€ l', parallel.aux2 l = Sum.inr l' â†’ s âˆˆ l' := by
      induction' l with c l IH' <;> intro l' e' <;> simp at m
      cases' m with e m <;> simp [parallel.aux2] at e'
      Â· rw [â† e] at e'
        revert e'
        split
        Â· simp
        Â· simp only [destruct_think, Sum.inr.injEq]
          rintro rfl
          simp
      Â· induction' e : List.foldr (fun c o =>
            match o with
            | Sum.inl a => Sum.inl a
            | Sum.inr ls => rmap (fun c' => c' :: ls) (destruct c))
          (Sum.inr List.nil) l with a' ls <;> erw [e] at e'
        Â· contradiction
        have := IH' m _ e
        revert e'
        cases destruct c <;> intro e' <;> [injection e'; injection e' with h']
        rw [â† h']
        simp [this]
    induction' h : parallel.aux2 l with a l'
    Â· exact lem1 _ _ âŸ¨a, hâŸ©
    Â· have H2 : corec parallel.aux1 (l, S) = think _ := destruct_eq_think (by
        simp only [parallel.aux1, rmap, corec_eq]
        rw [h])
      rw [H2]
      refine @Computation.think_terminates _ _ ?_
      have := H1 _ h
      rcases Seq.destruct S with (_ | âŸ¨_ | c, S'âŸ©) <;> simp [parallel.aux1] <;> apply IH <;>
        simp [this]"
Mathlib/Combinatorics/SimpleGraph/Clique.lean,SimpleGraph.CliqueFreeOn.of_succ,CliqueFreeOn.of_succ,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  classical
  refine' fun t hts ht => hs _ (ht.insert fun b hb => (hts hb).2)
  push_cast
  exact Set.insert_subset_iff.2 âŸ¨ha, hts.trans <| Set.inter_subset_left _ _âŸ©","error:  function expected at
  Set.inter_subset_left ?m.155309
term has type
  ?m.155308 âˆˆ ?m.155306","theorem CliqueFreeOn.of_succ (hs : G.CliqueFreeOn s (n + 1)) (ha : a âˆˆ s) :
    G.CliqueFreeOn (s âˆ© G.neighborSet a) n ",":= by
  classical
  refine fun t hts ht => hs ?_ (ht.insert fun b hb => (hts hb).2)
  push_cast
  exact Set.insert_subset_iff.2 âŸ¨ha, hts.trans Set.inter_subset_leftâŸ©"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,hasFDerivAt_of_tendstoUniformlyOnFilter,hasFDerivAt_of_tendstoUniformlyOnFilter,65f7857d510e130142dbb111786341d695ac399b,":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine' Tendsto.add (Tendsto.add _ _) _
  simp only
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine' Tendsto.mono_left _ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine' squeeze_zero_norm _
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod_map]
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)",error:  simp made no progress,"theorem hasFDerivAt_of_tendstoUniformlyOnFilter [NeBot l]
    (hf' : TendstoUniformlyOnFilter f' g' l (ğ“ x))
    (hf : âˆ€á¶  n : Î¹ Ã— E in l Ã—Ë¢ ğ“ x, HasFDerivAt (f n.1) (f' n.1 n.2) n.2)
    (hfg : âˆ€á¶  y in ğ“ x, Tendsto (fun n => f n y) l (ğ“ (g y))) : HasFDerivAt g (g' x) x ",":= by
  rw [hasFDerivAt_iff_tendsto]
  suffices
    Tendsto (fun y : Î¹ Ã— E => â€–y.2 - xâ€–â»Â¹ * â€–g y.2 - g x - (g' x) (y.2 - x)â€–)
      (l.curry (ğ“ x)) (ğ“ 0) by
    rw [Metric.tendsto_nhds] at this âŠ¢
    intro Îµ hÎµ
    specialize this Îµ hÎµ
    rw [eventually_curry_iff] at this
    simp only at this
    exact (eventually_const.mp this).mono (by simp only [imp_self, forall_const])
  conv =>
    congr
    ext
    rw [â† abs_norm, â† abs_inv, â† @RCLike.norm_ofReal ğ•œ _ _, RCLike.ofReal_inv, â† norm_smul]
  rw [â† tendsto_zero_iff_norm_tendsto_zero]
  have :
    (fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (g' x) (a.2 - x))) =
      ((fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (g a.2 - g x - (f a.1 a.2 - f a.1 x))) +
          fun a : Î¹ Ã— E =>
          (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f a.1 a.2 - f a.1 x - ((f' a.1 x) a.2 - (f' a.1 x) x))) +
        fun a : Î¹ Ã— E => (â€–a.2 - xâ€–â»Â¹ : ğ•œ) â€¢ (f' a.1 x - g' x) (a.2 - x) := by
    ext; simp only [Pi.add_apply]; rw [â† smul_add, â† smul_add]; congr
    simp only [map_sub, sub_add_sub_cancel, ContinuousLinearMap.coe_sub', Pi.sub_apply]
    abel
  simp_rw [this]
  have : ğ“ (0 : G) = ğ“ (0 + 0 + 0) := by simp only [add_zero]
  rw [this]
  refine Tendsto.add (Tendsto.add ?_ ?_) ?_
  Â· have := difference_quotients_converge_uniformly hf' hf hfg
    rw [Metric.tendstoUniformlyOnFilter_iff] at this
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    apply ((this Îµ hÎµ).filter_mono curry_le_prod).mono
    intro n hn
    rw [dist_eq_norm] at hn âŠ¢
    rw [â† smul_sub] at hn
    rwa [sub_zero]
  Â· 
    rw [Metric.tendsto_nhds]
    intro Îµ hÎµ
    rw [eventually_curry_iff]
    refine hf.curry.mono fun n hn => ?_
    have := hn.self_of_nhds
    rw [hasFDerivAt_iff_tendsto, Metric.tendsto_nhds] at this
    refine (this Îµ hÎµ).mono fun y hy => ?_
    rw [dist_eq_norm] at hy âŠ¢
    simp only [sub_zero, map_sub, norm_mul, norm_inv, norm_norm] at hy âŠ¢
    rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    exact hy
  Â· 
    refine Tendsto.mono_left ?_ curry_le_prod
    have h1 : Tendsto (fun n : Î¹ Ã— E => g' n.2 - f' n.1 n.2) (l Ã—Ë¢ ğ“ x) (ğ“ 0) := by
      rw [Metric.tendstoUniformlyOnFilter_iff] at hf'
      exact Metric.tendsto_nhds.mpr fun Îµ hÎµ => by simpa using hf' Îµ hÎµ
    have h2 : Tendsto (fun n : Î¹ => g' x - f' n x) l (ğ“ 0) := by
      rw [Metric.tendsto_nhds] at h1 âŠ¢
      exact fun Îµ hÎµ => (h1 Îµ hÎµ).curry.mono fun n hn => hn.self_of_nhds
    refine squeeze_zero_norm ?_
      (tendsto_zero_iff_norm_tendsto_zero.mp (tendsto_fst.comp (h2.prod_map tendsto_id)))
    intro n
    simp_rw [norm_smul, norm_inv, RCLike.norm_coe_norm]
    by_cases hx : x = n.2; Â· simp [hx]
    have hnx : 0 < â€–n.2 - xâ€– := by
      rw [norm_pos_iff]; intro hx'; exact hx (eq_of_sub_eq_zero hx').symm
    rw [inv_mul_le_iff hnx, mul_comm]
    simp only [Function.comp_apply, Prod.map_apply']
    rw [norm_sub_rev]
    exact (f' n.1 x - g' x).le_opNorm (n.2 - x)"
Mathlib/Analysis/NormedSpace/QuaternionExponential.lean,Quaternion.hasSum_expSeries_of_imaginary,hasSum_expSeries_of_imaginary,51d59c1b99e04eb6fe597dd39de4e4fcfa8512d2,":= by
  replace hc := hasSum_coe.mpr hc
  replace hs := (hs.div_const â€–qâ€–).smul_const q
  obtain rfl | hq0 := eq_or_ne q 0
  Â· simp_rw [expSeries_apply_zero, norm_zero, div_zero, zero_smul, add_zero]
    simp_rw [norm_zero] at hc
    convert hc using 1
    ext (_ | n) : 1
    Â· rw [pow_zero, Nat.zero_eq, mul_zero, pow_zero, Nat.factorial_zero, Nat.cast_one,
        div_one, one_mul, Pi.single_eq_same, coe_one]
    Â· rw [zero_pow (mul_pos two_pos (Nat.succ_pos _)), mul_zero, zero_div,
        Pi.single_eq_of_ne n.succ_ne_zero, coe_zero]
  simp_rw [expSeries_apply_eq]
  have hq2 : q ^ 2 = -normSq q := sq_eq_neg_normSq.mpr hq
  have hqn := norm_ne_zero_iff.mpr hq0
  refine' HasSum.even_add_odd _ _
  Â· convert hc using 1
    ext n : 1
    letI k : â„ := â†‘(2 * n)!
    calc
      kâ»Â¹ â€¢ q ^ (2 * n) = kâ»Â¹ â€¢ (-normSq q) ^ n := by rw [pow_mul, hq2]; norm_cast
      _ = kâ»Â¹ â€¢ â†‘((-1 : â„) ^ n * â€–qâ€– ^ (2 * n)) := ?_
      _ = â†‘((-1 : â„) ^ n * â€–qâ€– ^ (2 * n) / k) := ?_
    Â· congr 1
      rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq]
      push_cast
      rfl
    Â· rw [â† coe_mul_eq_smul, div_eq_mul_inv]
      norm_cast
      ring_nf
  Â· convert hs using 1
    ext n : 1
    let k : â„ := â†‘(2 * n + 1)!
    calc
      kâ»Â¹ â€¢ q ^ (2 * n + 1) = kâ»Â¹ â€¢ ((-normSq q) ^ n * q) := by
        rw [pow_succ', pow_mul, hq2]
        norm_cast
      _ = kâ»Â¹ â€¢ ((-1 : â„) ^ n * â€–qâ€– ^ (2 * n)) â€¢ q := ?_
      _ = ((-1 : â„) ^ n * â€–qâ€– ^ (2 * n + 1) / k / â€–qâ€–) â€¢ q := ?_
    Â· congr 1
      rw [neg_pow, normSq_eq_norm_mul_self, pow_mul, sq, â† coe_mul_eq_smul]
    Â· rw [smul_smul]
      congr 1
      simp_rw [pow_succ', mul_div_assoc, div_div_cancel_left' hqn]
      ring","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
case h.e'_5.h.zero
c s : â„
hq : re 0 = 0
hs : HasSum (fun z â†¦ ((-1) ^ z * â€–0â€– ^ (2 * z + 1) / â†‘(2 * z + 1)! / â€–0â€–) â€¢ 0) ((s / â€–0â€–) â€¢ 0)
hc : HasSum (fun a â†¦ â†‘((-1) ^ a * 0 ^ (2 * a) / â†‘(2 * a)!)) â†‘c
âŠ¢ Pi.single 0 1 0 = â†‘(1 * 0 ^ (2 * 0) / â†‘(2 * 0)!)
error:  application type mismatch
  zero_pow (mul_pos ?m.39247 (Nat.succ_pos ?m.39364))
argument
  mul_pos ?m.39247 (Nat.succ_pos ?m.39364)
has type
  0 < ?m.36565 * ?m.39364.succ : Prop
but is expected to have type
  ?m.36562 â‰  0 : Prop
error:  no goals to be solved
error:  unsolved goals
q : â„
hq : q.re = 0
c s : â„
hc : HasSum (fun a â†¦ â†‘((-1) ^ a * â€–qâ€– ^ (2 * a) / â†‘(2 * a)!)) â†‘c
hs : HasSum (fun z â†¦ ((-1) ^ z * â€–qâ€– ^ (2 * z + 1) / â†‘(2 * z + 1)! / â€–qâ€–) â€¢ q) ((s / â€–qâ€–) â€¢ q)
hq0 : q â‰  0
hq2 : q ^ 2 = -â†‘(normSq q)
hqn : â€–qâ€– â‰  0
n : â„•
k : â„ := â†‘(2 * n + 1)!
âŠ¢ kâ»Â¹ â€¢ (q * â†‘((-normSq q) ^ n)) = kâ»Â¹ â€¢ (â†‘((-normSq q) ^ n) * q)
error:  unsolved goals
case h.e'_5.h.calc_1.e_a
q : â„
hq : q.re = 0
c s : â„
hc : HasSum (fun a â†¦ â†‘((-1) ^ a * â€–qâ€– ^ (2 * a) / â†‘(2 * a)!)) â†‘c
hs : HasSum (fun z â†¦ ((-1) ^ z * â€–qâ€– ^ (2 * z + 1) / â†‘(2 * z + 1)! / â€–qâ€–) â€¢ q) ((s / â€–qâ€–) â€¢ q)
hq0 : q â‰  0
hq2 : q ^ 2 = -â†‘(normSq q)
hqn : â€–qâ€– â‰  0
n : â„•
k : â„ := â†‘(2 * n + 1)!
âŠ¢ (-1) ^ n * â†‘(â€–qâ€– * â€–qâ€–) ^ n * q = â†‘((-1) ^ n * (â€–qâ€– * â€–qâ€–) ^ n) * q
error:  simp made no progress","theorem hasSum_expSeries_of_imaginary {q : Quaternion â„} (hq : q.re = 0) {c s : â„}
    (hc : HasSum (fun n => (-1 : â„) ^ n * â€–qâ€– ^ (2 * n) / (2 * n)!) c)
    (hs : HasSum (fun n => (-1 : â„) ^ n * â€–qâ€– ^ (2 * n + 1) / (2 * n + 1)!) s) :
    HasSum (fun n => expSeries â„ (Quaternion â„) n fun _ => q) (â†‘c + (s / â€–qâ€–) â€¢ q) ",":= by
  replace hc := hasSum_coe.mpr hc
  replace hs := (hs.div_const â€–qâ€–).smul_const q
  refine HasSum.even_add_odd ?_ ?_
  Â· convert hc using 1
    ext n : 1
    rw [expSeries_even_of_imaginary hq]
  Â· convert hs using 1
    ext n : 1
    rw [expSeries_odd_of_imaginary hq]"
Mathlib/CategoryTheory/Sites/Preserves.lean,CategoryTheory.Presieve.isSheafFor_of_preservesProduct,isSheafFor_of_preservesProduct,e5c0c1ca53aee9bb1b9b49a12af71874bb517464,":= by
  rw [Equalizer.Presieve.Arrows.sheaf_condition, Limits.Types.type_equalizer_iff_unique]
  haveI : HasCoproduct X := âŸ¨âŸ¨c, hcâŸ©âŸ©
  have hi : IsIso (piComparison F (fun x â†¦ op (X x))) := inferInstance
  rw [piComparison_fac'' (hc := hc), isIso_iff_bijective, Function.bijective_iff_existsUnique] at hi
  intro b _
  obtain âŸ¨t, htâ‚, htâ‚‚âŸ© := hi b
  refine âŸ¨F.map ((opCoproductIsoProduct X).inv â‰«
    ((coproductIsCoproduct X).coconePointUniqueUpToIso hc).op.inv) t, htâ‚, fun y hy â†¦ ?_âŸ©
  specialize htâ‚‚ (F.map (((coproductIsCoproduct X).coconePointUniqueUpToIso hc).hom.op â‰«
    (opCoproductIsoProduct X).hom) y)
  apply_fun F.map (((coproductIsCoproduct X).coconePointUniqueUpToIso hc).hom.op â‰«
    (opCoproductIsoProduct X).hom) using injective_of_mono _
  simp only [â† FunctorToTypes.map_comp_apply, Iso.op, Category.assoc]
  rw [htâ‚‚ ?_]
  Â· change (ğŸ™ (F.obj (âˆ fun x â†¦ op (X x)))) t = _
    rw [â† Functor.map_id]
    refine congrFun ?_ t
    congr
    simp [Iso.eq_inv_comp, â† Category.assoc, â† op_comp, eq_comm, â† Iso.eq_comp_inv]
  Â· rw [â† hy]
    simp only [Cofan.mk_pt, Iso.op_inv, Functor.map_comp, FunctorToTypes.map_comp_apply,
      types_comp_apply, FunctorToTypes.map_inv_map_hom_apply]
    congr
    simp only [â† Functor.map_inv, â† FunctorToTypes.map_comp_apply, â† op_comp,
      Iso.inv_hom_id, op_id, FunctorToTypes.map_id_apply]",error:  expected token,"theorem isSheafFor_of_preservesProduct [PreservesLimit (Discrete.functor (fun x â†¦ op (X x))) F] :
    (ofArrows X c.inj).IsSheafFor F ",":= by
  rw [Equalizer.Presieve.Arrows.sheaf_condition, Limits.Types.type_equalizer_iff_unique]
  have : HasCoproduct X := âŸ¨âŸ¨c, hcâŸ©âŸ©
  have hi : IsIso (piComparison F (fun x â†¦ op (X x))) := inferInstance
  rw [piComparison_fac (hc := hc), isIso_iff_bijective, Function.bijective_iff_existsUnique] at hi
  intro b _
  obtain âŸ¨t, htâ‚, htâ‚‚âŸ© := hi b
  refine âŸ¨F.map ((opCoproductIsoProduct' hc (productIsProduct _)).inv) t, htâ‚, fun y hy â†¦ ?_âŸ©
  apply_fun F.map ((opCoproductIsoProduct' hc (productIsProduct _)).hom) using injective_of_mono _
  simp only [â† FunctorToTypes.map_comp_apply, Iso.op, Category.assoc]
  rw [htâ‚‚ (F.map ((opCoproductIsoProduct' hc (productIsProduct _)).hom) y) (by simp [â† hy])]
  change (ğŸ™ (F.obj (âˆá¶œ fun x â†¦ op (X x)))) t = _
  rw [â† Functor.map_id]
  refine congrFun ?_ t
  congr
  simp [Iso.eq_inv_comp, â† Category.assoc, â† op_comp, eq_comm, â† Iso.eq_comp_inv]"
Mathlib/MeasureTheory/Decomposition/Lebesgue.lean,MeasureTheory.Measure.exists_positive_of_not_mutuallySingular,exists_positive_of_not_mutuallySingular,5522fc375dfd18ea7496d18f560309e857582ca8,":= by
  have :
    âˆ€ n : â„•, âˆƒ i : Set Î±,
      MeasurableSet i âˆ§
        0 â‰¤[i] Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure âˆ§
          Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure â‰¤[iá¶œ] 0 := by
    intro; exact exists_compl_positive_negative _
  choose f hfâ‚ hfâ‚‚ hfâ‚ƒ using this
  set A := â‹‚ n, (f n)á¶œ with hAâ‚
  have hAmeas : MeasurableSet A := MeasurableSet.iInter fun n => (hfâ‚ n).compl
  have hAâ‚‚ : âˆ€ n : â„•, Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure â‰¤[A] 0 := by
    intro n; exact restrict_le_restrict_subset _ _ (hfâ‚ n).compl (hfâ‚ƒ n) (iInter_subset _ _)
  have hAâ‚ƒ : âˆ€ n : â„•, Î¼ A â‰¤ (1 / (n + 1) : â„â‰¥0) * Î½ A := by
    intro n
    have := nonpos_of_restrict_le_zero _ (hAâ‚‚ n)
    rwa [toSignedMeasure_sub_apply hAmeas, sub_nonpos, ENNReal.toReal_le_toReal] at this
    exacts [ne_of_lt (measure_lt_top _ _), ne_of_lt (measure_lt_top _ _)]
  have hÎ¼ : Î¼ A = 0 := by
    lift Î¼ A to â„â‰¥0 using ne_of_lt (measure_lt_top _ _) with Î¼A
    lift Î½ A to â„â‰¥0 using ne_of_lt (measure_lt_top _ _) with Î½A
    rw [ENNReal.coe_eq_zero]
    by_cases hb : 0 < Î½A
    Â· suffices âˆ€ b, 0 < b â†’ Î¼A â‰¤ b by
        by_contra h
        have h' := this (Î¼A / 2) (half_pos (zero_lt_iff.2 h))
        rw [â† @Classical.not_not (Î¼A â‰¤ Î¼A / 2)] at h'
        exact h' (not_le.2 (NNReal.half_lt_self h))
      intro c hc
      have : âˆƒ n : â„•, 1 / (n + 1 : â„) < c * (Î½A : â„)â»Â¹; refine' exists_nat_one_div_lt _
      Â· refine' mul_pos hc _
        rw [_root_.inv_pos]; exact hb
      rcases this with âŸ¨n, hnâŸ©
      have hbâ‚ : (0 : â„) < (Î½A : â„)â»Â¹ := by rw [_root_.inv_pos]; exact hb
      have h' : 1 / (â†‘n + 1) * Î½A < c := by
        rw [â† NNReal.coe_lt_coe, â† mul_lt_mul_right hbâ‚, NNReal.coe_mul, mul_assoc, â†
          NNReal.coe_inv, â† NNReal.coe_mul, _root_.mul_inv_cancel, â† NNReal.coe_mul, mul_one,
          NNReal.coe_inv]
        Â· exact hn
        Â· exact Ne.symm (ne_of_lt hb)
      refine' le_trans _ (le_of_lt h')
      rw [â† ENNReal.coe_le_coe, ENNReal.coe_mul]
      exact hAâ‚ƒ n
    Â· rw [not_lt, le_zero_iff] at hb
      specialize hAâ‚ƒ 0
      simp [hb, le_zero_iff] at hAâ‚ƒ
      assumption
  rw [MutuallySingular] at h; push_neg at h
  have := h _ hAmeas hÎ¼
  simp_rw [compl_iInter, compl_compl] at this
  obtain âŸ¨n, hnâŸ© := exists_measure_pos_of_not_measure_iUnion_null this
  exact âŸ¨1 / (n + 1), by simp, f n, hfâ‚ n, hn, hfâ‚‚ nâŸ©","error:  unexpected token ';'; expected '|'
error:  unsolved goals
case pos
Î± : Type u_1
Î² : Type u_2
m : MeasurableSpace Î±
Î¼âœ Î½âœ Î¼ Î½ : Measure Î±
instâœÂ¹ : IsFiniteMeasure Î¼
instâœ : IsFiniteMeasure Î½
h : Â¬Î¼ âŸ‚â‚˜ Î½
f : â„• â†’ Set Î±
hfâ‚ : âˆ€ (n : â„•), MeasurableSet (f n)
hfâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict 0 (f n) â‰¤
      VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)
hfâ‚ƒ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)á¶œ â‰¤
      VectorMeasure.restrict 0 (f n)á¶œ
A : Set Î± := â‹‚ n, (f n)á¶œ
hAmeas : MeasurableSet A
hAâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) A â‰¤ VectorMeasure.restrict 0 A
Î¼A : â„â‰¥0
hAâ‚âœ hAâ‚ : True
hAâ‚ƒâœÂ¹ : âˆ€ (n : â„•), â†‘Î¼A â‰¤ â†‘(1 / (â†‘n + 1)) * Î½ A
Î½A : â„â‰¥0
hAâ‚ƒâœ hAâ‚ƒ : âˆ€ (n : â„•), â†‘Î¼A â‰¤ â†‘(1 / (â†‘n + 1)) * â†‘Î½A
hb : 0 < Î½A
c : â„â‰¥0
hc : 0 < c
this : âˆƒ n, 1 / (â†‘n + 1) < â†‘c * (â†‘Î½A)â»Â¹
âŠ¢ Î¼A â‰¤ c
error:  unsolved goals
case neg
Î± : Type u_1
Î² : Type u_2
m : MeasurableSpace Î±
Î¼âœ Î½âœ Î¼ Î½ : Measure Î±
instâœÂ¹ : IsFiniteMeasure Î¼
instâœ : IsFiniteMeasure Î½
h : Â¬Î¼ âŸ‚â‚˜ Î½
f : â„• â†’ Set Î±
hfâ‚ : âˆ€ (n : â„•), MeasurableSet (f n)
hfâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict 0 (f n) â‰¤
      VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)
hfâ‚ƒ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)á¶œ â‰¤
      VectorMeasure.restrict 0 (f n)á¶œ
A : Set Î± := â‹‚ n, (f n)á¶œ
hAmeas : MeasurableSet A
hAâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) A â‰¤ VectorMeasure.restrict 0 A
Î¼A : â„â‰¥0
hAâ‚âœ hAâ‚ : True
hAâ‚ƒâœÂ¹ : âˆ€ (n : â„•), â†‘Î¼A â‰¤ â†‘(1 / (â†‘n + 1)) * Î½ A
Î½A : â„â‰¥0
hAâ‚ƒâœ hAâ‚ƒ : âˆ€ (n : â„•), â†‘Î¼A â‰¤ â†‘(1 / (â†‘n + 1)) * â†‘Î½A
hb : Â¬0 < Î½A
âŠ¢ Î¼A = 0
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
m : MeasurableSpace Î±
Î¼âœ Î½âœ Î¼ Î½ : Measure Î±
instâœÂ¹ : IsFiniteMeasure Î¼
instâœ : IsFiniteMeasure Î½
h : Â¬Î¼ âŸ‚â‚˜ Î½
f : â„• â†’ Set Î±
hfâ‚ : âˆ€ (n : â„•), MeasurableSet (f n)
hfâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict 0 (f n) â‰¤
      VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)
hfâ‚ƒ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) (f n)á¶œ â‰¤
      VectorMeasure.restrict 0 (f n)á¶œ
A : Set Î± := â‹‚ n, (f n)á¶œ
hAâ‚ : A = â‹‚ n, (f n)á¶œ
hAmeas : MeasurableSet A
hAâ‚‚ :
  âˆ€ (n : â„•),
    VectorMeasure.restrict (Î¼.toSignedMeasure - ((1 / (â†‘n + 1)) â€¢ Î½).toSignedMeasure) A â‰¤ VectorMeasure.restrict 0 A
hAâ‚ƒ : âˆ€ (n : â„•), Î¼ A â‰¤ â†‘(1 / (â†‘n + 1)) * Î½ A
hÎ¼ : Î¼ A = 0
âŠ¢ âˆƒ Îµ,
    0 < Îµ âˆ§
      âˆƒ E,
        MeasurableSet E âˆ§
          0 < Î½ E âˆ§ VectorMeasure.restrict 0 E â‰¤ VectorMeasure.restrict (Î¼.toSignedMeasure - (Îµ â€¢ Î½).toSignedMeasure) E","theorem exists_positive_of_not_mutuallySingular (Î¼ Î½ : Measure Î±) [IsFiniteMeasure Î¼]
    [IsFiniteMeasure Î½] (h : Â¬Î¼ âŸ‚â‚˜ Î½) :
    âˆƒ Îµ : â„â‰¥0, 0 < Îµ âˆ§
      âˆƒ E : Set Î±,
        MeasurableSet E âˆ§ 0 < Î½ E âˆ§ 0 â‰¤[E] Î¼.toSignedMeasure - (Îµ â€¢ Î½).toSignedMeasure ",":= by
  have :
    âˆ€ n : â„•, âˆƒ i : Set Î±,
      MeasurableSet i âˆ§
        0 â‰¤[i] Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure âˆ§
          Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure â‰¤[iá¶œ] 0 := by
    intro; exact exists_compl_positive_negative _
  choose f hfâ‚ hfâ‚‚ hfâ‚ƒ using this
  let A := â‹‚ n, (f n)á¶œ
  have hAmeas : MeasurableSet A := MeasurableSet.iInter fun n â†¦ (hfâ‚ n).compl
  have hAâ‚‚ : âˆ€ n : â„•, Î¼.toSignedMeasure - ((1 / (n + 1) : â„â‰¥0) â€¢ Î½).toSignedMeasure â‰¤[A] 0 := by
    intro n; exact restrict_le_restrict_subset _ _ (hfâ‚ n).compl (hfâ‚ƒ n) (iInter_subset _ _)
  have hAâ‚ƒ : âˆ€ n : â„•, Î¼ A â‰¤ (1 / (n + 1) : â„â‰¥0) * Î½ A := by
    intro n
    have := nonpos_of_restrict_le_zero _ (hAâ‚‚ n)
    rwa [toSignedMeasure_sub_apply hAmeas, sub_nonpos, ENNReal.toReal_le_toReal] at this
    exacts [measure_ne_top _ _, measure_ne_top _ _]
  have hÎ¼ : Î¼ A = 0 := by
    lift Î¼ A to â„â‰¥0 using measure_ne_top _ _ with Î¼A
    lift Î½ A to â„â‰¥0 using measure_ne_top _ _ with Î½A
    rw [ENNReal.coe_eq_zero]
    by_cases hb : 0 < Î½A
    Â· suffices âˆ€ b, 0 < b â†’ Î¼A â‰¤ b by
        by_contra h
        have h' := this (Î¼A / 2) (half_pos (zero_lt_iff.2 h))
        rw [â† @Classical.not_not (Î¼A â‰¤ Î¼A / 2)] at h'
        exact h' (not_le.2 (NNReal.half_lt_self h))
      intro c hc
      have : âˆƒ n : â„•, 1 / (n + 1 : â„) < c * (Î½A : â„)â»Â¹ := by
        refine exists_nat_one_div_lt ?_
        positivity
      rcases this with âŸ¨n, hnâŸ©
      have hbâ‚ : (0 : â„) < (Î½A : â„)â»Â¹ := by rw [_root_.inv_pos]; exact hb
      have h' : 1 / (â†‘n + 1) * Î½A < c := by
        rw [â† NNReal.coe_lt_coe, â† mul_lt_mul_right hbâ‚, NNReal.coe_mul, mul_assoc, â†
          NNReal.coe_inv, â† NNReal.coe_mul, _root_.mul_inv_cancel, â† NNReal.coe_mul, mul_one,
          NNReal.coe_inv]
        Â· exact hn
        Â· exact hb.ne'
      refine le_trans ?_ h'.le
      rw [â† ENNReal.coe_le_coe, ENNReal.coe_mul]
      exact hAâ‚ƒ n
    Â· rw [not_lt, le_zero_iff] at hb
      specialize hAâ‚ƒ 0
      simp? [hb] at hAâ‚ƒ says
        simp only [CharP.cast_eq_zero, zero_add, ne_eq, one_ne_zero, not_false_eq_true, div_self,
          ENNReal.coe_one, hb, ENNReal.coe_zero, mul_zero, nonpos_iff_eq_zero,
          ENNReal.coe_eq_zero] at hAâ‚ƒ
      assumption
  rw [MutuallySingular] at h; push_neg at h
  have := h _ hAmeas hÎ¼
  simp_rw [A, compl_iInter, compl_compl] at this
  obtain âŸ¨n, hnâŸ© := exists_measure_pos_of_not_measure_iUnion_null this
  exact âŸ¨1 / (n + 1), by simp, f n, hfâ‚ n, hn, hfâ‚‚ nâŸ©"
Mathlib/Topology/Semicontinuous.lean,ContinuousAt.comp_lowerSemicontinuousWithinAt,ContinuousAt.comp_lowerSemicontinuousWithinAt,e9974ddcbf5bfa2aa88fd39e26c4e3fc0a66edad,":=
  hg.continuousWithinAt.comp_lowerSemicontinuousWithinAt hf gmon","error:  invalid field 'comp_lowerSemicontinuousWithinAt', the environment does not contain 'ContinuousWithinAt.comp_lowerSemicontinuousWithinAt'
  continuousWithinAt hg
has type
  ContinuousWithinAt g ?m.41436 (f x)
error:  invalid field 'comp_lowerSemicontinuousWithinAt', the environment does not contain 'Filter.Tendsto.comp_lowerSemicontinuousWithinAt'
  continuousWithinAt hg
has type
  Tendsto g (ğ“[?m.41436] f x) (ğ“ (g (f x)))
error:  invalid field 'comp_lowerSemicontinuousWithinAt', the environment does not contain 'LE.le.comp_lowerSemicontinuousWithinAt'
  continuousWithinAt hg
has type
  map g (ğ“[?m.41436] f x) â‰¤ ğ“ (g (f x))
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  continuousWithinAt hg
has type
  ?m.41446 âˆˆ ğ“ (g (f x)) â†’ ?m.41446 âˆˆ map g (ğ“[?m.41436] f x)
error:  application type mismatch
  @comp_lowerSemicontinuousWithinAt Î± ?m.51169 x s Î³ ?m.51171 ?m.51172 ?m.51173 Î´áµ’áµˆ
argument
  Î´áµ’áµˆ
has type
  Type u_4 : Type (u_4 + 1)
but is expected to have type
  LinearOrder ?m.51173 : Type ?u.51166
error:  application type mismatch
  @comp_lowerSemicontinuousAt Î± ?m.55460 x Î³ ?m.55461 ?m.55462 ?m.55463 Î´áµ’áµˆ
argument
  Î´áµ’áµˆ
has type
  Type u_4 : Type (u_4 + 1)
but is expected to have type
  LinearOrder ?m.55463 : Type ?u.55457
error:  application type mismatch
  @comp_lowerSemicontinuousWithinAt Î± ?m.164854 x s Î³áµ’áµˆ ?m.164857 ?m.164858 ?m.164859 Î´áµ’áµˆ
argument
  Î´áµ’áµˆ
has type
  Type u_4 : Type (u_4 + 1)
but is expected to have type
  LinearOrder ?m.164859 : Type ?u.164851
error:  application type mismatch
  @comp_lowerSemicontinuousAt Î± ?m.169188 x Î³áµ’áµˆ ?m.169190 ?m.169191 ?m.169192 Î´áµ’áµˆ
argument
  Î´áµ’áµˆ
has type
  Type u_4 : Type (u_4 + 1)
but is expected to have type
  LinearOrder ?m.169192 : Type ?u.169185
error:  application type mismatch
  @comp_upperSemicontinuousWithinAt Î± ?m.178371 x s Î³ ?m.178373 ?m.178374 ?m.178375 Î´áµ’áµˆ
argument
  Î´áµ’áµˆ
has type
  Type u_4 : Type (u_4 + 1)
but is expected to have type
  LinearOrder ?m.178375 : Type ?u.178368
error:  application type mismatch
  @comp_upperSemicontinuousAt Î± ?m.182662 x Î³ ?m.182663 ?m.182664 ?m.182665 Î´áµ’áµˆ
argument
  Î´áµ’áµˆ
has type
  Type u_4 : Type (u_4 + 1)
but is expected to have type
  LinearOrder ?m.182665 : Type ?u.182659","theorem ContinuousAt.comp_lowerSemicontinuousWithinAt {g : Î³ â†’ Î´} {f : Î± â†’ Î³}
    (hg : ContinuousAt g (f x)) (hf : LowerSemicontinuousWithinAt f s x) (gmon : Monotone g) :
    LowerSemicontinuousWithinAt (g âˆ˜ f) s x ",":= by
  intro y hy
  by_cases h : âˆƒ l, l < f x
  Â· obtain âŸ¨z, zlt, hzâŸ© : âˆƒ z < f x, Ioc z (f x) âŠ† g â»Â¹' Ioi y :=
      exists_Ioc_subset_of_mem_nhds (hg (Ioi_mem_nhds hy)) h
    filter_upwards [hf z zlt] with a ha
    calc
      y < g (min (f x) (f a)) := hz (by simp [zlt, ha, le_refl])
      _ â‰¤ g (f a) := gmon (min_le_right _ _)

  Â· simp only [not_exists, not_lt] at h
    exact Filter.eventually_of_forall fun a => hy.trans_le (gmon (h (f a)))"
Mathlib/Analysis/Calculus/UniformLimitsDeriv.lean,uniformCauchySeqOn_ball_of_fderiv,uniformCauchySeqOn_ball_of_fderiv,1507c181c67dcc2ca8a6c4b34934872edf50bf0f,":= by
  let : NormedSpace â„ E; exact NormedSpace.restrictScalars â„ ğ•œ _
  have : NeBot l := (cauchy_map_iff.1 hfg).1
  rcases le_or_lt r 0 with (hr | hr)
  Â· simp only [Metric.ball_eq_empty.2 hr, UniformCauchySeqOn, Set.mem_empty_iff_false,
      IsEmpty.forall_iff, eventually_const, imp_true_iff]
  rw [SeminormedAddGroup.uniformCauchySeqOn_iff_tendstoUniformlyOn_zero] at hf' âŠ¢
  suffices
    TendstoUniformlyOn (fun (n : Î¹ Ã— Î¹) (z : E) => f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) 0
        (l Ã—Ë¢ l) (Metric.ball x r) âˆ§
      TendstoUniformlyOn (fun (n : Î¹ Ã— Î¹) (_ : E) => f n.1 x - f n.2 x) 0
        (l Ã—Ë¢ l) (Metric.ball x r) by
    have := this.1.add this.2
    rw [add_zero] at this
    refine' this.congr _
    apply eventually_of_forall
    intro n z _
    simp
  constructor
  Â· 
    rw [Metric.tendstoUniformlyOn_iff] at hf' âŠ¢
    intro Îµ hÎµ
    obtain âŸ¨q, hqpos, hqâŸ© : âˆƒ q : â„, 0 < q âˆ§ q * r < Îµ := by
      simp_rw [mul_comm]
      exact exists_pos_mul_lt hÎµ.lt r
    apply (hf' q hqpos.gt).mono
    intro n hn y hy
    simp_rw [dist_eq_norm, Pi.zero_apply, zero_sub, norm_neg] at hn âŠ¢
    have mvt :=
      Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le
        (fun z hz => ((hf n.1 z hz).sub (hf n.2 z hz)).hasFDerivWithinAt) (fun z hz => (hn z hz).le)
        (convex_ball x r) (Metric.mem_ball_self hr) hy
    refine' lt_of_le_of_lt mvt _
    have : q * â€–y - xâ€– < q * r :=
      mul_lt_mul' rfl.le (by simpa only [dist_eq_norm] using Metric.mem_ball.mp hy) (norm_nonneg _)
        hqpos
    exact this.trans hq
  Â· 
    refine' Metric.tendstoUniformlyOn_iff.mpr fun Îµ hÎµ => _
    obtain âŸ¨t, ht, ht'âŸ© := (Metric.cauchy_iff.mp hfg).2 Îµ hÎµ
    rw [eventually_prod_iff]
    refine' âŸ¨fun n => f n x âˆˆ t, ht, fun n => f n x âˆˆ t, ht, _âŸ©
    intro n hn n' hn' z _
    rw [dist_eq_norm, Pi.zero_apply, zero_sub, norm_neg, â† dist_eq_norm]
    exact ht' _ hn _ hn'","error:  unexpected token ':'; expected '_', identifier or term
error:  unsolved goals
Î¹ : Type u_1
l : Filter Î¹
E : Type u_2
instâœâ´ : NormedAddCommGroup E
ğ•œ : Type u_3
instâœÂ³ : RCLike ğ•œ
instâœÂ² : NormedSpace ğ•œ E
G : Type u_4
instâœÂ¹ : NormedAddCommGroup G
instâœ : NormedSpace ğ•œ G
f : Î¹ â†’ E â†’ G
g : E â†’ G
f' : Î¹ â†’ E â†’ E â†’L[ğ•œ] G
g' : E â†’ E â†’L[ğ•œ] G
x : E
r : â„
hf' : UniformCauchySeqOn f' l (Metric.ball x r)
hf : âˆ€ (n : Î¹), âˆ€ y âˆˆ Metric.ball x r, HasFDerivAt (f n) (f' n y) y
hfg : Cauchy (map (fun n â†¦ f n x) l)
âŠ¢ UniformCauchySeqOn f l (Metric.ball x r)","theorem uniformCauchySeqOn_ball_of_fderiv {r : â„} (hf' : UniformCauchySeqOn f' l (Metric.ball x r))
    (hf : âˆ€ n : Î¹, âˆ€ y : E, y âˆˆ Metric.ball x r â†’ HasFDerivAt (f n) (f' n y) y)
    (hfg : Cauchy (map (fun n => f n x) l)) : UniformCauchySeqOn f l (Metric.ball x r) ",":= by
  letI : NormedSpace â„ E := NormedSpace.restrictScalars â„ ğ•œ _
  have : NeBot l := (cauchy_map_iff.1 hfg).1
  rcases le_or_lt r 0 with (hr | hr)
  Â· simp only [Metric.ball_eq_empty.2 hr, UniformCauchySeqOn, Set.mem_empty_iff_false,
      IsEmpty.forall_iff, eventually_const, imp_true_iff]
  rw [SeminormedAddGroup.uniformCauchySeqOn_iff_tendstoUniformlyOn_zero] at hf' âŠ¢
  suffices
    TendstoUniformlyOn (fun (n : Î¹ Ã— Î¹) (z : E) => f n.1 z - f n.2 z - (f n.1 x - f n.2 x)) 0
        (l Ã—Ë¢ l) (Metric.ball x r) âˆ§
      TendstoUniformlyOn (fun (n : Î¹ Ã— Î¹) (_ : E) => f n.1 x - f n.2 x) 0
        (l Ã—Ë¢ l) (Metric.ball x r) by
    have := this.1.add this.2
    rw [add_zero] at this
    refine this.congr ?_
    filter_upwards with n z _ using (by simp)
  constructor
  Â· 
    rw [Metric.tendstoUniformlyOn_iff] at hf' âŠ¢
    intro Îµ hÎµ
    obtain âŸ¨q, hqpos, hqâŸ© : âˆƒ q : â„, 0 < q âˆ§ q * r < Îµ := by
      simp_rw [mul_comm]
      exact exists_pos_mul_lt hÎµ.lt r
    apply (hf' q hqpos.gt).mono
    intro n hn y hy
    simp_rw [dist_eq_norm, Pi.zero_apply, zero_sub, norm_neg] at hn âŠ¢
    have mvt :=
      Convex.norm_image_sub_le_of_norm_hasFDerivWithin_le
        (fun z hz => ((hf n.1 z hz).sub (hf n.2 z hz)).hasFDerivWithinAt) (fun z hz => (hn z hz).le)
        (convex_ball x r) (Metric.mem_ball_self hr) hy
    refine lt_of_le_of_lt mvt ?_
    have : q * â€–y - xâ€– < q * r :=
      mul_lt_mul' rfl.le (by simpa only [dist_eq_norm] using Metric.mem_ball.mp hy) (norm_nonneg _)
        hqpos
    exact this.trans hq
  Â· 
    refine Metric.tendstoUniformlyOn_iff.mpr fun Îµ hÎµ => ?_
    obtain âŸ¨t, ht, ht'âŸ© := (Metric.cauchy_iff.mp hfg).2 Îµ hÎµ
    rw [eventually_prod_iff]
    refine âŸ¨fun n => f n x âˆˆ t, ht, fun n => f n x âˆˆ t, ht, ?_âŸ©
    intro n hn n' hn' z _
    rw [dist_eq_norm, Pi.zero_apply, zero_sub, norm_neg, â† dist_eq_norm]
    exact ht' _ hn _ hn'"
Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean,TopCat.isTopologicalBasis_cofiltered_limit,isTopologicalBasis_cofiltered_limit,c342c339a777827331257acd880fea6d441a6aa6,":= by
  classical
  let D := limitConeInfi F
  let E : C.pt â‰… D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | âˆƒ (j : _) (V : Set (F.obj j)), V âˆˆ T j âˆ§ U = D.Ï€.app j â»Â¹' V} by
    convert this.inducing hE
    ext U0
    constructor
    Â· rintro âŸ¨j, V, hV, rflâŸ©
      exact âŸ¨D.Ï€.app j â»Â¹' V, âŸ¨j, V, hV, rflâŸ©, rflâŸ©
    Â· rintro âŸ¨W, âŸ¨j, V, hV, rflâŸ©, rflâŸ©
      exact âŸ¨j, V, hV, rflâŸ©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.Ï€.app j x using 1
  ext U0
  constructor
  Â· rintro âŸ¨j, V, hV, rflâŸ©
    let U : âˆ€ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine âŸ¨U, {j}, ?_, ?_âŸ©
    Â· simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    Â· simp [U]
  Â· rintro âŸ¨U, G, h1, h2âŸ©
    obtain âŸ¨j, hjâŸ© := IsCofiltered.inf_objs_exists G
    let g : âˆ€ e âˆˆ G, j âŸ¶ e := fun _ he => (hj he).some
    let Vs : J â†’ Set (F.obj j) := fun e => if h : e âˆˆ G then F.map (g e h) â»Â¹' U e else Set.univ
    let V : Set (F.obj j) := â‹‚ (e : J) (_he : e âˆˆ G), Vs e
    refine âŸ¨j, V, ?_, ?_âŸ©
    Â· 
      have :
        âˆ€ (S : Set (Set (F.obj j))) (E : Finset J) (P : J â†’ Set (F.obj j)) (_univ : Set.univ âˆˆ S)
          (_inter : âˆ€ A B : Set (F.obj j), A âˆˆ S â†’ B âˆˆ S â†’ A âˆ© B âˆˆ S)
          (_cond : âˆ€ (e : J) (_he : e âˆˆ E), P e âˆˆ S), (â‹‚ (e) (_he : e âˆˆ E), P e) âˆˆ S := by
        intro S E
        induction E with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    Â· 
      rw [h2]
      change _ = (D.Ï€.app j)â»Â¹' â‹‚ (e : J) (_ : e âˆˆ G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.Ï€.app e)â»Â¹' U e =
        (D.Ï€.app j) â»Â¹' if h : e âˆˆ G then F.map (g e h) â»Â¹' U e else Set.univ
      rw [dif_pos he, â† Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [â† coe_comp, D.w] 
      rfl",error:  invalid alternative name 'empty',"theorem isTopologicalBasis_cofiltered_limit (T : âˆ€ j, Set (Set (F.obj j)))
    (hT : âˆ€ j, IsTopologicalBasis (T j)) (univ : âˆ€ i : J, Set.univ âˆˆ T i)
    (inter : âˆ€ (i) (U1 U2 : Set (F.obj i)), U1 âˆˆ T i â†’ U2 âˆˆ T i â†’ U1 âˆ© U2 âˆˆ T i)
    (compat : âˆ€ (i j : J) (f : i âŸ¶ j) (V : Set (F.obj j)) (_hV : V âˆˆ T j), F.map f â»Â¹' V âˆˆ T i) :
    IsTopologicalBasis
      {U : Set C.pt | âˆƒ (j : _) (V : Set (F.obj j)), V âˆˆ T j âˆ§ U = C.Ï€.app j â»Â¹' V} ",":= by
  classical
  let D := limitConeInfi F
  let E : C.pt â‰… D.pt := hC.conePointUniqueUpToIso (limitConeInfiIsLimit _)
  have hE : Inducing E.hom := (TopCat.homeoOfIso E).inducing
  suffices
    IsTopologicalBasis
      {U : Set D.pt | âˆƒ (j : _) (V : Set (F.obj j)), V âˆˆ T j âˆ§ U = D.Ï€.app j â»Â¹' V} by
    convert this.inducing hE
    ext U0
    constructor
    Â· rintro âŸ¨j, V, hV, rflâŸ©
      exact âŸ¨D.Ï€.app j â»Â¹' V, âŸ¨j, V, hV, rflâŸ©, rflâŸ©
    Â· rintro âŸ¨W, âŸ¨j, V, hV, rflâŸ©, rflâŸ©
      exact âŸ¨j, V, hV, rflâŸ©
  convert IsTopologicalBasis.iInf_induced hT fun j (x : D.pt) => D.Ï€.app j x using 1
  ext U0
  constructor
  Â· rintro âŸ¨j, V, hV, rflâŸ©
    let U : âˆ€ i, Set (F.obj i) := fun i => if h : i = j then by rw [h]; exact V else Set.univ
    refine âŸ¨U, {j}, ?_, ?_âŸ©
    Â· simp only [Finset.mem_singleton]
      rintro i rfl
      simpa [U]
    Â· simp [U]
  Â· rintro âŸ¨U, G, h1, h2âŸ©
    obtain âŸ¨j, hjâŸ© := IsCofiltered.inf_objs_exists G
    let g : âˆ€ e âˆˆ G, j âŸ¶ e := fun _ he => (hj he).some
    let Vs : J â†’ Set (F.obj j) := fun e => if h : e âˆˆ G then F.map (g e h) â»Â¹' U e else Set.univ
    let V : Set (F.obj j) := â‹‚ (e : J) (_he : e âˆˆ G), Vs e
    refine âŸ¨j, V, ?_, ?_âŸ©
    Â· 
      have :
        âˆ€ (S : Set (Set (F.obj j))) (E : Finset J) (P : J â†’ Set (F.obj j)) (_univ : Set.univ âˆˆ S)
          (_inter : âˆ€ A B : Set (F.obj j), A âˆˆ S â†’ B âˆˆ S â†’ A âˆ© B âˆˆ S)
          (_cond : âˆ€ (e : J) (_he : e âˆˆ E), P e âˆˆ S), (â‹‚ (e) (_he : e âˆˆ E), P e) âˆˆ S := by
        intro S E
        induction E using Finset.induction_on with
        | empty =>
          intro P he _hh
          simpa
        | @insert a E _ha hh1 =>
          intro hh2 hh3 hh4 hh5
          rw [Finset.set_biInter_insert]
          refine hh4 _ _ (hh5 _ (Finset.mem_insert_self _ _)) (hh1 _ hh3 hh4 ?_)
          intro e he
          exact hh5 e (Finset.mem_insert_of_mem he)
      refine this _ _ _ (univ _) (inter _) ?_
      intro e he
      dsimp [Vs]
      rw [dif_pos he]
      exact compat j e (g e he) (U e) (h1 e he)
    Â· 
      rw [h2]
      change _ = (D.Ï€.app j)â»Â¹' â‹‚ (e : J) (_ : e âˆˆ G), Vs e
      rw [Set.preimage_iInter]
      apply congrArg
      ext1 e
      erw [Set.preimage_iInter]
      apply congrArg
      ext1 he
      change (D.Ï€.app e)â»Â¹' U e =
        (D.Ï€.app j) â»Â¹' if h : e âˆˆ G then F.map (g e h) â»Â¹' U e else Set.univ
      rw [dif_pos he, â† Set.preimage_comp]
      apply congrFun
      apply congrArg
      erw [â† coe_comp, D.w] 
      rfl"
Mathlib/Analysis/Fourier/PoissonSummation.lean,Real.fourierCoeff_tsum_comp_add,Real.fourierCoeff_tsum_comp_add,05dd33777bb0a96c66523df7c7d1a34b2d9a1be5,":= by
  let e : C(â„, â„‚) := (fourier (-m)).comp âŸ¨((â†‘) : â„ â†’ UnitAddCircle), continuous_quotient_mk'âŸ©
  have neK : âˆ€ (K : Compacts â„) (g : C(â„, â„‚)), â€–(e * g).restrict Kâ€– = â€–g.restrict Kâ€– := by
    have : âˆ€ x : â„, â€–e xâ€– = 1 := fun x => abs_coe_circle (AddCircle.toCircle (-m â€¢ x))
    intro K g
    simp_rw [norm_eq_iSup_norm, restrict_apply, mul_apply, norm_mul, this, one_mul]
  have eadd : âˆ€ (n : â„¤), e.comp (ContinuousMap.addRight n) = e := by
    intro n; ext1 x
    have : Periodic e 1 := Periodic.comp (fun x => AddCircle.coe_add_period 1 x) (fourier (-m))
    simpa only [mul_one] using this.int_mul n x
  calc
    fourierCoeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m =
        âˆ« x in (0 : â„)..1, e x * (âˆ‘' n : â„¤, f.comp (ContinuousMap.addRight n)) x := by
      simp_rw [fourierCoeff_eq_intervalIntegral _ m 0, div_one, one_smul, zero_add, comp_apply,
        coe_mk, Periodic.lift_coe, zsmul_one, smul_eq_mul]
    _ = âˆ« x in (0:â„)..1, âˆ‘' n : â„¤, (e * f.comp (ContinuousMap.addRight n)) x := by
      simp_rw [coe_mul, Pi.mul_apply,
        â† ContinuousMap.tsum_apply (summable_of_locally_summable_norm hf), tsum_mul_left]
    _ = âˆ‘' n : â„¤, âˆ« x in (0:â„)..1, (e * f.comp (ContinuousMap.addRight n)) x := by
      refine' (intervalIntegral.tsum_intervalIntegral_eq_of_summable_norm _).symm
      convert hf âŸ¨uIcc 0 1, isCompact_uIccâŸ© using 1
      exact funext fun n => neK _ _
    _ = âˆ‘' n : â„¤, âˆ« x in (0:â„)..1, (e * f).comp (ContinuousMap.addRight n) x := by
      simp only [ContinuousMap.comp_apply, mul_comp] at eadd âŠ¢
      simp_rw [eadd]
    _ = âˆ« x, e x * f x := by
      suffices Integrable (e * f) from this.hasSum_intervalIntegral_comp_add_int.tsum_eq
      apply integrable_of_summable_norm_Icc
      convert hf âŸ¨Icc 0 1, isCompact_IccâŸ© using 1
      simp_rw [mul_comp] at eadd âŠ¢
      simp_rw [eadd]
      exact funext fun n => neK âŸ¨Icc 0 1, isCompact_IccâŸ© _
    _ = ğ“• f m := by
      rw [fourierIntegral_eq_integral_exp_smul]
      congr 1 with x : 1
      rw [smul_eq_mul, comp_apply, coe_mk, coe_mk, ContinuousMap.toFun_eq_coe, fourier_coe_apply]
      congr 2
      push_cast
      ring","error:  simp made no progress
warning:  `Real.fourierIntegral_eq_integral_exp_smul` has been deprecated, use `Real.fourierIntegral_real_eq_integral_exp_smul` instead","theorem Real.fourierCoeff_tsum_comp_add {f : C(â„, â„‚)}
    (hf : âˆ€ K : Compacts â„, Summable fun n : â„¤ => â€–(f.comp (ContinuousMap.addRight n)).restrict Kâ€–)
    (m : â„¤) : fourierCoeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m = ğ“• f m ",":= by
  let e : C(â„, â„‚) := (fourier (-m)).comp âŸ¨((â†‘) : â„ â†’ UnitAddCircle), continuous_quotient_mk'âŸ©
  have neK : âˆ€ (K : Compacts â„) (g : C(â„, â„‚)), â€–(e * g).restrict Kâ€– = â€–g.restrict Kâ€– := by
    have (x : â„) : â€–e xâ€– = 1 := abs_coe_circle (AddCircle.toCircle (-m â€¢ x))
    intro K g
    simp_rw [norm_eq_iSup_norm, restrict_apply, mul_apply, norm_mul, this, one_mul]
  have eadd : âˆ€ (n : â„¤), e.comp (ContinuousMap.addRight n) = e := by
    intro n; ext1 x
    have : Periodic e 1 := Periodic.comp (fun x => AddCircle.coe_add_period 1 x) (fourier (-m))
    simpa only [mul_one] using this.int_mul n x
  calc
    fourierCoeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m =
        âˆ« x in (0 : â„)..1, e x * (âˆ‘' n : â„¤, f.comp (ContinuousMap.addRight n)) x := by
      simp_rw [fourierCoeff_eq_intervalIntegral _ m 0, div_one, one_smul, zero_add, e, comp_apply,
        coe_mk, Periodic.lift_coe, zsmul_one, smul_eq_mul]
    _ = âˆ« x in (0:â„)..1, âˆ‘' n : â„¤, (e * f.comp (ContinuousMap.addRight n)) x := by
      simp_rw [coe_mul, Pi.mul_apply,
        â† ContinuousMap.tsum_apply (summable_of_locally_summable_norm hf), tsum_mul_left]
    _ = âˆ‘' n : â„¤, âˆ« x in (0:â„)..1, (e * f.comp (ContinuousMap.addRight n)) x := by
      refine (intervalIntegral.tsum_intervalIntegral_eq_of_summable_norm ?_).symm
      convert hf âŸ¨uIcc 0 1, isCompact_uIccâŸ© using 1
      exact funext fun n => neK _ _
    _ = âˆ‘' n : â„¤, âˆ« x in (0:â„)..1, (e * f).comp (ContinuousMap.addRight n) x := by
      simp only [ContinuousMap.comp_apply, mul_comp] at eadd âŠ¢
      simp_rw [eadd]
    _ = âˆ« x, e x * f x := by
      suffices Integrable (e * f) from this.hasSum_intervalIntegral_comp_add_int.tsum_eq
      apply integrable_of_summable_norm_Icc
      convert hf âŸ¨Icc 0 1, isCompact_IccâŸ© using 1
      simp_rw [mul_comp] at eadd âŠ¢
      simp_rw [eadd]
      exact funext fun n => neK âŸ¨Icc 0 1, isCompact_IccâŸ© _
    _ = ğ“• f m := by
      rw [fourierIntegral_real_eq_integral_exp_smul]
      congr 1 with x : 1
      rw [smul_eq_mul, comp_apply, coe_mk, coe_mk, ContinuousMap.toFun_eq_coe, fourier_coe_apply]
      congr 2
      push_cast
      ring"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,IsometryEquiv.hausdorffMeasure_image,hausdorffMeasure_image,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine' iSup_le fun R => iSup_le fun hR => _
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine' ENNReal.tsum_le_tsum fun n => _
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left s) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd","error:  application type mismatch
  inter_subset_left s
argument
  s
has type
  Set X : Type u_2
but is expected to have type
  ?m.169595 âˆˆ t n âˆ© ?m.169594 : Prop
error:  simp made no progress","theorem hausdorffMeasure_image_le (h : HolderOnWith C r f s) (hr : 0 < r) {d : â„} (hd : 0 â‰¤ d) :
    Î¼H[d] (f '' s) â‰¤ (C : â„â‰¥0âˆ) ^ d * Î¼H[r * d] s ",":= by
  rcases (zero_le C).eq_or_lt with (rfl | hC0)
  Â· rcases eq_empty_or_nonempty s with (rfl | âŸ¨x, hxâŸ©)
    Â· simp only [measure_empty, nonpos_iff_eq_zero, mul_zero, image_empty]
    have : f '' s = {f x} :=
      have : (f '' s).Subsingleton := by simpa [diam_eq_zero_iff] using h.ediam_image_le
      (subsingleton_iff_singleton (mem_image_of_mem f hx)).1 this
    rw [this]
    rcases eq_or_lt_of_le hd with (rfl | h'd)
    Â· simp only [ENNReal.rpow_zero, one_mul, mul_zero]
      rw [hausdorffMeasure_zero_singleton]
      exact one_le_hausdorffMeasure_zero_of_nonempty âŸ¨x, hxâŸ©
    Â· haveI := noAtoms_hausdorff Y h'd
      simp only [zero_le, measure_singleton]
  Â· have hCd0 : (C : â„â‰¥0âˆ) ^ d â‰  0 := by simp [hC0.ne']
    have hCd : (C : â„â‰¥0âˆ) ^ d â‰  âˆ := by simp [hd]
    simp only [hausdorffMeasure_apply, ENNReal.mul_iSup, ENNReal.mul_iInf_of_ne hCd0 hCd,
      â† ENNReal.tsum_mul_left]
    refine iSup_le fun R => iSup_le fun hR => ?_
    have : Tendsto (fun d : â„â‰¥0âˆ => (C : â„â‰¥0âˆ) * d ^ (r : â„)) (ğ“ 0) (ğ“ 0) :=
      ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos ENNReal.coe_ne_top hr
    rcases ENNReal.nhds_zero_basis_Iic.eventually_iff.1 (this.eventually (gt_mem_nhds hR)) with
      âŸ¨Î´, Î´0, HâŸ©
    refine le_iSupâ‚‚_of_le Î´ Î´0 <| iInfâ‚‚_mono' fun t hst â†¦
      âŸ¨fun n => f '' (t n âˆ© s), ?_, iInf_mono' fun htÎ´ â†¦
        âŸ¨fun n => (h.ediam_image_inter_le (t n)).trans (H (htÎ´ n)).le, ?_âŸ©âŸ©
    Â· rw [â† image_iUnion, â† iUnion_inter]
      exact image_subset _ (subset_inter hst Subset.rfl)
    Â· refine ENNReal.tsum_le_tsum fun n => ?_
      simp only [iSup_le_iff, image_nonempty]
      intro hft
      simp only [Nonempty.mono ((t n).inter_subset_left) hft, ciSup_pos]
      rw [ENNReal.rpow_mul, â† ENNReal.mul_rpow_of_nonneg _ _ hd]
      exact ENNReal.rpow_le_rpow (h.ediam_image_inter_le _) hd"
Mathlib/Algebra/Order/Interval/Set/Monoid.lean,Set.Ici_add_bij,Ici_add_bij,67ee3b7709353762fdc01cfb00722ee8c27ff6a5,":= by
  refine
    âŸ¨fun x h => add_le_add_right (mem_Ici.mp h) _, (add_left_injective d).injOn _, fun _ h => ?_âŸ©
  obtain âŸ¨c, rflâŸ© := exists_add_of_le (mem_Ici.mp h)
  rw [mem_Ici, add_right_comm, add_le_add_iff_right] at h
  exact âŸ¨a + c, h, by rw [add_right_comm]âŸ©","error:  application type mismatch
  And.intro (Function.Injective.injOn (add_left_injective d) ?m.994)
argument
  Function.Injective.injOn (add_left_injective d) ?m.994
has type
  âˆ€ â¦ƒxâ‚‚ : Mâ¦„, xâ‚‚ âˆˆ ?m.992 â†’ ?m.993 + d = xâ‚‚ + d â†’ ?m.993 = xâ‚‚ : Prop
but is expected to have type
  InjOn (fun x â†¦ x + d) (Ici a) : Prop",theorem Ici_add_bij : BijOn (Â· + d) (Ici a) (Ici (a + d)) ,":= by
  refine
    âŸ¨fun x h => add_le_add_right (mem_Ici.mp h) _, (add_left_injective d).injOn, fun _ h => ?_âŸ©
  obtain âŸ¨c, rflâŸ© := exists_add_of_le (mem_Ici.mp h)
  rw [mem_Ici, add_right_comm, add_le_add_iff_right] at h
  exact âŸ¨a + c, h, by rw [add_right_comm]âŸ©"
Mathlib/Combinatorics/Hall/Basic.lean,Finset.all_card_le_biUnion_card_iff_exists_injective,Finset.all_card_le_biUnion_card_iff_exists_injective,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  constructor
  Â· intro h
    haveI : âˆ€ Î¹' : (Finset Î¹)áµ’áµ–, Nonempty ((hallMatchingsFunctor t).obj Î¹') := fun Î¹' =>
      hallMatchingsOn.nonempty t h Î¹'.unop
    classical
      haveI : âˆ€ Î¹' : (Finset Î¹)áµ’áµ–, Finite ((hallMatchingsFunctor t).obj Î¹') := by
        intro Î¹'
        rw [hallMatchingsFunctor]
        infer_instance
      obtain âŸ¨u, huâŸ© := nonempty_sections_of_finite_inverse_system (hallMatchingsFunctor t)
      refine âŸ¨?_,? _?, _âŸ©
      Â·
        exact fun i =>
          (u (Opposite.op ({i} : Finset Î¹))).val âŸ¨i, by simp only [Opposite.unop_op, mem_singleton]âŸ©
      Â· 
        intro i i'
        have subi : ({i} : Finset Î¹) âŠ† {i, i'} := by simp
        have subi' : ({i'} : Finset Î¹) âŠ† {i, i'} := by simp
        rw [â† Finset.le_iff_subset] at subi subi'
        simp only
        rw [â† hu (CategoryTheory.homOfLE subi).op, â† hu (CategoryTheory.homOfLE subi').op]
        let uii' := u (Opposite.op ({i, i'} : Finset Î¹))
        exact fun h => Subtype.mk_eq_mk.mp (uii'.property.1 h)
      Â· 
        intro i
        apply (u (Opposite.op ({i} : Finset Î¹))).property.2
  Â· 
    rintro âŸ¨f, hfâ‚, hfâ‚‚âŸ© s
    rw [â† Finset.card_image_of_injective s hfâ‚]
    apply Finset.card_le_card
    intro
    rw [Finset.mem_image, Finset.mem_biUnion]
    rintro âŸ¨x, hx, rflâŸ©
    exact âŸ¨x, hx, hfâ‚‚ xâŸ©","error:  don't know how to synthesize placeholder for argument 'right'
context:
Î¹ : Type u
Î± : Type v
instâœ : DecidableEq Î±
t : Î¹ â†’ Finset Î±
h : âˆ€ (s : Finset Î¹), s.card â‰¤ (s.biUnion t).card
thisâœ : âˆ€ (Î¹' : (Finset Î¹)áµ’áµ–), Nonempty ((hallMatchingsFunctor t).obj Î¹')
this : âˆ€ (Î¹' : (Finset Î¹)áµ’áµ–), Finite ((hallMatchingsFunctor t).obj Î¹')
u : (j : (Finset Î¹)áµ’áµ–) â†’ (hallMatchingsFunctor t).obj j
hu : u âˆˆ (hallMatchingsFunctor t).sections
âŠ¢ âˆ€ (x : Î¹), ?m.16742 x âˆˆ t x","theorem Finset.all_card_le_biUnion_card_iff_exists_injective {Î¹ : Type u} {Î± : Type v}
    [DecidableEq Î±] (t : Î¹ â†’ Finset Î±) :
    (âˆ€ s : Finset Î¹, s.card â‰¤ (s.biUnion t).card) â†”
      âˆƒ f : Î¹ â†’ Î±, Function.Injective f âˆ§ âˆ€ x, f x âˆˆ t x ",":= by
  constructor
  Â· intro h
    haveI : âˆ€ Î¹' : (Finset Î¹)áµ’áµ–, Nonempty ((hallMatchingsFunctor t).obj Î¹') := fun Î¹' =>
      hallMatchingsOn.nonempty t h Î¹'.unop
    classical
      haveI : âˆ€ Î¹' : (Finset Î¹)áµ’áµ–, Finite ((hallMatchingsFunctor t).obj Î¹') := by
        intro Î¹'
        rw [hallMatchingsFunctor]
        infer_instance
      obtain âŸ¨u, huâŸ© := nonempty_sections_of_finite_inverse_system (hallMatchingsFunctor t)
      refine âŸ¨?_, ?_, ?_âŸ©
      Â·
        exact fun i =>
          (u (Opposite.op ({i} : Finset Î¹))).val âŸ¨i, by simp only [Opposite.unop_op, mem_singleton]âŸ©
      Â· 
        intro i i'
        have subi : ({i} : Finset Î¹) âŠ† {i, i'} := by simp
        have subi' : ({i'} : Finset Î¹) âŠ† {i, i'} := by simp
        rw [â† Finset.le_iff_subset] at subi subi'
        simp only
        rw [â† hu (CategoryTheory.homOfLE subi).op, â† hu (CategoryTheory.homOfLE subi').op]
        let uii' := u (Opposite.op ({i, i'} : Finset Î¹))
        exact fun h => Subtype.mk_eq_mk.mp (uii'.property.1 h)
      Â· 
        intro i
        apply (u (Opposite.op ({i} : Finset Î¹))).property.2
  Â· 
    rintro âŸ¨f, hfâ‚, hfâ‚‚âŸ© s
    rw [â† Finset.card_image_of_injective s hfâ‚]
    apply Finset.card_le_card
    intro
    rw [Finset.mem_image, Finset.mem_biUnion]
    rintro âŸ¨x, hx, rflâŸ©
    exact âŸ¨x, hx, hfâ‚‚ xâŸ©"
Mathlib/Topology/OmegaCompletePartialOrder.lean,Scott.IsOpen.inter,IsOpen.inter,0c1dd9cbd45d804e559a743f61a0763f683221f0,":=
  CompleteLattice.Ï‰ScottContinuous.inf",error:  unknown constant 'CompleteLattice.Ï‰ScottContinuous.inf',theorem IsOpen.inter (s t : Set Î±) : IsOpen Î± s â†’ IsOpen Î± t â†’ IsOpen Î± (s âˆ© t) ,":=
  CompleteLattice.inf_continuous'"
Mathlib/NumberTheory/Cyclotomic/PrimitiveRoots.lean,IsPrimitiveRoot.norm_eq_one,norm_eq_one,0bb63b2bff135338722ab98f6da549f3e6350f0a,":= by
  haveI := IsCyclotomicExtension.neZero' n K L
  by_cases h1 : n = 1
  Â· rw [h1, one_coe, one_right_iff] at hÎ¶
    rw [hÎ¶, show 1 = algebraMap K L 1 by simp, Algebra.norm_algebraMap, one_pow]
  Â· replace h1 : 2 â‰¤ n
    Â· by_contra! h
      exact h1 (PNat.eq_one_of_lt_two h)
    rw [â† hÎ¶.powerBasis_gen K, PowerBasis.norm_gen_eq_coeff_zero_minpoly, hÎ¶.powerBasis_gen K, â†
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr,
      (cyclotomic_coeff_zero K h1 : coeff (cyclotomic n K) 0 = 1), mul_one,
      hÎ¶.powerBasis_dim K, â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, natDegree_cyclotomic]
    exact (totient_even <| h1.lt_of_ne hn.symm).neg_one_pow","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
case neg
p n : â„•+
A : Type w
B : Type z
K : Type u
L : Type v
C : Type w
instâœâ¸ : CommRing A
instâœâ· : CommRing B
instâœâ¶ : Algebra A B
instâœâµ : IsCyclotomicExtension {n} A B
instâœâ´ : CommRing L
Î¶ : L
hÎ¶ : IsPrimitiveRoot Î¶ â†‘n
instâœÂ³ : Field K
instâœÂ² : Algebra K L
instâœÂ¹ : IsDomain L
instâœ : IsCyclotomicExtension {n} K L
hn : n â‰  2
hirr : Irreducible (cyclotomic (â†‘n) K)
this : NeZero â†‘â†‘n
h1 : 2 â‰¤ n
âŠ¢ (Algebra.norm K) Î¶ = 1","theorem norm_eq_one [IsDomain L] [IsCyclotomicExtension {n} K L] (hn : n â‰  2)
    (hirr : Irreducible (cyclotomic n K)) : norm K Î¶ = 1 ",":= by
  haveI := IsCyclotomicExtension.neZero' n K L
  by_cases h1 : n = 1
  Â· rw [h1, one_coe, one_right_iff] at hÎ¶
    rw [hÎ¶, show 1 = algebraMap K L 1 by simp, Algebra.norm_algebraMap, one_pow]
  Â· replace h1 : 2 â‰¤ n := by
      by_contra! h
      exact h1 (PNat.eq_one_of_lt_two h)
    rw [â† hÎ¶.powerBasis_gen K, PowerBasis.norm_gen_eq_coeff_zero_minpoly, hÎ¶.powerBasis_gen K, â†
      hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr,
      (cyclotomic_coeff_zero K h1 : coeff (cyclotomic n K) 0 = 1), mul_one,
      hÎ¶.powerBasis_dim K, â† hÎ¶.minpoly_eq_cyclotomic_of_irreducible hirr, natDegree_cyclotomic]
    exact (totient_even <| h1.lt_of_ne hn.symm).neg_one_pow"
Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean,Real.Angle.sin_sub_pi_div_two,sin_sub_pi_div_two,c342c339a777827331257acd880fea6d441a6aa6,":= by
  induction Î¸
  exact Real.sin_sub_pi_div_two _","error:  tactic 'induction' failed, major premise type is not an inductive type 
  Quot Setoid.r
Î¸ : Angle
âŠ¢ (Î¸ - â†‘(Ï€ / 2)).sin = -Î¸.cos",theorem sin_sub_pi_div_two (Î¸ : Angle) : sin (Î¸ - â†‘(Ï€ / 2)) = -cos Î¸ ,":= by
  induction Î¸ using Real.Angle.induction_on
  exact Real.sin_sub_pi_div_two _"
Mathlib/Analysis/BoxIntegral/Partition/Split.lean,BoxIntegral.Prepartition.split_of_not_mem_Ioo,split_of_not_mem_Ioo,d1eb6264448286c8ff0dd2875db90fd9724a3cbf,":= by
  refine' ((isPartitionTop I).eq_of_boxes_subset fun J hJ => _).symm
  rcases mem_top.1 hJ with rfl; clear hJ
  rw [mem_boxes, mem_split_iff]
  rw [mem_Ioo, not_and_or, not_lt, not_lt] at h
  cases h <;> [right, left]
  Â· rwa [eq_comm, Box.splitUpper_eq_self]
  Â· rwa [eq_comm, Box.splitLower_eq_self]","error:  unexpected token ','; expected ']'",theorem split_of_not_mem_Ioo (h : x âˆ‰ Ioo (I.lower i) (I.upper i)) : split I i x = âŠ¤ ,":= by
  refine ((isPartitionTop I).eq_of_boxes_subset fun J hJ => ?_).symm
  rcases mem_top.1 hJ with rfl; clear hJ
  rw [mem_boxes, mem_split_iff]
  rw [mem_Ioo, not_and_or, not_lt, not_lt] at h
  cases h <;> [right; left]
  Â· rwa [eq_comm, Box.splitUpper_eq_self]
  Â· rwa [eq_comm, Box.splitLower_eq_self]"
Mathlib/Algebra/Polynomial/Module/Basic.lean,PolynomialModule.monomial_smul_single,monomial_smul_single,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  simp only [LinearMap.mul_apply, Polynomial.aeval_monomial, LinearMap.pow_apply,
    Module.algebraMap_end_apply, smul_def]
  induction i generalizing r j m with
  | zero =>
    rw [Nat.zero_eq, Function.iterate_zero, zero_add]
    exact Finsupp.smul_single r j m
  | succ n hn =>
    rw [Function.iterate_succ, Function.comp_apply, Nat.succ_eq_add_one, add_assoc, â† hn]
    congr 2
    rw [Nat.one_add]
    exact Finsupp.mapDomain_single","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  Nat.zero
case zero
R : Type u_1
M : Type u_2
instâœâ¶ : CommRing R
instâœâµ : AddCommGroup M
instâœâ´ : Module R M
I : Ideal R
S : Type u_3
instâœÂ³ : CommSemiring S
instâœÂ² : Algebra S R
instâœÂ¹ : Module S M
instâœ : IsScalarTower S R M
r : R
j : â„•
m : M
âŠ¢ r â€¢ (â‡‘(Finsupp.lmapDomain M R Nat.succ))^[0] ((single R j) m) = (single R (0 + j)) (r â€¢ m)
error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?n.succ
case succ
R : Type u_1
M : Type u_2
instâœâ¶ : CommRing R
instâœâµ : AddCommGroup M
instâœâ´ : Module R M
I : Ideal R
S : Type u_3
instâœÂ³ : CommSemiring S
instâœÂ² : Algebra S R
instâœÂ¹ : Module S M
instâœ : IsScalarTower S R M
n : â„•
hn :
  âˆ€ (r : R) (j : â„•) (m : M), r â€¢ (â‡‘(Finsupp.lmapDomain M R Nat.succ))^[n] ((single R j) m) = (single R (n + j)) (r â€¢ m)
r : R
j : â„•
m : M
âŠ¢ r â€¢ (â‡‘(Finsupp.lmapDomain M R Nat.succ))^[n] ((Finsupp.lmapDomain M R Nat.succ) ((single R j) m)) =
    (single R (n + 1 + j)) (r â€¢ m)","theorem monomial_smul_single (i : â„•) (r : R) (j : â„•) (m : M) :
    monomial i r â€¢ single R j m = single R (i + j) (r â€¢ m) ",":= by
  simp only [LinearMap.mul_apply, Polynomial.aeval_monomial, LinearMap.pow_apply,
    Module.algebraMap_end_apply, smul_def]
  induction i generalizing r j m with
  | zero =>
    rw [Function.iterate_zero, zero_add]
    exact Finsupp.smul_single r j m
  | succ n hn =>
    rw [Function.iterate_succ, Function.comp_apply, add_assoc, â† hn]
    congr 2
    rw [Nat.one_add]
    exact Finsupp.mapDomain_single"
Mathlib/RingTheory/UniqueFactorizationDomain.lean,UniqueFactorizationMonoid.multiplicative_of_coprime,multiplicative_of_coprime,a1dd400d181fcfa6e3a036c46f1aa505a2be5fe0,":= by
  letI := Classical.decEq Î±
  by_cases ha0 : a = 0
  Â· rw [ha0, zero_mul, h0, zero_mul]
  by_cases hb0 : b = 0
  Â· rw [hb0, mul_zero, h0, mul_zero]
  by_cases hf1 : f 1 = 0
  Â· calc
      f (a * b) = f (a * b * 1) := by rw [mul_one]
      _ = 0 := by simp only [h1 isUnit_one, hf1, mul_zero]
      _ = f a * f (b * 1) := by simp only [h1 isUnit_one, hf1, mul_zero]
      _ = f a * f b := by rw [mul_one]
  haveI : Nontrivial Î± := âŸ¨âŸ¨_, _, ha0âŸ©âŸ©
  letI : NormalizationMonoid Î± := UniqueFactorizationMonoid.normalizationMonoid
  suffices
      f (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
        p ^ ((normalizedFactors a).count p + (normalizedFactors b).count p)) =
      f (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
        p ^ (normalizedFactors a).count p) *
      f (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
        p ^ (normalizedFactors b).count p) by
    obtain âŸ¨ua, a_eqâŸ© := normalizedFactors_prod ha0
    obtain âŸ¨ub, b_eqâŸ© := normalizedFactors_prod hb0
    rw [â† a_eq, â† b_eq, mul_right_comm (Multiset.prod (normalizedFactors a)) ua
        (Multiset.prod (normalizedFactors b) * ub), h1 ua.isUnit, h1 ub.isUnit, h1 ua.isUnit, â†
      mul_assoc, h1 ub.isUnit, mul_right_comm _ (f ua), â† mul_assoc]
    congr
    rw [â† (normalizedFactors a).map_id, â† (normalizedFactors b).map_id,
      Finset.prod_multiset_map_count, Finset.prod_multiset_map_count,
      Finset.prod_subset (Finset.subset_union_left _ (normalizedFactors b).toFinset),
      Finset.prod_subset (Finset.subset_union_right _ (normalizedFactors b).toFinset), â†
      Finset.prod_mul_distrib]
    Â· simp_rw [id, â† pow_add, this]
    all_goals simp only [Multiset.mem_toFinset]
    Â· intro p _ hpb
      simp [hpb]
    Â· intro p _ hpa
      simp [hpa]
  refine multiplicative_prime_power _ _ _ ?_ ?_ @h1 @hpr @hcp
  all_goals simp only [Multiset.mem_toFinset, Finset.mem_union]
  Â· rintro p (hpa | hpb) <;> apply prime_of_normalized_factor <;> assumption
  Â· rintro p (hp | hp) q (hq | hq) hdvd <;>
      rw [â† normalize_normalized_factor _ hp, â† normalize_normalized_factor _ hq] <;>
      exact
        normalize_eq_normalize hdvd
          ((prime_of_normalized_factor _ hp).irreducible.dvd_symm
            (prime_of_normalized_factor _ hq).irreducible hdvd)","error:  function expected at
  Finset.subset_union_left ?m.296916
term has type
  ?m.296915 âˆˆ ?m.296913 âˆª ?m.296914
error:  function expected at
  Finset.subset_union_right ?m.297148
term has type
  ?m.297147 âˆˆ ?m.297145 âˆª ?m.297146
error:  simp made no progress
error:  simp made no progress
error:  unsolved goals
case intro.intro.e_a.e_a
Î± : Type u_1
R : Type u_2
instâœâ´ : CancelCommMonoidWithZero R
instâœÂ³ : UniqueFactorizationMonoid R
instâœÂ² : CancelCommMonoidWithZero Î±
instâœÂ¹ : UniqueFactorizationMonoid Î±
Î² : Type u_3
instâœ : CancelCommMonoidWithZero Î²
f : Î± â†’ Î²
a b : Î±
h0 : f 0 = 0
h1 : âˆ€ {x y : Î±}, IsUnit y â†’ f (x * y) = f x * f y
hpr : âˆ€ {p : Î±} (i : â„•), Prime p â†’ f (p ^ i) = f p ^ i
hcp : âˆ€ {x y : Î±}, IsRelPrime x y â†’ f (x * y) = f x * f y
thisâœÂ² : DecidableEq Î± := Classical.decEq Î±
ha0 : Â¬a = 0
hb0 : Â¬b = 0
hf1 : Â¬f 1 = 0
thisâœÂ¹ : Nontrivial Î±
thisâœ : NormalizationMonoid Î± := UniqueFactorizationMonoid.normalizationMonoid
this :
  f
      (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
        p ^ (Multiset.count p (normalizedFactors a) + Multiset.count p (normalizedFactors b))) =
    f
        (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
          p ^ Multiset.count p (normalizedFactors a)) *
      f
        (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
          p ^ Multiset.count p (normalizedFactors b))
ua : Î±Ë£
a_eq : (normalizedFactors a).prod * â†‘ua = a
ub : Î±Ë£
b_eq : (normalizedFactors b).prod * â†‘ub = b
p : Î±
aâœ : p âˆˆ normalizedFactors b
hpb : p âˆ‰ ?m.297138
âŠ¢ p ^ Multiset.count p (normalizedFactors a) = 1
error:  tactic 'introN' failed, insufficient number of binders
Î± : Type u_1
R : Type u_2
instâœâ´ : CancelCommMonoidWithZero R
instâœÂ³ : UniqueFactorizationMonoid R
instâœÂ² : CancelCommMonoidWithZero Î±
instâœÂ¹ : UniqueFactorizationMonoid Î±
Î² : Type u_3
instâœ : CancelCommMonoidWithZero Î²
f : Î± â†’ Î²
a b : Î±
h0 : f 0 = 0
h1 : âˆ€ {x y : Î±}, IsUnit y â†’ f (x * y) = f x * f y
hpr : âˆ€ {p : Î±} (i : â„•), Prime p â†’ f (p ^ i) = f p ^ i
hcp : âˆ€ {x y : Î±}, IsRelPrime x y â†’ f (x * y) = f x * f y
thisâœÂ² : DecidableEq Î± := Classical.decEq Î±
ha0 : Â¬a = 0
hb0 : Â¬b = 0
hf1 : Â¬f 1 = 0
thisâœÂ¹ : Nontrivial Î±
thisâœ : NormalizationMonoid Î± := UniqueFactorizationMonoid.normalizationMonoid
this :
  f
      (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
        p ^ (Multiset.count p (normalizedFactors a) + Multiset.count p (normalizedFactors b))) =
    f
        (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
          p ^ Multiset.count p (normalizedFactors a)) *
      f
        (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
          p ^ Multiset.count p (normalizedFactors b))
ua : Î±Ë£
a_eq : (normalizedFactors a).prod * â†‘ua = a
ub : Î±Ë£
b_eq : (normalizedFactors b).prod * â†‘ub = b
âŠ¢ Finset Î±
error:  unsolved goals
case intro.intro.e_a.e_a
Î± : Type u_1
R : Type u_2
instâœâ´ : CancelCommMonoidWithZero R
instâœÂ³ : UniqueFactorizationMonoid R
instâœÂ² : CancelCommMonoidWithZero Î±
instâœÂ¹ : UniqueFactorizationMonoid Î±
Î² : Type u_3
instâœ : CancelCommMonoidWithZero Î²
f : Î± â†’ Î²
a b : Î±
h0 : f 0 = 0
h1 : âˆ€ {x y : Î±}, IsUnit y â†’ f (x * y) = f x * f y
hpr : âˆ€ {p : Î±} (i : â„•), Prime p â†’ f (p ^ i) = f p ^ i
hcp : âˆ€ {x y : Î±}, IsRelPrime x y â†’ f (x * y) = f x * f y
thisâœÂ² : DecidableEq Î± := Classical.decEq Î±
ha0 : Â¬a = 0
hb0 : Â¬b = 0
hf1 : Â¬f 1 = 0
thisâœÂ¹ : Nontrivial Î±
thisâœ : NormalizationMonoid Î± := UniqueFactorizationMonoid.normalizationMonoid
this :
  f
      (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
        p ^ (Multiset.count p (normalizedFactors a) + Multiset.count p (normalizedFactors b))) =
    f
        (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
          p ^ Multiset.count p (normalizedFactors a)) *
      f
        (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
          p ^ Multiset.count p (normalizedFactors b))
ua : Î±Ë£
a_eq : (normalizedFactors a).prod * â†‘ua = a
ub : Î±Ë£
b_eq : (normalizedFactors b).prod * â†‘ub = b
âŠ¢ âˆ€ x âˆˆ sorryAx (Finset Î±) true, x âˆ‰ normalizedFactors a â†’ id x ^ Multiset.count x (normalizedFactors a) = 1","theorem multiplicative_of_coprime (f : Î± â†’ Î²) (a b : Î±) (h0 : f 0 = 0)
    (h1 : âˆ€ {x y}, IsUnit y â†’ f (x * y) = f x * f y)
    (hpr : âˆ€ {p} (i : â„•), Prime p â†’ f (p ^ i) = f p ^ i)
    (hcp : âˆ€ {x y}, IsRelPrime x y â†’ f (x * y) = f x * f y) :
    f (a * b) = f a * f b ",":= by
  letI := Classical.decEq Î±
  by_cases ha0 : a = 0
  Â· rw [ha0, zero_mul, h0, zero_mul]
  by_cases hb0 : b = 0
  Â· rw [hb0, mul_zero, h0, mul_zero]
  by_cases hf1 : f 1 = 0
  Â· calc
      f (a * b) = f (a * b * 1) := by rw [mul_one]
      _ = 0 := by simp only [h1 isUnit_one, hf1, mul_zero]
      _ = f a * f (b * 1) := by simp only [h1 isUnit_one, hf1, mul_zero]
      _ = f a * f b := by rw [mul_one]
  haveI : Nontrivial Î± := âŸ¨âŸ¨_, _, ha0âŸ©âŸ©
  letI : NormalizationMonoid Î± := UniqueFactorizationMonoid.normalizationMonoid
  suffices
      f (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
        p ^ ((normalizedFactors a).count p + (normalizedFactors b).count p)) =
      f (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
        p ^ (normalizedFactors a).count p) *
      f (âˆ p âˆˆ (normalizedFactors a).toFinset âˆª (normalizedFactors b).toFinset,
        p ^ (normalizedFactors b).count p) by
    obtain âŸ¨ua, a_eqâŸ© := normalizedFactors_prod ha0
    obtain âŸ¨ub, b_eqâŸ© := normalizedFactors_prod hb0
    rw [â† a_eq, â† b_eq, mul_right_comm (Multiset.prod (normalizedFactors a)) ua
        (Multiset.prod (normalizedFactors b) * ub), h1 ua.isUnit, h1 ub.isUnit, h1 ua.isUnit, â†
      mul_assoc, h1 ub.isUnit, mul_right_comm _ (f ua), â† mul_assoc]
    congr
    rw [â† (normalizedFactors a).map_id, â† (normalizedFactors b).map_id,
      Finset.prod_multiset_map_count, Finset.prod_multiset_map_count,
      Finset.prod_subset (Finset.subset_union_left (sâ‚‚:=(normalizedFactors b).toFinset)),
      Finset.prod_subset (Finset.subset_union_right (sâ‚‚:=(normalizedFactors b).toFinset)), â†
      Finset.prod_mul_distrib]
    Â· simp_rw [id, â† pow_add, this]
    all_goals simp only [Multiset.mem_toFinset]
    Â· intro p _ hpb
      simp [hpb]
    Â· intro p _ hpa
      simp [hpa]
  refine multiplicative_prime_power _ _ _ ?_ ?_ @h1 @hpr @hcp
  all_goals simp only [Multiset.mem_toFinset, Finset.mem_union]
  Â· rintro p (hpa | hpb) <;> apply prime_of_normalized_factor <;> assumption
  Â· rintro p (hp | hp) q (hq | hq) hdvd <;>
      rw [â† normalize_normalized_factor _ hp, â† normalize_normalized_factor _ hq] <;>
      exact
        normalize_eq_normalize hdvd
          ((prime_of_normalized_factor _ hp).irreducible.dvd_symm
            (prime_of_normalized_factor _ hq).irreducible hdvd)"
Mathlib/Logic/Equiv/List.lean,Denumerable.lower_raise,lower_raise,2235ae5100e2af7f16bea313637531b24bf8e1e0,"  | [], n => rfl
  | m :: l, n => by rw [raise, lower, add_tsub_cancel_right, lower_raise l]","error:  failed to synthesize
  OrderedSub â„•
use `set_option diagnostics true` to get diagnostic information
error:  failed to synthesize
  ContravariantClass â„• â„• (fun x x_1 â†¦ x + x_1) fun x x_1 â†¦ x â‰¤ x_1
use `set_option diagnostics true` to get diagnostic information
error:  unsolved goals
Î± : Type u_1
Î² : Type u_2
instâœÂ¹ : Denumerable Î±
instâœ : Denumerable Î²
m : â„•
l : List â„•
n : â„•
âŠ¢ OrderedSub â„•

Î± : Type u_1
Î² : Type u_2
instâœÂ¹ : Denumerable Î±
instâœ : Denumerable Î²
m : â„•
l : List â„•
n : â„•
âŠ¢ ContravariantClass â„• â„• (fun x x_1 â†¦ x + x_1) fun x x_1 â†¦ x â‰¤ x_1","theorem lower_raise : âˆ€ l n, lower (raise l n) n = l
","  | [], n => rfl
  | m :: l, n => by rw [raise, lower, Nat.add_sub_cancel_right, lower_raise l]"
Mathlib/CategoryTheory/Limits/Shapes/SingleObj.lean,CategoryTheory.Limits.SingleObj.Types.Quot.Rel.iff_orbitRel,Types.Quot.Rel.iff_orbitRel,a7fb90bf12fd33a310f0c526e3884169b7e38720,":= by
  have h (g : G) : y = g â€¢ x â†” g â€¢ x = y := âŸ¨symm, symmâŸ©
  conv => rhs; rw [Setoid.comm']
  show (âˆƒ g : G, y = g â€¢ x) â†” (âˆƒ g : G, g â€¢ x = y)
  conv => lhs; simp only [h]
  exact Iff.rfl",error:  no goals to be solved,"lemma Types.Quot.Rel.iff_orbitRel (x y : J.obj (SingleObj.star G)) :
    Types.Quot.Rel J âŸ¨SingleObj.star G, xâŸ© âŸ¨SingleObj.star G, yâŸ©
    â†” Setoid.Rel (MulAction.orbitRel G (J.obj (SingleObj.star G))) x y ",":= by
  have h (g : G) : y = g â€¢ x â†” g â€¢ x = y := âŸ¨symm, symmâŸ©
  conv => rhs; rw [Setoid.comm']
  show (âˆƒ g : G, y = g â€¢ x) â†” (âˆƒ g : G, g â€¢ x = y)
  conv => lhs; simp only [h]"
Mathlib/Data/Set/Card.lean,Set.exists_subset_or_subset_of_two_mul_lt_ncard,exists_subset_or_subset_of_two_mul_lt_ncard,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  classical
  have hu := finite_of_ncard_ne_zero ((Nat.zero_le _).trans_lt hst).ne.symm
  rw [ncard_eq_toFinset_card _ hu,
    Finite.toFinset_union (hu.subset (subset_union_left _ _))
      (hu.subset (subset_union_right _ _))] at hst
  obtain âŸ¨r', hnr', hr'âŸ© := Finset.exists_subset_or_subset_of_two_mul_lt_card hst
  exact âŸ¨r', by simpa, by simpa using hr'âŸ©","error:  function expected at
  subset_union_left ?m.212348
term has type
  ?m.212347 âˆˆ ?m.212345 âˆª ?m.212346
error:  function expected at
  subset_union_right ?m.212399
term has type
  ?m.212398 âˆˆ ?m.212396 âˆª ?m.212397","theorem exists_subset_or_subset_of_two_mul_lt_ncard {n : â„•} (hst : 2 * n < (s âˆª t).ncard) :
    âˆƒ r : Set Î±, n < r.ncard âˆ§ (r âŠ† s âˆ¨ r âŠ† t) ",":= by
  classical
  have hu := finite_of_ncard_ne_zero ((Nat.zero_le _).trans_lt hst).ne.symm
  rw [ncard_eq_toFinset_card _ hu,
    Finite.toFinset_union (hu.subset subset_union_left)
      (hu.subset subset_union_right)] at hst
  obtain âŸ¨r', hnr', hr'âŸ© := Finset.exists_subset_or_subset_of_two_mul_lt_card hst
  exact âŸ¨r', by simpa, by simpa using hr'âŸ©"
Mathlib/NumberTheory/FermatPsp.lean,Nat.exists_infinite_pseudoprimes,exists_infinite_pseudoprimes,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  by_cases b_ge_two : 2 â‰¤ b
  Â· have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hpâ‚ hpâ‚‚
    have hâ‚ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have hâ‚‚ : 4 â‰¤ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have hâ‚ƒ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt hâ‚‚ (by norm_num))
    have hâ‚„ : 0 < b * (b ^ 2 - 1) := mul_pos hâ‚ hâ‚ƒ
    have hâ‚… : b * (b ^ 2 - 1) < p := by linarith
    have hâ‚† : Â¬p âˆ£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt hâ‚„ hâ‚…
    have hâ‚‡ : b â‰¤ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right _ hâ‚ƒ
    have hâ‚ˆ : 2 â‰¤ b * (b ^ 2 - 1) := le_trans b_ge_two hâ‚‡
    have hâ‚‰ : 2 < p := gt_of_gt_of_ge hâ‚… hâ‚ˆ
    have hâ‚â‚€ := psp_from_prime_gt_p b_ge_two hpâ‚‚ hâ‚‰
    use psp_from_prime b p
    constructor
    Â· exact psp_from_prime_psp b_ge_two hpâ‚‚ hâ‚‰ hâ‚†
    Â· exact le_trans (show m â‰¤ p by linarith) (le_of_lt hâ‚â‚€)
  Â· have hâ‚ : b = 1 := by linarith
    rw [hâ‚]
    use 2 * (m + 2)
    have : Â¬Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by norm_num) (by norm_num)
    exact âŸ¨fermatPsp_base_one (by linarith) this, by linarithâŸ©","error:  unsolved goals
b : â„•
h : 1 â‰¤ b
m : â„•
b_ge_two : Â¬2 â‰¤ b
hâ‚ : b = 1
âŠ¢ Â¬m + 2 = 1","theorem exists_infinite_pseudoprimes {b : â„•} (h : 1 â‰¤ b) (m : â„•) :
    âˆƒ n : â„•, FermatPsp n b âˆ§ m â‰¤ n ",":= by
  by_cases b_ge_two : 2 â‰¤ b
  Â· have h := Nat.exists_infinite_primes (b * (b ^ 2 - 1) + 1 + m)
    cases' h with p hp
    cases' hp with hpâ‚ hpâ‚‚
    have hâ‚ : 0 < b := pos_of_gt (Nat.succ_le_iff.mp b_ge_two)
    have hâ‚‚ : 4 â‰¤ b ^ 2 := pow_le_pow_left' b_ge_two 2
    have hâ‚ƒ : 0 < b ^ 2 - 1 := tsub_pos_of_lt (gt_of_ge_of_gt hâ‚‚ (by norm_num))
    have hâ‚„ : 0 < b * (b ^ 2 - 1) := mul_pos hâ‚ hâ‚ƒ
    have hâ‚… : b * (b ^ 2 - 1) < p := by omega
    have hâ‚† : Â¬p âˆ£ b * (b ^ 2 - 1) := Nat.not_dvd_of_pos_of_lt hâ‚„ hâ‚…
    have hâ‚‡ : b â‰¤ b * (b ^ 2 - 1) := Nat.le_mul_of_pos_right _ hâ‚ƒ
    have hâ‚ˆ : 2 â‰¤ b * (b ^ 2 - 1) := le_trans b_ge_two hâ‚‡
    have hâ‚‰ : 2 < p := gt_of_gt_of_ge hâ‚… hâ‚ˆ
    have hâ‚â‚€ := psp_from_prime_gt_p b_ge_two hpâ‚‚ hâ‚‰
    use psp_from_prime b p
    constructor
    Â· exact psp_from_prime_psp b_ge_two hpâ‚‚ hâ‚‰ hâ‚†
    Â· exact le_trans (show m â‰¤ p by omega) (le_of_lt hâ‚â‚€)
  Â· have hâ‚ : b = 1 := by omega
    rw [hâ‚]
    use 2 * (m + 2)
    have : Â¬Nat.Prime (2 * (m + 2)) := Nat.not_prime_mul (by omega) (by omega)
    exact âŸ¨fermatPsp_base_one (by omega) this, by omegaâŸ©"
Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean,MeasureTheory.SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge,SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge,9e34a191034458a56331f976ff7400a26407c888,":= by
  induction' f using MeasureTheory.SimpleFunc.induction with c s hs fâ‚ fâ‚‚ _ hâ‚ hâ‚‚ generalizing Îµ
  Â· let f := SimpleFunc.piecewise s hs (SimpleFunc.const Î± c) (SimpleFunc.const Î± 0)
    by_cases h : âˆ«â» x, f x âˆ‚Î¼ = âŠ¤
    Â· refine'
        âŸ¨fun _ => c, fun x => _, lowerSemicontinuous_const, by
          simp only [_root_.top_add, le_top, h]âŸ©
      simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,
        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]
      exact Set.indicator_le_self _ _ _
    by_cases hc : c = 0
    Â· refine' âŸ¨fun _ => 0, _, lowerSemicontinuous_const, _âŸ©
      Â· classical
        simp only [hc, Set.indicator_zero', Pi.zero_apply, SimpleFunc.const_zero, imp_true_iff,
          eq_self_iff_true, SimpleFunc.coe_zero, Set.piecewise_eq_indicator,
          SimpleFunc.coe_piecewise, le_zero_iff]
      Â· simp only [lintegral_const, MulZeroClass.zero_mul, zero_le, ENNReal.coe_zero]
    have : Î¼ s < Î¼ s + Îµ / c := by
      have : (0 : â„â‰¥0âˆ) < Îµ / c := ENNReal.div_pos_iff.2 âŸ¨Îµ0, ENNReal.coe_ne_topâŸ©
      simpa using ENNReal.add_lt_add_left ?aux this
    case aux =>
      classical
      simpa [hs, hc, lt_top_iff_ne_top, true_and_iff, SimpleFunc.coe_const,
        Function.const_apply, lintegral_const, ENNReal.coe_indicator, Set.univ_inter,
        ENNReal.coe_ne_top, MeasurableSet.univ, ENNReal.mul_eq_top, SimpleFunc.const_zero,
        or_false_iff, lintegral_indicator, ENNReal.coe_eq_zero, Ne.def, not_false_iff,
        SimpleFunc.coe_zero, Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise, false_and_iff,
        restrict_apply] using h
    obtain âŸ¨u, su, u_open, Î¼uâŸ© : âˆƒ (u : _), u âŠ‡ s âˆ§ IsOpen u âˆ§ Î¼ u < Î¼ s + Îµ / c :=
      s.exists_isOpen_lt_of_lt _ this
    refine'
      âŸ¨Set.indicator u fun _ => c, fun x => _, u_open.lowerSemicontinuous_indicator (zero_le _), _âŸ©
    Â· simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,
        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]
      exact Set.indicator_le_indicator_of_subset su (fun x => zero_le _) _
    Â· suffices (c : â„â‰¥0âˆ) * Î¼ u â‰¤ c * Î¼ s + Îµ by
        classical
        simpa only [ENNReal.coe_indicator, u_open.measurableSet, lintegral_indicator,
          lintegral_const, MeasurableSet.univ, Measure.restrict_apply, Set.univ_inter, const_zero,
          coe_piecewise, coe_const, coe_zero, Set.piecewise_eq_indicator, Function.const_apply, hs]
      calc
        (c : â„â‰¥0âˆ) * Î¼ u â‰¤ c * (Î¼ s + Îµ / c) := mul_le_mul_left' Î¼u.le _
        _ = c * Î¼ s + Îµ := by
          simp_rw [mul_add]
          rw [ENNReal.mul_div_cancel' _ ENNReal.coe_ne_top]
          simpa using hc

  Â· rcases hâ‚ (ENNReal.half_pos Îµ0).ne' with âŸ¨gâ‚, fâ‚_le_gâ‚, gâ‚cont, gâ‚intâŸ©
    rcases hâ‚‚ (ENNReal.half_pos Îµ0).ne' with âŸ¨gâ‚‚, fâ‚‚_le_gâ‚‚, gâ‚‚cont, gâ‚‚intâŸ©
    refine'
      âŸ¨fun x => gâ‚ x + gâ‚‚ x, fun x => add_le_add (fâ‚_le_gâ‚ x) (fâ‚‚_le_gâ‚‚ x), gâ‚cont.add gâ‚‚cont, _âŸ©
    simp only [SimpleFunc.coe_add, ENNReal.coe_add, Pi.add_apply]
    rw [lintegral_add_left fâ‚.measurable.coe_nnreal_ennreal,
      lintegral_add_left gâ‚cont.measurable.coe_nnreal_ennreal]
    convert add_le_add gâ‚int gâ‚‚int using 1
    simp only
    conv_lhs => rw [â† ENNReal.add_halves Îµ]
    abel","error:  Case tag 'aux' not found.

The only available case tag is 'neg._@.Mathlib.MeasureTheory.Integral.VitaliCaratheodory._hyg.739'.
error:  simp made no progress","theorem SimpleFunc.exists_le_lowerSemicontinuous_lintegral_ge (f : Î± â†’â‚› â„â‰¥0) {Îµ : â„â‰¥0âˆ}
    (Îµ0 : Îµ â‰  0) :
    âˆƒ g : Î± â†’ â„â‰¥0, (âˆ€ x, f x â‰¤ g x) âˆ§ LowerSemicontinuous g âˆ§
      (âˆ«â» x, g x âˆ‚Î¼) â‰¤ (âˆ«â» x, f x âˆ‚Î¼) + Îµ ",":= by
  induction' f using MeasureTheory.SimpleFunc.induction with c s hs fâ‚ fâ‚‚ _ hâ‚ hâ‚‚ generalizing Îµ
  Â· let f := SimpleFunc.piecewise s hs (SimpleFunc.const Î± c) (SimpleFunc.const Î± 0)
    by_cases h : âˆ«â» x, f x âˆ‚Î¼ = âŠ¤
    Â· refine
        âŸ¨fun _ => c, fun x => ?_, lowerSemicontinuous_const, by
          simp only [_root_.top_add, le_top, h]âŸ©
      simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,
        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]
      exact Set.indicator_le_self _ _ _
    by_cases hc : c = 0
    Â· refine âŸ¨fun _ => 0, ?_, lowerSemicontinuous_const, ?_âŸ©
      Â· classical
        simp only [hc, Set.indicator_zero', Pi.zero_apply, SimpleFunc.const_zero, imp_true_iff,
          eq_self_iff_true, SimpleFunc.coe_zero, Set.piecewise_eq_indicator,
          SimpleFunc.coe_piecewise, le_zero_iff]
      Â· simp only [lintegral_const, zero_mul, zero_le, ENNReal.coe_zero]
    have ne_top : Î¼ s â‰  âŠ¤ := by
      classical
      simpa [f, hs, hc, lt_top_iff_ne_top, true_and_iff, SimpleFunc.coe_const,
        Function.const_apply, lintegral_const, ENNReal.coe_indicator, Set.univ_inter,
        ENNReal.coe_ne_top, MeasurableSet.univ, ENNReal.mul_eq_top, SimpleFunc.const_zero,
        or_false_iff, lintegral_indicator, ENNReal.coe_eq_zero, Ne, not_false_iff,
        SimpleFunc.coe_zero, Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise, false_and_iff,
        restrict_apply] using h
    have : Î¼ s < Î¼ s + Îµ / c := by
      have : (0 : â„â‰¥0âˆ) < Îµ / c := ENNReal.div_pos_iff.2 âŸ¨Îµ0, ENNReal.coe_ne_topâŸ©
      simpa using ENNReal.add_lt_add_left ne_top this
    obtain âŸ¨u, su, u_open, Î¼uâŸ© : âˆƒ (u : _), u âŠ‡ s âˆ§ IsOpen u âˆ§ Î¼ u < Î¼ s + Îµ / c :=
      s.exists_isOpen_lt_of_lt _ this
    refine âŸ¨Set.indicator u fun _ => c,
            fun x => ?_, u_open.lowerSemicontinuous_indicator (zero_le _), ?_âŸ©
    Â· simp only [SimpleFunc.coe_const, SimpleFunc.const_zero, SimpleFunc.coe_zero,
        Set.piecewise_eq_indicator, SimpleFunc.coe_piecewise]
      exact Set.indicator_le_indicator_of_subset su (fun x => zero_le _) _
    Â· suffices (c : â„â‰¥0âˆ) * Î¼ u â‰¤ c * Î¼ s + Îµ by
        classical
        simpa only [ENNReal.coe_indicator, u_open.measurableSet, lintegral_indicator,
          lintegral_const, MeasurableSet.univ, Measure.restrict_apply, Set.univ_inter, const_zero,
          coe_piecewise, coe_const, coe_zero, Set.piecewise_eq_indicator, Function.const_apply, hs]
      calc
        (c : â„â‰¥0âˆ) * Î¼ u â‰¤ c * (Î¼ s + Îµ / c) := mul_le_mul_left' Î¼u.le _
        _ = c * Î¼ s + Îµ := by
          simp_rw [mul_add]
          rw [ENNReal.mul_div_cancel' _ ENNReal.coe_ne_top]
          simpa using hc

  Â· rcases hâ‚ (ENNReal.half_pos Îµ0).ne' with âŸ¨gâ‚, fâ‚_le_gâ‚, gâ‚cont, gâ‚intâŸ©
    rcases hâ‚‚ (ENNReal.half_pos Îµ0).ne' with âŸ¨gâ‚‚, fâ‚‚_le_gâ‚‚, gâ‚‚cont, gâ‚‚intâŸ©
    refine
      âŸ¨fun x => gâ‚ x + gâ‚‚ x, fun x => add_le_add (fâ‚_le_gâ‚ x) (fâ‚‚_le_gâ‚‚ x), gâ‚cont.add gâ‚‚cont, ?_âŸ©
    simp only [SimpleFunc.coe_add, ENNReal.coe_add, Pi.add_apply]
    rw [lintegral_add_left fâ‚.measurable.coe_nnreal_ennreal,
      lintegral_add_left gâ‚cont.measurable.coe_nnreal_ennreal]
    convert add_le_add gâ‚int gâ‚‚int using 1
    conv_lhs => rw [â† ENNReal.add_halves Îµ]
    abel"
Mathlib/RingTheory/Valuation/ValuationSubring.lean,ValuationSubring.idealOfLE_ofPrime,idealOfLE_ofPrime,d76804446de1af30ab113b40fe5517a4197a0a67,":= by
  refine Ideal.ext (fun x => ?_)
  apply IsLocalization.AtPrime.to_map_mem_maximal_iff","error:  unsolved goals
case h
K : Type u
instâœÂ¹ : Field K
Aâœ A : ValuationSubring K
P : Ideal â†¥A
instâœ : P.IsPrime
x : â†¥A
âŠ¢ optParam (LocalRing â†¥(A.ofPrime P)) â‹¯","theorem idealOfLE_ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :
    idealOfLE A (ofPrime A P) (le_ofPrime A P) = P ",":= by
  refine Ideal.ext (fun x => ?_)
  apply IsLocalization.AtPrime.to_map_mem_maximal_iff
  exact localRing (ofPrime A P)"
Mathlib/Combinatorics/SetFamily/Compression/UV.lean,UV.shadow_compression_subset_compression_shadow,shadow_compression_subset_compression_shadow,a36d8932e98ea1d7efcdd316318586a6329f53a3,":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine Or.inl âŸ¨hs, ?_âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine' mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, _âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine'
        mem_shadow_iff.2
          âŸ¨(t âŠ” u) \ v,
            sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, _, _âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine'
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) _
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans (subset_union_right _ _)
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans <| subset_union_left _ _) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine' âŸ¨hus, hsv.symm, âŸ¨x, _, _âŸ©, _âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right _ _, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine' sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) _
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans <| subset_union_left _ _),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]","warning:  @UV.compression does not have a doc string
error:  function expected at
  subset_union_right ?m.92173
term has type
  ?m.92172 âˆˆ ?m.92170 âˆª ?m.92171
error:  function expected at
  subset_union_left ?m.92639
term has type
  ?m.92638 âˆˆ ?m.92636 âˆª ?m.92637
error:  function expected at
  subset_union_right ?m.94506
term has type
  ?m.94505 âˆˆ ?m.94503 âˆª ?m.94504
error:  function expected at
  subset_union_left ?m.97300
term has type
  ?m.97299 âˆˆ ?m.97297 âˆª ?m.97298
error:  function expected at
  subset_union_left ?m.98875
term has type
  ?m.98874 âˆˆ ?m.98872 âˆª ?m.98873","theorem shadow_compression_subset_compression_shadow (u v : Finset Î±)
    (huv : âˆ€ x âˆˆ u, âˆƒ y âˆˆ v, IsCompressed (u.erase x) (v.erase y) ğ’œ) :
    âˆ‚ (ğ“’ u v ğ’œ) âŠ† ğ“’ u v (âˆ‚ ğ’œ) ",":= by
  set ğ’œ' := ğ“’ u v ğ’œ
  suffices H : âˆ€ s âˆˆ âˆ‚ ğ’œ',
      s âˆ‰ âˆ‚ ğ’œ â†’ u âŠ† s âˆ§ Disjoint v s âˆ§ (s âˆª v) \ u âˆˆ âˆ‚ ğ’œ âˆ§ (s âˆª v) \ u âˆ‰ âˆ‚ ğ’œ' by
    rintro s hs'
    rw [mem_compression]
    by_cases hs : s âˆˆ ğ’œ.shadow
    swap
    Â· obtain âŸ¨hus, hvs, h, _âŸ© := H _ hs' hs
      exact Or.inr âŸ¨hs, _, h, compress_of_disjoint_of_le' hvs husâŸ©
    refine Or.inl âŸ¨hs, ?_âŸ©
    rw [compress]
    split_ifs with huvs
    swap
    Â· exact hs
    rw [mem_shadow_iff] at hs'
    obtain âŸ¨t, Ht, a, hat, rflâŸ© := hs'
    have hav : a âˆ‰ v := not_mem_mono huvs.2 (not_mem_erase a t)
    have hvt : v â‰¤ t := huvs.2.trans (erase_subset _ t)
    have ht : t âˆˆ ğ’œ := mem_of_mem_compression Ht hvt (aux huv)
    by_cases hau : a âˆˆ u
    Â· obtain âŸ¨b, hbv, HcompâŸ© := huv a hau
      refine mem_shadow_iff_insert_mem.2 âŸ¨b, not_mem_sdiff_of_mem_right hbv, ?_âŸ©
      rw [â† Hcomp.eq] at ht
      have hsb :=
        sup_sdiff_mem_of_mem_compression ht ((erase_subset _ _).trans hvt)
          (disjoint_erase_comm.2 huvs.1)
      rwa [sup_eq_union, sdiff_erase (mem_union_left _ <| hvt hbv), union_erase_of_mem hat, â†
        erase_union_of_mem hau] at hsb
    Â· refine mem_shadow_iff.2
        âŸ¨(t âŠ” u) \ v,
          sup_sdiff_mem_of_mem_compression Ht hvt <| disjoint_of_erase_right hau huvs.1, a, ?_, ?_âŸ©
      Â· rw [sup_eq_union, mem_sdiff, mem_union]
        exact âŸ¨Or.inl hat, havâŸ©
      Â· rw [â† erase_sdiff_comm, sup_eq_union, erase_union_distrib, erase_eq_of_not_mem hau]
  intro s hsğ’œ' hsğ’œ
  have m : âˆ€ y, y âˆ‰ s â†’ insert y s âˆ‰ ğ’œ := fun y h a => hsğ’œ (mem_shadow_iff_insert_mem.2 âŸ¨y, h, aâŸ©)
  obtain âŸ¨x, _, _âŸ© := mem_shadow_iff_insert_mem.1 hsğ’œ'
  have hus : u âŠ† insert x s := le_of_mem_compression_of_not_mem â€¹_ âˆˆ ğ’œ'â€º (m _ â€¹x âˆ‰ sâ€º)
  have hvs : Disjoint v (insert x s) := disjoint_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have : (insert x s âˆª v) \ u âˆˆ ğ’œ := sup_sdiff_mem_of_mem_compression_of_not_mem â€¹_â€º (m _ â€¹x âˆ‰ sâ€º)
  have hsv : Disjoint s v := hvs.symm.mono_left (subset_insert _ _)
  have hvu : Disjoint v u := disjoint_of_subset_right hus hvs
  have hxv : x âˆ‰ v := disjoint_right.1 hvs (mem_insert_self _ _)
  have : v \ u = v := â€¹Disjoint v uâ€º.sdiff_eq_left
  have : x âˆ‰ u := by
    intro hxu
    obtain âŸ¨y, hyv, hxyâŸ© := huv x hxu
    apply m y (disjoint_right.1 hsv hyv)
    have : ((insert x s âˆª v) \ u âˆª erase u x) \ erase v y âˆˆ ğ’œ := by
      refine
        sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ?_
          (disjoint_of_subset_left (erase_subset _ _) disjoint_sdiff)
      rw [union_sdiff_distrib, â€¹v \ u = vâ€º]
      exact (erase_subset _ _).trans subset_union_right
    convert this using 1
    rw [sdiff_union_erase_cancel (hus.trans subset_union_left) â€¹x âˆˆ uâ€º, erase_union_distrib,
      erase_insert â€¹x âˆ‰ sâ€º, erase_eq_of_not_mem â€¹x âˆ‰ vâ€º, sdiff_erase (mem_union_right _ hyv),
      union_sdiff_cancel_right hsv]
  have hus : u âŠ† s := by rwa [â† erase_eq_of_not_mem â€¹x âˆ‰ uâ€º, â† subset_insert_iff]
  simp_rw [mem_shadow_iff_insert_mem]
  refine âŸ¨hus, hsv.symm, âŸ¨x, ?_, ?_âŸ©, ?_âŸ©
  Â· exact not_mem_sdiff_of_not_mem_left (not_mem_union.2 âŸ¨â€¹x âˆ‰ sâ€º, â€¹x âˆ‰ vâ€ºâŸ©)
  Â· rwa [â† insert_sdiff_of_not_mem _ â€¹x âˆ‰ uâ€º, â† insert_union]
  rintro âŸ¨w, hwB, hwğ’œ'âŸ©
  have : v âŠ† insert w ((s âˆª v) \ u) :=
    (subset_sdiff.2 âŸ¨subset_union_right, hvuâŸ©).trans (subset_insert _ _)
  by_cases hwu : w âˆˆ u
  Â· obtain âŸ¨z, hz, hxyâŸ© := huv w hwu
    apply m z (disjoint_right.1 hsv hz)
    have : insert w ((s âˆª v) \ u) âˆˆ ğ’œ := mem_of_mem_compression hwğ’œ' â€¹_â€º (aux huv)
    have : (insert w ((s âˆª v) \ u) âˆª erase u w) \ erase v z âˆˆ ğ’œ := by
      refine sup_sdiff_mem_of_mem_compression (by rwa [hxy.eq]) ((erase_subset _ _).trans â€¹_â€º) ?_
      rw [â† sdiff_erase (mem_union_left _ <| hus hwu)]
      exact disjoint_sdiff
    convert this using 1
    rw [insert_union_comm, insert_erase â€¹w âˆˆ uâ€º,
      sdiff_union_of_subset (hus.trans subset_union_left),
      sdiff_erase (mem_union_right _ â€¹z âˆˆ vâ€º), union_sdiff_cancel_right hsv]
  rw [mem_sdiff, â† Classical.not_imp, Classical.not_not] at hwB
  apply m w (hwu âˆ˜ hwB âˆ˜ mem_union_left _)
  have : (insert w ((s âˆª v) \ u) âˆª u) \ v âˆˆ ğ’œ :=
    sup_sdiff_mem_of_mem_compression â€¹insert w ((s âˆª v) \ u) âˆˆ ğ’œ'â€º â€¹_â€º
      (disjoint_insert_right.2 âŸ¨â€¹_â€º, disjoint_sdiffâŸ©)
  convert this using 1
  rw [insert_union, sdiff_union_of_subset (hus.trans subset_union_left),
    insert_sdiff_of_not_mem _ (hwu âˆ˜ hwB âˆ˜ mem_union_right _), union_sdiff_cancel_right hsv]"
Mathlib/Data/Nat/Fib/Zeckendorf.lean,Nat.zeckendorf_sum_fib,zeckendorf_sum_fib,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,"  | [], _ => rfl
  | a :: l, hl => by
    have hl' := hl
    simp only [IsZeckendorfRep, cons_append, chain'_iff_pairwise, pairwise_cons, mem_append,
      mem_singleton, or_imp, forall_and, forall_eq, zero_add] at hl
    rw [â† chain'_iff_pairwise] at hl
    have ha : 0 < a := hl.1.2.trans_lt' zero_lt_two
    suffices h : greatestFib (fib a + sum (map fib l)) = a by
      simp only [map, List.sum_cons, add_pos_iff, fib_pos.2 ha, true_or, zeckendorf_of_pos, h,
      add_tsub_cancel_left, zeckendorf_sum_fib hl.2]
    simp only [add_comm, add_assoc, greatestFib, findGreatest_eq_iff, ne_eq, ha.ne',
      not_false_eq_true, le_add_iff_nonneg_left, _root_.zero_le, forall_true_left, not_le, true_and]
    refine âŸ¨le_add_of_le_right <| le_fib_add_one _, fun n hn _ â†¦ ?_âŸ©
    rw [add_comm, â† List.sum_cons, â† map_cons]
    exact hl'.sum_fib_lt (by simpa)","error:  type mismatch
  rfl
has type
  (map fib []).sum.zeckendorf = (map fib []).sum.zeckendorf : Prop
but is expected to have type
  (map fib []).sum.zeckendorf = [] : Prop","lemma zeckendorf_sum_fib : âˆ€ {l}, IsZeckendorfRep l â†’ zeckendorf (l.map fib).sum = l
","  | [], _ => by simp only [map_nil, List.sum_nil, zeckendorf_zero]
  | a :: l, hl => by
    have hl' := hl
    simp only [IsZeckendorfRep, cons_append, chain'_iff_pairwise, pairwise_cons, mem_append,
      mem_singleton, or_imp, forall_and, forall_eq, zero_add] at hl
    rw [â† chain'_iff_pairwise] at hl
    have ha : 0 < a := hl.1.2.trans_lt' zero_lt_two
    suffices h : greatestFib (fib a + sum (map fib l)) = a by
      simp only [map, List.sum_cons, add_pos_iff, fib_pos.2 ha, true_or, zeckendorf_of_pos, h,
      add_tsub_cancel_left, zeckendorf_sum_fib hl.2]
    simp only [add_comm, add_assoc, greatestFib, findGreatest_eq_iff, ne_eq, ha.ne',
      not_false_eq_true, le_add_iff_nonneg_left, _root_.zero_le, forall_true_left, not_le, true_and]
    refine âŸ¨le_add_of_le_right <| le_fib_add_one _, fun n hn _ â†¦ ?_âŸ©
    rw [add_comm, â† List.sum_cons, â† map_cons]
    exact hl'.sum_fib_lt (by simpa)"
Mathlib/GroupTheory/Perm/List.lean,List.formPerm_pow_length_eq_one_of_nodup,formPerm_pow_length_eq_one_of_nodup,754ba19de1471fd928c4fa0cc102d1f06f90e902,":= by
  ext x
  by_cases hx : x âˆˆ l
  Â· obtain âŸ¨âŸ¨k, hkâŸ©, rflâŸ© := get_of_mem hx
    simp [formPerm_pow_apply_get _ hl, Nat.mod_eq_of_lt hk]
  Â· have : x âˆ‰ { x | (l.formPerm ^ l.length) x â‰  x } := by
      intro H
      refine hx ?_
      replace H := set_support_zpow_subset l.formPerm l.length H
      simpa using support_formPerm_le' _ H
    simpa using this","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
error:  unsolved goals
case pos.intro.mk
Î± : Type u_1
Î² : Type u_2
instâœ : DecidableEq Î±
l : List Î±
x : Î±
hl : l.Nodup
k : â„•
hk : k < l.length
hx : l.get âŸ¨k, hkâŸ© âˆˆ l
âŠ¢ (l.formPerm ^ l.length) l[k] = l[k]",theorem formPerm_pow_length_eq_one_of_nodup (hl : Nodup l) : formPerm l ^ length l = 1 ,":= by
  ext x
  by_cases hx : x âˆˆ l
  Â· obtain âŸ¨k, hk, rflâŸ© := getElem_of_mem hx
    simp [formPerm_pow_apply_getElem _ hl, Nat.mod_eq_of_lt hk]
  Â· have : x âˆ‰ { x | (l.formPerm ^ l.length) x â‰  x } := by
      intro H
      refine hx ?_
      replace H := set_support_zpow_subset l.formPerm l.length H
      simpa using support_formPerm_le' _ H
    simpa using this"
Mathlib/Topology/Metrizable/Urysohn.lean,TopologicalSpace.exists_inducing_l_infty,exists_inducing_l_infty,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  rcases exists_countable_basis X with âŸ¨B, hBc, -, hBâŸ©
  let s : Set (Set X Ã— Set X) := { UV âˆˆ B Ã—Ë¢ B | closure UV.1 âŠ† UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono (inter_subset_left _ _)).toEncodable
  letI : TopologicalSpace s := âŠ¥
  haveI : DiscreteTopology s := âŸ¨rflâŸ©
  rsuffices âŸ¨f, hfâŸ© : âˆƒ f : X â†’ s â†’áµ‡ â„, Inducing f
  Â· exact âŸ¨fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : â„• â†’áµ‡ â„)).embedding.toInducing.comp hfâŸ©
  have hd : âˆ€ UV : s, Disjoint (closure UV.1.1) UV.1.2á¶œ :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain âŸ¨Îµ, Îµ01, hÎµâŸ© : âˆƒ Îµ : s â†’ â„, (âˆ€ UV, Îµ UV âˆˆ Ioc (0 : â„) 1) âˆ§ Tendsto Îµ cofinite (ğ“ 0) := by
    rcases posSumOfEncodable zero_lt_one s with âŸ¨Îµ, Îµ0, c, hÎµc, hc1âŸ©
    refine âŸ¨Îµ, fun UV => âŸ¨Îµ0 UV, ?_âŸ©, hÎµc.summable.tendsto_cofinite_zeroâŸ©
    exact (le_hasSum hÎµc UV fun _ _ => (Îµ0 _).le).trans hc1
  have : âˆ€ UV : s, âˆƒ f : C(X, â„),
      EqOn f 0 UV.1.1 âˆ§ EqOn f (fun _ => Îµ UV) UV.1.2á¶œ âˆ§ âˆ€ x, f x âˆˆ Icc 0 (Îµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      âŸ¨f, hfâ‚€, hfâ‚, hf01âŸ©
    exact âŸ¨Îµ UV â€¢ f, fun x hx => by simp [hfâ‚€ (subset_closure hx)], fun x hx => by simp [hfâ‚ hx],
      fun x => âŸ¨mul_nonneg (Îµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Îµ01 _).1.le (hf01 _).2âŸ©âŸ©
  choose f hf0 hfÎµ hf0Îµ using this
  have hf01 : âˆ€ UV x, f UV x âˆˆ Icc (0 : â„) 1 :=
    fun UV x => Icc_subset_Icc_right (Îµ01 _).2 (hf0Îµ _ _)
  set F : X â†’ s â†’áµ‡ â„ := fun x =>
    âŸ¨âŸ¨fun UV => f UV x, continuous_of_discreteTopologyâŸ©, 1,
      fun UVâ‚ UVâ‚‚ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)âŸ©
  have hF : âˆ€ x UV, F x UV = f UV x := fun _ _ => rfl
  refine âŸ¨F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_âŸ©
  Â· refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Î´ Î´0 => ?_
    have h_fin : { UV : s | Î´ â‰¤ Îµ UV }.Finite := by simpa only [â† not_lt] using hÎµ (gt_mem_nhds Î´0)
    have : âˆ€á¶  y in ğ“ x, âˆ€ UV, Î´ â‰¤ Îµ UV â†’ dist (F y UV) (F x UV) â‰¤ Î´ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Î´0)
    refine this.mono fun y hy => (BoundedContinuousFunction.dist_le Î´0.le).2 fun UV => ?_
    rcases le_total Î´ (Îµ UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Îµ _ _) (hf0Îµ _ _)).trans (by rwa [sub_zero])]
  Â· refine ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 ?_
    rintro V âŸ¨hVB, hxVâŸ©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with âŸ¨U, hUB, hxU, hUVâŸ©
    set UV : â†¥s := âŸ¨(U, V), âŸ¨hUB, hVBâŸ©, hUVâŸ©
    refine âŸ¨Îµ UV, (Îµ01 UV).1, fun y (hy : dist (F y) (F x) < Îµ UV) => ?_âŸ©
    replace hy : dist (F y UV) (F x UV) < Îµ UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfÎµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _","error:  function expected at
  inter_subset_left ?m.504
term has type
  ?m.503 âˆˆ ?m.501","theorem exists_inducing_l_infty : âˆƒ f : X â†’ â„• â†’áµ‡ â„, Inducing f ",":= by
  rcases exists_countable_basis X with âŸ¨B, hBc, -, hBâŸ©
  let s : Set (Set X Ã— Set X) := { UV âˆˆ B Ã—Ë¢ B | closure UV.1 âŠ† UV.2 }
  haveI : Encodable s := ((hBc.prod hBc).mono inter_subset_left).toEncodable
  letI : TopologicalSpace s := âŠ¥
  haveI : DiscreteTopology s := âŸ¨rflâŸ©
  rsuffices âŸ¨f, hfâŸ© : âˆƒ f : X â†’ s â†’áµ‡ â„, Inducing f
  Â· exact âŸ¨fun x => (f x).extend (Encodable.encode' s) 0,
      (BoundedContinuousFunction.isometry_extend (Encodable.encode' s)
        (0 : â„• â†’áµ‡ â„)).embedding.toInducing.comp hfâŸ©
  have hd : âˆ€ UV : s, Disjoint (closure UV.1.1) UV.1.2á¶œ :=
    fun UV => disjoint_compl_right.mono_right (compl_subset_compl.2 UV.2.2)
  obtain âŸ¨Îµ, Îµ01, hÎµâŸ© : âˆƒ Îµ : s â†’ â„, (âˆ€ UV, Îµ UV âˆˆ Ioc (0 : â„) 1) âˆ§ Tendsto Îµ cofinite (ğ“ 0) := by
    rcases posSumOfEncodable zero_lt_one s with âŸ¨Îµ, Îµ0, c, hÎµc, hc1âŸ©
    refine âŸ¨Îµ, fun UV => âŸ¨Îµ0 UV, ?_âŸ©, hÎµc.summable.tendsto_cofinite_zeroâŸ©
    exact (le_hasSum hÎµc UV fun _ _ => (Îµ0 _).le).trans hc1
  have : âˆ€ UV : s, âˆƒ f : C(X, â„),
      EqOn f 0 UV.1.1 âˆ§ EqOn f (fun _ => Îµ UV) UV.1.2á¶œ âˆ§ âˆ€ x, f x âˆˆ Icc 0 (Îµ UV) := by
    intro UV
    rcases exists_continuous_zero_one_of_isClosed isClosed_closure
        (hB.isOpen UV.2.1.2).isClosed_compl (hd UV) with
      âŸ¨f, hfâ‚€, hfâ‚, hf01âŸ©
    exact âŸ¨Îµ UV â€¢ f, fun x hx => by simp [hfâ‚€ (subset_closure hx)], fun x hx => by simp [hfâ‚ hx],
      fun x => âŸ¨mul_nonneg (Îµ01 _).1.le (hf01 _).1, mul_le_of_le_one_right (Îµ01 _).1.le (hf01 _).2âŸ©âŸ©
  choose f hf0 hfÎµ hf0Îµ using this
  have hf01 : âˆ€ UV x, f UV x âˆˆ Icc (0 : â„) 1 :=
    fun UV x => Icc_subset_Icc_right (Îµ01 _).2 (hf0Îµ _ _)
  set F : X â†’ s â†’áµ‡ â„ := fun x =>
    âŸ¨âŸ¨fun UV => f UV x, continuous_of_discreteTopologyâŸ©, 1,
      fun UVâ‚ UVâ‚‚ => Real.dist_le_of_mem_Icc_01 (hf01 _ _) (hf01 _ _)âŸ©
  have hF : âˆ€ x UV, F x UV = f UV x := fun _ _ => rfl
  refine âŸ¨F, inducing_iff_nhds.2 fun x => le_antisymm ?_ ?_âŸ©
  Â· refine (nhds_basis_closedBall.comap _).ge_iff.2 fun Î´ Î´0 => ?_
    have h_fin : { UV : s | Î´ â‰¤ Îµ UV }.Finite := by simpa only [â† not_lt] using hÎµ (gt_mem_nhds Î´0)
    have : âˆ€á¶  y in ğ“ x, âˆ€ UV, Î´ â‰¤ Îµ UV â†’ dist (F y UV) (F x UV) â‰¤ Î´ := by
      refine (eventually_all_finite h_fin).2 fun UV _ => ?_
      exact (f UV).continuous.tendsto x (closedBall_mem_nhds _ Î´0)
    refine this.mono fun y hy => (BoundedContinuousFunction.dist_le Î´0.le).2 fun UV => ?_
    rcases le_total Î´ (Îµ UV) with hle | hle
    exacts [hy _ hle, (Real.dist_le_of_mem_Icc (hf0Îµ _ _) (hf0Îµ _ _)).trans (by rwa [sub_zero])]
  Â· refine ((nhds_basis_ball.comap _).le_basis_iff hB.nhds_hasBasis).2 ?_
    rintro V âŸ¨hVB, hxVâŸ©
    rcases hB.exists_closure_subset (hB.mem_nhds hVB hxV) with âŸ¨U, hUB, hxU, hUVâŸ©
    set UV : â†¥s := âŸ¨(U, V), âŸ¨hUB, hVBâŸ©, hUVâŸ©
    refine âŸ¨Îµ UV, (Îµ01 UV).1, fun y (hy : dist (F y) (F x) < Îµ UV) => ?_âŸ©
    replace hy : dist (F y UV) (F x UV) < Îµ UV :=
      (BoundedContinuousFunction.dist_coe_le_dist _).trans_lt hy
    contrapose! hy
    rw [hF, hF, hfÎµ UV hy, hf0 UV hxU, Pi.zero_apply, dist_zero_right]
    exact le_abs_self _"
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.unifIntegrable_of',unifIntegrable_of',6be2bec13d4dd1fd901f9a619d053d7549cfe177,":= by
  have hpzero := (lt_of_lt_of_le zero_lt_one hp).ne.symm
  by_cases hÎ¼ : Î¼ Set.univ = 0
  Â· rw [Measure.measure_univ_eq_zero] at hÎ¼
    exact hÎ¼.symm â–¸ unifIntegrable_zero_meas
  intro Îµ hÎµ
  obtain âŸ¨C, hCpos, hCâŸ© := h (Îµ / 2) (half_pos hÎµ)
  refine' âŸ¨(Îµ / (2 * C)) ^ ENNReal.toReal p,
    Real.rpow_pos_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos))) _,
    fun i s hs hÎ¼s => _âŸ©
  by_cases hÎ¼s' : Î¼ s = 0
  Â· rw [(snorm_eq_zero_iff ((hf i).indicator hs).aestronglyMeasurable hpzero).2
        (indicator_meas_zero hÎ¼s')]
    set_option tactic.skipAssignedInstances false in norm_num
  calc
    snorm (Set.indicator s (f i)) p Î¼ â‰¤
        snorm (Set.indicator (s âˆ© { x | C â‰¤ â€–f i xâ€–â‚Š }) (f i)) p Î¼ +
          snorm (Set.indicator (s âˆ© { x | â€–f i xâ€–â‚Š < C }) (f i)) p Î¼ := by
      refine' le_trans (Eq.le _) (snorm_add_le
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter (stronglyMeasurable_const.measurableSet_le (hf i).nnnorm))))
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter ((hf i).nnnorm.measurableSet_lt stronglyMeasurable_const))))
        hp)
      congr
      change _ = fun x => (s âˆ© { x : Î± | C â‰¤ â€–f i xâ€–â‚Š }).indicator (f i) x +
        (s âˆ© { x : Î± | â€–f i xâ€–â‚Š < C }).indicator (f i) x
      rw [â† Set.indicator_union_of_disjoint]
      Â· rw [â† Set.inter_union_distrib_left, (by ext; simp [le_or_lt] :
            { x : Î± | C â‰¤ â€–f i xâ€–â‚Š } âˆª { x : Î± | â€–f i xâ€–â‚Š < C } = Set.univ),
          Set.inter_univ]
      Â· refine' (Disjoint.inf_right' _ _).inf_left' _
        rw [disjoint_iff_inf_le]
        rintro x âŸ¨hxâ‚, hxâ‚‚âŸ©
        rw [Set.mem_setOf_eq] at hxâ‚ hxâ‚‚
        exact False.elim (hxâ‚‚.ne (eq_of_le_of_not_lt hxâ‚ (not_lt.2 hxâ‚‚.le)).symm)
    _ â‰¤ snorm (Set.indicator { x | C â‰¤ â€–f i xâ€–â‚Š } (f i)) p Î¼ +
        (C : â„â‰¥0âˆ) * Î¼ s ^ (1 / ENNReal.toReal p) := by
      refine' add_le_add
        (snorm_mono fun x => norm_indicator_le_of_subset (Set.inter_subset_right _ _) _ _) _
      rw [â† Set.indicator_indicator]
      rw [snorm_indicator_eq_snorm_restrict hs]
      have : âˆ€áµ x âˆ‚Î¼.restrict s, â€–{ x : Î± | â€–f i xâ€–â‚Š < C }.indicator (f i) xâ€– â‰¤ C := by
        filter_upwards
        simp_rw [norm_indicator_eq_indicator_norm]
        exact Set.indicator_le' (fun x (hx : _ < _) => hx.le) fun _ _ => NNReal.coe_nonneg _
      refine le_trans (snorm_le_of_ae_bound this) ?_
      rw [mul_comm, Measure.restrict_apply' hs, Set.univ_inter, ENNReal.ofReal_coe_nnreal, one_div]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + C * ENNReal.ofReal (Îµ / (2 * C)) := by
      refine' add_le_add (hC i) (mul_le_mul_left' _ _)
      rwa [ENNReal.rpow_one_div_le_iff (ENNReal.toReal_pos hpzero hp'),
        ENNReal.ofReal_rpow_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos)))]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + ENNReal.ofReal (Îµ / 2) := by
      refine' add_le_add_left _ _
      rw [â† ENNReal.ofReal_coe_nnreal, â† ENNReal.ofReal_mul (NNReal.coe_nonneg _), â† div_div,
        mul_div_cancelâ‚€ _ (NNReal.coe_pos.2 hCpos).ne.symm]
    _ â‰¤ ENNReal.ofReal Îµ := by
      rw [â† ENNReal.ofReal_add (half_pos hÎµ).le (half_pos hÎµ).le, add_halves]","error:  function expected at
  inter_subset_right ?m.230357
term has type
  ?m.230356 âˆˆ ?m.230355","theorem unifIntegrable_of' (hp : 1 â‰¤ p) (hp' : p â‰  âˆ) {f : Î¹ â†’ Î± â†’ Î²}
    (hf : âˆ€ i, StronglyMeasurable (f i))
    (h : âˆ€ Îµ : â„, 0 < Îµ â†’ âˆƒ C : â„â‰¥0, 0 < C âˆ§
      âˆ€ i, snorm ({ x | C â‰¤ â€–f i xâ€–â‚Š }.indicator (f i)) p Î¼ â‰¤ ENNReal.ofReal Îµ) :
    UnifIntegrable f p Î¼ ",":= by
  have hpzero := (lt_of_lt_of_le zero_lt_one hp).ne.symm
  by_cases hÎ¼ : Î¼ Set.univ = 0
  Â· rw [Measure.measure_univ_eq_zero] at hÎ¼
    exact hÎ¼.symm â–¸ unifIntegrable_zero_meas
  intro Îµ hÎµ
  obtain âŸ¨C, hCpos, hCâŸ© := h (Îµ / 2) (half_pos hÎµ)
  refine âŸ¨(Îµ / (2 * C)) ^ ENNReal.toReal p,
    Real.rpow_pos_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos))) _,
    fun i s hs hÎ¼s => ?_âŸ©
  by_cases hÎ¼s' : Î¼ s = 0
  Â· rw [(snorm_eq_zero_iff ((hf i).indicator hs).aestronglyMeasurable hpzero).2
        (indicator_meas_zero hÎ¼s')]
    norm_num
  calc
    snorm (Set.indicator s (f i)) p Î¼ â‰¤
        snorm (Set.indicator (s âˆ© { x | C â‰¤ â€–f i xâ€–â‚Š }) (f i)) p Î¼ +
          snorm (Set.indicator (s âˆ© { x | â€–f i xâ€–â‚Š < C }) (f i)) p Î¼ := by
      refine le_trans (Eq.le ?_) (snorm_add_le
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter (stronglyMeasurable_const.measurableSet_le (hf i).nnnorm))))
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter ((hf i).nnnorm.measurableSet_lt stronglyMeasurable_const))))
        hp)
      congr
      change _ = fun x => (s âˆ© { x : Î± | C â‰¤ â€–f i xâ€–â‚Š }).indicator (f i) x +
        (s âˆ© { x : Î± | â€–f i xâ€–â‚Š < C }).indicator (f i) x
      rw [â† Set.indicator_union_of_disjoint]
      Â· rw [â† Set.inter_union_distrib_left, (by ext; simp [le_or_lt] :
            { x : Î± | C â‰¤ â€–f i xâ€–â‚Š } âˆª { x : Î± | â€–f i xâ€–â‚Š < C } = Set.univ),
          Set.inter_univ]
      Â· refine (Disjoint.inf_right' _ ?_).inf_left' _
        rw [disjoint_iff_inf_le]
        rintro x âŸ¨hxâ‚, hxâ‚‚âŸ©
        rw [Set.mem_setOf_eq] at hxâ‚ hxâ‚‚
        exact False.elim (hxâ‚‚.ne (eq_of_le_of_not_lt hxâ‚ (not_lt.2 hxâ‚‚.le)).symm)
    _ â‰¤ snorm (Set.indicator { x | C â‰¤ â€–f i xâ€–â‚Š } (f i)) p Î¼ +
        (C : â„â‰¥0âˆ) * Î¼ s ^ (1 / ENNReal.toReal p) := by
      refine add_le_add
        (snorm_mono fun x => norm_indicator_le_of_subset Set.inter_subset_right _ _) ?_
      rw [â† Set.indicator_indicator]
      rw [snorm_indicator_eq_snorm_restrict hs]
      have : âˆ€áµ x âˆ‚Î¼.restrict s, â€–{ x : Î± | â€–f i xâ€–â‚Š < C }.indicator (f i) xâ€– â‰¤ C := by
        filter_upwards
        simp_rw [norm_indicator_eq_indicator_norm]
        exact Set.indicator_le' (fun x (hx : _ < _) => hx.le) fun _ _ => NNReal.coe_nonneg _
      refine le_trans (snorm_le_of_ae_bound this) ?_
      rw [mul_comm, Measure.restrict_apply' hs, Set.univ_inter, ENNReal.ofReal_coe_nnreal, one_div]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + C * ENNReal.ofReal (Îµ / (2 * C)) := by
      refine add_le_add (hC i) (mul_le_mul_left' ?_ _)
      rwa [ENNReal.rpow_one_div_le_iff (ENNReal.toReal_pos hpzero hp'),
        ENNReal.ofReal_rpow_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos)))]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + ENNReal.ofReal (Îµ / 2) := by
      refine add_le_add_left ?_ _
      rw [â† ENNReal.ofReal_coe_nnreal, â† ENNReal.ofReal_mul (NNReal.coe_nonneg _), â† div_div,
        mul_div_cancelâ‚€ _ (NNReal.coe_pos.2 hCpos).ne.symm]
    _ â‰¤ ENNReal.ofReal Îµ := by
      rw [â† ENNReal.ofReal_add (half_pos hÎµ).le (half_pos hÎµ).le, add_halves]"
Mathlib/MeasureTheory/Constructions/Polish.lean,MeasureTheory.measurableSet_range_of_continuous_injective,measurableSet_range_of_continuous_injective,71880da883b383ac13b9beb76b1bd41a0f023582,":= by
  letI := upgradePolishSpace Î³
  obtain âŸ¨b, b_count, b_nonempty, hbâŸ© :
    âˆƒ b : Set (Set Î³), b.Countable âˆ§ âˆ… âˆ‰ b âˆ§ IsTopologicalBasis b := exists_countable_basis Î³
  haveI : Encodable b := b_count.toEncodable
  let A := { p : b Ã— b // Disjoint (p.1 : Set Î³) p.2 }
  have : âˆ€ p : A, âˆƒ q : Set Î²,
      f '' (p.1.1 : Set Î³) âŠ† q âˆ§ Disjoint (f '' (p.1.2 : Set Î³)) q âˆ§ MeasurableSet q := by
    intro p
    apply
      AnalyticSet.measurablySeparable ((hb.isOpen p.1.1.2).analyticSet_image f_cont)
        ((hb.isOpen p.1.2.2).analyticSet_image f_cont)
    exact Disjoint.image p.2 (f_inj.injOn univ) (subset_univ _) (subset_univ _)
  choose q hq1 hq2 q_meas using this
  let E : b â†’ Set Î² := fun s =>
    closure (f '' s) âˆ© â‹‚ (t : b) (ht : Disjoint s.1 t.1), q âŸ¨(s, t), htâŸ© \ q âŸ¨(t, s), ht.symmâŸ©
  obtain âŸ¨u, u_anti, u_pos, u_limâŸ© :
    âˆƒ u : â„• â†’ â„, StrictAnti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=
    exists_seq_strictAnti_tendsto (0 : â„)
  let F : â„• â†’ Set Î² := fun n => â‹ƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), E s
  suffices range f = â‹‚ n, F n by
    have E_meas : âˆ€ s : b, MeasurableSet (E s) := by
      intro b
      refine' isClosed_closure.measurableSet.inter _
      refine' MeasurableSet.iInter fun s => _
      exact MeasurableSet.iInter fun hs => (q_meas _).diff (q_meas _)
    have F_meas : âˆ€ n, MeasurableSet (F n) := by
      intro n
      refine' MeasurableSet.iUnion fun s => _
      exact MeasurableSet.iUnion fun _ => E_meas _
    rw [this]
    exact MeasurableSet.iInter fun n => F_meas n
  apply Subset.antisymm
  Â· rintro x âŸ¨y, rflâŸ©
    refine mem_iInter.2 fun n => ?_
    obtain âŸ¨s, sb, ys, hsâŸ© : âˆƒ (s : Set Î³), s âˆˆ b âˆ§ y âˆˆ s âˆ§ s âŠ† ball y (u n / 2) := by
      apply hb.mem_nhds_iff.1
      exact ball_mem_nhds _ (half_pos (u_pos n))
    have diam_s : diam s â‰¤ u n := by
      apply (diam_mono hs isBounded_ball).trans
      convert diam_ball (x := y) (half_pos (u_pos n)).le
      ring
    refine' mem_iUnion.2 âŸ¨âŸ¨s, sbâŸ©, _âŸ©
    refine' mem_iUnion.2 âŸ¨âŸ¨isBounded_ball.subset hs, diam_sâŸ©, _âŸ©
    apply mem_inter (subset_closure (mem_image_of_mem _ ys))
    refine' mem_iInter.2 fun t => mem_iInter.2 fun ht => âŸ¨_, _âŸ©
    Â· apply hq1
      exact mem_image_of_mem _ ys
    Â· apply disjoint_left.1 (hq2 âŸ¨(t, âŸ¨s, sbâŸ©), ht.symmâŸ©)
      exact mem_image_of_mem _ ys
  Â· intro x hx
    have C1 : âˆ€ n, âˆƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), x âˆˆ E s := fun n => by
      simpa only [mem_iUnion] using mem_iInter.1 hx n
    choose s hs hxs using C1
    have C2 : âˆ€ n, (s n).1.Nonempty := by
      intro n
      rw [nonempty_iff_ne_empty]
      intro hn
      have := (s n).2
      rw [hn] at this
      exact b_nonempty this
    choose y hy using C2
    have I : âˆ€ m n, ((s m).1 âˆ© (s n).1).Nonempty := by
      intro m n
      rw [â† not_disjoint_iff_nonempty_inter]
      by_contra' h
      have A : x âˆˆ q âŸ¨(s m, s n), hâŸ© \ q âŸ¨(s n, s m), h.symmâŸ© :=
        haveI := mem_iInter.1 (hxs m).2 (s n)
        (mem_iInter.1 this h : _)
      have B : x âˆˆ q âŸ¨(s n, s m), h.symmâŸ© \ q âŸ¨(s m, s n), hâŸ© :=
        haveI := mem_iInter.1 (hxs n).2 (s m)
        (mem_iInter.1 this h.symm : _)
      exact A.2 B.1
    have cauchy_y : CauchySeq y := by
      have : Tendsto (fun n => 2 * u n) atTop (ğ“ 0) := by
        simpa only [mul_zero] using u_lim.const_mul 2
      refine cauchySeq_of_le_tendsto_0' (fun n => 2 * u n) (fun m n hmn => ?_) this
      rcases I m n with âŸ¨z, zsm, zsnâŸ©
      calc
        dist (y m) (y n) â‰¤ dist (y m) z + dist z (y n) := dist_triangle _ _ _
        _ â‰¤ u m + u n :=
          (add_le_add ((dist_le_diam_of_mem (hs m).1 (hy m) zsm).trans (hs m).2)
            ((dist_le_diam_of_mem (hs n).1 zsn (hy n)).trans (hs n).2))
        _ â‰¤ 2 * u m := by linarith [u_anti.antitone hmn]
    haveI : Nonempty Î³ := âŸ¨y 0âŸ©
    let z := limUnder atTop y
    have y_lim : Tendsto y atTop (ğ“ z) := cauchy_y.tendsto_limUnder
    suffices f z = x by
      rw [â† this]
      exact mem_range_self _
    by_contra' hne
    obtain âŸ¨v, w, v_open, w_open, fzv, xw, hvwâŸ© := t2_separation hne
    obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´ > (0 : â„), ball z Î´ âŠ† f â»Â¹' v := by
      apply Metric.mem_nhds_iff.1
      exact f_cont.continuousAt.preimage_mem_nhds (v_open.mem_nhds fzv)
    obtain âŸ¨n, hnâŸ© : âˆƒ n, u n + dist (y n) z < Î´ :=
      haveI : Tendsto (fun n => u n + dist (y n) z) atTop (ğ“ 0) := by
        simpa only [add_zero] using u_lim.add (tendsto_iff_dist_tendsto_zero.1 y_lim)
      ((tendsto_order.1 this).2 _ Î´pos).exists
    have fsnv : f '' s n âŠ† v := by
      rw [image_subset_iff]
      apply Subset.trans _ hÎ´
      intro a ha
      calc
        dist a z â‰¤ dist a (y n) + dist (y n) z := dist_triangle _ _ _
        _ â‰¤ u n + dist (y n) z :=
          (add_le_add_right ((dist_le_diam_of_mem (hs n).1 ha (hy n)).trans (hs n).2) _)
        _ < Î´ := hn
    have : x âˆˆ closure v := closure_mono fsnv (hxs n).1
    exact disjoint_left.1 (hvw.closure_left w_open) this xw","error:  unknown tactic
error:  unsolved goals
Î± : Type u_1
Î¹ : Type u_2
Î³ : Type u_3
Î² : Type u_4
instâœâµ : TopologicalSpace Î³
instâœâ´ : PolishSpace Î³
instâœÂ³ : TopologicalSpace Î²
instâœÂ² : T2Space Î²
instâœÂ¹ : MeasurableSpace Î²
instâœ : OpensMeasurableSpace Î²
f : Î³ â†’ Î²
f_cont : Continuous f
f_inj : Injective f
thisâœ : UpgradedPolishSpace Î³ := upgradePolishSpace Î³
b : Set (Set Î³)
b_count : b.Countable
b_nonempty : âˆ… âˆ‰ b
hb : IsTopologicalBasis b
this : Encodable â†‘b
A : Type u_3 := { p // Disjoint â†‘p.1 â†‘p.2 }
q : A â†’ Set Î²
hq1 : âˆ€ (p : A), f '' â†‘(â†‘p).1 âŠ† q p
hq2 : âˆ€ (p : A), Disjoint (f '' â†‘(â†‘p).2) (q p)
q_meas : âˆ€ (p : A), MeasurableSet (q p)
E : â†‘b â†’ Set Î² := fun s â†¦ closure (f '' â†‘s) âˆ© â‹‚ t, â‹‚ (ht : Disjoint â†‘s â†‘t), q âŸ¨(s, t), htâŸ© \ q âŸ¨(t, s), â‹¯âŸ©
u : â„• â†’ â„
u_anti : StrictAnti u
u_pos : âˆ€ (n : â„•), 0 < u n
u_lim : Tendsto u atTop (ğ“ 0)
F : â„• â†’ Set Î² := fun n â†¦ â‹ƒ s, â‹ƒ (_ : Bornology.IsBounded â†‘s âˆ§ diam â†‘s â‰¤ u n), E s
x : Î²
hx : x âˆˆ â‹‚ n, F n
s : â„• â†’ â†‘b
hs : âˆ€ (n : â„•), Bornology.IsBounded â†‘(s n) âˆ§ diam â†‘(s n) â‰¤ u n
hxs : âˆ€ (n : â„•), x âˆˆ E (s n)
y : â„• â†’ Î³
hy : âˆ€ (n : â„•), y n âˆˆ â†‘(s n)
m n : â„•
âŠ¢ Â¬Disjoint â†‘(s m) â†‘(s n)
error:  unsolved goals
case intro.intro.intro.intro.intro.intro.hâ‚‚
Î± : Type u_1
Î¹ : Type u_2
Î³ : Type u_3
Î² : Type u_4
instâœâµ : TopologicalSpace Î³
instâœâ´ : PolishSpace Î³
instâœÂ³ : TopologicalSpace Î²
instâœÂ² : T2Space Î²
instâœÂ¹ : MeasurableSpace Î²
instâœ : OpensMeasurableSpace Î²
f : Î³ â†’ Î²
f_cont : Continuous f
f_inj : Injective f
thisâœ : UpgradedPolishSpace Î³ := upgradePolishSpace Î³
b : Set (Set Î³)
b_count : b.Countable
b_nonempty : âˆ… âˆ‰ b
hb : IsTopologicalBasis b
this : Encodable â†‘b
A : Type u_3 := { p // Disjoint â†‘p.1 â†‘p.2 }
q : A â†’ Set Î²
hq1 : âˆ€ (p : A), f '' â†‘(â†‘p).1 âŠ† q p
hq2 : âˆ€ (p : A), Disjoint (f '' â†‘(â†‘p).2) (q p)
q_meas : âˆ€ (p : A), MeasurableSet (q p)
E : â†‘b â†’ Set Î² := fun s â†¦ closure (f '' â†‘s) âˆ© â‹‚ t, â‹‚ (ht : Disjoint â†‘s â†‘t), q âŸ¨(s, t), htâŸ© \ q âŸ¨(t, s), â‹¯âŸ©
u : â„• â†’ â„
u_anti : StrictAnti u
u_pos : âˆ€ (n : â„•), 0 < u n
u_lim : Tendsto u atTop (ğ“ 0)
F : â„• â†’ Set Î² := fun n â†¦ â‹ƒ s, â‹ƒ (_ : Bornology.IsBounded â†‘s âˆ§ diam â†‘s â‰¤ u n), E s
x : Î²
hx : x âˆˆ â‹‚ n, F n
s : â„• â†’ â†‘b
hs : âˆ€ (n : â„•), Bornology.IsBounded â†‘(s n) âˆ§ diam â†‘(s n) â‰¤ u n
hxs : âˆ€ (n : â„•), x âˆˆ E (s n)
y : â„• â†’ Î³
hy : âˆ€ (n : â„•), y n âˆˆ â†‘(s n)
I : âˆ€ (m n : â„•), (â†‘(s m) âˆ© â†‘(s n)).Nonempty
âŠ¢ x âˆˆ range f","theorem measurableSet_range_of_continuous_injective {Î² : Type*} [TopologicalSpace Î³]
    [PolishSpace Î³] [TopologicalSpace Î²] [T2Space Î²] [MeasurableSpace Î²] [OpensMeasurableSpace Î²]
    {f : Î³ â†’ Î²} (f_cont : Continuous f) (f_inj : Injective f) :
    MeasurableSet (range f) ",":= by
  letI := upgradePolishSpace Î³
  obtain âŸ¨b, b_count, b_nonempty, hbâŸ© :
    âˆƒ b : Set (Set Î³), b.Countable âˆ§ âˆ… âˆ‰ b âˆ§ IsTopologicalBasis b := exists_countable_basis Î³
  haveI : Encodable b := b_count.toEncodable
  let A := { p : b Ã— b // Disjoint (p.1 : Set Î³) p.2 }
  have : âˆ€ p : A, âˆƒ q : Set Î²,
      f '' (p.1.1 : Set Î³) âŠ† q âˆ§ Disjoint (f '' (p.1.2 : Set Î³)) q âˆ§ MeasurableSet q := by
    intro p
    apply
      AnalyticSet.measurablySeparable ((hb.isOpen p.1.1.2).analyticSet_image f_cont)
        ((hb.isOpen p.1.2.2).analyticSet_image f_cont)
    exact Disjoint.image p.2 f_inj.injOn (subset_univ _) (subset_univ _)
  choose q hq1 hq2 q_meas using this
  let E : b â†’ Set Î² := fun s =>
    closure (f '' s) âˆ© â‹‚ (t : b) (ht : Disjoint s.1 t.1), q âŸ¨(s, t), htâŸ© \ q âŸ¨(t, s), ht.symmâŸ©
  obtain âŸ¨u, u_anti, u_pos, u_limâŸ© :
      âˆƒ u : â„• â†’ â„, StrictAnti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=
    exists_seq_strictAnti_tendsto (0 : â„)
  let F : â„• â†’ Set Î² := fun n => â‹ƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), E s
  suffices range f = â‹‚ n, F n by
    have E_meas : âˆ€ s : b, MeasurableSet (E s) := by
      intro b
      refine isClosed_closure.measurableSet.inter ?_
      refine MeasurableSet.iInter fun s => ?_
      exact MeasurableSet.iInter fun hs => (q_meas _).diff (q_meas _)
    have F_meas : âˆ€ n, MeasurableSet (F n) := by
      intro n
      refine MeasurableSet.iUnion fun s => ?_
      exact MeasurableSet.iUnion fun _ => E_meas _
    rw [this]
    exact MeasurableSet.iInter fun n => F_meas n
  apply Subset.antisymm
  Â· rintro x âŸ¨y, rflâŸ©
    refine mem_iInter.2 fun n => ?_
    obtain âŸ¨s, sb, ys, hsâŸ© : âˆƒ (s : Set Î³), s âˆˆ b âˆ§ y âˆˆ s âˆ§ s âŠ† ball y (u n / 2) := by
      apply hb.mem_nhds_iff.1
      exact ball_mem_nhds _ (half_pos (u_pos n))
    have diam_s : diam s â‰¤ u n := by
      apply (diam_mono hs isBounded_ball).trans
      convert diam_ball (x := y) (half_pos (u_pos n)).le
      ring
    refine mem_iUnion.2 âŸ¨âŸ¨s, sbâŸ©, ?_âŸ©
    refine mem_iUnion.2 âŸ¨âŸ¨isBounded_ball.subset hs, diam_sâŸ©, ?_âŸ©
    apply mem_inter (subset_closure (mem_image_of_mem _ ys))
    refine mem_iInter.2 fun t => mem_iInter.2 fun ht => âŸ¨?_, ?_âŸ©
    Â· apply hq1
      exact mem_image_of_mem _ ys
    Â· apply disjoint_left.1 (hq2 âŸ¨(t, âŸ¨s, sbâŸ©), ht.symmâŸ©)
      exact mem_image_of_mem _ ys
  Â· intro x hx
    have C1 : âˆ€ n, âˆƒ (s : b) (_ : IsBounded s.1 âˆ§ diam s.1 â‰¤ u n), x âˆˆ E s := fun n => by
      simpa only [F, mem_iUnion] using mem_iInter.1 hx n
    choose s hs hxs using C1
    have C2 : âˆ€ n, (s n).1.Nonempty := by
      intro n
      rw [nonempty_iff_ne_empty]
      intro hn
      have := (s n).2
      rw [hn] at this
      exact b_nonempty this
    choose y hy using C2
    have I : âˆ€ m n, ((s m).1 âˆ© (s n).1).Nonempty := by
      intro m n
      rw [â† not_disjoint_iff_nonempty_inter]
      by_contra! h
      have A : x âˆˆ q âŸ¨(s m, s n), hâŸ© \ q âŸ¨(s n, s m), h.symmâŸ© :=
        haveI := mem_iInter.1 (hxs m).2 (s n)
        (mem_iInter.1 this h : _)
      have B : x âˆˆ q âŸ¨(s n, s m), h.symmâŸ© \ q âŸ¨(s m, s n), hâŸ© :=
        haveI := mem_iInter.1 (hxs n).2 (s m)
        (mem_iInter.1 this h.symm : _)
      exact A.2 B.1
    have cauchy_y : CauchySeq y := by
      have : Tendsto (fun n => 2 * u n) atTop (ğ“ 0) := by
        simpa only [mul_zero] using u_lim.const_mul 2
      refine cauchySeq_of_le_tendsto_0' (fun n => 2 * u n) (fun m n hmn => ?_) this
      rcases I m n with âŸ¨z, zsm, zsnâŸ©
      calc
        dist (y m) (y n) â‰¤ dist (y m) z + dist z (y n) := dist_triangle _ _ _
        _ â‰¤ u m + u n :=
          (add_le_add ((dist_le_diam_of_mem (hs m).1 (hy m) zsm).trans (hs m).2)
            ((dist_le_diam_of_mem (hs n).1 zsn (hy n)).trans (hs n).2))
        _ â‰¤ 2 * u m := by linarith [u_anti.antitone hmn]
    haveI : Nonempty Î³ := âŸ¨y 0âŸ©
    let z := limUnder atTop y
    have y_lim : Tendsto y atTop (ğ“ z) := cauchy_y.tendsto_limUnder
    suffices f z = x by
      rw [â† this]
      exact mem_range_self _
    by_contra! hne
    obtain âŸ¨v, w, v_open, w_open, fzv, xw, hvwâŸ© := t2_separation hne
    obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´ > (0 : â„), ball z Î´ âŠ† f â»Â¹' v := by
      apply Metric.mem_nhds_iff.1
      exact f_cont.continuousAt.preimage_mem_nhds (v_open.mem_nhds fzv)
    obtain âŸ¨n, hnâŸ© : âˆƒ n, u n + dist (y n) z < Î´ :=
      haveI : Tendsto (fun n => u n + dist (y n) z) atTop (ğ“ 0) := by
        simpa only [add_zero] using u_lim.add (tendsto_iff_dist_tendsto_zero.1 y_lim)
      ((tendsto_order.1 this).2 _ Î´pos).exists
    have fsnv : f '' s n âŠ† v := by
      rw [image_subset_iff]
      apply Subset.trans _ hÎ´
      intro a ha
      calc
        dist a z â‰¤ dist a (y n) + dist (y n) z := dist_triangle _ _ _
        _ â‰¤ u n + dist (y n) z :=
          (add_le_add_right ((dist_le_diam_of_mem (hs n).1 ha (hy n)).trans (hs n).2) _)
        _ < Î´ := hn
    have : x âˆˆ closure v := closure_mono fsnv (hxs n).1
    exact disjoint_left.1 (hvw.closure_left w_open) this xw"
Mathlib/NumberTheory/ClassNumber/Finite.lean,ClassGroup.exists_min,exists_min,9bc35020058f4a5a844eb7662d9de673056d4dbe,":= by
  classical
  obtain âŸ¨_, âŸ¨b, b_mem, b_ne_zero, rflâŸ©, minâŸ© := @Int.exists_least_of_bdd
      (fun a => âˆƒ b âˆˆ (I : Ideal S), b â‰  (0 : S) âˆ§ abv (Algebra.norm R b) = a) _
    (by
      use 0
      rintro _ âŸ¨b, _, _, rflâŸ©
      apply abv.nonneg)
    (by
      obtain âŸ¨b, b_mem, b_ne_zeroâŸ© := (I : Ideal S).ne_bot_iff.mp (nonZeroDivisors.coe_ne_zero I)
      exact âŸ¨_, âŸ¨b, b_mem, b_ne_zero, rflâŸ©âŸ©)
  Â· refine' âŸ¨b, b_mem, b_ne_zero, _âŸ©
    intro c hc lt
    contrapose! lt with c_ne_zero
    exact min _ âŸ¨c, hc, c_ne_zero, rflâŸ©","error:  function expected at
  Int.exists_least_of_bdd ?m.105572 ?m.105573
term has type
  âˆƒ lb,
    (fun a â†¦ âˆƒ b âˆˆ â†‘I, b â‰  0 âˆ§ abv ((Algebra.norm R) b) = a) lb âˆ§
      âˆ€ (z : â„¤), (fun a â†¦ âˆƒ b âˆˆ â†‘I, b â‰  0 âˆ§ abv ((Algebra.norm R) b) = a) z â†’ lb â‰¤ z
error:  tactic 'introN' failed, insufficient number of binders
case h
R : Type u_1
S : Type u_2
K : Type u_3
L : Type u_4
instâœÂ¹â´ : EuclideanDomain R
instâœÂ¹Â³ : CommRing S
instâœÂ¹Â² : IsDomain S
instâœÂ¹Â¹ : Field K
instâœÂ¹â° : Field L
instâœâ¹ : Algebra R K
instâœâ¸ : IsFractionRing R K
instâœâ· : Algebra K L
instâœâ¶ : FiniteDimensional K L
instâœâµ : IsSeparable K L
algRL : Algebra R L
instâœâ´ : IsScalarTower R K L
instâœÂ³ : Algebra R S
instâœÂ² : Algebra S L
ist : IsScalarTower R S L
iic : IsIntegralClosure S R L
abv : AbsoluteValue R â„¤
Î¹ : Type u_5
instâœÂ¹ : DecidableEq Î¹
instâœ : Fintype Î¹
bS : Basis Î¹ R S
I : â†¥(Ideal S)â°
âŠ¢ (fun a â†¦ âˆƒ b âˆˆ â†‘I, b â‰  0 âˆ§ abv ((Algebra.norm R) b) = a) 0
error:  rcases tactic failed: xâœ : ?m.105611 is not an inductive datatype","theorem exists_min (I : (Ideal S)â°) :
    âˆƒ b âˆˆ (I : Ideal S),
      b â‰  0 âˆ§ âˆ€ c âˆˆ (I : Ideal S), abv (Algebra.norm R c) < abv (Algebra.norm R b) â†’ c =
      (0 : S) ",":= by
  obtain âŸ¨_, âŸ¨b, b_mem, b_ne_zero, rflâŸ©, minâŸ© := @Int.exists_least_of_bdd
      (fun a => âˆƒ b âˆˆ (I : Ideal S), b â‰  (0 : S) âˆ§ abv (Algebra.norm R b) = a)
    (by
      use 0
      rintro _ âŸ¨b, _, _, rflâŸ©
      apply abv.nonneg)
    (by
      obtain âŸ¨b, b_mem, b_ne_zeroâŸ© := (I : Ideal S).ne_bot_iff.mp (nonZeroDivisors.coe_ne_zero I)
      exact âŸ¨_, âŸ¨b, b_mem, b_ne_zero, rflâŸ©âŸ©)
  refine âŸ¨b, b_mem, b_ne_zero, ?_âŸ©
  intro c hc lt
  contrapose! lt with c_ne_zero
  exact min _ âŸ¨c, hc, c_ne_zero, rflâŸ©"
Mathlib/Analysis/Calculus/LHopital.lean,HasDerivAt.lhopital_zero_nhds_right,lhopital_zero_nhds_right,fd3379ddac23e991aaf3056785fd48b9fc8dbdb6,":= by
  rw [eventually_iff_exists_mem] at *
  rcases hff' with âŸ¨sâ‚, hsâ‚, hff'âŸ©
  rcases hgg' with âŸ¨sâ‚‚, hsâ‚‚, hgg'âŸ©
  rcases hg' with âŸ¨sâ‚ƒ, hsâ‚ƒ, hg'âŸ©
  let s := sâ‚ âˆ© sâ‚‚ âˆ© sâ‚ƒ
  have hs : s âˆˆ ğ“[>] a := inter_mem (inter_mem hsâ‚ hsâ‚‚) hsâ‚ƒ
  rw [mem_nhdsWithin_Ioi_iff_exists_Ioo_subset] at hs
  rcases hs with âŸ¨u, hau, huâŸ©
  refine lhopital_zero_right_on_Ioo hau ?_ ??_ _ hfa hga hdiv <;> intro x hx <;> apply_assumption <;>
    first | exact (hu hx).1.1 | exact (hu hx).1.2 | exact (hu hx).2",error:  unexpected token '?'; expected '_' or identifier,"theorem lhopital_zero_nhds_right (hff' : âˆ€á¶  x in ğ“[>] a, HasDerivAt f (f' x) x)
    (hgg' : âˆ€á¶  x in ğ“[>] a, HasDerivAt g (g' x) x) (hg' : âˆ€á¶  x in ğ“[>] a, g' x â‰  0)
    (hfa : Tendsto f (ğ“[>] a) (ğ“ 0)) (hga : Tendsto g (ğ“[>] a) (ğ“ 0))
    (hdiv : Tendsto (fun x => f' x / g' x) (ğ“[>] a) l) :
    Tendsto (fun x => f x / g x) (ğ“[>] a) l ",":= by
  rw [eventually_iff_exists_mem] at *
  rcases hff' with âŸ¨sâ‚, hsâ‚, hff'âŸ©
  rcases hgg' with âŸ¨sâ‚‚, hsâ‚‚, hgg'âŸ©
  rcases hg' with âŸ¨sâ‚ƒ, hsâ‚ƒ, hg'âŸ©
  let s := sâ‚ âˆ© sâ‚‚ âˆ© sâ‚ƒ
  have hs : s âˆˆ ğ“[>] a := inter_mem (inter_mem hsâ‚ hsâ‚‚) hsâ‚ƒ
  rw [mem_nhdsWithin_Ioi_iff_exists_Ioo_subset] at hs
  rcases hs with âŸ¨u, hau, huâŸ©
  refine lhopital_zero_right_on_Ioo hau ?_ ?_ ?_ hfa hga hdiv <;>
    intro x hx <;> apply_assumption <;>
    first | exact (hu hx).1.1 | exact (hu hx).1.2 | exact (hu hx).2"
Mathlib/NumberTheory/ClassNumber/AdmissibleCardPowDegree.lean,Polynomial.exists_partition_polynomial_aux,exists_partition_polynomial_aux,693fd79515903b10b1d31f10dccfc49e633cf7ee,":= by
  have hbÎµ : 0 < cardPowDegree b â€¢ Îµ := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hÎµ
  induction' n with n ih
  Â· refine' âŸ¨finZeroElim, finZeroElimâŸ©
  have anti_archim' : âˆ€ {i j k} {Îµ : â„},
    (cardPowDegree (A i % b - A j % b) : â„) < Îµ â†’
      (cardPowDegree (A j % b - A k % b) : â„) < Îµ â†’
        (cardPowDegree (A i % b - A k % b) : â„) < Îµ := by
    intro i j k Îµ
    simp_rw [â† Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain âŸ¨t', ht'âŸ© := ih (Fin.tail A)
  rsuffices âŸ¨j, hjâŸ© :
    âˆƒ j, âˆ€ i, t' i = j â†” (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· refine' âŸ¨Fin.cons j t', fun iâ‚€ iâ‚ => _âŸ©
    refine' Fin.cases _ (fun iâ‚€ => _) iâ‚€ <;> refine' Fin.cases _ (fun iâ‚ => _) iâ‚
    Â· simpa using hbÎµ
    Â· rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj iâ‚
    Â· rw [Fin.cons_succ, Fin.cons_zero]
      exact hj iâ‚€
    Â· rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' iâ‚€ iâ‚
  obtain âŸ¨j, hjâŸ© : âˆƒ j, âˆ€ i : Fin n,
      t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ := by
    by_contra hg
    push_neg at hg
    obtain âŸ¨jâ‚€, jâ‚, j_ne, approxâŸ© := exists_approx_polynomial hb hÎµ
      (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (hg j))))
    revert j_ne approx
    refine' Fin.cases _ (fun jâ‚€ => _) jâ‚€ <;>
      refine' Fin.cases (fun j_ne approx => _) (fun jâ‚ j_ne approx => _) jâ‚
    Â· exact absurd rfl j_ne
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg jâ‚)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le] at approx
      have := (Classical.choose_spec (hg jâ‚€)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne.def, Fin.succ_inj] at j_ne
      have : jâ‚€ = jâ‚ := (Classical.choose_spec (hg jâ‚€)).1.symm.trans
        (((ht' (Classical.choose (hg jâ‚€)) (Classical.choose (hg jâ‚))).mpr approx).trans
          (Classical.choose_spec (hg jâ‚)).1)
      contradiction
  by_cases exists_nonempty_j : âˆƒ j, (âˆƒ i, t' i = j) âˆ§
      âˆ€ i, t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· obtain âŸ¨j, âŸ¨i, hiâŸ©, hjâŸ© := exists_nonempty_j
    refine' âŸ¨j, fun i' => âŸ¨hj i', fun hi' => _root_.trans ((ht' _ _).mpr _) hiâŸ©âŸ©
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  refine' âŸ¨j, fun i => âŸ¨hj i, fun hi => _âŸ©âŸ©
  have := exists_nonempty_j âŸ¨t' i, âŸ¨i, rflâŸ©, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')âŸ©
  contradiction","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.81178 â†’ ?m.81178 â†’ Prop
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.81180
case intro.intro.intro.refine'_2.refine'_2
Fq : Type u_1
instâœÂ¹ : Fintype Fq
instâœ : Field Fq
Îµ : â„
hÎµ : 0 < Îµ
b : Fq[X]
hb : b â‰  0
hbÎµ : 0 < cardPowDegree b â€¢ Îµ
n : â„•
ih :
  âˆ€ (A : Fin n â†’ Fq[X]),
    âˆƒ t, âˆ€ (iâ‚€ iâ‚ : Fin n), t iâ‚€ = t iâ‚ â†” â†‘(cardPowDegree (A iâ‚ % b - A iâ‚€ % b)) < cardPowDegree b â€¢ Îµ
A : Fin (n + 1) â†’ Fq[X]
anti_archim' :
  âˆ€ {i j k : Fin (n + 1)} {Îµ : â„},
    â†‘(cardPowDegree (A i % b - A j % b)) < Îµ â†’
      â†‘(cardPowDegree (A j % b - A k % b)) < Îµ â†’ â†‘(cardPowDegree (A i % b - A k % b)) < Îµ
t' : Fin n â†’ Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š)
ht' : âˆ€ (iâ‚€ iâ‚ : Fin n), t' iâ‚€ = t' iâ‚ â†” â†‘(cardPowDegree (Fin.tail A iâ‚ % b - Fin.tail A iâ‚€ % b)) < cardPowDegree b â€¢ Îµ
hg :
  âˆ€ (j : Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š)),
    âˆƒ i, t' i = j âˆ§ cardPowDegree b â€¢ Îµ â‰¤ â†‘(cardPowDegree (A 0 % b - A i.succ % b))
jâ‚€âœ jâ‚âœ : Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š).succ
jâ‚€ jâ‚ : Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log â†‘(Fintype.card Fq)âŒ‰â‚Š)
j_ne : jâ‚€.succ â‰  jâ‚.succ
approx : â†‘(cardPowDegree (A (Classical.choose â‹¯).succ % b - A (Classical.choose â‹¯).succ % b)) < cardPowDegree b â€¢ Îµ
âŠ¢ False","theorem exists_partition_polynomial_aux (n : â„•) {Îµ : â„} (hÎµ : 0 < Îµ) {b : Fq[X]} (hb : b â‰  0)
    (A : Fin n â†’ Fq[X]) : âˆƒ t : Fin n â†’ Fin (Fintype.card Fq ^ âŒˆ-log Îµ / log (Fintype.card Fq)âŒ‰â‚Š),
      âˆ€ iâ‚€ iâ‚ : Fin n, t iâ‚€ = t iâ‚ â†”
        (cardPowDegree (A iâ‚ % b - A iâ‚€ % b) : â„) < cardPowDegree b â€¢ Îµ ",":= by
  have hbÎµ : 0 < cardPowDegree b â€¢ Îµ := by
    rw [Algebra.smul_def, eq_intCast]
    exact mul_pos (Int.cast_pos.mpr (AbsoluteValue.pos _ hb)) hÎµ
  induction' n with n ih
  Â· refine âŸ¨finZeroElim, finZeroElimâŸ©
  have anti_archim' : âˆ€ {i j k} {Îµ : â„},
    (cardPowDegree (A i % b - A j % b) : â„) < Îµ â†’
      (cardPowDegree (A j % b - A k % b) : â„) < Îµ â†’
        (cardPowDegree (A i % b - A k % b) : â„) < Îµ := by
    intro i j k Îµ
    simp_rw [â† Int.lt_ceil]
    exact cardPowDegree_anti_archimedean
  obtain âŸ¨t', ht'âŸ© := ih (Fin.tail A)
  rsuffices âŸ¨j, hjâŸ© :
    âˆƒ j, âˆ€ i, t' i = j â†” (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· refine âŸ¨Fin.cons j t', fun iâ‚€ iâ‚ => ?_âŸ©
    refine Fin.cases ?_ (fun iâ‚€ => ?_) iâ‚€ <;> refine Fin.cases ?_ (fun iâ‚ => ?_) iâ‚
    Â· simpa using hbÎµ
    Â· rw [Fin.cons_succ, Fin.cons_zero, eq_comm, AbsoluteValue.map_sub]
      exact hj iâ‚
    Â· rw [Fin.cons_succ, Fin.cons_zero]
      exact hj iâ‚€
    Â· rw [Fin.cons_succ, Fin.cons_succ]
      exact ht' iâ‚€ iâ‚
  obtain âŸ¨j, hjâŸ© : âˆƒ j, âˆ€ i : Fin n,
      t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ := by
    by_contra! hg
    obtain âŸ¨jâ‚€, jâ‚, j_ne, approxâŸ© := exists_approx_polynomial hb hÎµ
      (Fin.cons (A 0) fun j => A (Fin.succ (Classical.choose (hg j))))
    revert j_ne approx
    refine Fin.cases ?_ (fun jâ‚€ => ?_) jâ‚€ <;>
      refine Fin.cases (fun j_ne approx => ?_) (fun jâ‚ j_ne approx => ?_) jâ‚
    Â· exact absurd rfl j_ne
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le, AbsoluteValue.map_sub] at approx
      have := (Classical.choose_spec (hg jâ‚)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_zero, â† not_le] at approx
      have := (Classical.choose_spec (hg jâ‚€)).2
      contradiction
    Â· rw [Fin.cons_succ, Fin.cons_succ] at approx
      rw [Ne, Fin.succ_inj] at j_ne
      have : jâ‚€ = jâ‚ := (Classical.choose_spec (hg jâ‚€)).1.symm.trans
        (((ht' (Classical.choose (hg jâ‚€)) (Classical.choose (hg jâ‚))).mpr approx).trans
          (Classical.choose_spec (hg jâ‚)).1)
      contradiction
  by_cases exists_nonempty_j : âˆƒ j, (âˆƒ i, t' i = j) âˆ§
      âˆ€ i, t' i = j â†’ (cardPowDegree (A 0 % b - A i.succ % b) : â„) < cardPowDegree b â€¢ Îµ
  Â· obtain âŸ¨j, âŸ¨i, hiâŸ©, hjâŸ© := exists_nonempty_j
    refine âŸ¨j, fun i' => âŸ¨hj i', fun hi' => _root_.trans ((ht' _ _).mpr ?_) hiâŸ©âŸ©
    apply anti_archim' _ hi'
    rw [AbsoluteValue.map_sub]
    exact hj _ hi
  refine âŸ¨j, fun i => âŸ¨hj i, fun hi => ?_âŸ©âŸ©
  have := exists_nonempty_j âŸ¨t' i, âŸ¨i, rflâŸ©, fun i' hi' => anti_archim' hi ((ht' _ _).mp hi')âŸ©
  contradiction"
Mathlib/Topology/Irreducible.lean,isIrreducible_iff_sInter,isIrreducible_iff_sInter,c342c339a777827331257acd880fea6d441a6aa6,":= by
  refine âŸ¨fun h U hu hU => ?_, fun h => âŸ¨?_, ?_âŸ©âŸ©
  Â· induction U with
    | empty => simpa using h.nonempty
    | @insert u U _ IH =>
      rw [Finset.coe_insert, sInter_insert]
      rw [Finset.forall_mem_insert] at hu hU
      exact h.2 _ _ hu.1 (U.finite_toSet.isOpen_sInter hu.2) hU.1 (IH hu.2 hU.2)
  Â· simpa using h âˆ…
  Â· intro u v hu hv hu' hv'
    simpa [*] using h {u, v}",error:  invalid alternative name 'empty',"theorem isIrreducible_iff_sInter :
    IsIrreducible s â†”
      âˆ€ (U : Finset (Set X)), (âˆ€ u âˆˆ U, IsOpen u) â†’ (âˆ€ u âˆˆ U, (s âˆ© u).Nonempty) â†’
        (s âˆ© â‹‚â‚€ â†‘U).Nonempty ",":= by
  refine âŸ¨fun h U hu hU => ?_, fun h => âŸ¨?_, ?_âŸ©âŸ©
  Â· induction U using Finset.induction_on with
    | empty => simpa using h.nonempty
    | @insert u U _ IH =>
      rw [Finset.coe_insert, sInter_insert]
      rw [Finset.forall_mem_insert] at hu hU
      exact h.2 _ _ hu.1 (U.finite_toSet.isOpen_sInter hu.2) hU.1 (IH hu.2 hU.2)
  Â· simpa using h âˆ…
  Â· intro u v hu hv hu' hv'
    simpa [*] using h {u, v}"
Mathlib/Algebra/Polynomial/Module/Basic.lean,PolynomialModule.map_smul,map_smul,c342c339a777827331257acd880fea6d441a6aa6,":= by
  apply induction_linear q
  Â· rw [smul_zero, map_zero, smul_zero]
  Â· intro f g eâ‚ eâ‚‚
    rw [smul_add, map_add, eâ‚, eâ‚‚, map_add, smul_add]
  intro i m
  induction' p with _ _ eâ‚ eâ‚‚
  Â· rw [add_smul, map_add, eâ‚, eâ‚‚, Polynomial.map_add, add_smul]
  Â· rw [monomial_smul_single, map_single, Polynomial.map_monomial, map_single, monomial_smul_single,
      f.map_smul, algebraMap_smul]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  (?r + ?s) â€¢ ?x
case hsingle.ofFinsupp
R : Type u_1
M : Type u_2
instâœÂ¹Â² : CommRing R
instâœÂ¹Â¹ : AddCommGroup M
instâœÂ¹â° : Module R M
I : Ideal R
S : Type u_3
instâœâ¹ : CommSemiring S
instâœâ¸ : Algebra S R
instâœâ· : Module S M
instâœâ¶ : IsScalarTower S R M
R' : Type u_4
M' : Type u_5
instâœâµ : CommRing R'
instâœâ´ : AddCommGroup M'
instâœÂ³ : Module R' M'
instâœÂ² : Algebra R R'
instâœÂ¹ : Module R M'
instâœ : IsScalarTower R R' M'
f : M â†’â‚—[R] M'
q : PolynomialModule R M
i : â„•
m : M
toFinsuppâœ : AddMonoidAlgebra R â„•
âŠ¢ (map R' f) ({ toFinsupp := toFinsuppâœ } â€¢ (single R i) m) =
    Polynomial.map (algebraMap R R') { toFinsupp := toFinsuppâœ } â€¢ (map R' f) ((single R i) m)
error:  no goals to be solved","theorem map_smul (f : M â†’â‚—[R] M') (p : R[X]) (q : PolynomialModule R M) :
    map R' f (p â€¢ q) = p.map (algebraMap R R') â€¢ map R' f q ",":= by
  apply induction_linear q
  Â· rw [smul_zero, map_zero, smul_zero]
  Â· intro f g eâ‚ eâ‚‚
    rw [smul_add, map_add, eâ‚, eâ‚‚, map_add, smul_add]
  intro i m
  induction' p using Polynomial.induction_on' with _ _ eâ‚ eâ‚‚
  Â· rw [add_smul, map_add, eâ‚, eâ‚‚, Polynomial.map_add, add_smul]
  Â· rw [monomial_smul_single, map_single, Polynomial.map_monomial, map_single, monomial_smul_single,
      f.map_smul, algebraMap_smul]"
Mathlib/Data/Nat/Choose/Basic.lean,Nat.choose_le_succ_of_lt_half_left,choose_le_succ_of_lt_half_left,d5bbeefb89cbef6267cf0109f4a7750302f1ca71,":= by
  refine' le_of_mul_le_mul_right _ (lt_tsub_iff_left.mpr (lt_of_lt_of_le h (n.div_le_self 2)))
  rw [â† choose_succ_right_eq]
  apply Nat.mul_le_mul_left
  rw [â† Nat.lt_iff_add_one_le, lt_tsub_iff_left, â† mul_two]
  exact lt_of_lt_of_le (mul_lt_mul_of_pos_right h zero_lt_two) (n.div_mul_le_self 2)","error:  unknown identifier 'le_of_mul_le_mul_right'
error:  no goals to be solved","theorem choose_le_succ_of_lt_half_left {r n : â„•} (h : r < n / 2) :
    choose n r â‰¤ choose n (r + 1) ",":= by
  refine Nat.le_of_mul_le_mul_right ?_ (Nat.sub_pos_of_lt (h.trans_le (n.div_le_self 2)))
  rw [â† choose_succ_right_eq]
  apply Nat.mul_le_mul_left
  rw [â† Nat.lt_iff_add_one_le, Nat.lt_sub_iff_add_lt, â† Nat.mul_two]
  exact lt_of_lt_of_le (Nat.mul_lt_mul_of_pos_right h Nat.zero_lt_two) (n.div_mul_le_self 2)"
Mathlib/FieldTheory/AbelRuffini.lean,solvableByRad.induction2,induction2,1aadd4f4012334f6f1cd811e685b9c75a27ee9ed,":= by
  let p := minpoly F Î±
  let q := minpoly F Î²
  have hpq := Polynomial.splits_of_splits_mul _
    (mul_ne_zero (minpoly.ne_zero (isIntegral Î±)) (minpoly.ne_zero (isIntegral Î²)))
    (SplittingField.splits (p * q))
  let f : â†¥FâŸ®Î±, Î²âŸ¯ â†’â‚[F] (p * q).SplittingField := Classical.choice <| algHom_mk_adjoin_splits (by
    intro x hx
    cases' hx with hx hx
    rw [hx]
    exact âŸ¨isIntegral Î±, hpq.1âŸ©
    cases hx
    exact âŸ¨isIntegral Î², hpq.2âŸ©)
  have key : minpoly F Î³ = minpoly F (f âŸ¨Î³, hÎ³âŸ©) := by
    refine' minpoly.eq_of_irreducible_of_monic
      (minpoly.irreducible (isIntegral Î³)) _ (minpoly.monic (isIntegral Î³))
    suffices aeval (âŸ¨Î³, hÎ³âŸ© : FâŸ®Î±, Î²âŸ¯) (minpoly F Î³) = 0 by
      rw [aeval_algHom_apply, this, AlgHom.map_zero]
    haveI := @IntermediateField.toAlgebra F (solvableByRad F E) _ _ _ FâŸ®Î±, Î²âŸ¯
      (solvableByRad F E) _ (Algebra.id (solvableByRad F E))
    apply (algebraMap (â†¥FâŸ®Î±, Î²âŸ¯) (solvableByRad F E)).injective
    simp only [map_zero, _root_.map_eq_zero]
    apply Subtype.val_injective
    erw [Polynomial.aeval_subalgebra_coe (minpoly F Î³)]
    simp
  rw [P, key]
  refine' gal_isSolvable_of_splits âŸ¨Normal.splits _ (f âŸ¨Î³, hÎ³âŸ©)âŸ© (gal_mul_isSolvable hÎ± hÎ²)
  apply SplittingField.instNormal","error:  unknown identifier 'algHom_mk_adjoin_splits'
error:  invalid use of field notation with `@` modifier","theorem induction2 {Î± Î² Î³ : solvableByRad F E} (hÎ³ : Î³ âˆˆ FâŸ®Î±, Î²âŸ¯) (hÎ± : P Î±) (hÎ² : P Î²) : P Î³ ",":= by
  let p := minpoly F Î±
  let q := minpoly F Î²
  have hpq := Polynomial.splits_of_splits_mul _
    (mul_ne_zero (minpoly.ne_zero (isIntegral Î±)) (minpoly.ne_zero (isIntegral Î²)))
    (SplittingField.splits (p * q))
  let f : â†¥FâŸ®Î±, Î²âŸ¯ â†’â‚[F] (p * q).SplittingField :=
    Classical.choice <| nonempty_algHom_adjoin_of_splits <| by
      intro x hx
      simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hx
      cases hx with rw [hx]
      | inl hx => exact âŸ¨isIntegral Î±, hpq.1âŸ©
      | inr hx => exact âŸ¨isIntegral Î², hpq.2âŸ©
  have key : minpoly F Î³ = minpoly F (f âŸ¨Î³, hÎ³âŸ©) := by
    refine minpoly.eq_of_irreducible_of_monic
      (minpoly.irreducible (isIntegral Î³)) ?_ (minpoly.monic (isIntegral Î³))
    suffices aeval (âŸ¨Î³, hÎ³âŸ© : FâŸ®Î±, Î²âŸ¯) (minpoly F Î³) = 0 by
      rw [aeval_algHom_apply, this, AlgHom.map_zero]
    apply (algebraMap (â†¥FâŸ®Î±, Î²âŸ¯) (solvableByRad F E)).injective
    simp only [map_zero, _root_.map_eq_zero]
    apply Subtype.val_injective
    erw [Polynomial.aeval_subalgebra_coe (minpoly F Î³)]
    simp
  rw [P, key]
  refine gal_isSolvable_of_splits âŸ¨Normal.splits ?_ (f âŸ¨Î³, hÎ³âŸ©)âŸ© (gal_mul_isSolvable hÎ± hÎ²)
  apply SplittingField.instNormal"
Mathlib/Algebra/GroupWithZero/Basic.lean,pow_eq_zero,pow_eq_zero,7b8bf07cc2a20c8dc82ce0858b4824f036e4a88b,"  | _, _, Nat.le.refl, ha => ha
  | _, _, Nat.le.step hmn, ha => by rw [pow_succ, pow_eq_zero_of_le hmn ha, mul_zero]","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?a * 0
Î± : Type u_1
Mâ‚€ : Type u_2
Gâ‚€ : Type u_3
Mâ‚€' : Type u_4
Gâ‚€' : Type u_5
F : Type u_6
F' : Type u_7
instâœ : MonoidWithZero Mâ‚€
a : Mâ‚€
m n nâœ mâœ : â„•
hmn : nâœ.le mâœ
ha : a ^ nâœ = 0
âŠ¢ 0 * a = 0","lemma pow_eq_zero_of_le : âˆ€ {m n} (hmn : m â‰¤ n) (ha : a ^ m = 0), a ^ n = 0
","  | _, _, Nat.le.refl, ha => ha
  | _, _, Nat.le.step hmn, ha => by rw [pow_succ, pow_eq_zero_of_le hmn ha, zero_mul]"
Mathlib/Data/Multiset/Bind.lean,Multiset.prod_join,prod_join,b64837072a412d143f71d2cfc07b7ec5117cbb4c,":= by
  induction S using Multiset.induction with
  | empty => simp
  | cons ih => simp [ih]","error:  invalid argument, variable is not a proposition or let-declaration
error:  unsolved goals
case cons
Î± : Type u_1
Î² : Type v
Î³ : Type u_2
Î´ : Type u_3
instâœ : CommMonoid Î±
ih : Multiset Î±
sâœ : Multiset (Multiset Î±)
aâœ : sâœ.join.prod = (map prod sâœ).prod
âŠ¢ ih.prod * sâœ.join.prod = ih.prod * (map prod sâœ).prod","theorem prod_join [CommMonoid Î±] {S : Multiset (Multiset Î±)} :
    prod (join S) = prod (map prod S) ",":= by
  induction S using Multiset.induction with
  | empty => simp
  | cons _ _ ih => simp [ih]"
Mathlib/Algebra/Star/Order.lean,IsSelfAdjoint.of_nonneg,IsSelfAdjoint.of_nonneg,1c643aca968064296312bf5328c84d0c50cfe5ae,":=
  .mono hx <| .zero R","error:  invalid dotted identifier notation, unknown identifier `IsSelfAdjoint.zero` from expected type
  IsSelfAdjoint 0
error:  invalid dotted identifier notation, unknown identifier `Eq.zero` from expected type
  IsSelfAdjoint 0",lemma IsSelfAdjoint.of_nonneg {x : R} (hx : 0 â‰¤ x) : IsSelfAdjoint x ,":=
  (isSelfAdjoint_zero R).mono hx"
Mathlib/Probability/Martingale/Convergence.lean,MeasureTheory.Submartingale.upcrossings_ae_lt_top,Submartingale.upcrossings_ae_lt_top,9f6d33884de569540c527b667d1573e1b97e1347,":= by
  refine' ae_lt_top (hf.adapted.measurable_upcrossings hab) _
  have := hf.mul_lintegral_upcrossings_le_lintegral_pos_part a b
  rw [mul_comm, â† ENNReal.le_div_iff_mul_le] at this
  Â· refine' (lt_of_le_of_lt this (ENNReal.div_lt_top _ _)).ne
    Â· have hR' : âˆ€ n, âˆ«â» Ï‰, â€–f n Ï‰ - aâ€–â‚Š âˆ‚Î¼ â‰¤ R + â€–aâ€–â‚Š * Î¼ Set.univ := by
        simp_rw [snorm_one_eq_lintegral_nnnorm] at hbdd
        intro n
        refine' (lintegral_mono _ : âˆ«â» Ï‰, â€–f n Ï‰ - aâ€–â‚Š âˆ‚Î¼ â‰¤ âˆ«â» Ï‰, â€–f n Ï‰â€–â‚Š + â€–aâ€–â‚Š âˆ‚Î¼).trans _
        Â· intro Ï‰
          simp_rw [sub_eq_add_neg, â† nnnorm_neg a, â† ENNReal.coe_add, ENNReal.coe_le_coe]
          exact nnnorm_add_le _ _
        Â· simp_rw [lintegral_add_right _ measurable_const, lintegral_const]
          exact add_le_add (hbdd _) le_rfl
      refine' ne_of_lt (iSup_lt_iff.2 âŸ¨R + â€–aâ€–â‚Š * Î¼ Set.univ, ENNReal.add_lt_top.2
        âŸ¨ENNReal.coe_lt_top, ENNReal.mul_lt_top ENNReal.coe_lt_top.ne (measure_ne_top _ _)âŸ©,
        fun n => le_trans _ (hR' n)âŸ©)
      refine' lintegral_mono fun Ï‰ => _
      rw [ENNReal.ofReal_le_iff_le_toReal, ENNReal.coe_toReal, coe_nnnorm]
      by_cases hnonneg : 0 â‰¤ f n Ï‰ - a
      Â· rw [LatticeOrderedGroup.pos_of_nonneg _ hnonneg, Real.norm_eq_abs,
          abs_of_nonneg hnonneg]
      Â· rw [LatticeOrderedGroup.pos_of_nonpos _ (not_le.1 hnonneg).le]
        exact norm_nonneg _
      Â· simp only [Ne.def, ENNReal.coe_ne_top, not_false_iff]
    Â· simp only [hab, Ne.def, ENNReal.ofReal_eq_zero, sub_nonpos, not_le]
  Â· simp only [hab, Ne.def, ENNReal.ofReal_eq_zero, sub_nonpos, not_le, true_or_iff]
  Â· simp only [Ne.def, ENNReal.ofReal_ne_top, not_false_iff, true_or_iff]","error:  unknown identifier 'LatticeOrderedGroup.pos_of_nonneg'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.15362
case pos
Î© : Type u_1
Î¹ : Type u_2
m0 : MeasurableSpace Î©
Î¼ : Measure Î©
â„± : Filtration â„• m0
a b : â„
f : â„• â†’ Î© â†’ â„
Ï‰âœ : Î©
R : â„â‰¥0
instâœ : IsFiniteMeasure Î¼
hf : Submartingale f â„± Î¼
hbdd : âˆ€ (n : â„•), snorm (f n) 1 Î¼ â‰¤ â†‘R
hab : a < b
this : âˆ«â» (Ï‰ : Î©), upcrossings a b f Ï‰ âˆ‚Î¼ â‰¤ (â¨† N, âˆ«â» (Ï‰ : Î©), ENNReal.ofReal (f N Ï‰ - a)âº âˆ‚Î¼) / ENNReal.ofReal (b - a)
hR' : âˆ€ (n : â„•), âˆ«â» (Ï‰ : Î©), â†‘â€–f n Ï‰ - aâ€–â‚Š âˆ‚Î¼ â‰¤ â†‘R + â†‘â€–aâ€–â‚Š * Î¼ Set.univ
n : â„•
Ï‰ : Î©
hnonneg : 0 â‰¤ f n Ï‰ - a
âŠ¢ (f n Ï‰ - a)âº â‰¤ â€–f n Ï‰ - aâ€–
error:  unknown identifier 'LatticeOrderedGroup.pos_of_nonpos'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.15364
case neg
Î© : Type u_1
Î¹ : Type u_2
m0 : MeasurableSpace Î©
Î¼ : Measure Î©
â„± : Filtration â„• m0
a b : â„
f : â„• â†’ Î© â†’ â„
Ï‰âœ : Î©
R : â„â‰¥0
instâœ : IsFiniteMeasure Î¼
hf : Submartingale f â„± Î¼
hbdd : âˆ€ (n : â„•), snorm (f n) 1 Î¼ â‰¤ â†‘R
hab : a < b
this : âˆ«â» (Ï‰ : Î©), upcrossings a b f Ï‰ âˆ‚Î¼ â‰¤ (â¨† N, âˆ«â» (Ï‰ : Î©), ENNReal.ofReal (f N Ï‰ - a)âº âˆ‚Î¼) / ENNReal.ofReal (b - a)
hR' : âˆ€ (n : â„•), âˆ«â» (Ï‰ : Î©), â†‘â€–f n Ï‰ - aâ€–â‚Š âˆ‚Î¼ â‰¤ â†‘R + â†‘â€–aâ€–â‚Š * Î¼ Set.univ
n : â„•
Ï‰ : Î©
hnonneg : Â¬0 â‰¤ f n Ï‰ - a
âŠ¢ (f n Ï‰ - a)âº â‰¤ â€–f n Ï‰ - aâ€–
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.15379 â†’ ?m.15379 â†’ Prop
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.15500 â†’ ?m.15500 â†’ Prop
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.15618 â†’ ?m.15618 â†’ Prop
error:  simp made no progress
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.15801 â†’ ?m.15801 â†’ Prop
error:  simp made no progress","theorem Submartingale.upcrossings_ae_lt_top' [IsFiniteMeasure Î¼] (hf : Submartingale f â„± Î¼)
    (hbdd : âˆ€ n, snorm (f n) 1 Î¼ â‰¤ R) (hab : a < b) : âˆ€áµ Ï‰ âˆ‚Î¼, upcrossings a b f Ï‰ < âˆ ",":= by
  refine ae_lt_top (hf.adapted.measurable_upcrossings hab) ?_
  have := hf.mul_lintegral_upcrossings_le_lintegral_pos_part a b
  rw [mul_comm, â† ENNReal.le_div_iff_mul_le] at this
  Â· refine (lt_of_le_of_lt this (ENNReal.div_lt_top ?_ ?_)).ne
    Â· have hR' : âˆ€ n, âˆ«â» Ï‰, â€–f n Ï‰ - aâ€–â‚Š âˆ‚Î¼ â‰¤ R + â€–aâ€–â‚Š * Î¼ Set.univ := by
        simp_rw [snorm_one_eq_lintegral_nnnorm] at hbdd
        intro n
        refine (lintegral_mono ?_ : âˆ«â» Ï‰, â€–f n Ï‰ - aâ€–â‚Š âˆ‚Î¼ â‰¤ âˆ«â» Ï‰, â€–f n Ï‰â€–â‚Š + â€–aâ€–â‚Š âˆ‚Î¼).trans ?_
        Â· intro Ï‰
          simp_rw [sub_eq_add_neg, â† nnnorm_neg a, â† ENNReal.coe_add, ENNReal.coe_le_coe]
          exact nnnorm_add_le _ _
        Â· simp_rw [lintegral_add_right _ measurable_const, lintegral_const]
          exact add_le_add (hbdd _) le_rfl
      refine ne_of_lt (iSup_lt_iff.2 âŸ¨R + â€–aâ€–â‚Š * Î¼ Set.univ, ENNReal.add_lt_top.2
        âŸ¨ENNReal.coe_lt_top, ENNReal.mul_lt_top ENNReal.coe_lt_top.ne (measure_ne_top _ _)âŸ©,
        fun n => le_trans ?_ (hR' n)âŸ©)
      refine lintegral_mono fun Ï‰ => ?_
      rw [ENNReal.ofReal_le_iff_le_toReal, ENNReal.coe_toReal, coe_nnnorm]
      Â· by_cases hnonneg : 0 â‰¤ f n Ï‰ - a
        Â· rw [posPart_eq_self.2 hnonneg, Real.norm_eq_abs, abs_of_nonneg hnonneg]
        Â· rw [posPart_eq_zero.2 (not_le.1 hnonneg).le]
          exact norm_nonneg _
      Â· simp only [Ne, ENNReal.coe_ne_top, not_false_iff]
    Â· simp only [hab, Ne, ENNReal.ofReal_eq_zero, sub_nonpos, not_le]
  Â· simp only [hab, Ne, ENNReal.ofReal_eq_zero, sub_nonpos, not_le, true_or_iff]
  Â· simp only [Ne, ENNReal.ofReal_ne_top, not_false_iff, true_or_iff]"
Mathlib/Analysis/Calculus/InverseFunctionTheorem/FDeriv.lean,HasStrictFDerivAt.to_localInverse,to_localInverse,5d4fa55028ca22525074d4c2141f8f2a04dc0e32,":=
  (hf.toLocalHomeomorph f).hasStrictFDerivAt_symm hf.image_mem_toLocalHomeomorph_target <| by
    simpa [â† localInverse_def] using hf","error:  invalid field 'toLocalHomeomorph', the environment does not contain 'HasStrictFDerivAt.toLocalHomeomorph'
  hf
has type
  HasStrictFDerivAt f (â†‘f') a
error:  invalid field 'toLocalHomeomorph', the environment does not contain 'Asymptotics.IsLittleO.toLocalHomeomorph'
  hf
has type
  (fun p â†¦ f p.1 - f p.2 - â†‘f' (p.1 - p.2)) =o[ğ“ (a, a)] fun p â†¦ p.1 - p.2","theorem to_localInverse (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) a) :
    HasStrictFDerivAt (hf.localInverse f f' a) (f'.symm : F â†’L[ğ•œ] E) (f a) ",":=
  (hf.toPartialHomeomorph f).hasStrictFDerivAt_symm hf.image_mem_toPartialHomeomorph_target <| by
    simpa [â† localInverse_def] using hf"
Mathlib/Algebra/Category/Grp/Zero.lean,Grp.isZero_of_subsingleton,isZero_of_subsingleton,f9a92ed3d67873862051aaeedcedfa1472745048,":= by
  refine âŸ¨fun X => âŸ¨âŸ¨âŸ¨1âŸ©, fun f => ?_âŸ©âŸ©, fun X => âŸ¨âŸ¨âŸ¨1âŸ©, fun f => ?_âŸ©âŸ©âŸ©
  Â· ext x
    have : x = 1 := Subsingleton.elim _ _
    rw [this, map_one, map_one]
  Â· ext
    subsingleton","error:  unknown tactic
error:  unsolved goals
case refine_2.w
G : Grp
instâœ : Subsingleton â†‘G
X : Grp
f : X âŸ¶ G
xâœ : â†‘X
âŠ¢ f xâœ = default xâœ",theorem isZero_of_subsingleton (G : Grp) [Subsingleton G] : IsZero G ,":= by
  refine âŸ¨fun X => âŸ¨âŸ¨âŸ¨1âŸ©, fun f => ?_âŸ©âŸ©, fun X => âŸ¨âŸ¨âŸ¨1âŸ©, fun f => ?_âŸ©âŸ©âŸ©
  Â· ext x
    have : x = 1 := Subsingleton.elim _ _
    rw [this, map_one, map_one]
  Â· ext
    apply Subsingleton.elim"
Mathlib/GroupTheory/Coxeter/Inversion.lean,CoxeterSystem.wordProd_mul_getD_rightInvSeq,wordProd_mul_getD_rightInvSeq,c9d416f0791ec06898de80866c80323f32652367,":= by
  rw [getD_rightInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 1 [â† take_append_drop (j + 1) Ï‰]
  rw [take_succ]
  obtain lt | le := lt_or_le j Ï‰.length
  Â· simp only [get?_eq_getElem?, getElem?_eq_getElem lt]
    simp [wordProd_append, wordProd_cons, mul_assoc]
  Â· simp only [get?_eq_getElem?, getElem?_eq_none.mpr le]
    simp","error:  unsolved goals
case inl
B : Type u_1
W : Type u_2
instâœ : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
Ï‰ : List B
j : â„•
lt : j < Ï‰.length
âŠ¢ cs.wordProd Ï‰ * ((cs.wordProd (drop (j + 1) Ï‰))â»Â¹ * (cs.simple Ï‰[j] * cs.wordProd (drop (j + 1) Ï‰))) =
    cs.wordProd (take j Ï‰) * cs.wordProd (drop (j + 1) Ï‰)
error:  invalid field notation, type is not of the form (C ...) where C is a constant
  getElem?_eq_none
has type
  ?m.113126.length â‰¤ ?m.113127 â†’ ?m.113126[?m.113127]? = none
error:  unsolved goals
case inr
B : Type u_1
W : Type u_2
instâœ : Group W
M : CoxeterMatrix B
cs : CoxeterSystem M W
Ï‰ : List B
j : â„•
le : Ï‰.length â‰¤ j
âŠ¢ cs.wordProd (take j Ï‰ ++ (Ï‰[j]?.toList ++ drop (j + 1) Ï‰)) *
      ((cs.wordProd (drop (j + 1) Ï‰))â»Â¹ * (Option.map cs.simple Ï‰[j]?).getD 1 * cs.wordProd (drop (j + 1) Ï‰)) =
    cs.wordProd (take j Ï‰ ++ drop (j + 1) Ï‰)","theorem wordProd_mul_getD_rightInvSeq (Ï‰ : List B) (j : â„•) :
    Ï€ Ï‰ * ((ris Ï‰).getD j 1) = Ï€ (Ï‰.eraseIdx j) ",":= by
  rw [getD_rightInvSeq, eraseIdx_eq_take_drop_succ]
  nth_rw 1 [â† take_append_drop (j + 1) Ï‰]
  rw [take_succ]
  obtain lt | le := lt_or_le j Ï‰.length
  Â· simp only [get?_eq_getElem?, getElem?_eq_getElem lt, wordProd_append, wordProd_cons, mul_assoc]
    simp
  Â· simp only [get?_eq_getElem?, getElem?_eq_none le]
    simp"
Mathlib/Data/Seq/Computation.lean,Computation.ret_orElse,ret_orElse,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  destruct_eq_pure <| by
    unfold HOrElse.hOrElse instHOrElse
    unfold OrElse.orElse instOrElse Alternative.orElse instAlternativeComputation
    simp [orElse]",error:  unknown constant 'instHOrElse',theorem ret_orElse (a : Î±) (câ‚‚ : Computation Î±) : (pure a <|> câ‚‚) = pure a ,":=
  destruct_eq_pure <| by
    unfold_projs
    simp [orElse]"
Mathlib/RingTheory/Polynomial/Pochhammer.lean,descPochhammer_natDegree,descPochhammer_natDegree,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction' n with n hn
  Â· simp
  Â· have : natDegree (X - (n : R[X])) = 1 := natDegree_X_sub_C (n : R)
    rw [descPochhammer_succ_right,
        natDegree_mul _ (ne_zero_of_natDegree_gt <| this.symm â–¸ Nat.zero_lt_one), hn, this]
    cases n
    Â· simp
    Â· refine' ne_zero_of_natDegree_gt <| hn.symm â–¸ Nat.succ_pos _","error:  invalid `â–¸` notation, the equality
  Eq.symm hn
has type 
  nâœ + 1 = (descPochhammer R (nâœ + 1)).natDegree
but neither side of the equality is mentioned in the type
  0 < ?m.63742.succ
error:  unsolved goals
case succ
R : Type u
instâœÂ² : Ring R
instâœÂ¹ : NoZeroDivisors R
instâœ : Nontrivial R
nâœ : â„•
hn : (descPochhammer R (nâœ + 1)).natDegree = nâœ + 1
this : (X - â†‘(nâœ + 1)).natDegree = 1
âŠ¢ â„•","theorem descPochhammer_natDegree (n : â„•) [NoZeroDivisors R] [Nontrivial R] :
    (descPochhammer R n).natDegree = n ",":= by
  induction' n with n hn
  Â· simp
  Â· have : natDegree (X - (n : R[X])) = 1 := natDegree_X_sub_C (n : R)
    rw [descPochhammer_succ_right,
        natDegree_mul _ (ne_zero_of_natDegree_gt <| this.symm â–¸ Nat.zero_lt_one), hn, this]
    cases n
    Â· simp
    Â· refine ne_zero_of_natDegree_gt <| hn.symm â–¸ Nat.add_one_pos _"
Mathlib/Probability/ConditionalProbability.lean,ProbabilityTheory.cond_isProbabilityMeasure,cond_isProbabilityMeasure,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  âŸ¨by
    unfold ProbabilityTheory.cond
    simp only [Measure.smul_toOuterMeasure, OuterMeasure.coe_smul, Pi.smul_apply,
      MeasurableSet.univ, Measure.restrict_apply, Set.univ_inter, smul_eq_mul]
    exact ENNReal.inv_mul_cancel hcs hsâŸ©","warning:  @cond does not have a doc string
warning:  @cond does not have a doc string
error:  simp made no progress","theorem cond_isProbabilityMeasure_of_finite (hcs : Î¼ s â‰  0) (hs : Î¼ s â‰  âˆ) :
    IsProbabilityMeasure Î¼[|s] ",":=
  âŸ¨by
    unfold ProbabilityTheory.cond
    simp only [Measure.coe_smul, Pi.smul_apply, MeasurableSet.univ, Measure.restrict_apply,
      Set.univ_inter, smul_eq_mul]
    exact ENNReal.inv_mul_cancel hcs hsâŸ©"
Mathlib/RingTheory/Unramified/Basic.lean,Algebra.FormallyUnramified.of_comp,of_comp,3a31aabe59645ce291dedbcbdd3f949a56d5178f,":= by
  constructor
  intro Q _ _ I e fâ‚ fâ‚‚ e'
  letI := ((algebraMap A Q).comp (algebraMap R A)).toSMul
  letI := ((algebraMap A Q).comp (algebraMap R A)).toAlgebra
  letI : IsScalarTower R A Q := IsScalarTower.of_algebraMap_eq' rfl
  sorry","error:  invalid field 'toSMul', the environment does not contain 'RingHom.toSMul'
  (algebraMap A Q).comp (algebraMap R A)
has type
  R â†’+* Q
error:  unsolved goals
case comp_injective
R : Type u
instâœâ¹ : CommSemiring R
A : Type u
instâœâ¸ : CommSemiring A
instâœâ· : Algebra R A
B : Type u
instâœâ¶ : Semiring B
instâœâµ : Algebra R B
instâœâ´ : Algebra A B
instâœÂ³ : IsScalarTower R A B
instâœÂ² : FormallyUnramified R B
Q : Type u
instâœÂ¹ : CommRing Q
instâœ : Algebra A Q
I : Ideal Q
e : I ^ 2 = âŠ¥
fâ‚ fâ‚‚ : B â†’â‚[A] Q
e' : (Ideal.Quotient.mkâ‚ A I).comp fâ‚ = (Ideal.Quotient.mkâ‚ A I).comp fâ‚‚
âŠ¢ fâ‚ = fâ‚‚",theorem of_comp [FormallyUnramified R B] : FormallyUnramified A B ,":= by
  constructor
  intro Q _ _ I e fâ‚ fâ‚‚ e'
  letI := ((algebraMap A Q).comp (algebraMap R A)).toAlgebra
  letI : IsScalarTower R A Q := IsScalarTower.of_algebraMap_eq' rfl
  refine AlgHom.restrictScalars_injective R ?_
  refine FormallyUnramified.ext I âŸ¨2, eâŸ© ?_
  intro x
  exact AlgHom.congr_fun e' x"
Mathlib/RingTheory/PowerSeries/Basic.lean,PowerSeries.ext,ext,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":=
  funext h","error:  application type mismatch
  funext h
argument
  h
has type
  âˆ€ (n : â„•), (coeff R n) Ï† = (coeff R n) Ïˆ : Prop
but is expected to have type
  âˆ€ (x : Unit â†’â‚€ â„•), Ï† x = Ïˆ x : Prop
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated","theorem ext {Ï† Ïˆ : RâŸ¦XâŸ§} (h : âˆ€ n, coeff R n Ï† = coeff R n Ïˆ) : Ï† = Ïˆ ",":=
  MvPowerSeries.ext fun n => by
    rw [â† coeff_def]
    Â· apply h
    rfl"
Mathlib/MeasureTheory/Measure/Hausdorff.lean,MeasureTheory.Measure.mkMetric_mono,mkMetric_mono,ced4d3c0af763b9fd00166e49cf999cf46c891cc,":= by
  classical
  rcases (mem_nhdsWithin_Ici_iff_exists_Ico_subset' zero_lt_one).1 hle with âŸ¨r, hr0, hrâŸ©
  refine fun s =>
    le_of_tendsto_of_tendsto (mkMetric'.tendsto_pre _ s)
      (ENNReal.Tendsto.const_mul (mkMetric'.tendsto_pre _ s) (Or.inr hc))
      (mem_of_superset (Ioo_mem_nhdsWithin_Ioi âŸ¨le_rfl, hr0âŸ©) fun r' hr' => _)
  simp only [mem_setOf_eq, mkMetric'.pre, RingHom.id_apply]
  rw [â† smul_eq_mul, â† smul_apply, smul_boundedBy hc]
  refine le_boundedBy.2 (fun t => (boundedBy_le _).trans _) _
  simp only [smul_eq_mul, Pi.smul_apply, extend, iInf_eq_if]
  split_ifs with ht
  Â· apply hr
    exact âŸ¨zero_le _, ht.trans_lt hr'.2âŸ©
  Â· simp [h0]","error:  don't know how to synthesize placeholder
context:
Î¹ : Type u_1
X : Type u_2
Y : Type u_3
instâœÂ¹ : EMetricSpace X
instâœ : EMetricSpace Y
mâ‚ mâ‚‚ : â„â‰¥0âˆ â†’ â„â‰¥0âˆ
c : â„â‰¥0âˆ
hc : c â‰  âŠ¤
h0 : c â‰  0
hle : mâ‚ â‰¤á¶ [ğ“[â‰¥] 0] c â€¢ mâ‚‚
r : â„â‰¥0âˆ
hr0 : r âˆˆ Ioi 0
hr : Ico 0 r âŠ† {x | (fun x â†¦ mâ‚ x â‰¤ (c â€¢ mâ‚‚) x) x}
s : Set X
r' : â„â‰¥0âˆ
hr' : r' âˆˆ Ioo 0 r
âŠ¢ r' âˆˆ
    {x |
      (fun x â†¦
          (fun r â†¦ (mkMetric'.pre (fun s â†¦ mâ‚ (diam s)) r) s) x â‰¤
            (fun b â†¦ c * (mkMetric'.pre (fun s â†¦ mâ‚‚ (diam s)) b) s) x)
        x}
error:  unsolved goals
case intro.intro
Î¹ : Type u_1
X : Type u_2
Y : Type u_3
instâœÂ¹ : EMetricSpace X
instâœ : EMetricSpace Y
mâ‚ mâ‚‚ : â„â‰¥0âˆ â†’ â„â‰¥0âˆ
c : â„â‰¥0âˆ
hc : c â‰  âŠ¤
h0 : c â‰  0
hle : mâ‚ â‰¤á¶ [ğ“[â‰¥] 0] c â€¢ mâ‚‚
r : â„â‰¥0âˆ
hr0 : r âˆˆ Ioi 0
hr : Ico 0 r âŠ† {x | (fun x â†¦ mâ‚ x â‰¤ (c â€¢ mâ‚‚) x) x}
âŠ¢ mkMetric mâ‚ â‰¤ c â€¢ mkMetric mâ‚‚","theorem mkMetric_mono_smul {mâ‚ mâ‚‚ : â„â‰¥0âˆ â†’ â„â‰¥0âˆ} {c : â„â‰¥0âˆ} (hc : c â‰  âˆ) (h0 : c â‰  0)
    (hle : mâ‚ â‰¤á¶ [ğ“[â‰¥] 0] c â€¢ mâ‚‚) : (mkMetric mâ‚ : OuterMeasure X) â‰¤ c â€¢ mkMetric mâ‚‚ ",":= by
  classical
  rcases (mem_nhdsWithin_Ici_iff_exists_Ico_subset' zero_lt_one).1 hle with âŸ¨r, hr0, hrâŸ©
  refine fun s =>
    le_of_tendsto_of_tendsto (mkMetric'.tendsto_pre _ s)
      (ENNReal.Tendsto.const_mul (mkMetric'.tendsto_pre _ s) (Or.inr hc))
      (mem_of_superset (Ioo_mem_nhdsWithin_Ioi âŸ¨le_rfl, hr0âŸ©) fun r' hr' => ?_)
  simp only [mem_setOf_eq, mkMetric'.pre, RingHom.id_apply]
  rw [â† smul_eq_mul, â† smul_apply, smul_boundedBy hc]
  refine le_boundedBy.2 (fun t => (boundedBy_le _).trans ?_) _
  simp only [smul_eq_mul, Pi.smul_apply, extend, iInf_eq_if]
  split_ifs with ht
  Â· apply hr
    exact âŸ¨zero_le _, ht.trans_lt hr'.2âŸ©
  Â· simp [h0]"
Mathlib/MeasureTheory/Integral/VitaliCaratheodory.lean,MeasureTheory.exists_lt_lowerSemicontinuous_integral_gt_nnreal,exists_lt_lowerSemicontinuous_integral_gt_nnreal,e234e64075504db13790aa471a4239039c94703b,":= by
  have fmeas : AEMeasurable f Î¼ := by
    convert fint.aestronglyMeasurable.real_toNNReal.aemeasurable
    simp only [Real.toNNReal_coe]
  lift Îµ to â„â‰¥0 using Îµpos.le
  obtain âŸ¨Î´, Î´pos, hÎ´ÎµâŸ© : âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§ Î´ < Îµ; exact exists_between Îµpos
  have int_f_ne_top : (âˆ«â» a : Î±, f a âˆ‚Î¼) â‰  âˆ :=
    (hasFiniteIntegral_iff_ofNNReal.1 fint.hasFiniteIntegral).ne
  rcases exists_lt_lowerSemicontinuous_lintegral_ge_of_aemeasurable Î¼ f fmeas
      (ENNReal.coe_ne_zero.2 Î´pos.ne') with
    âŸ¨g, f_lt_g, gcont, gintâŸ©
  have gint_ne : (âˆ«â» x : Î±, g x âˆ‚Î¼) â‰  âˆ := ne_top_of_le_ne_top (by simpa) gint
  have g_lt_top : âˆ€áµ x : Î± âˆ‚Î¼, g x < âˆ := ae_lt_top gcont.measurable gint_ne
  have Ig : (âˆ«â» a : Î±, ENNReal.ofReal (g a).toReal âˆ‚Î¼) = âˆ«â» a : Î±, g a âˆ‚Î¼ := by
    apply lintegral_congr_ae
    filter_upwards [g_lt_top] with _ hx
    simp only [hx.ne, ENNReal.ofReal_toReal, Ne.def, not_false_iff]
  refine' âŸ¨g, f_lt_g, gcont, g_lt_top, _, _âŸ©
  Â· refine' âŸ¨gcont.measurable.ennreal_toReal.aemeasurable.aestronglyMeasurable, _âŸ©
    simp only [hasFiniteIntegral_iff_norm, Real.norm_eq_abs, abs_of_nonneg ENNReal.toReal_nonneg]
    convert gint_ne.lt_top using 1
  Â· rw [integral_eq_lintegral_of_nonneg_ae, integral_eq_lintegral_of_nonneg_ae]
    Â·
      calc
        ENNReal.toReal (âˆ«â» a : Î±, ENNReal.ofReal (g a).toReal âˆ‚Î¼) =
            ENNReal.toReal (âˆ«â» a : Î±, g a âˆ‚Î¼) :=
          by congr 1
        _ â‰¤ ENNReal.toReal ((âˆ«â» a : Î±, f a âˆ‚Î¼) + Î´) := by
          apply ENNReal.toReal_mono _ gint
          simpa using int_f_ne_top
        _ = ENNReal.toReal (âˆ«â» a : Î±, f a âˆ‚Î¼) + Î´ := by
          rw [ENNReal.toReal_add int_f_ne_top ENNReal.coe_ne_top, ENNReal.coe_toReal]
        _ < ENNReal.toReal (âˆ«â» a : Î±, f a âˆ‚Î¼) + Îµ := (add_lt_add_left hÎ´Îµ _)
        _ = (âˆ«â» a : Î±, ENNReal.ofReal â†‘(f a) âˆ‚Î¼).toReal + Îµ := by simp

    Â· apply Filter.eventually_of_forall fun x => _; simp
    Â· exact fmeas.coe_nnreal_real.aestronglyMeasurable
    Â· apply Filter.eventually_of_forall fun x => _; simp
    Â· apply gcont.measurable.ennreal_toReal.aemeasurable.aestronglyMeasurable","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Ne
has type
  ?m.71156 â†’ ?m.71156 â†’ Prop
error:  simp made no progress","theorem exists_lt_lowerSemicontinuous_integral_gt_nnreal [SigmaFinite Î¼] (f : Î± â†’ â„â‰¥0)
    (fint : Integrable (fun x => (f x : â„)) Î¼) {Îµ : â„} (Îµpos : 0 < Îµ) :
    âˆƒ g : Î± â†’ â„â‰¥0âˆ,
      (âˆ€ x, (f x : â„â‰¥0âˆ) < g x) âˆ§
      LowerSemicontinuous g âˆ§
      (âˆ€áµ x âˆ‚Î¼, g x < âŠ¤) âˆ§
      Integrable (fun x => (g x).toReal) Î¼ âˆ§ (âˆ« x, (g x).toReal âˆ‚Î¼) < (âˆ« x, â†‘(f x) âˆ‚Î¼) + Îµ ",":= by
  have fmeas : AEMeasurable f Î¼ := by
    convert fint.aestronglyMeasurable.real_toNNReal.aemeasurable
    simp only [Real.toNNReal_coe]
  lift Îµ to â„â‰¥0 using Îµpos.le
  obtain âŸ¨Î´, Î´pos, hÎ´ÎµâŸ© : âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§ Î´ < Îµ := exists_between Îµpos
  have int_f_ne_top : (âˆ«â» a : Î±, f a âˆ‚Î¼) â‰  âˆ :=
    (hasFiniteIntegral_iff_ofNNReal.1 fint.hasFiniteIntegral).ne
  rcases exists_lt_lowerSemicontinuous_lintegral_ge_of_aemeasurable Î¼ f fmeas
      (ENNReal.coe_ne_zero.2 Î´pos.ne') with
    âŸ¨g, f_lt_g, gcont, gintâŸ©
  have gint_ne : (âˆ«â» x : Î±, g x âˆ‚Î¼) â‰  âˆ := ne_top_of_le_ne_top (by simpa) gint
  have g_lt_top : âˆ€áµ x : Î± âˆ‚Î¼, g x < âˆ := ae_lt_top gcont.measurable gint_ne
  have Ig : (âˆ«â» a : Î±, ENNReal.ofReal (g a).toReal âˆ‚Î¼) = âˆ«â» a : Î±, g a âˆ‚Î¼ := by
    apply lintegral_congr_ae
    filter_upwards [g_lt_top] with _ hx
    simp only [hx.ne, ENNReal.ofReal_toReal, Ne, not_false_iff]
  refine âŸ¨g, f_lt_g, gcont, g_lt_top, ?_, ?_âŸ©
  Â· refine âŸ¨gcont.measurable.ennreal_toReal.aemeasurable.aestronglyMeasurable, ?_âŸ©
    simp only [hasFiniteIntegral_iff_norm, Real.norm_eq_abs, abs_of_nonneg ENNReal.toReal_nonneg]
    convert gint_ne.lt_top using 1
  Â· rw [integral_eq_lintegral_of_nonneg_ae, integral_eq_lintegral_of_nonneg_ae]
    Â· calc
        ENNReal.toReal (âˆ«â» a : Î±, ENNReal.ofReal (g a).toReal âˆ‚Î¼) =
            ENNReal.toReal (âˆ«â» a : Î±, g a âˆ‚Î¼) := by congr 1
        _ â‰¤ ENNReal.toReal ((âˆ«â» a : Î±, f a âˆ‚Î¼) + Î´) := by
          apply ENNReal.toReal_mono _ gint
          simpa using int_f_ne_top
        _ = ENNReal.toReal (âˆ«â» a : Î±, f a âˆ‚Î¼) + Î´ := by
          rw [ENNReal.toReal_add int_f_ne_top ENNReal.coe_ne_top, ENNReal.coe_toReal]
        _ < ENNReal.toReal (âˆ«â» a : Î±, f a âˆ‚Î¼) + Îµ := add_lt_add_left hÎ´Îµ _
        _ = (âˆ«â» a : Î±, ENNReal.ofReal â†‘(f a) âˆ‚Î¼).toReal + Îµ := by simp

    Â· apply Filter.eventually_of_forall fun x => _; simp
    Â· exact fmeas.coe_nnreal_real.aestronglyMeasurable
    Â· apply Filter.eventually_of_forall fun x => _; simp
    Â· apply gcont.measurable.ennreal_toReal.aemeasurable.aestronglyMeasurable"
Mathlib/Data/Finset/Basic.lean,Multiset.toFinset_singleton,toFinset_singleton,b502dbb455f708f5af5e6017e88f53565165ab0a,":= by
  rw [â† cons_zero, toFinset_cons, toFinset_zero, IsLawfulSingleton.insert_emptyc_eq]","error:  unknown identifier 'IsLawfulSingleton.insert_emptyc_eq'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.251503
Î± : Type u_1
Î² : Type u_2
Î³ : Type u_3
instâœ : DecidableEq Î±
s t : Multiset Î±
a : Î±
âŠ¢ insert a âˆ… = {a}",theorem toFinset_singleton (a : Î±) : toFinset ({a} : Multiset Î±) = {a} ,":= by
  rw [â† cons_zero, toFinset_cons, toFinset_zero, LawfulSingleton.insert_emptyc_eq]"
Mathlib/RingTheory/Bialgebra/Hom.lean,BialgHom.coe_coalgHom_injective,coe_coalgHom_injective,3a75d0bf19f68430ce526cb9e63de3580baf57bf,":=
  fun Ï†â‚ Ï†â‚‚ H => coe_fn_injective <|
    show ((Ï†â‚ : A â†’â‚—[R] B) : A â†’ B) = ((Ï†â‚‚ : A â†’â‚—[R] B) : A â†’ B) from congr_arg _ H","warning:  BialgHom does not have a doc string
warning:  BialgHom does not have a doc string
error:  application type mismatch
  congr_arg DFunLike.coe H
argument
  H
has type
  â†‘Ï†â‚ = â†‘Ï†â‚‚ : Prop
but is expected to have type
  â†‘Ï†â‚ = â†‘Ï†â‚‚ : Prop",theorem coe_coalgHom_injective : Function.Injective ((â†‘) : (A â†’â‚c[R] B) â†’ A â†’â‚—c[R] B) ,":=
  fun Ï†â‚ Ï†â‚‚ H => coe_fn_injective <|
    show ((Ï†â‚ : A â†’â‚—c[R] B) : A â†’ B) = ((Ï†â‚‚ : A â†’â‚—c[R] B) : A â†’ B) from congr_arg _ H"
Mathlib/Computability/Primrec.lean,Primrec.list_cons,list_cons,b912476b37f2ea41ee51af7e63439f4a769be095,":=
  letI := prim H
  encode_iff.1 (succ.comp <| Primrec.natPair.compâ‚‚ (encode_iff.2 fst) (encode_iff.2 snd))","error:  invalid field notation, type is not of the form (C ...) where C is a constant
  Primrec
has type
  (?m.127720 â†’ ?m.127721) â†’ Prop",theorem list_cons' : (haveI := prim H; Primrecâ‚‚ (@List.cons Î²)) ,":=
  letI := prim H
  encode_iff.1 (succ.comp <| Primrecâ‚‚.natPair.comp (encode_iff.2 fst) (encode_iff.2 snd))"
Mathlib/Data/Int/Log.lean,Int.zpow_lt_iff_lt_clog,zpow_lt_iff_lt_clog,693fd79515903b10b1d31f10dccfc49e633cf7ee,":=
  (@GaloisConnection.lt_iff_lt _ _ _ _ _ _ (clogZpowGi R hb).gc âŸ¨r, hrâŸ© x).symm","error:  unknown identifier 'clogZpowGi'
error:  invalid constructor âŸ¨...âŸ©, expected type must be an inductive type 
  ?m.70095","theorem zpow_lt_iff_lt_clog {b : â„•} (hb : 1 < b) {x : â„¤} {r : R} (hr : 0 < r) :
    (b : R) ^ x < r â†” x < clog b r ",":=
  (@GaloisConnection.lt_iff_lt _ _ _ _ _ _ (clogZPowGi R hb).gc âŸ¨r, hrâŸ© x).symm"
Mathlib/CategoryTheory/Sites/ConcreteSheafification.lean,CategoryTheory.GrothendieckTopology.Plus.toPlus_apply,toPlus_apply,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  dsimp only [toPlus, plusObj]
  delta Cover.toMultiequalizer
  dsimp [mk]
  erw [â† comp_apply]
  rw [Î¹_colimMap_assoc, colimit.Î¹_pre, comp_apply, comp_apply]
  dsimp only [Functor.op]
  let e : (J.pullback I.f).obj (unop (op S)) âŸ¶ âŠ¤ := homOfLE (OrderTop.le_top _)
  rw [â† colimit.w _ e.op]
  erw [comp_apply]
  apply congr_arg
  apply Concrete.multiequalizer_ext
  intro i
  dsimp [diagram]
  rw [â† comp_apply, â† comp_apply, â† comp_apply, Multiequalizer.lift_Î¹, Multiequalizer.lift_Î¹,
    Multiequalizer.lift_Î¹]
  erw [Meq.equiv_symm_eq_apply]
  let RR : S.Relation :=
    âŸ¨_, _, _, i.f, ğŸ™ _, I.f, i.f â‰« I.f, I.hf, Sieve.downward_closed _ I.hf _, by simpâŸ©
  erw [x.condition RR]
  simp only [unop_op, pullback_obj, op_id, Functor.map_id, id_apply]
  rfl","error:  tactic 'rewrite' failed, did not find instance of the pattern in the target expression
  ?g (?f ?x)
case h.h
C : Type u
instâœâµ : Category.{v, u} C
J : GrothendieckTopology C
D : Type w
instâœâ´ : Category.{max v u, w} D
instâœÂ³ : ConcreteCategory D
instâœÂ² : PreservesLimits (forget D)
instâœÂ¹ : âˆ€ (X : C), HasColimitsOfShape (J.Cover X)áµ’áµ– D
instâœ : âˆ€ (P : Cáµ’áµ– â¥¤ D) (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)
X : C
P : Cáµ’áµ– â¥¤ D
S : J.Cover X
x : Meq P S
I : S.Arrow
e : (J.pullback I.f).obj { unop := S }.unop âŸ¶ âŠ¤ := homOfLE â‹¯
i : ({ unop := (J.pullback I.f).obj { unop := S }.unop }.unop.index P).L
âŠ¢ (Multiequalizer.Î¹ ((S.pullback I.f).index P) i)
      ((Multiequalizer.lift (âŠ¤.index P) (P.obj { unop := I.Y }) (fun I_1 â†¦ P.map I_1.f.op) â‹¯ â‰«
          Multiequalizer.lift ((S.pullback I.f).index P) (multiequalizer (âŠ¤.index P))
            (fun I_1 â†¦ Multiequalizer.Î¹ (âŠ¤.index P) (I_1.map e)) â‹¯)
        (â†‘x I)) =
    (Multiequalizer.Î¹ ((S.pullback I.f).index P) i)
      ((Multiequalizer.lift ((S.pullback I.f).index P) (multiequalizer (S.index P))
          (fun I_1 â†¦ Multiequalizer.Î¹ (S.index P) I_1.base) â‹¯)
        ((Meq.equiv P S).symm x))","theorem toPlus_apply {X : C} {P : Cáµ’áµ– â¥¤ D} (S : J.Cover X) (x : Meq P S) (I : S.Arrow) :
    (J.toPlus P).app _ (x I) = (J.plusObj P).map I.f.op (mk x) ",":= by
  dsimp only [toPlus, plusObj]
  delta Cover.toMultiequalizer
  dsimp [mk]
  erw [â† comp_apply]
  rw [Î¹_colimMap_assoc, colimit.Î¹_pre, comp_apply, comp_apply]
  dsimp only [Functor.op]
  let e : (J.pullback I.f).obj (unop (op S)) âŸ¶ âŠ¤ := homOfLE (OrderTop.le_top _)
  rw [â† colimit.w _ e.op]
  erw [comp_apply]
  apply congr_arg
  apply Concrete.multiequalizer_ext
  intro i
  dsimp
  erw [â† comp_apply, â† comp_apply, â† comp_apply]
  rw [Multiequalizer.lift_Î¹, Multiequalizer.lift_Î¹, Multiequalizer.lift_Î¹]
  erw [Meq.equiv_symm_eq_apply]
  simpa using (x.condition (Cover.Relation.mk' (I.precompRelation i.f))).symm"
Mathlib/Analysis/Normed/Group/ControlledClosure.lean,controlled_closure_of_complete,controlled_closure_of_complete,ebf0b7502c334150094390d6111d33ee017c7f8a,":= by
  rintro (h : H) (h_in : h âˆˆ K.topologicalClosure)
  by_cases hyp_h : h = 0
  Â· rw [hyp_h]
    use 0
    simp
  set b : â„• â†’ â„ := fun i => (1 / 2) ^ i * (Îµ * â€–hâ€– / 2) / C
  have b_pos : âˆ€ i, 0 < b i := by
    intro i
    field_simp [hC]
    exact
      div_pos (mul_pos hÎµ (norm_pos_iff.mpr hyp_h)) (mul_pos (by norm_num : (0 : â„) < 2 ^ i * 2) hC)
  obtain
    âŸ¨v : â„• â†’ H, lim_v : Tendsto (fun n : â„• => âˆ‘ k in range (n + 1), v k) atTop (ğ“ h), v_in :
      âˆ€ n, v n âˆˆ K, hvâ‚€ : â€–v 0 - hâ€– < b 0, hv : âˆ€ n > 0, â€–v nâ€– < b nâŸ© :=
    controlled_sum_of_mem_closure h_in b_pos
  have : âˆ€ n, âˆƒ m' : G, f m' = v n âˆ§ â€–m'â€– â‰¤ C * â€–v nâ€– := fun n : â„• => hyp (v n) (v_in n)
  choose u hu hnorm_u using this
  set s : â„• â†’ G := fun n => âˆ‘ k in range (n + 1), u k
  have : CauchySeq s := by
    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one
    rintro n (hn : n â‰¥ 1)
    calc
      â€–u nâ€– â‰¤ C * â€–v nâ€– := hnorm_u n
      _ â‰¤ C * b n := (mul_le_mul_of_nonneg_left (hv _ <| Nat.succ_le_iff.mp hn).le hC.le)
      _ = (1 / 2) ^ n * (Îµ * â€–hâ€– / 2) := by simp [mul_div_cancel' _ hC.ne.symm]
      _ = Îµ * â€–hâ€– / 2 * (1 / 2) ^ n := mul_comm _ _
  obtain âŸ¨g : G, hgâŸ© := cauchySeq_tendsto_of_complete this
  refine' âŸ¨g, _, _âŸ©
  Â· 
    have : f âˆ˜ s = fun n => âˆ‘ k in range (n + 1), v k := by
      ext n
      simp [map_sum, hu]
    rw [â† this] at lim_v
    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v
  Â· 
    suffices : âˆ€ n, â€–s nâ€– â‰¤ (C + Îµ) * â€–hâ€–
    exact le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this
    intro n
    have hnormâ‚€ : â€–u 0â€– â‰¤ C * b 0 + C * â€–hâ€– := by
      have :=
        calc
          â€–v 0â€– â‰¤ â€–hâ€– + â€–v 0 - hâ€– := norm_le_insert' _ _
          _ â‰¤ â€–hâ€– + b 0 := by apply add_le_add_left hvâ‚€.le
      calc
        â€–u 0â€– â‰¤ C * â€–v 0â€– := hnorm_u 0
        _ â‰¤ C * (â€–hâ€– + b 0) := (mul_le_mul_of_nonneg_left this hC.le)
        _ = C * b 0 + C * â€–hâ€– := by rw [add_comm, mul_add]
    have : (âˆ‘ k in range (n + 1), C * b k) â‰¤ Îµ * â€–hâ€– :=
      calc
        (âˆ‘ k in range (n + 1), C * b k) = (âˆ‘ k in range (n + 1), (1 / 2 : â„) ^ k) * (Îµ * â€–hâ€– / 2) :=
          by simp only [mul_div_cancel' _ hC.ne.symm, â† sum_mul]
        _ â‰¤ 2 * (Îµ * â€–hâ€– / 2) :=
          (mul_le_mul_of_nonneg_right (sum_geometric_two_le _) (by nlinarith [hÎµ, norm_nonneg h]))
        _ = Îµ * â€–hâ€– := mul_div_cancel' _ two_ne_zero
    calc
      â€–s nâ€– â‰¤ âˆ‘ k in range (n + 1), â€–u kâ€– := norm_sum_le _ _
      _ = (âˆ‘ k in range n, â€–u (k + 1)â€–) + â€–u 0â€– := (sum_range_succ' _ _)
      _ â‰¤ (âˆ‘ k in range n, C * â€–v (k + 1)â€–) + â€–u 0â€– :=
        (add_le_add_right (sum_le_sum fun _ _ => hnorm_u _) _)
      _ â‰¤ (âˆ‘ k in range n, C * b (k + 1)) + (C * b 0 + C * â€–hâ€–) :=
        (add_le_add (sum_le_sum fun k _ => mul_le_mul_of_nonneg_left (hv _ k.succ_pos).le hC.le)
          hnormâ‚€)
      _ = (âˆ‘ k in range (n + 1), C * b k) + C * â€–hâ€– := by rw [â† add_assoc, sum_range_succ']
      _ â‰¤ (C + Îµ) * â€–hâ€– := by
        rw [add_comm, add_mul]
        apply add_le_add_left this","error:  unexpected token ':'; expected term
error:  unsolved goals
case h
G : Type u_1
instâœÂ² : NormedAddCommGroup G
instâœÂ¹ : CompleteSpace G
H : Type u_2
instâœ : NormedAddCommGroup H
f : NormedAddGroupHom G H
K : AddSubgroup H
C Îµ : â„
hC : 0 < C
hÎµ : 0 < Îµ
hyp : f.SurjectiveOnWith K C
h : H
h_in : h âˆˆ K.topologicalClosure
hyp_h : Â¬h = 0
b : â„• â†’ â„ := fun i â†¦ (1 / 2) ^ i * (Îµ * â€–hâ€– / 2) / C
b_pos : âˆ€ (i : â„•), 0 < b i
v : â„• â†’ H
lim_v : Tendsto (fun n â†¦ âˆ‘ k âˆˆ range (n + 1), v k) atTop (ğ“ h)
v_in : âˆ€ (n : â„•), v n âˆˆ K
hvâ‚€ : â€–v 0 - hâ€– < b 0
hv : âˆ€ n > 0, â€–v nâ€– < b n
u : â„• â†’ G
hu : âˆ€ (n : â„•), f (u n) = v n
hnorm_u : âˆ€ (n : â„•), â€–u nâ€– â‰¤ C * â€–v nâ€–
s : â„• â†’ G := fun n â†¦ âˆ‘ k âˆˆ range (n + 1), u k
this : CauchySeq s
g : G
hg : Tendsto s atTop (ğ“ g)
n : â„•
âŠ¢ f (s n) = âˆ‘ k âˆˆ range (n + 1), v k","theorem controlled_closure_of_complete {f : NormedAddGroupHom G H} {K : AddSubgroup H} {C Îµ : â„}
    (hC : 0 < C) (hÎµ : 0 < Îµ) (hyp : f.SurjectiveOnWith K C) :
    f.SurjectiveOnWith K.topologicalClosure (C + Îµ) ",":= by
  rintro (h : H) (h_in : h âˆˆ K.topologicalClosure)
  by_cases hyp_h : h = 0
  Â· rw [hyp_h]
    use 0
    simp
  set b : â„• â†’ â„ := fun i => (1 / 2) ^ i * (Îµ * â€–hâ€– / 2) / C
  have b_pos (i) : 0 < b i := by field_simp [b, hC, hyp_h]
  obtain
    âŸ¨v : â„• â†’ H, lim_v : Tendsto (fun n : â„• => âˆ‘ k âˆˆ range (n + 1), v k) atTop (ğ“ h), v_in :
      âˆ€ n, v n âˆˆ K, hvâ‚€ : â€–v 0 - hâ€– < b 0, hv : âˆ€ n > 0, â€–v nâ€– < b nâŸ© :=
    controlled_sum_of_mem_closure h_in b_pos
  have : âˆ€ n, âˆƒ m' : G, f m' = v n âˆ§ â€–m'â€– â‰¤ C * â€–v nâ€– := fun n : â„• => hyp (v n) (v_in n)
  choose u hu hnorm_u using this
  set s : â„• â†’ G := fun n => âˆ‘ k âˆˆ range (n + 1), u k
  have : CauchySeq s := by
    apply NormedAddCommGroup.cauchy_series_of_le_geometric'' (by norm_num) one_half_lt_one
    Â· rintro n (hn : n â‰¥ 1)
      calc
        â€–u nâ€– â‰¤ C * â€–v nâ€– := hnorm_u n
        _ â‰¤ C * b n := by gcongr; exact (hv _ <| Nat.succ_le_iff.mp hn).le
        _ = (1 / 2) ^ n * (Îµ * â€–hâ€– / 2) := by simp [mul_div_cancelâ‚€ _ hC.ne.symm]
        _ = Îµ * â€–hâ€– / 2 * (1 / 2) ^ n := mul_comm _ _
  obtain âŸ¨g : G, hgâŸ© := cauchySeq_tendsto_of_complete this
  refine âŸ¨g, ?_, ?_âŸ©
  Â· 
    have : f âˆ˜ s = fun n => âˆ‘ k âˆˆ range (n + 1), v k := by
      ext n
      simp [s, map_sum, hu]
    rw [â† this] at lim_v
    exact tendsto_nhds_unique ((f.continuous.tendsto g).comp hg) lim_v
  Â· 
    suffices âˆ€ n, â€–s nâ€– â‰¤ (C + Îµ) * â€–hâ€– from
      le_of_tendsto' (continuous_norm.continuousAt.tendsto.comp hg) this
    intro n
    have hnormâ‚€ : â€–u 0â€– â‰¤ C * b 0 + C * â€–hâ€– := by
      have :=
        calc
          â€–v 0â€– â‰¤ â€–hâ€– + â€–v 0 - hâ€– := norm_le_insert' _ _
          _ â‰¤ â€–hâ€– + b 0 := by gcongr
      calc
        â€–u 0â€– â‰¤ C * â€–v 0â€– := hnorm_u 0
        _ â‰¤ C * (â€–hâ€– + b 0) := by gcongr
        _ = C * b 0 + C * â€–hâ€– := by rw [add_comm, mul_add]
    have : (âˆ‘ k âˆˆ range (n + 1), C * b k) â‰¤ Îµ * â€–hâ€– :=
      calc (âˆ‘ k âˆˆ range (n + 1), C * b k)
        _ = (âˆ‘ k âˆˆ range (n + 1), (1 / 2 : â„) ^ k) * (Îµ * â€–hâ€– / 2) := by
          simp only [mul_div_cancelâ‚€ _ hC.ne.symm, â† sum_mul]
        _ â‰¤ 2 * (Îµ * â€–hâ€– / 2) := by gcongr; apply sum_geometric_two_le
        _ = Îµ * â€–hâ€– := mul_div_cancelâ‚€ _ two_ne_zero
    calc
      â€–s nâ€– â‰¤ âˆ‘ k âˆˆ range (n + 1), â€–u kâ€– := norm_sum_le _ _
      _ = (âˆ‘ k âˆˆ range n, â€–u (k + 1)â€–) + â€–u 0â€– := sum_range_succ' _ _
      _ â‰¤ (âˆ‘ k âˆˆ range n, C * â€–v (k + 1)â€–) + â€–u 0â€– := by gcongr; apply hnorm_u
      _ â‰¤ (âˆ‘ k âˆˆ range n, C * b (k + 1)) + (C * b 0 + C * â€–hâ€–) := by
        gcongr with k; exact (hv _ k.succ_pos).le
      _ = (âˆ‘ k âˆˆ range (n + 1), C * b k) + C * â€–hâ€– := by rw [â† add_assoc, sum_range_succ']
      _ â‰¤ (C + Îµ) * â€–hâ€– := by
        rw [add_comm, add_mul]
        apply add_le_add_left this"
Mathlib/ModelTheory/Fraisse.lean,FirstOrder.Language.age.countable_quotient,age.countable_quotient,20100f1475ea197bf6dea643b6ee137219455a51,":= by
  classical
  refine' (congr_arg _ (Set.ext <| forall_quotient_iff.2 fun N => _)).mp
    (countable_range fun s : Finset M => âŸ¦âŸ¨closure L (s : Set M), inferInstanceâŸ©âŸ§)
  constructor
  Â· rintro âŸ¨s, hsâŸ©
    use Bundled.of (closure L (s : Set M))
    exact âŸ¨âŸ¨(fg_iff_structure_fg _).1 (fg_closure s.finite_toSet), âŸ¨Substructure.subtype _âŸ©âŸ©, hsâŸ©
  Â· simp only [mem_range, Quotient.eq]
    rintro âŸ¨P, âŸ¨âŸ¨s, hsâŸ©, âŸ¨PMâŸ©âŸ©, hP2âŸ©
    have : P â‰ˆ N := by apply Quotient.eq'.mp; rw [hP2]; rfl 
    refine' âŸ¨s.image PM, Setoid.trans (b := P) _ thisâŸ©
    rw [â† Embedding.coe_toHom, Finset.coe_image, closure_image PM.toHom, hs, â† Hom.range_eq_map]
    exact âŸ¨PM.equivRange.symmâŸ©","error:  unknown identifier 'forall_quotient_iff'
error:  no goals to be solved",theorem age.countable_quotient [h : Countable M] : (Quotient.mk' '' L.age M).Countable ,":= by
  classical
  refine (congr_arg _ (Set.ext <| Quotient.forall.2 fun N => ?_)).mp
    (countable_range fun s : Finset M => âŸ¦âŸ¨closure L (s : Set M), inferInstanceâŸ©âŸ§)
  constructor
  Â· rintro âŸ¨s, hsâŸ©
    use Bundled.of (closure L (s : Set M))
    exact âŸ¨âŸ¨(fg_iff_structure_fg _).1 (fg_closure s.finite_toSet), âŸ¨Substructure.subtype _âŸ©âŸ©, hsâŸ©
  Â· simp only [mem_range, Quotient.eq]
    rintro âŸ¨P, âŸ¨âŸ¨s, hsâŸ©, âŸ¨PMâŸ©âŸ©, hP2âŸ©
    have : P â‰ˆ N := by apply Quotient.eq'.mp; rw [hP2]; rfl 
    refine âŸ¨s.image PM, Setoid.trans (b := P) ?_ thisâŸ©
    rw [â† Embedding.coe_toHom, Finset.coe_image, closure_image PM.toHom, hs, â† Hom.range_eq_map]
    exact âŸ¨PM.equivRange.symmâŸ©"
Mathlib/GroupTheory/OrderOfElement.lean,isOfFinOrder_one,isOfFinOrder_one,2ac7d87c221020b247729b180bbe2575cceb0700,":=
  (isOfFinOrder_iff_pow_eq_one 1).mpr âŸ¨1, Nat.one_pos, one_pow 1âŸ©","error:  function expected at
  isOfFinOrder_iff_pow_eq_one
term has type
  IsOfFinOrder ?m.14778 â†” âˆƒ n, 0 < n âˆ§ ?m.14778 ^ n = 1",theorem isOfFinOrder_one : IsOfFinOrder (1 : G) ,":=
  isOfFinOrder_iff_pow_eq_one.mpr âŸ¨1, Nat.one_pos, one_pow 1âŸ©"
Mathlib/MeasureTheory/Measure/MeasureSpaceDef.lean,MeasureTheory.measure_inter_lt_top_of_right_ne_top,measure_inter_lt_top_of_right_ne_top,596865180ecc63dcd1d95809202e31027ac3ae38,":=
  measure_lt_top_of_subset (inter_subset_right s t) ht_finite","warning:  `MeasureTheory.OuterMeasure.empty'` has been deprecated, use `MeasureTheory.measure_empty` instead
error:  application type mismatch
  inter_subset_right s
argument
  s
has type
  Set Î± : Type u_1
but is expected to have type
  ?m.24065 âˆˆ ?m.24063 âˆ© ?m.24064 : Prop",theorem measure_inter_lt_top_of_right_ne_top (ht_finite : Î¼ t â‰  âˆ) : Î¼ (s âˆ© t) < âˆ ,":=
  measure_lt_top_of_subset inter_subset_right ht_finite"
Mathlib/Algebra/Lie/OfAssociative.lean,LieSubalgebra.coe_ad_pow,LieSubalgebra.coe_ad_pow,cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":=
  LieSubmodule.coe_toEndomorphism_pow R H L H.toLieSubmodule x y n",error:  unknown constant 'LieSubmodule.coe_toEndomorphism_pow',"lemma LieSubalgebra.coe_ad_pow (H : LieSubalgebra R L) (x y : H) (n : â„•) :
    ((ad R H x ^ n) y : L) = (ad R L x ^ n) y ",":=
  LieSubmodule.coe_toEnd_pow R H L H.toLieSubmodule x y n"
Mathlib/RingTheory/DedekindDomain/Different.lean,traceForm_dualSubmodule_adjoin,traceForm_dualSubmodule_adjoin,bc76db74ce5ed54a72d80fca488c6549cfb0a8ab,":= by
  classical
  have hKx : IsIntegral K x := Algebra.IsIntegral.of_finite (R := K) (B := L) x
  let pb := (Algebra.adjoin.powerBasis' hKx).map
    ((Subalgebra.equivOfEq _ _ hx).trans (Subalgebra.topEquiv))
  have pbgen : pb.gen = x := by simp
  have hpb : â‡‘(BilinForm.dualBasis (traceForm K L) _ pb.basis) = _ :=
    _root_.funext (traceForm_dualBasis_powerBasis_eq pb)
  have : (Subalgebra.toSubmodule (Algebra.adjoin A {x})) =
      Submodule.span A (Set.range pb.basis) := by
    rw [â† span_range_natDegree_eq_adjoin (minpoly.monic hAx) (minpoly.aeval _ _)]
    congr; ext y
    have : natDegree (minpoly A x) = natDegree (minpoly K x) := by
      rw [minpoly.isIntegrallyClosed_eq_field_fractions' K hAx, (minpoly.monic hAx).natDegree_map]
    simp only [Finset.coe_image, Finset.coe_range, Set.mem_image, Set.mem_Iio, Set.mem_range,
      pb.basis_eq_pow, pbgen]
    simp only [PowerBasis.map_dim, adjoin.powerBasis'_dim, this]
    exact âŸ¨fun âŸ¨a, b, câŸ© â†¦ âŸ¨âŸ¨a, bâŸ©, câŸ©, fun âŸ¨âŸ¨a, bâŸ©, câŸ© â†¦ âŸ¨a, b, câŸ©âŸ©
  clear_value pb
  conv_lhs => rw [this]
  rw [â† span_coeff_minpolyDiv hAx, BilinForm.dualSubmodule_span_of_basis,
    Submodule.smul_span, hpb]
  show _ = Submodule.span A (_ '' _)
  simp only [â† Set.range_comp, smul_eq_mul, div_eq_inv_mul, pbgen,
    minpolyDiv_eq_of_isIntegrallyClosed K hAx]
  apply le_antisymm <;> rw [Submodule.span_le]
  Â· rintro _ âŸ¨i, rflâŸ©; exact Submodule.subset_span âŸ¨i, rflâŸ©
  Â· rintro _ âŸ¨i, rflâŸ©
    by_cases hi : i < pb.dim
    Â· exact Submodule.subset_span âŸ¨âŸ¨i, hiâŸ©, rflâŸ©
    Â· rw [Function.comp_apply, coeff_eq_zero_of_natDegree_lt, mul_zero]; exact zero_mem _
      rw [â† pb.natDegree_minpoly, pbgen, â† natDegree_minpolyDiv_succ hKx,
        â† Nat.succ_eq_add_one] at hi
      exact le_of_not_lt hi","error:  function expected at
  Algebra.IsIntegral.of_finite K L
term has type
  Algebra.IsIntegral K L
error:  simp made no progress
error:  unknown identifier 'BilinForm.dualBasis'","lemma traceForm_dualSubmodule_adjoin
    {x : L} (hx : Algebra.adjoin K {x} = âŠ¤) (hAx : IsIntegral A x) :
    (traceForm K L).dualSubmodule (Subalgebra.toSubmodule (Algebra.adjoin A {x})) =
      (aeval x (derivative <| minpoly K x) : L)â»Â¹ â€¢
        (Subalgebra.toSubmodule (Algebra.adjoin A {x})) ",":= by
  classical
  have hKx : IsIntegral K x := Algebra.IsIntegral.isIntegral x
  let pb := (Algebra.adjoin.powerBasis' hKx).map
    ((Subalgebra.equivOfEq _ _ hx).trans (Subalgebra.topEquiv))
  have pbgen : pb.gen = x := by simp [pb]
  have hpb : â‡‘(LinearMap.BilinForm.dualBasis (traceForm K L) _ pb.basis) = _ :=
    _root_.funext (traceForm_dualBasis_powerBasis_eq pb)
  have : (Subalgebra.toSubmodule (Algebra.adjoin A {x})) =
      Submodule.span A (Set.range pb.basis) := by
    rw [â† span_range_natDegree_eq_adjoin (minpoly.monic hAx) (minpoly.aeval _ _)]
    congr; ext y
    have : natDegree (minpoly A x) = natDegree (minpoly K x) := by
      rw [minpoly.isIntegrallyClosed_eq_field_fractions' K hAx, (minpoly.monic hAx).natDegree_map]
    simp only [Finset.coe_image, Finset.coe_range, Set.mem_image, Set.mem_Iio, Set.mem_range,
      pb.basis_eq_pow, pbgen]
    simp only [PowerBasis.map_dim, adjoin.powerBasis'_dim, this]
    exact âŸ¨fun âŸ¨a, b, câŸ© â†¦ âŸ¨âŸ¨a, bâŸ©, câŸ©, fun âŸ¨âŸ¨a, bâŸ©, câŸ© â†¦ âŸ¨a, b, câŸ©âŸ©
  clear_value pb
  conv_lhs => rw [this]
  rw [â† span_coeff_minpolyDiv hAx, LinearMap.BilinForm.dualSubmodule_span_of_basis,
    Submodule.smul_span, hpb]
  show _ = Submodule.span A (_ '' _)
  simp only [â† Set.range_comp, smul_eq_mul, div_eq_inv_mul, pbgen,
    minpolyDiv_eq_of_isIntegrallyClosed K hAx]
  apply le_antisymm <;> rw [Submodule.span_le]
  Â· rintro _ âŸ¨i, rflâŸ©; exact Submodule.subset_span âŸ¨i, rflâŸ©
  Â· rintro _ âŸ¨i, rflâŸ©
    by_cases hi : i < pb.dim
    Â· exact Submodule.subset_span âŸ¨âŸ¨i, hiâŸ©, rflâŸ©
    Â· rw [Function.comp_apply, coeff_eq_zero_of_natDegree_lt, mul_zero]
      Â· exact zero_mem _
      rw [â† pb.natDegree_minpoly, pbgen, â† natDegree_minpolyDiv_succ hKx,
        â† Nat.succ_eq_add_one] at hi
      exact le_of_not_lt hi"
Mathlib/RingTheory/PowerSeries/Basic.lean,PowerSeries.coeff_prod,coeff_prod,413e5b872a7c758e0eb91f99cb96d6a61c81f0a2,":= by
  induction s using Finset.induction_on generalizing d with
  | empty =>
    simp only [prod_empty, sum_const, nsmul_eq_mul, mul_one, coeff_one, piAntidiagonal_empty]
    split_ifs
    Â· simp only [card_singleton, Nat.cast_one]
    Â· simp only [card_empty, Nat.cast_zero]
  | @insert a s ha ih =>
    rw [piAntidiagonal_insert ha, prod_insert ha, coeff_mul, sum_biUnion]
    Â· apply Finset.sum_congr rfl
      Â· simp only [mem_antidiagonal, sum_map, Function.Embedding.coeFn_mk, coe_update, Prod.forall]
        rintro u v rfl
        rw [ih, Finset.mul_sum, â† Finset.sum_attach]
        apply Finset.sum_congr rfl
        simp only [mem_attach, Finset.prod_insert ha, Function.update_same, forall_true_left,
          Subtype.forall]
        rintro x -
        rw [Finset.prod_congr rfl]
        intro i hi
        rw [Function.update_noteq]
        exact ne_of_mem_of_not_mem hi ha
    Â· simp only [Set.PairwiseDisjoint, Set.Pairwise, mem_coe, mem_antidiagonal, ne_eq,
        disjoint_left, mem_map, mem_attach, Function.Embedding.coeFn_mk, true_and, Subtype.exists,
        exists_prop, not_exists, not_and, forall_exists_index, and_imp, forall_apply_eq_imp_iffâ‚‚,
        Prod.forall, Prod.mk.injEq]
      rintro u v rfl u' v' huv h k - l - hkl
      obtain rfl : u' = u := by
        simpa only [Finsupp.coe_update, Function.update_same] using DFunLike.congr_fun hkl a
      simp only [add_right_inj] at huv
      exact h rfl huv.symm","error:  unknown identifier 'piAntidiagonal_empty'
error:  simp made no progress
error:  simp made no progress
error:  unknown identifier 'piAntidiagonal_insert'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.161871
case insert
Râœ : Type u_1
R : Type u_2
instâœÂ¹ : CommSemiring R
Î¹ : Type u_3
instâœ : DecidableEq Î¹
f : Î¹ â†’ RâŸ¦XâŸ§
a : Î¹
s : Finset Î¹
ha : a âˆ‰ s
ih : âˆ€ (d : â„•), (coeff R d) (âˆ j âˆˆ s, f j) = âˆ‘ l âˆˆ s.finsuppAntidiag d, âˆ i âˆˆ s, (coeff R (l i)) (f i)
d : â„•
âŠ¢ (coeff R d) (âˆ j âˆˆ insert a s, f j) = âˆ‘ l âˆˆ (insert a s).finsuppAntidiag d, âˆ i âˆˆ insert a s, (coeff R (l i)) (f i)
warning:  `bit0` has been deprecated
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated
warning:  `bit1` has been deprecated","theorem coeff_prod (f : Î¹ â†’ PowerSeries R) (d : â„•) (s : Finset Î¹) :
    coeff R d (âˆ j âˆˆ s, f j) = âˆ‘ l âˆˆ finsuppAntidiag s d, âˆ i âˆˆ s, coeff R (l i) (f i) ",":= by
  simp only [coeff]
  convert MvPowerSeries.coeff_prod _ _ _
  rw [â† AddEquiv.finsuppUnique_symm d, â† mapRange_finsuppAntidiag_eq, sum_map, sum_congr rfl]
  intro x _
  apply prod_congr rfl
  intro i _
  congr 2
  simp only [AddEquiv.toEquiv_eq_coe, Finsupp.mapRange.addEquiv_toEquiv, AddEquiv.toEquiv_symm,
    Equiv.coe_toEmbedding, Finsupp.mapRange.equiv_apply, AddEquiv.coe_toEquiv_symm,
    Finsupp.mapRange_apply, AddEquiv.finsuppUnique_symm]"
Mathlib/MeasureTheory/Function/UniformIntegrable.lean,MeasureTheory.unifIntegrable_of',unifIntegrable_of',d1f3a3851e09620cfb59f550525ab125a0ea6c9e,":= by
  have hpzero := (lt_of_lt_of_le zero_lt_one hp).ne.symm
  by_cases hÎ¼ : Î¼ Set.univ = 0
  Â· rw [Measure.measure_univ_eq_zero] at hÎ¼
    exact hÎ¼.symm â–¸ unifIntegrable_zero_meas
  intro Îµ hÎµ
  obtain âŸ¨C, hCpos, hCâŸ© := h (Îµ / 2) (half_pos hÎµ)
  refine' âŸ¨(Îµ / (2 * C)) ^ ENNReal.toReal p,
    Real.rpow_pos_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos))) _,
    fun i s hs hÎ¼s => _âŸ©
  by_cases hÎ¼s' : Î¼ s = 0
  Â· rw [(snorm_eq_zero_iff ((hf i).indicator hs).aestronglyMeasurable hpzero).2
        (indicator_meas_zero hÎ¼s')]
    set_option tactic.skipAssignedInstances false in norm_num
  calc
    snorm (Set.indicator s (f i)) p Î¼ â‰¤
        snorm (Set.indicator (s âˆ© { x | C â‰¤ â€–f i xâ€–â‚Š }) (f i)) p Î¼ +
          snorm (Set.indicator (s âˆ© { x | â€–f i xâ€–â‚Š < C }) (f i)) p Î¼ := by
      refine' le_trans (Eq.le _) (snorm_add_le
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter (stronglyMeasurable_const.measurableSet_le (hf i).nnnorm))))
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter ((hf i).nnnorm.measurableSet_lt stronglyMeasurable_const))))
        hp)
      congr
      change _ = fun x => (s âˆ© { x : Î± | C â‰¤ â€–f i xâ€–â‚Š }).indicator (f i) x +
        (s âˆ© { x : Î± | â€–f i xâ€–â‚Š < C }).indicator (f i) x
      rw [â† Set.indicator_union_of_disjoint]
      Â· rw [â† Set.inter_union_distrib_left, (by ext; simp [le_or_lt] :
            { x : Î± | C â‰¤ â€–f i xâ€–â‚Š } âˆª { x : Î± | â€–f i xâ€–â‚Š < C } = Set.univ),
          Set.inter_univ]
      Â· refine' (Disjoint.inf_right' _ _).inf_left' _
        rw [disjoint_iff_inf_le]
        rintro x âŸ¨hxâ‚, hxâ‚‚âŸ©
        rw [Set.mem_setOf_eq] at hxâ‚ hxâ‚‚
        exact False.elim (hxâ‚‚.ne (eq_of_le_of_not_lt hxâ‚ (not_lt.2 hxâ‚‚.le)).symm)
    _ â‰¤ snorm (Set.indicator { x | C â‰¤ â€–f i xâ€–â‚Š } (f i)) p Î¼ +
        (C : â„â‰¥0âˆ) * Î¼ s ^ (1 / ENNReal.toReal p) := by
      refine' add_le_add
        (snorm_mono fun x => norm_indicator_le_of_subset (Set.inter_subset_right _ _) _ _) _
      rw [â† Set.indicator_indicator]
      rw [snorm_indicator_eq_snorm_restrict hs]
      have : âˆ€áµ x âˆ‚Î¼.restrict s, â€–{ x : Î± | â€–f i xâ€–â‚Š < C }.indicator (f i) xâ€– â‰¤ C := by
        refine' ae_of_all _ _
        simp_rw [norm_indicator_eq_indicator_norm]
        exact Set.indicator_le' (fun x (hx : _ < _) => hx.le) fun _ _ => NNReal.coe_nonneg _
      refine' le_trans (snorm_le_of_ae_bound this) _
      rw [mul_comm, Measure.restrict_apply' hs, Set.univ_inter, ENNReal.ofReal_coe_nnreal, one_div]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + C * ENNReal.ofReal (Îµ / (2 * C)) := by
      refine' add_le_add (hC i) (mul_le_mul_left' _ _)
      rwa [ENNReal.rpow_one_div_le_iff (ENNReal.toReal_pos hpzero hp'),
        ENNReal.ofReal_rpow_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos)))]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + ENNReal.ofReal (Îµ / 2) := by
      refine' add_le_add_left _ _
      rw [â† ENNReal.ofReal_coe_nnreal, â† ENNReal.ofReal_mul (NNReal.coe_nonneg _), â† div_div,
        mul_div_cancel' _ (NNReal.coe_pos.2 hCpos).ne.symm]
    _ â‰¤ ENNReal.ofReal Îµ := by
      rw [â† ENNReal.ofReal_add (half_pos hÎµ).le (half_pos hÎµ).le, add_halves]","error:  function expected at
  inter_subset_right ?m.230357
term has type
  ?m.230356 âˆˆ ?m.230355
warning:  `mul_div_cancel'` has been deprecated, use `mul_div_cancelâ‚€` instead","theorem unifIntegrable_of' (hp : 1 â‰¤ p) (hp' : p â‰  âˆ) {f : Î¹ â†’ Î± â†’ Î²}
    (hf : âˆ€ i, StronglyMeasurable (f i))
    (h : âˆ€ Îµ : â„, 0 < Îµ â†’ âˆƒ C : â„â‰¥0, 0 < C âˆ§
      âˆ€ i, snorm ({ x | C â‰¤ â€–f i xâ€–â‚Š }.indicator (f i)) p Î¼ â‰¤ ENNReal.ofReal Îµ) :
    UnifIntegrable f p Î¼ ",":= by
  have hpzero := (lt_of_lt_of_le zero_lt_one hp).ne.symm
  by_cases hÎ¼ : Î¼ Set.univ = 0
  Â· rw [Measure.measure_univ_eq_zero] at hÎ¼
    exact hÎ¼.symm â–¸ unifIntegrable_zero_meas
  intro Îµ hÎµ
  obtain âŸ¨C, hCpos, hCâŸ© := h (Îµ / 2) (half_pos hÎµ)
  refine âŸ¨(Îµ / (2 * C)) ^ ENNReal.toReal p,
    Real.rpow_pos_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos))) _,
    fun i s hs hÎ¼s => ?_âŸ©
  by_cases hÎ¼s' : Î¼ s = 0
  Â· rw [(snorm_eq_zero_iff ((hf i).indicator hs).aestronglyMeasurable hpzero).2
        (indicator_meas_zero hÎ¼s')]
    norm_num
  calc
    snorm (Set.indicator s (f i)) p Î¼ â‰¤
        snorm (Set.indicator (s âˆ© { x | C â‰¤ â€–f i xâ€–â‚Š }) (f i)) p Î¼ +
          snorm (Set.indicator (s âˆ© { x | â€–f i xâ€–â‚Š < C }) (f i)) p Î¼ := by
      refine le_trans (Eq.le ?_) (snorm_add_le
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter (stronglyMeasurable_const.measurableSet_le (hf i).nnnorm))))
        (StronglyMeasurable.aestronglyMeasurable
          ((hf i).indicator (hs.inter ((hf i).nnnorm.measurableSet_lt stronglyMeasurable_const))))
        hp)
      congr
      change _ = fun x => (s âˆ© { x : Î± | C â‰¤ â€–f i xâ€–â‚Š }).indicator (f i) x +
        (s âˆ© { x : Î± | â€–f i xâ€–â‚Š < C }).indicator (f i) x
      rw [â† Set.indicator_union_of_disjoint]
      Â· rw [â† Set.inter_union_distrib_left, (by ext; simp [le_or_lt] :
            { x : Î± | C â‰¤ â€–f i xâ€–â‚Š } âˆª { x : Î± | â€–f i xâ€–â‚Š < C } = Set.univ),
          Set.inter_univ]
      Â· refine (Disjoint.inf_right' _ ?_).inf_left' _
        rw [disjoint_iff_inf_le]
        rintro x âŸ¨hxâ‚, hxâ‚‚âŸ©
        rw [Set.mem_setOf_eq] at hxâ‚ hxâ‚‚
        exact False.elim (hxâ‚‚.ne (eq_of_le_of_not_lt hxâ‚ (not_lt.2 hxâ‚‚.le)).symm)
    _ â‰¤ snorm (Set.indicator { x | C â‰¤ â€–f i xâ€–â‚Š } (f i)) p Î¼ +
        (C : â„â‰¥0âˆ) * Î¼ s ^ (1 / ENNReal.toReal p) := by
      refine add_le_add
        (snorm_mono fun x => norm_indicator_le_of_subset Set.inter_subset_right _ _) ?_
      rw [â† Set.indicator_indicator]
      rw [snorm_indicator_eq_snorm_restrict hs]
      have : âˆ€áµ x âˆ‚Î¼.restrict s, â€–{ x : Î± | â€–f i xâ€–â‚Š < C }.indicator (f i) xâ€– â‰¤ C := by
        filter_upwards
        simp_rw [norm_indicator_eq_indicator_norm]
        exact Set.indicator_le' (fun x (hx : _ < _) => hx.le) fun _ _ => NNReal.coe_nonneg _
      refine le_trans (snorm_le_of_ae_bound this) ?_
      rw [mul_comm, Measure.restrict_apply' hs, Set.univ_inter, ENNReal.ofReal_coe_nnreal, one_div]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + C * ENNReal.ofReal (Îµ / (2 * C)) := by
      refine add_le_add (hC i) (mul_le_mul_left' ?_ _)
      rwa [ENNReal.rpow_one_div_le_iff (ENNReal.toReal_pos hpzero hp'),
        ENNReal.ofReal_rpow_of_pos (div_pos hÎµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos)))]
    _ â‰¤ ENNReal.ofReal (Îµ / 2) + ENNReal.ofReal (Îµ / 2) := by
      refine add_le_add_left ?_ _
      rw [â† ENNReal.ofReal_coe_nnreal, â† ENNReal.ofReal_mul (NNReal.coe_nonneg _), â† div_div,
        mul_div_cancelâ‚€ _ (NNReal.coe_pos.2 hCpos).ne.symm]
    _ â‰¤ ENNReal.ofReal Îµ := by
      rw [â† ENNReal.ofReal_add (half_pos hÎµ).le (half_pos hÎµ).le, add_halves]"
Mathlib/Algebra/Ring/Divisibility/Basic.lean,map_dvd_iff,map_dvd_iff,3b0baa425c7f4e18fdeeb7271bf104ecfee0d57a,":=
  let f := MulHomClass.toMulEquiv f
  âŸ¨fun h â†¦ by rw [â† f.left_inv a, â† f.left_inv b]; exact map_dvd f.symm h, map_dvd fâŸ©","error:  unknown constant 'MulHomClass.toMulEquiv'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.2899
Î± : Type u_1
Î² : Type u_2
instâœÂ³ : Semigroup Î±
instâœÂ² : Semigroup Î²
F : Type u_3
instâœÂ¹ : EquivLike F Î± Î²
instâœ : MulEquivClass F Î± Î²
fâœ : F
a b : Î±
f : ?m.1545 := sorryAx ?m.1545 true
h : fâœ a âˆ£ fâœ b
âŠ¢ a âˆ£ b
warning:  `bit0` has been deprecated
warning:  `bit1` has been deprecated",theorem map_dvd_iff {a b} : f a âˆ£ f b â†” a âˆ£ b ,":=
  let f := MulEquivClass.toMulEquiv f
  âŸ¨fun h â†¦ by rw [â† f.left_inv a, â† f.left_inv b]; exact map_dvd f.symm h, map_dvd fâŸ©"
Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean,coeff_minpolyDiv_mem_adjoin,coeff_minpolyDiv_mem_adjoin,b764e03d48c53e3f744636472c9d205d33ffdb4c,":= by
  by_contra H
  have : âˆ€ j, coeff (minpolyDiv R x) (i + j) âˆ‰ Algebra.adjoin R {x}
  Â· intro j; induction j with
    | zero => exact H
    | succ j IH =>
      intro H; apply IH
      rw [coeff_minpolyDiv]
      refine add_mem ?_ (mul_mem H (Algebra.self_mem_adjoin_singleton R x))
      exact Subalgebra.algebraMap_mem _ _
  apply this (natDegree (minpolyDiv R x) + 1)
  rw [coeff_eq_zero_of_natDegree_lt]
  Â· exact zero_mem _
  Â· refine (Nat.le_add_left _ i).trans_lt ?_
    rw [â† add_assoc]
    exact Nat.lt_succ_self _","error:  unexpected token 'Â·'; expected '|'
error:  unsolved goals
R : Type u_2
K : Type ?u.70499
L : Type ?u.70502
S : Type u_1
instâœâµ : CommRing R
instâœâ´ : Field K
instâœÂ³ : Field L
instâœÂ² : CommRing S
instâœÂ¹ : Algebra R S
instâœ : Algebra K L
xâœ : S
hx : IsIntegral R xâœ
x : S
i : â„•
H : (minpolyDiv R x).coeff i âˆ‰ Algebra.adjoin R {x}
this : âˆ€ (j : â„•), (minpolyDiv R x).coeff (i + j) âˆ‰ Algebra.adjoin R {x}
âŠ¢ False","lemma coeff_minpolyDiv_mem_adjoin (x : S) (i) :
    coeff (minpolyDiv R x) i âˆˆ Algebra.adjoin R {x} ",":= by
  by_contra H
  have : âˆ€ j, coeff (minpolyDiv R x) (i + j) âˆ‰ Algebra.adjoin R {x} := by
    intro j; induction j with
    | zero => exact H
    | succ j IH =>
      intro H; apply IH
      rw [coeff_minpolyDiv]
      refine add_mem ?_ (mul_mem H (Algebra.self_mem_adjoin_singleton R x))
      exact Subalgebra.algebraMap_mem _ _
  apply this (natDegree (minpolyDiv R x) + 1)
  rw [coeff_eq_zero_of_natDegree_lt]
  Â· exact zero_mem _
  Â· refine (Nat.le_add_left _ i).trans_lt ?_
    rw [â† add_assoc]
    exact Nat.lt_succ_self _"
Mathlib/Data/Nat/Factorization/Basic.lean,Nat.card_multiples',card_multiples',cc6e5e01514b06a44caccb55bc04e269ede6a7c8,":= by
  induction N with
    | zero => simp
    | succ N ih =>
        rw [Finset.range_succ, Finset.filter_insert]
        by_cases h : n âˆ£ N.succ
        Â· simp [h, succ_div_of_dvd, ih]
        Â· simp [h, succ_div_of_not_dvd, ih]","error:  unsolved goals
case zero
a b m nâœ p n : â„•
âŠ¢ Finset.filter (fun k â†¦ Â¬k = 0 âˆ§ n âˆ£ k) {0} = âˆ…","lemma card_multiples' (N n : â„•) :
    ((Finset.range N.succ).filter (fun k â†¦ k â‰  0 âˆ§ n âˆ£ k)).card = N / n ",":= by
  induction N with
    | zero => simp [Finset.filter_false_of_mem]
    | succ N ih =>
        rw [Finset.range_succ, Finset.filter_insert]
        by_cases h : n âˆ£ N.succ
        Â· simp [h, succ_div_of_dvd, ih]
        Â· simp [h, succ_div_of_not_dvd, ih]"
Mathlib/Data/List/Basic.lean,List.splitOnP_spec,splitOnP_spec,f2a5deba297a26bef9ac4c8360c662eda5b38c90,":= by
  induction as with
  | nil => rfl
  | cons a as' ih =>
    rw [splitOnP_cons, filter]
    by_cases p a
    Â· rw [if_pos h, h, map, cons_append, zipWith, nil_append, join, cons_append, cons_inj]
      exact ih
    Â· rw [if_neg h, eq_false_of_ne_true h, join_zipWith (splitOnP_ne_nil _ _)
        (append_ne_nil_of_ne_nil_right _ [[]] (cons_ne_nil [] [])), cons_inj]
      exact ih","warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_map` has been deprecated, use `List.getElem_map` instead
warning:  `List.get_map` has been deprecated, use `List.getElem_map` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_map` has been deprecated, use `List.get_map` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_map` has been deprecated, use `List.get_map` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_append_right_aux` has been deprecated
warning:  `List.get_append_right'` has been deprecated, use `List.getElem_append_right'` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_cons_length` has been deprecated, use `List.getElem_cons_length` instead
warning:  `List.drop_eq_get_cons` has been deprecated, use `List.drop_eq_getElem_cons` instead
warning:  `List.ext` has been deprecated
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_reverse_auxâ‚` has been deprecated
warning:  `List.get_reverse_auxâ‚‚` has been deprecated, use `List.getElem_reverse_auxâ‚‚` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_reverse` has been deprecated, use `List.getElem_reverse` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_reverse` has been deprecated, use `List.get_reverse` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_singleton` has been deprecated, use `List.getElem_singleton` instead
warning:  `List.ret` has been deprecated, use `List.pure` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.get_zero_scanl` has been deprecated, use `List.getElem_scanl_zero` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe_zero_scanl` has been deprecated, use `List.get_zero_scanl` instead
warning:  `List.nthLe_append_right` has been deprecated, use `List.get_append_right'` instead
error:  unknown identifier 'h'
error:  unknown identifier 'h'
error:  tactic 'rewrite' failed, equality or iff proof expected
  ?m.135311
case pos
Î¹ : Type u_1
Î± : Type u
Î² : Type v
Î³ : Type w
lâ‚ lâ‚‚ : List Î±
p : Î± â†’ Bool
xs ys : List Î±
ls : List (List Î±)
f : List Î± â†’ List Î±
a : Î±
as' : List Î±
ih : (zipWith (fun x x_1 â†¦ x ++ x_1) (splitOnP p as') (map (fun x â†¦ [x]) (filter p as') ++ [[]])).join = as'
hâœ : p a = true
âŠ¢ (zipWith (fun x x_1 â†¦ x ++ x_1) ([] :: splitOnP p as')
        (map (fun x â†¦ [x])
            (match p a with
            | true => a :: filter p as'
            | false => filter p as') ++
          [[]])).join =
    a :: as'
error:  unknown identifier 'h'
error:  unknown identifier 'h'
error:  tactic 'rewrite' failed, pattern is a metavariable
  ?m.135327
from equation
  ?m.135327 = false
case neg
Î¹ : Type u_1
Î± : Type u
Î² : Type v
Î³ : Type w
lâ‚ lâ‚‚ : List Î±
p : Î± â†’ Bool
xs ys : List Î±
ls : List (List Î±)
f : List Î± â†’ List Î±
a : Î±
as' : List Î±
ih : (zipWith (fun x x_1 â†¦ x ++ x_1) (splitOnP p as') (map (fun x â†¦ [x]) (filter p as') ++ [[]])).join = as'
hâœ : Â¬p a = true
âŠ¢ (zipWith (fun x x_1 â†¦ x ++ x_1) (modifyHead (cons a) (splitOnP p as'))
        (map (fun x â†¦ [x])
            (match p a with
            | true => a :: filter p as'
            | false => filter p as') ++
          [[]])).join =
    a :: as'
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead
warning:  `List.nthLe` has been deprecated, use `List.get` instead","theorem splitOnP_spec (as : List Î±) :
    join (zipWith (Â· ++ Â·) (splitOnP p as) (((as.filter p).map fun x => [x]) ++ [[]])) = as ",":= by
  induction as with
  | nil => rfl
  | cons a as' ih =>
    rw [splitOnP_cons, filter]
    by_cases h : p a
    Â· rw [if_pos h, h, map, cons_append, zipWith, nil_append, join, cons_append, cons_inj_right]
      exact ih
    Â· rw [if_neg h, eq_false_of_ne_true h, join_zipWith (splitOnP_ne_nil _ _)
        (append_ne_nil_of_ne_nil_right _ [[]] (cons_ne_nil [] [])), cons_inj_right]
      exact ih"
Mathlib/Order/OrderIsoNat.lean,exists_increasing_or_nonincreasing_subseq',exists_increasing_or_nonincreasing_subseq',596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  classical
    let bad : Set â„• := { m | âˆ€ n, m < n â†’ Â¬r (f m) (f n) }
    by_cases hbad : Infinite bad
    Â· haveI := hbad
      refine âŸ¨Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => ?_âŸ©
      have h := @Set.mem_range_self _ _ â†‘(Nat.orderEmbeddingOfSet bad) m
      rw [Nat.orderEmbeddingOfSet_range bad] at h
      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)
    Â· rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad
      obtain âŸ¨m, hmâŸ© : âˆƒ m, âˆ€ n, m â‰¤ n â†’ Â¬n âˆˆ bad := by
        by_cases he : hbad.toFinset.Nonempty
        Â· refine'
            âŸ¨(hbad.toFinset.max' he).succ, fun n hn nbad =>
              Nat.not_succ_le_self _
                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))âŸ©
        Â· exact âŸ¨0, fun n _ nbad => he âŸ¨n, hbad.mem_toFinset.2 nbadâŸ©âŸ©
      have h : âˆ€ n : â„•, âˆƒ n' : â„•, n < n' âˆ§ r (f (n + m)) (f (n' + m)) := by
        intro n
        have h := hm _ (le_add_of_nonneg_left n.zero_le)
        simp only [bad, exists_prop, not_not, Set.mem_setOf_eq, not_forall] at h
        obtain âŸ¨n', hn1, hn2âŸ© := h
        obtain âŸ¨x, hpos, rflâŸ© := exists_pos_add_of_lt hn1
        refine âŸ¨n + x, add_lt_add_left hpos n, ?_âŸ©
        rw [add_assoc, add_comm x m, â† add_assoc]
        exact hn2
      let g' : â„• â†’ â„• := @Nat.rec (fun _ => â„•) m fun n gn => Nat.find (h gn)
      exact
        âŸ¨(RelEmbedding.natLT (fun n => g' n + m) fun n =>
              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,
          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2âŸ©","error:  failed to synthesize
  CovariantClass â„• â„• (Function.swap fun x x_1 â†¦ x + x_1) fun x x_1 â†¦ x â‰¤ x_1
use `set_option diagnostics true` to get diagnostic information
error:  application type mismatch
  exists_pos_add_of_lt hn1
argument
  hn1
has type
  @LT.lt â„• instLTNat (n + m) n' : Prop
but is expected to have type
  @LT.lt â„• Preorder.toLT (n + m) n' : Prop","theorem exists_increasing_or_nonincreasing_subseq' (r : Î± â†’ Î± â†’ Prop) (f : â„• â†’ Î±) :
    âˆƒ g : â„• â†ªo â„•,
      (âˆ€ n : â„•, r (f (g n)) (f (g (n + 1)))) âˆ¨ âˆ€ m n : â„•, m < n â†’ Â¬r (f (g m)) (f (g n)) ",":= by
  classical
    let bad : Set â„• := { m | âˆ€ n, m < n â†’ Â¬r (f m) (f n) }
    by_cases hbad : Infinite bad
    Â· haveI := hbad
      refine âŸ¨Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => ?_âŸ©
      have h := @Set.mem_range_self _ _ â†‘(Nat.orderEmbeddingOfSet bad) m
      rw [Nat.orderEmbeddingOfSet_range bad] at h
      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)
    Â· rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad
      obtain âŸ¨m, hmâŸ© : âˆƒ m, âˆ€ n, m â‰¤ n â†’ Â¬n âˆˆ bad := by
        by_cases he : hbad.toFinset.Nonempty
        Â· refine
            âŸ¨(hbad.toFinset.max' he).succ, fun n hn nbad =>
              Nat.not_succ_le_self _
                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))âŸ©
        Â· exact âŸ¨0, fun n _ nbad => he âŸ¨n, hbad.mem_toFinset.2 nbadâŸ©âŸ©
      have h : âˆ€ n : â„•, âˆƒ n' : â„•, n < n' âˆ§ r (f (n + m)) (f (n' + m)) := by
        intro n
        have h := hm _ (Nat.le_add_left m n)
        simp only [bad, exists_prop, not_not, Set.mem_setOf_eq, not_forall] at h
        obtain âŸ¨n', hn1, hn2âŸ© := h
        refine âŸ¨n + n' - n - m, by omega, ?_âŸ©
        convert hn2
        omega
      let g' : â„• â†’ â„• := @Nat.rec (fun _ => â„•) m fun n gn => Nat.find (h gn)
      exact
        âŸ¨(RelEmbedding.natLT (fun n => g' n + m) fun n =>
              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,
          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2âŸ©"
Mathlib/MeasureTheory/Measure/FiniteMeasureProd.lean,MeasureTheory.ProbabilityMeasure.prod_apply_symm,prod_apply_symm,596865180ecc63dcd1d95809202e31027ac3ae38,":= by
  simp [Measure.prod_apply_symm s_mble]","error:  simp made no progress
error:  simp made no progress","lemma prod_apply_symm (s : Set (Î± Ã— Î²)) (s_mble : MeasurableSet s) :
    Î¼.prod Î½ s = ENNReal.toNNReal (âˆ«â» y, Î¼.toMeasure ((fun x â†¦ âŸ¨x, yâŸ©) â»Â¹' s) âˆ‚Î½) ",":= by
  simp [coeFn_def, Measure.prod_apply_symm s_mble]"
